# pylint: skip-file
# mypy: ignore-errors

"""Auto-generated DuckDB function namespaces.

This file is generated by ``scripts/generate_function_namespaces.py``.
Do not edit by hand; regenerate to pull in new function definitions.

"""

from __future__ import annotations

from typing import ClassVar, Iterable

from .functions import (
    DuckDBFunctionDefinition,
    DuckDBFunctionSignature,
    _StaticFunctionNamespace,
    duckdb_function,
    call_duckdb_filter_function,
    call_duckdb_function,
)
from .types import parse_type


class AggregateBlobFunctions(_StaticFunctionNamespace):
    """DuckDB aggregate functions returning binary results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'aggregate'
    return_category: ClassVar[str] = 'blob'
    _ARG_MAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_max')
    def arg_max(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``arg_max``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_max(BLOB arg, INTEGER val) -> BLOB
        - main.arg_max(BLOB arg, BIGINT val) -> BLOB
        - main.arg_max(BLOB arg, HUGEINT val) -> BLOB
        - main.arg_max(BLOB arg, DOUBLE val) -> BLOB
        - main.arg_max(BLOB arg, VARCHAR val) -> BLOB
        - main.arg_max(BLOB arg, DATE val) -> BLOB
        - main.arg_max(BLOB arg, TIMESTAMP val) -> BLOB
        - main.arg_max(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.arg_max(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_function(
            self._ARG_MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_max_filter')
    def arg_max_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``arg_max`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_max(BLOB arg, INTEGER val) -> BLOB
        - main.arg_max(BLOB arg, BIGINT val) -> BLOB
        - main.arg_max(BLOB arg, HUGEINT val) -> BLOB
        - main.arg_max(BLOB arg, DOUBLE val) -> BLOB
        - main.arg_max(BLOB arg, VARCHAR val) -> BLOB
        - main.arg_max(BLOB arg, DATE val) -> BLOB
        - main.arg_max(BLOB arg, TIMESTAMP val) -> BLOB
        - main.arg_max(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.arg_max(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MAX_NULL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_max_null')
    def arg_max_null(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``arg_max_null``.

        Finds the row with the maximum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_max_null(BLOB arg, INTEGER val) -> BLOB
        - main.arg_max_null(BLOB arg, BIGINT val) -> BLOB
        - main.arg_max_null(BLOB arg, HUGEINT val) -> BLOB
        - main.arg_max_null(BLOB arg, DOUBLE val) -> BLOB
        - main.arg_max_null(BLOB arg, VARCHAR val) -> BLOB
        - main.arg_max_null(BLOB arg, DATE val) -> BLOB
        - main.arg_max_null(BLOB arg, TIMESTAMP val) -> BLOB
        - main.arg_max_null(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.arg_max_null(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_function(
            self._ARG_MAX_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_max_null_filter')
    def arg_max_null_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``arg_max_null`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_max_null(BLOB arg, INTEGER val) -> BLOB
        - main.arg_max_null(BLOB arg, BIGINT val) -> BLOB
        - main.arg_max_null(BLOB arg, HUGEINT val) -> BLOB
        - main.arg_max_null(BLOB arg, DOUBLE val) -> BLOB
        - main.arg_max_null(BLOB arg, VARCHAR val) -> BLOB
        - main.arg_max_null(BLOB arg, DATE val) -> BLOB
        - main.arg_max_null(BLOB arg, TIMESTAMP val) -> BLOB
        - main.arg_max_null(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.arg_max_null(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MAX_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_min')
    def arg_min(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``arg_min``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_min(BLOB arg, INTEGER val) -> BLOB
        - main.arg_min(BLOB arg, BIGINT val) -> BLOB
        - main.arg_min(BLOB arg, HUGEINT val) -> BLOB
        - main.arg_min(BLOB arg, DOUBLE val) -> BLOB
        - main.arg_min(BLOB arg, VARCHAR val) -> BLOB
        - main.arg_min(BLOB arg, DATE val) -> BLOB
        - main.arg_min(BLOB arg, TIMESTAMP val) -> BLOB
        - main.arg_min(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.arg_min(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_function(
            self._ARG_MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_min_filter')
    def arg_min_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``arg_min`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_min(BLOB arg, INTEGER val) -> BLOB
        - main.arg_min(BLOB arg, BIGINT val) -> BLOB
        - main.arg_min(BLOB arg, HUGEINT val) -> BLOB
        - main.arg_min(BLOB arg, DOUBLE val) -> BLOB
        - main.arg_min(BLOB arg, VARCHAR val) -> BLOB
        - main.arg_min(BLOB arg, DATE val) -> BLOB
        - main.arg_min(BLOB arg, TIMESTAMP val) -> BLOB
        - main.arg_min(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.arg_min(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MIN_NULL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_min_null')
    def arg_min_null(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``arg_min_null``.

        Finds the row with the minimum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_min_null(BLOB arg, INTEGER val) -> BLOB
        - main.arg_min_null(BLOB arg, BIGINT val) -> BLOB
        - main.arg_min_null(BLOB arg, HUGEINT val) -> BLOB
        - main.arg_min_null(BLOB arg, DOUBLE val) -> BLOB
        - main.arg_min_null(BLOB arg, VARCHAR val) -> BLOB
        - main.arg_min_null(BLOB arg, DATE val) -> BLOB
        - main.arg_min_null(BLOB arg, TIMESTAMP val) -> BLOB
        - main.arg_min_null(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.arg_min_null(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_function(
            self._ARG_MIN_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_min_null_filter')
    def arg_min_null_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``arg_min_null`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_min_null(BLOB arg, INTEGER val) -> BLOB
        - main.arg_min_null(BLOB arg, BIGINT val) -> BLOB
        - main.arg_min_null(BLOB arg, HUGEINT val) -> BLOB
        - main.arg_min_null(BLOB arg, DOUBLE val) -> BLOB
        - main.arg_min_null(BLOB arg, VARCHAR val) -> BLOB
        - main.arg_min_null(BLOB arg, DATE val) -> BLOB
        - main.arg_min_null(BLOB arg, TIMESTAMP val) -> BLOB
        - main.arg_min_null(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.arg_min_null(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MIN_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARGMAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('argmax')
    def argmax(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``argmax``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmax(BLOB arg, INTEGER val) -> BLOB
        - main.argmax(BLOB arg, BIGINT val) -> BLOB
        - main.argmax(BLOB arg, HUGEINT val) -> BLOB
        - main.argmax(BLOB arg, DOUBLE val) -> BLOB
        - main.argmax(BLOB arg, VARCHAR val) -> BLOB
        - main.argmax(BLOB arg, DATE val) -> BLOB
        - main.argmax(BLOB arg, TIMESTAMP val) -> BLOB
        - main.argmax(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.argmax(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_function(
            self._ARGMAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('argmax_filter')
    def argmax_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``argmax`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmax(BLOB arg, INTEGER val) -> BLOB
        - main.argmax(BLOB arg, BIGINT val) -> BLOB
        - main.argmax(BLOB arg, HUGEINT val) -> BLOB
        - main.argmax(BLOB arg, DOUBLE val) -> BLOB
        - main.argmax(BLOB arg, VARCHAR val) -> BLOB
        - main.argmax(BLOB arg, DATE val) -> BLOB
        - main.argmax(BLOB arg, TIMESTAMP val) -> BLOB
        - main.argmax(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.argmax(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARGMAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARGMIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('argmin')
    def argmin(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``argmin``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmin(BLOB arg, INTEGER val) -> BLOB
        - main.argmin(BLOB arg, BIGINT val) -> BLOB
        - main.argmin(BLOB arg, HUGEINT val) -> BLOB
        - main.argmin(BLOB arg, DOUBLE val) -> BLOB
        - main.argmin(BLOB arg, VARCHAR val) -> BLOB
        - main.argmin(BLOB arg, DATE val) -> BLOB
        - main.argmin(BLOB arg, TIMESTAMP val) -> BLOB
        - main.argmin(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.argmin(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_function(
            self._ARGMIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('argmin_filter')
    def argmin_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``argmin`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmin(BLOB arg, INTEGER val) -> BLOB
        - main.argmin(BLOB arg, BIGINT val) -> BLOB
        - main.argmin(BLOB arg, HUGEINT val) -> BLOB
        - main.argmin(BLOB arg, DOUBLE val) -> BLOB
        - main.argmin(BLOB arg, VARCHAR val) -> BLOB
        - main.argmin(BLOB arg, DATE val) -> BLOB
        - main.argmin(BLOB arg, TIMESTAMP val) -> BLOB
        - main.argmin(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.argmin(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARGMIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MAX_BY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('max_by')
    def max_by(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``max_by``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.max_by(BLOB arg, INTEGER val) -> BLOB
        - main.max_by(BLOB arg, BIGINT val) -> BLOB
        - main.max_by(BLOB arg, HUGEINT val) -> BLOB
        - main.max_by(BLOB arg, DOUBLE val) -> BLOB
        - main.max_by(BLOB arg, VARCHAR val) -> BLOB
        - main.max_by(BLOB arg, DATE val) -> BLOB
        - main.max_by(BLOB arg, TIMESTAMP val) -> BLOB
        - main.max_by(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.max_by(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_function(
            self._MAX_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('max_by_filter')
    def max_by_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``max_by`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.max_by(BLOB arg, INTEGER val) -> BLOB
        - main.max_by(BLOB arg, BIGINT val) -> BLOB
        - main.max_by(BLOB arg, HUGEINT val) -> BLOB
        - main.max_by(BLOB arg, DOUBLE val) -> BLOB
        - main.max_by(BLOB arg, VARCHAR val) -> BLOB
        - main.max_by(BLOB arg, DATE val) -> BLOB
        - main.max_by(BLOB arg, TIMESTAMP val) -> BLOB
        - main.max_by(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.max_by(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_filter_function(
            predicate,
            self._MAX_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MIN_BY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('min_by')
    def min_by(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``min_by``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.min_by(BLOB arg, INTEGER val) -> BLOB
        - main.min_by(BLOB arg, BIGINT val) -> BLOB
        - main.min_by(BLOB arg, HUGEINT val) -> BLOB
        - main.min_by(BLOB arg, DOUBLE val) -> BLOB
        - main.min_by(BLOB arg, VARCHAR val) -> BLOB
        - main.min_by(BLOB arg, DATE val) -> BLOB
        - main.min_by(BLOB arg, TIMESTAMP val) -> BLOB
        - main.min_by(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.min_by(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_function(
            self._MIN_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('min_by_filter')
    def min_by_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BlobExpression:
        """Call DuckDB function ``min_by`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.min_by(BLOB arg, INTEGER val) -> BLOB
        - main.min_by(BLOB arg, BIGINT val) -> BLOB
        - main.min_by(BLOB arg, HUGEINT val) -> BLOB
        - main.min_by(BLOB arg, DOUBLE val) -> BLOB
        - main.min_by(BLOB arg, VARCHAR val) -> BLOB
        - main.min_by(BLOB arg, DATE val) -> BLOB
        - main.min_by(BLOB arg, TIMESTAMP val) -> BLOB
        - main.min_by(BLOB arg, TIMESTAMP WITH TIME ZONE val) -> BLOB
        - main.min_by(BLOB arg, BLOB val) -> BLOB
        """
        return call_duckdb_filter_function(
            predicate,
            self._MIN_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        'arg_max': 'arg_max',
        'arg_max_filter': 'arg_max_filter',
        'arg_max_null': 'arg_max_null',
        'arg_max_null_filter': 'arg_max_null_filter',
        'arg_min': 'arg_min',
        'arg_min_filter': 'arg_min_filter',
        'arg_min_null': 'arg_min_null',
        'arg_min_null_filter': 'arg_min_null_filter',
        'argmax': 'argmax',
        'argmax_filter': 'argmax_filter',
        'argmin': 'argmin',
        'argmin_filter': 'argmin_filter',
        'max_by': 'max_by',
        'max_by_filter': 'max_by_filter',
        'min_by': 'min_by',
        'min_by_filter': 'min_by_filter',
    }
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class AggregateBooleanFunctions(_StaticFunctionNamespace):
    """DuckDB aggregate functions returning boolean results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'aggregate'
    return_category: ClassVar[str] = 'boolean'
    _BOOL_AND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bool_and',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('BOOLEAN'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns TRUE if every input value is TRUE, otherwise FALSE.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bool_and')
    def bool_and(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BooleanExpression:
        """Call DuckDB function ``bool_and``.

        Returns TRUE if every input value is TRUE, otherwise FALSE.

        Overloads:
        - main.bool_and(BOOLEAN arg) -> BOOLEAN
        """
        return call_duckdb_function(
            self._BOOL_AND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('bool_and_filter')
    def bool_and_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BooleanExpression:
        """Call DuckDB function ``bool_and`` with ``FILTER``.

        Returns TRUE if every input value is TRUE, otherwise FALSE.

        Overloads:
        - main.bool_and(BOOLEAN arg) -> BOOLEAN
        """
        return call_duckdb_filter_function(
            predicate,
            self._BOOL_AND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _BOOL_OR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bool_or',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('BOOLEAN'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns TRUE if any input value is TRUE, otherwise FALSE.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bool_or')
    def bool_or(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BooleanExpression:
        """Call DuckDB function ``bool_or``.

        Returns TRUE if any input value is TRUE, otherwise FALSE.

        Overloads:
        - main.bool_or(BOOLEAN arg) -> BOOLEAN
        """
        return call_duckdb_function(
            self._BOOL_OR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('bool_or_filter')
    def bool_or_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> BooleanExpression:
        """Call DuckDB function ``bool_or`` with ``FILTER``.

        Returns TRUE if any input value is TRUE, otherwise FALSE.

        Overloads:
        - main.bool_or(BOOLEAN arg) -> BOOLEAN
        """
        return call_duckdb_filter_function(
            predicate,
            self._BOOL_OR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        'bool_and': 'bool_and',
        'bool_and_filter': 'bool_and_filter',
        'bool_or': 'bool_or',
        'bool_or_filter': 'bool_or_filter',
    }
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class AggregateGenericFunctions(_StaticFunctionNamespace):
    """DuckDB aggregate functions returning generic results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'aggregate'
    return_category: ClassVar[str] = 'generic'
    _ANY_VALUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='any_value',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the first non-NULL value from arg. This function is affected by ordering.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('any_value')
    def any_value(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``any_value``.

        Returns the first non-NULL value from arg. This function is affected by ordering.

        Overloads:
        - main.any_value(ANY arg) -> ANY
        """
        return call_duckdb_function(
            self._ANY_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('any_value_filter')
    def any_value_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``any_value`` with ``FILTER``.

        Returns the first non-NULL value from arg. This function is affected by ordering.

        Overloads:
        - main.any_value(ANY arg) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._ANY_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _APPROX_QUANTILE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('TIME'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('DATE[]'),
                        parameter_types=(parse_type('DATE'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('TIME[]'),
                        parameter_types=(parse_type('TIME'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE[]'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP[]'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE[]'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('approx_quantile')
    def approx_quantile(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``approx_quantile``.

        Computes the approximate quantile using T-Digest.

        Overloads:
        - main.approx_quantile(DATE x, FLOAT pos) -> DATE
        - main.approx_quantile(TIME x, FLOAT pos) -> TIME
        - main.approx_quantile(TIME WITH TIME ZONE x, FLOAT pos) -> TIME WITH TIME ZONE
        - main.approx_quantile(TIMESTAMP x, FLOAT pos) -> TIMESTAMP
        - main.approx_quantile(TIMESTAMP WITH TIME ZONE x, FLOAT pos) -> TIMESTAMP WITH TIME ZONE
        - main.approx_quantile(DATE x, FLOAT[] pos) -> DATE[]
        - main.approx_quantile(TIME x, FLOAT[] pos) -> TIME[]
        - main.approx_quantile(TIME WITH TIME ZONE x, FLOAT[] pos) -> TIME WITH TIME ZONE[]
        - main.approx_quantile(TIMESTAMP x, FLOAT[] pos) -> TIMESTAMP[]
        - main.approx_quantile(TIMESTAMP WITH TIME ZONE x, FLOAT[] pos) -> TIMESTAMP WITH TIME ZONE[]
        """
        return call_duckdb_function(
            self._APPROX_QUANTILE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('approx_quantile_filter')
    def approx_quantile_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``approx_quantile`` with ``FILTER``.

        Computes the approximate quantile using T-Digest.

        Overloads:
        - main.approx_quantile(DATE x, FLOAT pos) -> DATE
        - main.approx_quantile(TIME x, FLOAT pos) -> TIME
        - main.approx_quantile(TIME WITH TIME ZONE x, FLOAT pos) -> TIME WITH TIME ZONE
        - main.approx_quantile(TIMESTAMP x, FLOAT pos) -> TIMESTAMP
        - main.approx_quantile(TIMESTAMP WITH TIME ZONE x, FLOAT pos) -> TIMESTAMP WITH TIME ZONE
        - main.approx_quantile(DATE x, FLOAT[] pos) -> DATE[]
        - main.approx_quantile(TIME x, FLOAT[] pos) -> TIME[]
        - main.approx_quantile(TIME WITH TIME ZONE x, FLOAT[] pos) -> TIME WITH TIME ZONE[]
        - main.approx_quantile(TIMESTAMP x, FLOAT[] pos) -> TIMESTAMP[]
        - main.approx_quantile(TIMESTAMP WITH TIME ZONE x, FLOAT[] pos) -> TIMESTAMP WITH TIME ZONE[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._APPROX_QUANTILE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _APPROX_TOP_K_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_top_k',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('val', 'k'),
                        varargs=None,
                        description='Finds the k approximately most occurring values in the data set',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('approx_top_k')
    def approx_top_k(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``approx_top_k``.

        Finds the k approximately most occurring values in the data set

        Overloads:
        - main.approx_top_k(ANY val, BIGINT k) -> ANY[]
        """
        return call_duckdb_function(
            self._APPROX_TOP_K_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('approx_top_k_filter')
    def approx_top_k_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``approx_top_k`` with ``FILTER``.

        Finds the k approximately most occurring values in the data set

        Overloads:
        - main.approx_top_k(ANY val, BIGINT k) -> ANY[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._APPROX_TOP_K_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARBITRARY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arbitrary',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arbitrary')
    def arbitrary(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arbitrary``.

        Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.

        Overloads:
        - main.arbitrary(ANY arg) -> ANY
        """
        return call_duckdb_function(
            self._ARBITRARY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arbitrary_filter')
    def arbitrary_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arbitrary`` with ``FILTER``.

        Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.

        Overloads:
        - main.arbitrary(ANY arg) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARBITRARY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val', 'col2'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_max')
    def arg_max(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arg_max``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_max(DATE arg, INTEGER val) -> DATE
        - main.arg_max(DATE arg, BIGINT val) -> DATE
        - main.arg_max(DATE arg, HUGEINT val) -> DATE
        - main.arg_max(DATE arg, DOUBLE val) -> DATE
        - main.arg_max(DATE arg, VARCHAR val) -> DATE
        - main.arg_max(DATE arg, DATE val) -> DATE
        - main.arg_max(DATE arg, TIMESTAMP val) -> DATE
        - main.arg_max(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.arg_max(DATE arg, BLOB val) -> DATE
        - main.arg_max(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(ANY arg, INTEGER val) -> ANY
        - main.arg_max(ANY arg, BIGINT val) -> ANY
        - main.arg_max(ANY arg, HUGEINT val) -> ANY
        - main.arg_max(ANY arg, DOUBLE val) -> ANY
        - main.arg_max(ANY arg, VARCHAR val) -> ANY
        - main.arg_max(ANY arg, DATE val) -> ANY
        - main.arg_max(ANY arg, TIMESTAMP val) -> ANY
        - main.arg_max(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.arg_max(ANY arg, BLOB val) -> ANY
        - main.arg_max(ANY arg, ANY val) -> ANY
        - main.arg_max(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_function(
            self._ARG_MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_max_filter')
    def arg_max_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arg_max`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_max(DATE arg, INTEGER val) -> DATE
        - main.arg_max(DATE arg, BIGINT val) -> DATE
        - main.arg_max(DATE arg, HUGEINT val) -> DATE
        - main.arg_max(DATE arg, DOUBLE val) -> DATE
        - main.arg_max(DATE arg, VARCHAR val) -> DATE
        - main.arg_max(DATE arg, DATE val) -> DATE
        - main.arg_max(DATE arg, TIMESTAMP val) -> DATE
        - main.arg_max(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.arg_max(DATE arg, BLOB val) -> DATE
        - main.arg_max(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max(ANY arg, INTEGER val) -> ANY
        - main.arg_max(ANY arg, BIGINT val) -> ANY
        - main.arg_max(ANY arg, HUGEINT val) -> ANY
        - main.arg_max(ANY arg, DOUBLE val) -> ANY
        - main.arg_max(ANY arg, VARCHAR val) -> ANY
        - main.arg_max(ANY arg, DATE val) -> ANY
        - main.arg_max(ANY arg, TIMESTAMP val) -> ANY
        - main.arg_max(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.arg_max(ANY arg, BLOB val) -> ANY
        - main.arg_max(ANY arg, ANY val) -> ANY
        - main.arg_max(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MAX_NULL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_max_null')
    def arg_max_null(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arg_max_null``.

        Finds the row with the maximum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_max_null(DATE arg, INTEGER val) -> DATE
        - main.arg_max_null(DATE arg, BIGINT val) -> DATE
        - main.arg_max_null(DATE arg, HUGEINT val) -> DATE
        - main.arg_max_null(DATE arg, DOUBLE val) -> DATE
        - main.arg_max_null(DATE arg, VARCHAR val) -> DATE
        - main.arg_max_null(DATE arg, DATE val) -> DATE
        - main.arg_max_null(DATE arg, TIMESTAMP val) -> DATE
        - main.arg_max_null(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.arg_max_null(DATE arg, BLOB val) -> DATE
        - main.arg_max_null(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(ANY arg, INTEGER val) -> ANY
        - main.arg_max_null(ANY arg, BIGINT val) -> ANY
        - main.arg_max_null(ANY arg, HUGEINT val) -> ANY
        - main.arg_max_null(ANY arg, DOUBLE val) -> ANY
        - main.arg_max_null(ANY arg, VARCHAR val) -> ANY
        - main.arg_max_null(ANY arg, DATE val) -> ANY
        - main.arg_max_null(ANY arg, TIMESTAMP val) -> ANY
        - main.arg_max_null(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.arg_max_null(ANY arg, BLOB val) -> ANY
        - main.arg_max_null(ANY arg, ANY val) -> ANY
        """
        return call_duckdb_function(
            self._ARG_MAX_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_max_null_filter')
    def arg_max_null_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arg_max_null`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_max_null(DATE arg, INTEGER val) -> DATE
        - main.arg_max_null(DATE arg, BIGINT val) -> DATE
        - main.arg_max_null(DATE arg, HUGEINT val) -> DATE
        - main.arg_max_null(DATE arg, DOUBLE val) -> DATE
        - main.arg_max_null(DATE arg, VARCHAR val) -> DATE
        - main.arg_max_null(DATE arg, DATE val) -> DATE
        - main.arg_max_null(DATE arg, TIMESTAMP val) -> DATE
        - main.arg_max_null(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.arg_max_null(DATE arg, BLOB val) -> DATE
        - main.arg_max_null(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_max_null(ANY arg, INTEGER val) -> ANY
        - main.arg_max_null(ANY arg, BIGINT val) -> ANY
        - main.arg_max_null(ANY arg, HUGEINT val) -> ANY
        - main.arg_max_null(ANY arg, DOUBLE val) -> ANY
        - main.arg_max_null(ANY arg, VARCHAR val) -> ANY
        - main.arg_max_null(ANY arg, DATE val) -> ANY
        - main.arg_max_null(ANY arg, TIMESTAMP val) -> ANY
        - main.arg_max_null(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.arg_max_null(ANY arg, BLOB val) -> ANY
        - main.arg_max_null(ANY arg, ANY val) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MAX_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val', 'col2'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_min')
    def arg_min(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arg_min``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_min(DATE arg, INTEGER val) -> DATE
        - main.arg_min(DATE arg, BIGINT val) -> DATE
        - main.arg_min(DATE arg, HUGEINT val) -> DATE
        - main.arg_min(DATE arg, DOUBLE val) -> DATE
        - main.arg_min(DATE arg, VARCHAR val) -> DATE
        - main.arg_min(DATE arg, DATE val) -> DATE
        - main.arg_min(DATE arg, TIMESTAMP val) -> DATE
        - main.arg_min(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.arg_min(DATE arg, BLOB val) -> DATE
        - main.arg_min(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(ANY arg, INTEGER val) -> ANY
        - main.arg_min(ANY arg, BIGINT val) -> ANY
        - main.arg_min(ANY arg, HUGEINT val) -> ANY
        - main.arg_min(ANY arg, DOUBLE val) -> ANY
        - main.arg_min(ANY arg, VARCHAR val) -> ANY
        - main.arg_min(ANY arg, DATE val) -> ANY
        - main.arg_min(ANY arg, TIMESTAMP val) -> ANY
        - main.arg_min(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.arg_min(ANY arg, BLOB val) -> ANY
        - main.arg_min(ANY arg, ANY val) -> ANY
        - main.arg_min(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_function(
            self._ARG_MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_min_filter')
    def arg_min_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arg_min`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_min(DATE arg, INTEGER val) -> DATE
        - main.arg_min(DATE arg, BIGINT val) -> DATE
        - main.arg_min(DATE arg, HUGEINT val) -> DATE
        - main.arg_min(DATE arg, DOUBLE val) -> DATE
        - main.arg_min(DATE arg, VARCHAR val) -> DATE
        - main.arg_min(DATE arg, DATE val) -> DATE
        - main.arg_min(DATE arg, TIMESTAMP val) -> DATE
        - main.arg_min(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.arg_min(DATE arg, BLOB val) -> DATE
        - main.arg_min(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min(ANY arg, INTEGER val) -> ANY
        - main.arg_min(ANY arg, BIGINT val) -> ANY
        - main.arg_min(ANY arg, HUGEINT val) -> ANY
        - main.arg_min(ANY arg, DOUBLE val) -> ANY
        - main.arg_min(ANY arg, VARCHAR val) -> ANY
        - main.arg_min(ANY arg, DATE val) -> ANY
        - main.arg_min(ANY arg, TIMESTAMP val) -> ANY
        - main.arg_min(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.arg_min(ANY arg, BLOB val) -> ANY
        - main.arg_min(ANY arg, ANY val) -> ANY
        - main.arg_min(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MIN_NULL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_min_null')
    def arg_min_null(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arg_min_null``.

        Finds the row with the minimum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_min_null(DATE arg, INTEGER val) -> DATE
        - main.arg_min_null(DATE arg, BIGINT val) -> DATE
        - main.arg_min_null(DATE arg, HUGEINT val) -> DATE
        - main.arg_min_null(DATE arg, DOUBLE val) -> DATE
        - main.arg_min_null(DATE arg, VARCHAR val) -> DATE
        - main.arg_min_null(DATE arg, DATE val) -> DATE
        - main.arg_min_null(DATE arg, TIMESTAMP val) -> DATE
        - main.arg_min_null(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.arg_min_null(DATE arg, BLOB val) -> DATE
        - main.arg_min_null(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(ANY arg, INTEGER val) -> ANY
        - main.arg_min_null(ANY arg, BIGINT val) -> ANY
        - main.arg_min_null(ANY arg, HUGEINT val) -> ANY
        - main.arg_min_null(ANY arg, DOUBLE val) -> ANY
        - main.arg_min_null(ANY arg, VARCHAR val) -> ANY
        - main.arg_min_null(ANY arg, DATE val) -> ANY
        - main.arg_min_null(ANY arg, TIMESTAMP val) -> ANY
        - main.arg_min_null(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.arg_min_null(ANY arg, BLOB val) -> ANY
        - main.arg_min_null(ANY arg, ANY val) -> ANY
        """
        return call_duckdb_function(
            self._ARG_MIN_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_min_null_filter')
    def arg_min_null_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``arg_min_null`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_min_null(DATE arg, INTEGER val) -> DATE
        - main.arg_min_null(DATE arg, BIGINT val) -> DATE
        - main.arg_min_null(DATE arg, HUGEINT val) -> DATE
        - main.arg_min_null(DATE arg, DOUBLE val) -> DATE
        - main.arg_min_null(DATE arg, VARCHAR val) -> DATE
        - main.arg_min_null(DATE arg, DATE val) -> DATE
        - main.arg_min_null(DATE arg, TIMESTAMP val) -> DATE
        - main.arg_min_null(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.arg_min_null(DATE arg, BLOB val) -> DATE
        - main.arg_min_null(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.arg_min_null(ANY arg, INTEGER val) -> ANY
        - main.arg_min_null(ANY arg, BIGINT val) -> ANY
        - main.arg_min_null(ANY arg, HUGEINT val) -> ANY
        - main.arg_min_null(ANY arg, DOUBLE val) -> ANY
        - main.arg_min_null(ANY arg, VARCHAR val) -> ANY
        - main.arg_min_null(ANY arg, DATE val) -> ANY
        - main.arg_min_null(ANY arg, TIMESTAMP val) -> ANY
        - main.arg_min_null(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.arg_min_null(ANY arg, BLOB val) -> ANY
        - main.arg_min_null(ANY arg, ANY val) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MIN_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARGMAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val', 'col2'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('argmax')
    def argmax(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``argmax``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmax(DATE arg, INTEGER val) -> DATE
        - main.argmax(DATE arg, BIGINT val) -> DATE
        - main.argmax(DATE arg, HUGEINT val) -> DATE
        - main.argmax(DATE arg, DOUBLE val) -> DATE
        - main.argmax(DATE arg, VARCHAR val) -> DATE
        - main.argmax(DATE arg, DATE val) -> DATE
        - main.argmax(DATE arg, TIMESTAMP val) -> DATE
        - main.argmax(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.argmax(DATE arg, BLOB val) -> DATE
        - main.argmax(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(ANY arg, INTEGER val) -> ANY
        - main.argmax(ANY arg, BIGINT val) -> ANY
        - main.argmax(ANY arg, HUGEINT val) -> ANY
        - main.argmax(ANY arg, DOUBLE val) -> ANY
        - main.argmax(ANY arg, VARCHAR val) -> ANY
        - main.argmax(ANY arg, DATE val) -> ANY
        - main.argmax(ANY arg, TIMESTAMP val) -> ANY
        - main.argmax(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.argmax(ANY arg, BLOB val) -> ANY
        - main.argmax(ANY arg, ANY val) -> ANY
        - main.argmax(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_function(
            self._ARGMAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('argmax_filter')
    def argmax_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``argmax`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmax(DATE arg, INTEGER val) -> DATE
        - main.argmax(DATE arg, BIGINT val) -> DATE
        - main.argmax(DATE arg, HUGEINT val) -> DATE
        - main.argmax(DATE arg, DOUBLE val) -> DATE
        - main.argmax(DATE arg, VARCHAR val) -> DATE
        - main.argmax(DATE arg, DATE val) -> DATE
        - main.argmax(DATE arg, TIMESTAMP val) -> DATE
        - main.argmax(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.argmax(DATE arg, BLOB val) -> DATE
        - main.argmax(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.argmax(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.argmax(ANY arg, INTEGER val) -> ANY
        - main.argmax(ANY arg, BIGINT val) -> ANY
        - main.argmax(ANY arg, HUGEINT val) -> ANY
        - main.argmax(ANY arg, DOUBLE val) -> ANY
        - main.argmax(ANY arg, VARCHAR val) -> ANY
        - main.argmax(ANY arg, DATE val) -> ANY
        - main.argmax(ANY arg, TIMESTAMP val) -> ANY
        - main.argmax(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.argmax(ANY arg, BLOB val) -> ANY
        - main.argmax(ANY arg, ANY val) -> ANY
        - main.argmax(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARGMAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARGMIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val', 'col2'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('argmin')
    def argmin(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``argmin``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmin(DATE arg, INTEGER val) -> DATE
        - main.argmin(DATE arg, BIGINT val) -> DATE
        - main.argmin(DATE arg, HUGEINT val) -> DATE
        - main.argmin(DATE arg, DOUBLE val) -> DATE
        - main.argmin(DATE arg, VARCHAR val) -> DATE
        - main.argmin(DATE arg, DATE val) -> DATE
        - main.argmin(DATE arg, TIMESTAMP val) -> DATE
        - main.argmin(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.argmin(DATE arg, BLOB val) -> DATE
        - main.argmin(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(ANY arg, INTEGER val) -> ANY
        - main.argmin(ANY arg, BIGINT val) -> ANY
        - main.argmin(ANY arg, HUGEINT val) -> ANY
        - main.argmin(ANY arg, DOUBLE val) -> ANY
        - main.argmin(ANY arg, VARCHAR val) -> ANY
        - main.argmin(ANY arg, DATE val) -> ANY
        - main.argmin(ANY arg, TIMESTAMP val) -> ANY
        - main.argmin(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.argmin(ANY arg, BLOB val) -> ANY
        - main.argmin(ANY arg, ANY val) -> ANY
        - main.argmin(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_function(
            self._ARGMIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('argmin_filter')
    def argmin_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``argmin`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmin(DATE arg, INTEGER val) -> DATE
        - main.argmin(DATE arg, BIGINT val) -> DATE
        - main.argmin(DATE arg, HUGEINT val) -> DATE
        - main.argmin(DATE arg, DOUBLE val) -> DATE
        - main.argmin(DATE arg, VARCHAR val) -> DATE
        - main.argmin(DATE arg, DATE val) -> DATE
        - main.argmin(DATE arg, TIMESTAMP val) -> DATE
        - main.argmin(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.argmin(DATE arg, BLOB val) -> DATE
        - main.argmin(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.argmin(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.argmin(ANY arg, INTEGER val) -> ANY
        - main.argmin(ANY arg, BIGINT val) -> ANY
        - main.argmin(ANY arg, HUGEINT val) -> ANY
        - main.argmin(ANY arg, DOUBLE val) -> ANY
        - main.argmin(ANY arg, VARCHAR val) -> ANY
        - main.argmin(ANY arg, DATE val) -> ANY
        - main.argmin(ANY arg, TIMESTAMP val) -> ANY
        - main.argmin(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.argmin(ANY arg, BLOB val) -> ANY
        - main.argmin(ANY arg, ANY val) -> ANY
        - main.argmin(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARGMIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARRAY_AGG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_agg',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a LIST containing all the values of a column.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_agg')
    def array_agg(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``array_agg``.

        Returns a LIST containing all the values of a column.

        Overloads:
        - main.array_agg(T arg) -> T[]
        """
        return call_duckdb_function(
            self._ARRAY_AGG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('array_agg_filter')
    def array_agg_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``array_agg`` with ``FILTER``.

        Returns a LIST containing all the values of a column.

        Overloads:
        - main.array_agg(T arg) -> T[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARRAY_AGG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _AVG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('avg')
    def avg(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``avg``.

        Calculates the average value for all tuples in x.

        Overloads:
        - main.avg(TIMESTAMP x) -> TIMESTAMP
        - main.avg(TIMESTAMP WITH TIME ZONE x) -> TIMESTAMP WITH TIME ZONE
        - main.avg(TIME x) -> TIME
        - main.avg(TIME WITH TIME ZONE x) -> TIME WITH TIME ZONE
        """
        return call_duckdb_function(
            self._AVG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('avg_filter')
    def avg_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``avg`` with ``FILTER``.

        Calculates the average value for all tuples in x.

        Overloads:
        - main.avg(TIMESTAMP x) -> TIMESTAMP
        - main.avg(TIMESTAMP WITH TIME ZONE x) -> TIMESTAMP WITH TIME ZONE
        - main.avg(TIME x) -> TIME
        - main.avg(TIME WITH TIME ZONE x) -> TIME WITH TIME ZONE
        """
        return call_duckdb_filter_function(
            predicate,
            self._AVG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _BIT_AND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bit_and')
    def bit_and(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``bit_and``.

        Returns the bitwise AND of all bits in a given expression.

        Overloads:
        - main.bit_and(UHUGEINT arg) -> UHUGEINT
        - main.bit_and(BIT arg) -> BIT
        """
        return call_duckdb_function(
            self._BIT_AND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('bit_and_filter')
    def bit_and_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``bit_and`` with ``FILTER``.

        Returns the bitwise AND of all bits in a given expression.

        Overloads:
        - main.bit_and(UHUGEINT arg) -> UHUGEINT
        - main.bit_and(BIT arg) -> BIT
        """
        return call_duckdb_filter_function(
            predicate,
            self._BIT_AND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _BIT_OR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bit_or')
    def bit_or(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``bit_or``.

        Returns the bitwise OR of all bits in a given expression.

        Overloads:
        - main.bit_or(UHUGEINT arg) -> UHUGEINT
        - main.bit_or(BIT arg) -> BIT
        """
        return call_duckdb_function(
            self._BIT_OR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('bit_or_filter')
    def bit_or_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``bit_or`` with ``FILTER``.

        Returns the bitwise OR of all bits in a given expression.

        Overloads:
        - main.bit_or(UHUGEINT arg) -> UHUGEINT
        - main.bit_or(BIT arg) -> BIT
        """
        return call_duckdb_filter_function(
            predicate,
            self._BIT_OR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _BIT_XOR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bit_xor')
    def bit_xor(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``bit_xor``.

        Returns the bitwise XOR of all bits in a given expression.

        Overloads:
        - main.bit_xor(UHUGEINT arg) -> UHUGEINT
        - main.bit_xor(BIT arg) -> BIT
        """
        return call_duckdb_function(
            self._BIT_XOR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('bit_xor_filter')
    def bit_xor_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``bit_xor`` with ``FILTER``.

        Returns the bitwise XOR of all bits in a given expression.

        Overloads:
        - main.bit_xor(UHUGEINT arg) -> UHUGEINT
        - main.bit_xor(BIT arg) -> BIT
        """
        return call_duckdb_filter_function(
            predicate,
            self._BIT_XOR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _BITSTRING_AGG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring_agg',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('arg', 'col1', 'col2'),
                        varargs=None,
                        description='Returns a bitstring with bits set for each distinct value.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bitstring_agg')
    def bitstring_agg(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``bitstring_agg``.

        Returns a bitstring with bits set for each distinct value.

        Overloads:
        - main.bitstring_agg(TINYINT arg) -> BIT
        - main.bitstring_agg(SMALLINT arg) -> BIT
        - main.bitstring_agg(INTEGER arg) -> BIT
        - main.bitstring_agg(BIGINT arg) -> BIT
        - main.bitstring_agg(HUGEINT arg) -> BIT
        - main.bitstring_agg(UTINYINT arg) -> BIT
        - main.bitstring_agg(USMALLINT arg) -> BIT
        - main.bitstring_agg(UINTEGER arg) -> BIT
        - main.bitstring_agg(UBIGINT arg) -> BIT
        - main.bitstring_agg(UHUGEINT arg) -> BIT
        - main.bitstring_agg(TINYINT arg, TINYINT col1, TINYINT col2) -> BIT
        - main.bitstring_agg(SMALLINT arg, SMALLINT col1, SMALLINT col2) -> BIT
        - main.bitstring_agg(INTEGER arg, INTEGER col1, INTEGER col2) -> BIT
        - main.bitstring_agg(BIGINT arg, BIGINT col1, BIGINT col2) -> BIT
        - main.bitstring_agg(HUGEINT arg, HUGEINT col1, HUGEINT col2) -> BIT
        - main.bitstring_agg(UTINYINT arg, UTINYINT col1, UTINYINT col2) -> BIT
        - main.bitstring_agg(USMALLINT arg, USMALLINT col1, USMALLINT col2) -> BIT
        - main.bitstring_agg(UINTEGER arg, UINTEGER col1, UINTEGER col2) -> BIT
        - main.bitstring_agg(UBIGINT arg, UBIGINT col1, UBIGINT col2) -> BIT
        - main.bitstring_agg(UHUGEINT arg, UHUGEINT col1, UHUGEINT col2) -> BIT
        """
        return call_duckdb_function(
            self._BITSTRING_AGG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('bitstring_agg_filter')
    def bitstring_agg_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``bitstring_agg`` with ``FILTER``.

        Returns a bitstring with bits set for each distinct value.

        Overloads:
        - main.bitstring_agg(TINYINT arg) -> BIT
        - main.bitstring_agg(SMALLINT arg) -> BIT
        - main.bitstring_agg(INTEGER arg) -> BIT
        - main.bitstring_agg(BIGINT arg) -> BIT
        - main.bitstring_agg(HUGEINT arg) -> BIT
        - main.bitstring_agg(UTINYINT arg) -> BIT
        - main.bitstring_agg(USMALLINT arg) -> BIT
        - main.bitstring_agg(UINTEGER arg) -> BIT
        - main.bitstring_agg(UBIGINT arg) -> BIT
        - main.bitstring_agg(UHUGEINT arg) -> BIT
        - main.bitstring_agg(TINYINT arg, TINYINT col1, TINYINT col2) -> BIT
        - main.bitstring_agg(SMALLINT arg, SMALLINT col1, SMALLINT col2) -> BIT
        - main.bitstring_agg(INTEGER arg, INTEGER col1, INTEGER col2) -> BIT
        - main.bitstring_agg(BIGINT arg, BIGINT col1, BIGINT col2) -> BIT
        - main.bitstring_agg(HUGEINT arg, HUGEINT col1, HUGEINT col2) -> BIT
        - main.bitstring_agg(UTINYINT arg, UTINYINT col1, UTINYINT col2) -> BIT
        - main.bitstring_agg(USMALLINT arg, USMALLINT col1, USMALLINT col2) -> BIT
        - main.bitstring_agg(UINTEGER arg, UINTEGER col1, UINTEGER col2) -> BIT
        - main.bitstring_agg(UBIGINT arg, UBIGINT col1, UBIGINT col2) -> BIT
        - main.bitstring_agg(UHUGEINT arg, UHUGEINT col1, UHUGEINT col2) -> BIT
        """
        return call_duckdb_filter_function(
            predicate,
            self._BITSTRING_AGG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _FIRST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='first',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('first')
    def first(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``first``.

        Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.

        Overloads:
        - main.first(ANY arg) -> ANY
        """
        return call_duckdb_function(
            self._FIRST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('first_filter')
    def first_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``first`` with ``FILTER``.

        Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.

        Overloads:
        - main.first(ANY arg) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._FIRST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _HISTOGRAM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='histogram',
                        function_type=function_type,
                        return_type=parse_type('MAP'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a LIST of STRUCTs with the fields bucket and count.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='histogram',
                        function_type=function_type,
                        return_type=parse_type('MAP'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY[]')),
                        parameters=('arg', 'col1'),
                        varargs=None,
                        description='Returns a LIST of STRUCTs with the fields bucket and count.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('histogram')
    def histogram(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``histogram``.

        Returns a LIST of STRUCTs with the fields bucket and count.

        Overloads:
        - main.histogram(ANY arg) -> MAP
        - main.histogram(ANY arg, ANY[] col1) -> MAP
        """
        return call_duckdb_function(
            self._HISTOGRAM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('histogram_filter')
    def histogram_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``histogram`` with ``FILTER``.

        Returns a LIST of STRUCTs with the fields bucket and count.

        Overloads:
        - main.histogram(ANY arg) -> MAP
        - main.histogram(ANY arg, ANY[] col1) -> MAP
        """
        return call_duckdb_filter_function(
            predicate,
            self._HISTOGRAM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _HISTOGRAM_EXACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='histogram_exact',
                        function_type=function_type,
                        return_type=parse_type('MAP'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY[]')),
                        parameters=('arg', 'bins'),
                        varargs=None,
                        description='Returns a LIST of STRUCTs with the fields bucket and count matching the buckets exactly.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('histogram_exact')
    def histogram_exact(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``histogram_exact``.

        Returns a LIST of STRUCTs with the fields bucket and count matching the buckets exactly.

        Overloads:
        - main.histogram_exact(ANY arg, ANY[] bins) -> MAP
        """
        return call_duckdb_function(
            self._HISTOGRAM_EXACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('histogram_exact_filter')
    def histogram_exact_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``histogram_exact`` with ``FILTER``.

        Returns a LIST of STRUCTs with the fields bucket and count matching the buckets exactly.

        Overloads:
        - main.histogram_exact(ANY arg, ANY[] bins) -> MAP
        """
        return call_duckdb_filter_function(
            predicate,
            self._HISTOGRAM_EXACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _LAST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='last',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the last value of a column. This function is affected by ordering.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('last')
    def last(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``last``.

        Returns the last value of a column. This function is affected by ordering.

        Overloads:
        - main.last(ANY arg) -> ANY
        """
        return call_duckdb_function(
            self._LAST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('last_filter')
    def last_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``last`` with ``FILTER``.

        Returns the last value of a column. This function is affected by ordering.

        Overloads:
        - main.last(ANY arg) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._LAST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _LIST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns a LIST containing all the values of a column.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list')
    def list(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``list``.

        Returns a LIST containing all the values of a column.

        Overloads:
        - main.list(T arg) -> T[]
        """
        return call_duckdb_function(
            self._LIST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('list_filter')
    def list_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``list`` with ``FILTER``.

        Returns a LIST containing all the values of a column.

        Overloads:
        - main.list(T arg) -> T[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._LIST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the maximum value present in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'col1'),
                        varargs=None,
                        description='Returns the maximum value present in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('max')
    def max(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``max``.

        Returns the maximum value present in arg.

        Overloads:
        - main.max(ANY arg) -> ANY
        - main.max(ANY arg, BIGINT col1) -> ANY[]
        """
        return call_duckdb_function(
            self._MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('max_filter')
    def max_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``max`` with ``FILTER``.

        Returns the maximum value present in arg.

        Overloads:
        - main.max(ANY arg) -> ANY
        - main.max(ANY arg, BIGINT col1) -> ANY[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MAX_BY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val', 'col2'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('max_by')
    def max_by(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``max_by``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.max_by(DATE arg, INTEGER val) -> DATE
        - main.max_by(DATE arg, BIGINT val) -> DATE
        - main.max_by(DATE arg, HUGEINT val) -> DATE
        - main.max_by(DATE arg, DOUBLE val) -> DATE
        - main.max_by(DATE arg, VARCHAR val) -> DATE
        - main.max_by(DATE arg, DATE val) -> DATE
        - main.max_by(DATE arg, TIMESTAMP val) -> DATE
        - main.max_by(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.max_by(DATE arg, BLOB val) -> DATE
        - main.max_by(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(ANY arg, INTEGER val) -> ANY
        - main.max_by(ANY arg, BIGINT val) -> ANY
        - main.max_by(ANY arg, HUGEINT val) -> ANY
        - main.max_by(ANY arg, DOUBLE val) -> ANY
        - main.max_by(ANY arg, VARCHAR val) -> ANY
        - main.max_by(ANY arg, DATE val) -> ANY
        - main.max_by(ANY arg, TIMESTAMP val) -> ANY
        - main.max_by(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.max_by(ANY arg, BLOB val) -> ANY
        - main.max_by(ANY arg, ANY val) -> ANY
        - main.max_by(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_function(
            self._MAX_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('max_by_filter')
    def max_by_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``max_by`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.max_by(DATE arg, INTEGER val) -> DATE
        - main.max_by(DATE arg, BIGINT val) -> DATE
        - main.max_by(DATE arg, HUGEINT val) -> DATE
        - main.max_by(DATE arg, DOUBLE val) -> DATE
        - main.max_by(DATE arg, VARCHAR val) -> DATE
        - main.max_by(DATE arg, DATE val) -> DATE
        - main.max_by(DATE arg, TIMESTAMP val) -> DATE
        - main.max_by(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.max_by(DATE arg, BLOB val) -> DATE
        - main.max_by(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.max_by(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.max_by(ANY arg, INTEGER val) -> ANY
        - main.max_by(ANY arg, BIGINT val) -> ANY
        - main.max_by(ANY arg, HUGEINT val) -> ANY
        - main.max_by(ANY arg, DOUBLE val) -> ANY
        - main.max_by(ANY arg, VARCHAR val) -> ANY
        - main.max_by(ANY arg, DATE val) -> ANY
        - main.max_by(ANY arg, TIMESTAMP val) -> ANY
        - main.max_by(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.max_by(ANY arg, BLOB val) -> ANY
        - main.max_by(ANY arg, ANY val) -> ANY
        - main.max_by(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._MAX_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MEAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('mean')
    def mean(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``mean``.

        Calculates the average value for all tuples in x.

        Overloads:
        - main.mean(TIMESTAMP x) -> TIMESTAMP
        - main.mean(TIMESTAMP WITH TIME ZONE x) -> TIMESTAMP WITH TIME ZONE
        - main.mean(TIME x) -> TIME
        - main.mean(TIME WITH TIME ZONE x) -> TIME WITH TIME ZONE
        """
        return call_duckdb_function(
            self._MEAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('mean_filter')
    def mean_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``mean`` with ``FILTER``.

        Calculates the average value for all tuples in x.

        Overloads:
        - main.mean(TIMESTAMP x) -> TIMESTAMP
        - main.mean(TIMESTAMP WITH TIME ZONE x) -> TIMESTAMP WITH TIME ZONE
        - main.mean(TIME x) -> TIME
        - main.mean(TIME WITH TIME ZONE x) -> TIME WITH TIME ZONE
        """
        return call_duckdb_filter_function(
            predicate,
            self._MEAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MEDIAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='median',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the middle value of the set. NULL values are ignored. For even value counts, interpolate-able types (numeric, date/time) return the average of the two middle values. Non-interpolate-able types (everything else) return the lower of the two middle values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('median')
    def median(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``median``.

        Returns the middle value of the set. NULL values are ignored. For even value counts, interpolate-able types (numeric, date/time) return the average of the two middle values. Non-interpolate-able types (everything else) return the lower of the two middle values.

        Overloads:
        - main.median(ANY x) -> ANY
        """
        return call_duckdb_function(
            self._MEDIAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('median_filter')
    def median_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``median`` with ``FILTER``.

        Returns the middle value of the set. NULL values are ignored. For even value counts, interpolate-able types (numeric, date/time) return the average of the two middle values. Non-interpolate-able types (everything else) return the lower of the two middle values.

        Overloads:
        - main.median(ANY x) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._MEDIAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the minimum value present in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'col1'),
                        varargs=None,
                        description='Returns the minimum value present in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('min')
    def min(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``min``.

        Returns the minimum value present in arg.

        Overloads:
        - main.min(ANY arg) -> ANY
        - main.min(ANY arg, BIGINT col1) -> ANY[]
        """
        return call_duckdb_function(
            self._MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('min_filter')
    def min_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``min`` with ``FILTER``.

        Returns the minimum value present in arg.

        Overloads:
        - main.min(ANY arg) -> ANY
        - main.min(ANY arg, BIGINT col1) -> ANY[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MIN_BY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('arg', 'val', 'col2'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('min_by')
    def min_by(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``min_by``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.min_by(DATE arg, INTEGER val) -> DATE
        - main.min_by(DATE arg, BIGINT val) -> DATE
        - main.min_by(DATE arg, HUGEINT val) -> DATE
        - main.min_by(DATE arg, DOUBLE val) -> DATE
        - main.min_by(DATE arg, VARCHAR val) -> DATE
        - main.min_by(DATE arg, DATE val) -> DATE
        - main.min_by(DATE arg, TIMESTAMP val) -> DATE
        - main.min_by(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.min_by(DATE arg, BLOB val) -> DATE
        - main.min_by(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(ANY arg, INTEGER val) -> ANY
        - main.min_by(ANY arg, BIGINT val) -> ANY
        - main.min_by(ANY arg, HUGEINT val) -> ANY
        - main.min_by(ANY arg, DOUBLE val) -> ANY
        - main.min_by(ANY arg, VARCHAR val) -> ANY
        - main.min_by(ANY arg, DATE val) -> ANY
        - main.min_by(ANY arg, TIMESTAMP val) -> ANY
        - main.min_by(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.min_by(ANY arg, BLOB val) -> ANY
        - main.min_by(ANY arg, ANY val) -> ANY
        - main.min_by(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_function(
            self._MIN_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('min_by_filter')
    def min_by_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``min_by`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.min_by(DATE arg, INTEGER val) -> DATE
        - main.min_by(DATE arg, BIGINT val) -> DATE
        - main.min_by(DATE arg, HUGEINT val) -> DATE
        - main.min_by(DATE arg, DOUBLE val) -> DATE
        - main.min_by(DATE arg, VARCHAR val) -> DATE
        - main.min_by(DATE arg, DATE val) -> DATE
        - main.min_by(DATE arg, TIMESTAMP val) -> DATE
        - main.min_by(DATE arg, TIMESTAMP WITH TIME ZONE val) -> DATE
        - main.min_by(DATE arg, BLOB val) -> DATE
        - main.min_by(TIMESTAMP arg, INTEGER val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, BIGINT val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, HUGEINT val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, DOUBLE val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, VARCHAR val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, DATE val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, TIMESTAMP val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP
        - main.min_by(TIMESTAMP arg, BLOB val) -> TIMESTAMP
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, INTEGER val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, BIGINT val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, HUGEINT val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, DOUBLE val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, VARCHAR val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, DATE val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, TIMESTAMP WITH TIME ZONE val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(TIMESTAMP WITH TIME ZONE arg, BLOB val) -> TIMESTAMP WITH TIME ZONE
        - main.min_by(ANY arg, INTEGER val) -> ANY
        - main.min_by(ANY arg, BIGINT val) -> ANY
        - main.min_by(ANY arg, HUGEINT val) -> ANY
        - main.min_by(ANY arg, DOUBLE val) -> ANY
        - main.min_by(ANY arg, VARCHAR val) -> ANY
        - main.min_by(ANY arg, DATE val) -> ANY
        - main.min_by(ANY arg, TIMESTAMP val) -> ANY
        - main.min_by(ANY arg, TIMESTAMP WITH TIME ZONE val) -> ANY
        - main.min_by(ANY arg, BLOB val) -> ANY
        - main.min_by(ANY arg, ANY val) -> ANY
        - main.min_by(ANY arg, ANY val, BIGINT col2) -> ANY[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._MIN_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MODE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mode',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the most frequent value for the values within x. NULL values are ignored.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('mode')
    def mode(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``mode``.

        Returns the most frequent value for the values within x. NULL values are ignored.

        Overloads:
        - main.mode(ANY x) -> ANY
        """
        return call_duckdb_function(
            self._MODE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('mode_filter')
    def mode_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``mode`` with ``FILTER``.

        Returns the most frequent value for the values within x. NULL values are ignored.

        Overloads:
        - main.mode(ANY x) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._MODE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _QUANTILE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('quantile')
    def quantile(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``quantile``.

        Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.

        Overloads:
        - main.quantile(ANY x) -> ANY
        - main.quantile(ANY x, DOUBLE pos) -> ANY
        - main.quantile(ANY x, DOUBLE[] pos) -> ANY
        """
        return call_duckdb_function(
            self._QUANTILE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('quantile_filter')
    def quantile_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``quantile`` with ``FILTER``.

        Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.

        Overloads:
        - main.quantile(ANY x) -> ANY
        - main.quantile(ANY x, DOUBLE pos) -> ANY
        - main.quantile(ANY x, DOUBLE[] pos) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._QUANTILE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _QUANTILE_CONT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('TIME'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('TIME'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('quantile_cont')
    def quantile_cont(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``quantile_cont``.

        Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.	

        Overloads:
        - main.quantile_cont(DATE x, DOUBLE pos) -> DATE
        - main.quantile_cont(DATE x, DOUBLE[] pos) -> DATE
        - main.quantile_cont(TIMESTAMP x, DOUBLE pos) -> TIMESTAMP
        - main.quantile_cont(TIMESTAMP x, DOUBLE[] pos) -> TIMESTAMP
        - main.quantile_cont(TIME x, DOUBLE pos) -> TIME
        - main.quantile_cont(TIME x, DOUBLE[] pos) -> TIME
        - main.quantile_cont(TIMESTAMP WITH TIME ZONE x, DOUBLE pos) -> TIMESTAMP WITH TIME ZONE
        - main.quantile_cont(TIMESTAMP WITH TIME ZONE x, DOUBLE[] pos) -> TIMESTAMP WITH TIME ZONE
        - main.quantile_cont(TIME WITH TIME ZONE x, DOUBLE pos) -> TIME WITH TIME ZONE
        - main.quantile_cont(TIME WITH TIME ZONE x, DOUBLE[] pos) -> TIME WITH TIME ZONE
        """
        return call_duckdb_function(
            self._QUANTILE_CONT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('quantile_cont_filter')
    def quantile_cont_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``quantile_cont`` with ``FILTER``.

        Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.	

        Overloads:
        - main.quantile_cont(DATE x, DOUBLE pos) -> DATE
        - main.quantile_cont(DATE x, DOUBLE[] pos) -> DATE
        - main.quantile_cont(TIMESTAMP x, DOUBLE pos) -> TIMESTAMP
        - main.quantile_cont(TIMESTAMP x, DOUBLE[] pos) -> TIMESTAMP
        - main.quantile_cont(TIME x, DOUBLE pos) -> TIME
        - main.quantile_cont(TIME x, DOUBLE[] pos) -> TIME
        - main.quantile_cont(TIMESTAMP WITH TIME ZONE x, DOUBLE pos) -> TIMESTAMP WITH TIME ZONE
        - main.quantile_cont(TIMESTAMP WITH TIME ZONE x, DOUBLE[] pos) -> TIMESTAMP WITH TIME ZONE
        - main.quantile_cont(TIME WITH TIME ZONE x, DOUBLE pos) -> TIME WITH TIME ZONE
        - main.quantile_cont(TIME WITH TIME ZONE x, DOUBLE[] pos) -> TIME WITH TIME ZONE
        """
        return call_duckdb_filter_function(
            predicate,
            self._QUANTILE_CONT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _QUANTILE_DISC_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_disc',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_disc',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_disc',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('quantile_disc')
    def quantile_disc(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``quantile_disc``.

        Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.

        Overloads:
        - main.quantile_disc(ANY x) -> ANY
        - main.quantile_disc(ANY x, DOUBLE pos) -> ANY
        - main.quantile_disc(ANY x, DOUBLE[] pos) -> ANY
        """
        return call_duckdb_function(
            self._QUANTILE_DISC_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('quantile_disc_filter')
    def quantile_disc_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``quantile_disc`` with ``FILTER``.

        Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding exact quantiles.

        Overloads:
        - main.quantile_disc(ANY x) -> ANY
        - main.quantile_disc(ANY x, DOUBLE pos) -> ANY
        - main.quantile_disc(ANY x, DOUBLE[] pos) -> ANY
        """
        return call_duckdb_filter_function(
            predicate,
            self._QUANTILE_DISC_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _SUM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum',
                        function_type=function_type,
                        return_type=parse_type('BIGNUM'),
                        parameter_types=(parse_type('BIGNUM'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum value for all tuples in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sum')
    def sum(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``sum``.

        Calculates the sum value for all tuples in arg.

        Overloads:
        - main.sum(BIGNUM arg) -> BIGNUM
        """
        return call_duckdb_function(
            self._SUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('sum_filter')
    def sum_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> TypedExpression:
        """Call DuckDB function ``sum`` with ``FILTER``.

        Calculates the sum value for all tuples in arg.

        Overloads:
        - main.sum(BIGNUM arg) -> BIGNUM
        """
        return call_duckdb_filter_function(
            predicate,
            self._SUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        'any_value': 'any_value',
        'any_value_filter': 'any_value_filter',
        'approx_quantile': 'approx_quantile',
        'approx_quantile_filter': 'approx_quantile_filter',
        'approx_top_k': 'approx_top_k',
        'approx_top_k_filter': 'approx_top_k_filter',
        'arbitrary': 'arbitrary',
        'arbitrary_filter': 'arbitrary_filter',
        'arg_max': 'arg_max',
        'arg_max_filter': 'arg_max_filter',
        'arg_max_null': 'arg_max_null',
        'arg_max_null_filter': 'arg_max_null_filter',
        'arg_min': 'arg_min',
        'arg_min_filter': 'arg_min_filter',
        'arg_min_null': 'arg_min_null',
        'arg_min_null_filter': 'arg_min_null_filter',
        'argmax': 'argmax',
        'argmax_filter': 'argmax_filter',
        'argmin': 'argmin',
        'argmin_filter': 'argmin_filter',
        'array_agg': 'array_agg',
        'array_agg_filter': 'array_agg_filter',
        'avg': 'avg',
        'avg_filter': 'avg_filter',
        'bit_and': 'bit_and',
        'bit_and_filter': 'bit_and_filter',
        'bit_or': 'bit_or',
        'bit_or_filter': 'bit_or_filter',
        'bit_xor': 'bit_xor',
        'bit_xor_filter': 'bit_xor_filter',
        'bitstring_agg': 'bitstring_agg',
        'bitstring_agg_filter': 'bitstring_agg_filter',
        'first': 'first',
        'first_filter': 'first_filter',
        'histogram': 'histogram',
        'histogram_filter': 'histogram_filter',
        'histogram_exact': 'histogram_exact',
        'histogram_exact_filter': 'histogram_exact_filter',
        'last': 'last',
        'last_filter': 'last_filter',
        'list': 'list',
        'list_filter': 'list_filter',
        'max': 'max',
        'max_filter': 'max_filter',
        'max_by': 'max_by',
        'max_by_filter': 'max_by_filter',
        'mean': 'mean',
        'mean_filter': 'mean_filter',
        'median': 'median',
        'median_filter': 'median_filter',
        'min': 'min',
        'min_filter': 'min_filter',
        'min_by': 'min_by',
        'min_by_filter': 'min_by_filter',
        'mode': 'mode',
        'mode_filter': 'mode_filter',
        'quantile': 'quantile',
        'quantile_filter': 'quantile_filter',
        'quantile_cont': 'quantile_cont',
        'quantile_cont_filter': 'quantile_cont_filter',
        'quantile_disc': 'quantile_disc',
        'quantile_disc_filter': 'quantile_disc_filter',
        'sum': 'sum',
        'sum_filter': 'sum_filter',
    }
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class AggregateNumericFunctions(_StaticFunctionNamespace):
    """DuckDB aggregate functions returning numeric results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'aggregate'
    return_category: ClassVar[str] = 'numeric'
    _ANY_VALUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='any_value',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the first non-NULL value from arg. This function is affected by ordering.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('any_value')
    def any_value(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``any_value``.

        Returns the first non-NULL value from arg. This function is affected by ordering.

        Overloads:
        - main.any_value(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_function(
            self._ANY_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('any_value_filter')
    def any_value_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``any_value`` with ``FILTER``.

        Returns the first non-NULL value from arg. This function is affected by ordering.

        Overloads:
        - main.any_value(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._ANY_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _APPROX_COUNT_DISTINCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_count_distinct',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('any',),
                        varargs=None,
                        description='Computes the approximate count of distinct elements using HyperLogLog.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('approx_count_distinct')
    def approx_count_distinct(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``approx_count_distinct``.

        Computes the approximate count of distinct elements using HyperLogLog.

        Overloads:
        - main.approx_count_distinct(ANY any) -> BIGINT
        """
        return call_duckdb_function(
            self._APPROX_COUNT_DISTINCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('approx_count_distinct_filter')
    def approx_count_distinct_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``approx_count_distinct`` with ``FILTER``.

        Computes the approximate count of distinct elements using HyperLogLog.

        Overloads:
        - main.approx_count_distinct(ANY any) -> BIGINT
        """
        return call_duckdb_filter_function(
            predicate,
            self._APPROX_COUNT_DISTINCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _APPROX_QUANTILE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('FLOAT')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL[]'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('TINYINT[]'),
                        parameter_types=(parse_type('TINYINT'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT[]'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('INTEGER[]'),
                        parameter_types=(parse_type('INTEGER'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('BIGINT[]'),
                        parameter_types=(parse_type('BIGINT'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT[]'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('FLOAT[]'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='approx_quantile',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE[]'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('FLOAT[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Computes the approximate quantile using T-Digest.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('approx_quantile')
    def approx_quantile(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``approx_quantile``.

        Computes the approximate quantile using T-Digest.

        Overloads:
        - main.approx_quantile(DECIMAL x, FLOAT pos) -> DECIMAL
        - main.approx_quantile(SMALLINT x, FLOAT pos) -> SMALLINT
        - main.approx_quantile(INTEGER x, FLOAT pos) -> INTEGER
        - main.approx_quantile(BIGINT x, FLOAT pos) -> BIGINT
        - main.approx_quantile(HUGEINT x, FLOAT pos) -> HUGEINT
        - main.approx_quantile(DOUBLE x, FLOAT pos) -> DOUBLE
        - main.approx_quantile(DECIMAL x, FLOAT[] pos) -> DECIMAL[]
        - main.approx_quantile(TINYINT x, FLOAT[] pos) -> TINYINT[]
        - main.approx_quantile(SMALLINT x, FLOAT[] pos) -> SMALLINT[]
        - main.approx_quantile(INTEGER x, FLOAT[] pos) -> INTEGER[]
        - main.approx_quantile(BIGINT x, FLOAT[] pos) -> BIGINT[]
        - main.approx_quantile(HUGEINT x, FLOAT[] pos) -> HUGEINT[]
        - main.approx_quantile(FLOAT x, FLOAT[] pos) -> FLOAT[]
        - main.approx_quantile(DOUBLE x, FLOAT[] pos) -> DOUBLE[]
        """
        return call_duckdb_function(
            self._APPROX_QUANTILE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('approx_quantile_filter')
    def approx_quantile_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``approx_quantile`` with ``FILTER``.

        Computes the approximate quantile using T-Digest.

        Overloads:
        - main.approx_quantile(DECIMAL x, FLOAT pos) -> DECIMAL
        - main.approx_quantile(SMALLINT x, FLOAT pos) -> SMALLINT
        - main.approx_quantile(INTEGER x, FLOAT pos) -> INTEGER
        - main.approx_quantile(BIGINT x, FLOAT pos) -> BIGINT
        - main.approx_quantile(HUGEINT x, FLOAT pos) -> HUGEINT
        - main.approx_quantile(DOUBLE x, FLOAT pos) -> DOUBLE
        - main.approx_quantile(DECIMAL x, FLOAT[] pos) -> DECIMAL[]
        - main.approx_quantile(TINYINT x, FLOAT[] pos) -> TINYINT[]
        - main.approx_quantile(SMALLINT x, FLOAT[] pos) -> SMALLINT[]
        - main.approx_quantile(INTEGER x, FLOAT[] pos) -> INTEGER[]
        - main.approx_quantile(BIGINT x, FLOAT[] pos) -> BIGINT[]
        - main.approx_quantile(HUGEINT x, FLOAT[] pos) -> HUGEINT[]
        - main.approx_quantile(FLOAT x, FLOAT[] pos) -> FLOAT[]
        - main.approx_quantile(DOUBLE x, FLOAT[] pos) -> DOUBLE[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._APPROX_QUANTILE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARBITRARY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arbitrary',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arbitrary')
    def arbitrary(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arbitrary``.

        Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.

        Overloads:
        - main.arbitrary(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_function(
            self._ARBITRARY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arbitrary_filter')
    def arbitrary_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arbitrary`` with ``FILTER``.

        Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.

        Overloads:
        - main.arbitrary(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARBITRARY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_max')
    def arg_max(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arg_max``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_max(INTEGER arg, INTEGER val) -> INTEGER
        - main.arg_max(INTEGER arg, BIGINT val) -> INTEGER
        - main.arg_max(INTEGER arg, HUGEINT val) -> INTEGER
        - main.arg_max(INTEGER arg, DOUBLE val) -> INTEGER
        - main.arg_max(INTEGER arg, VARCHAR val) -> INTEGER
        - main.arg_max(INTEGER arg, DATE val) -> INTEGER
        - main.arg_max(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.arg_max(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.arg_max(INTEGER arg, BLOB val) -> INTEGER
        - main.arg_max(BIGINT arg, INTEGER val) -> BIGINT
        - main.arg_max(BIGINT arg, BIGINT val) -> BIGINT
        - main.arg_max(BIGINT arg, HUGEINT val) -> BIGINT
        - main.arg_max(BIGINT arg, DOUBLE val) -> BIGINT
        - main.arg_max(BIGINT arg, VARCHAR val) -> BIGINT
        - main.arg_max(BIGINT arg, DATE val) -> BIGINT
        - main.arg_max(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.arg_max(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.arg_max(BIGINT arg, BLOB val) -> BIGINT
        - main.arg_max(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.arg_max(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.arg_max(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.arg_max(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.arg_max(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.arg_max(DOUBLE arg, DATE val) -> DOUBLE
        - main.arg_max(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.arg_max(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.arg_max(DOUBLE arg, BLOB val) -> DOUBLE
        - main.arg_max(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.arg_max(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.arg_max(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.arg_max(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.arg_max(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.arg_max(DECIMAL arg, DATE val) -> DECIMAL
        - main.arg_max(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.arg_max(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.arg_max(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_function(
            self._ARG_MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_max_filter')
    def arg_max_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arg_max`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_max(INTEGER arg, INTEGER val) -> INTEGER
        - main.arg_max(INTEGER arg, BIGINT val) -> INTEGER
        - main.arg_max(INTEGER arg, HUGEINT val) -> INTEGER
        - main.arg_max(INTEGER arg, DOUBLE val) -> INTEGER
        - main.arg_max(INTEGER arg, VARCHAR val) -> INTEGER
        - main.arg_max(INTEGER arg, DATE val) -> INTEGER
        - main.arg_max(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.arg_max(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.arg_max(INTEGER arg, BLOB val) -> INTEGER
        - main.arg_max(BIGINT arg, INTEGER val) -> BIGINT
        - main.arg_max(BIGINT arg, BIGINT val) -> BIGINT
        - main.arg_max(BIGINT arg, HUGEINT val) -> BIGINT
        - main.arg_max(BIGINT arg, DOUBLE val) -> BIGINT
        - main.arg_max(BIGINT arg, VARCHAR val) -> BIGINT
        - main.arg_max(BIGINT arg, DATE val) -> BIGINT
        - main.arg_max(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.arg_max(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.arg_max(BIGINT arg, BLOB val) -> BIGINT
        - main.arg_max(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.arg_max(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.arg_max(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.arg_max(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.arg_max(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.arg_max(DOUBLE arg, DATE val) -> DOUBLE
        - main.arg_max(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.arg_max(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.arg_max(DOUBLE arg, BLOB val) -> DOUBLE
        - main.arg_max(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.arg_max(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.arg_max(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.arg_max(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.arg_max(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.arg_max(DECIMAL arg, DATE val) -> DECIMAL
        - main.arg_max(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.arg_max(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.arg_max(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MAX_NULL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_max_null')
    def arg_max_null(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arg_max_null``.

        Finds the row with the maximum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_max_null(INTEGER arg, INTEGER val) -> INTEGER
        - main.arg_max_null(INTEGER arg, BIGINT val) -> INTEGER
        - main.arg_max_null(INTEGER arg, HUGEINT val) -> INTEGER
        - main.arg_max_null(INTEGER arg, DOUBLE val) -> INTEGER
        - main.arg_max_null(INTEGER arg, VARCHAR val) -> INTEGER
        - main.arg_max_null(INTEGER arg, DATE val) -> INTEGER
        - main.arg_max_null(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.arg_max_null(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.arg_max_null(INTEGER arg, BLOB val) -> INTEGER
        - main.arg_max_null(BIGINT arg, INTEGER val) -> BIGINT
        - main.arg_max_null(BIGINT arg, BIGINT val) -> BIGINT
        - main.arg_max_null(BIGINT arg, HUGEINT val) -> BIGINT
        - main.arg_max_null(BIGINT arg, DOUBLE val) -> BIGINT
        - main.arg_max_null(BIGINT arg, VARCHAR val) -> BIGINT
        - main.arg_max_null(BIGINT arg, DATE val) -> BIGINT
        - main.arg_max_null(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.arg_max_null(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.arg_max_null(BIGINT arg, BLOB val) -> BIGINT
        - main.arg_max_null(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, DATE val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, BLOB val) -> DOUBLE
        - main.arg_max_null(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, DATE val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_function(
            self._ARG_MAX_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_max_null_filter')
    def arg_max_null_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arg_max_null`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_max_null(INTEGER arg, INTEGER val) -> INTEGER
        - main.arg_max_null(INTEGER arg, BIGINT val) -> INTEGER
        - main.arg_max_null(INTEGER arg, HUGEINT val) -> INTEGER
        - main.arg_max_null(INTEGER arg, DOUBLE val) -> INTEGER
        - main.arg_max_null(INTEGER arg, VARCHAR val) -> INTEGER
        - main.arg_max_null(INTEGER arg, DATE val) -> INTEGER
        - main.arg_max_null(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.arg_max_null(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.arg_max_null(INTEGER arg, BLOB val) -> INTEGER
        - main.arg_max_null(BIGINT arg, INTEGER val) -> BIGINT
        - main.arg_max_null(BIGINT arg, BIGINT val) -> BIGINT
        - main.arg_max_null(BIGINT arg, HUGEINT val) -> BIGINT
        - main.arg_max_null(BIGINT arg, DOUBLE val) -> BIGINT
        - main.arg_max_null(BIGINT arg, VARCHAR val) -> BIGINT
        - main.arg_max_null(BIGINT arg, DATE val) -> BIGINT
        - main.arg_max_null(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.arg_max_null(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.arg_max_null(BIGINT arg, BLOB val) -> BIGINT
        - main.arg_max_null(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, DATE val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.arg_max_null(DOUBLE arg, BLOB val) -> DOUBLE
        - main.arg_max_null(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, DATE val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.arg_max_null(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MAX_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_min')
    def arg_min(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arg_min``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_min(INTEGER arg, INTEGER val) -> INTEGER
        - main.arg_min(INTEGER arg, BIGINT val) -> INTEGER
        - main.arg_min(INTEGER arg, HUGEINT val) -> INTEGER
        - main.arg_min(INTEGER arg, DOUBLE val) -> INTEGER
        - main.arg_min(INTEGER arg, VARCHAR val) -> INTEGER
        - main.arg_min(INTEGER arg, DATE val) -> INTEGER
        - main.arg_min(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.arg_min(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.arg_min(INTEGER arg, BLOB val) -> INTEGER
        - main.arg_min(BIGINT arg, INTEGER val) -> BIGINT
        - main.arg_min(BIGINT arg, BIGINT val) -> BIGINT
        - main.arg_min(BIGINT arg, HUGEINT val) -> BIGINT
        - main.arg_min(BIGINT arg, DOUBLE val) -> BIGINT
        - main.arg_min(BIGINT arg, VARCHAR val) -> BIGINT
        - main.arg_min(BIGINT arg, DATE val) -> BIGINT
        - main.arg_min(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.arg_min(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.arg_min(BIGINT arg, BLOB val) -> BIGINT
        - main.arg_min(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.arg_min(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.arg_min(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.arg_min(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.arg_min(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.arg_min(DOUBLE arg, DATE val) -> DOUBLE
        - main.arg_min(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.arg_min(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.arg_min(DOUBLE arg, BLOB val) -> DOUBLE
        - main.arg_min(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.arg_min(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.arg_min(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.arg_min(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.arg_min(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.arg_min(DECIMAL arg, DATE val) -> DECIMAL
        - main.arg_min(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.arg_min(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.arg_min(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_function(
            self._ARG_MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_min_filter')
    def arg_min_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arg_min`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_min(INTEGER arg, INTEGER val) -> INTEGER
        - main.arg_min(INTEGER arg, BIGINT val) -> INTEGER
        - main.arg_min(INTEGER arg, HUGEINT val) -> INTEGER
        - main.arg_min(INTEGER arg, DOUBLE val) -> INTEGER
        - main.arg_min(INTEGER arg, VARCHAR val) -> INTEGER
        - main.arg_min(INTEGER arg, DATE val) -> INTEGER
        - main.arg_min(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.arg_min(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.arg_min(INTEGER arg, BLOB val) -> INTEGER
        - main.arg_min(BIGINT arg, INTEGER val) -> BIGINT
        - main.arg_min(BIGINT arg, BIGINT val) -> BIGINT
        - main.arg_min(BIGINT arg, HUGEINT val) -> BIGINT
        - main.arg_min(BIGINT arg, DOUBLE val) -> BIGINT
        - main.arg_min(BIGINT arg, VARCHAR val) -> BIGINT
        - main.arg_min(BIGINT arg, DATE val) -> BIGINT
        - main.arg_min(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.arg_min(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.arg_min(BIGINT arg, BLOB val) -> BIGINT
        - main.arg_min(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.arg_min(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.arg_min(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.arg_min(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.arg_min(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.arg_min(DOUBLE arg, DATE val) -> DOUBLE
        - main.arg_min(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.arg_min(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.arg_min(DOUBLE arg, BLOB val) -> DOUBLE
        - main.arg_min(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.arg_min(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.arg_min(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.arg_min(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.arg_min(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.arg_min(DECIMAL arg, DATE val) -> DECIMAL
        - main.arg_min(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.arg_min(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.arg_min(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MIN_NULL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_min_null')
    def arg_min_null(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arg_min_null``.

        Finds the row with the minimum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_min_null(INTEGER arg, INTEGER val) -> INTEGER
        - main.arg_min_null(INTEGER arg, BIGINT val) -> INTEGER
        - main.arg_min_null(INTEGER arg, HUGEINT val) -> INTEGER
        - main.arg_min_null(INTEGER arg, DOUBLE val) -> INTEGER
        - main.arg_min_null(INTEGER arg, VARCHAR val) -> INTEGER
        - main.arg_min_null(INTEGER arg, DATE val) -> INTEGER
        - main.arg_min_null(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.arg_min_null(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.arg_min_null(INTEGER arg, BLOB val) -> INTEGER
        - main.arg_min_null(BIGINT arg, INTEGER val) -> BIGINT
        - main.arg_min_null(BIGINT arg, BIGINT val) -> BIGINT
        - main.arg_min_null(BIGINT arg, HUGEINT val) -> BIGINT
        - main.arg_min_null(BIGINT arg, DOUBLE val) -> BIGINT
        - main.arg_min_null(BIGINT arg, VARCHAR val) -> BIGINT
        - main.arg_min_null(BIGINT arg, DATE val) -> BIGINT
        - main.arg_min_null(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.arg_min_null(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.arg_min_null(BIGINT arg, BLOB val) -> BIGINT
        - main.arg_min_null(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, DATE val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, BLOB val) -> DOUBLE
        - main.arg_min_null(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, DATE val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_function(
            self._ARG_MIN_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_min_null_filter')
    def arg_min_null_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``arg_min_null`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_min_null(INTEGER arg, INTEGER val) -> INTEGER
        - main.arg_min_null(INTEGER arg, BIGINT val) -> INTEGER
        - main.arg_min_null(INTEGER arg, HUGEINT val) -> INTEGER
        - main.arg_min_null(INTEGER arg, DOUBLE val) -> INTEGER
        - main.arg_min_null(INTEGER arg, VARCHAR val) -> INTEGER
        - main.arg_min_null(INTEGER arg, DATE val) -> INTEGER
        - main.arg_min_null(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.arg_min_null(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.arg_min_null(INTEGER arg, BLOB val) -> INTEGER
        - main.arg_min_null(BIGINT arg, INTEGER val) -> BIGINT
        - main.arg_min_null(BIGINT arg, BIGINT val) -> BIGINT
        - main.arg_min_null(BIGINT arg, HUGEINT val) -> BIGINT
        - main.arg_min_null(BIGINT arg, DOUBLE val) -> BIGINT
        - main.arg_min_null(BIGINT arg, VARCHAR val) -> BIGINT
        - main.arg_min_null(BIGINT arg, DATE val) -> BIGINT
        - main.arg_min_null(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.arg_min_null(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.arg_min_null(BIGINT arg, BLOB val) -> BIGINT
        - main.arg_min_null(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, DATE val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.arg_min_null(DOUBLE arg, BLOB val) -> DOUBLE
        - main.arg_min_null(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, DATE val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.arg_min_null(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MIN_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARGMAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('argmax')
    def argmax(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``argmax``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmax(INTEGER arg, INTEGER val) -> INTEGER
        - main.argmax(INTEGER arg, BIGINT val) -> INTEGER
        - main.argmax(INTEGER arg, HUGEINT val) -> INTEGER
        - main.argmax(INTEGER arg, DOUBLE val) -> INTEGER
        - main.argmax(INTEGER arg, VARCHAR val) -> INTEGER
        - main.argmax(INTEGER arg, DATE val) -> INTEGER
        - main.argmax(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.argmax(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.argmax(INTEGER arg, BLOB val) -> INTEGER
        - main.argmax(BIGINT arg, INTEGER val) -> BIGINT
        - main.argmax(BIGINT arg, BIGINT val) -> BIGINT
        - main.argmax(BIGINT arg, HUGEINT val) -> BIGINT
        - main.argmax(BIGINT arg, DOUBLE val) -> BIGINT
        - main.argmax(BIGINT arg, VARCHAR val) -> BIGINT
        - main.argmax(BIGINT arg, DATE val) -> BIGINT
        - main.argmax(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.argmax(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.argmax(BIGINT arg, BLOB val) -> BIGINT
        - main.argmax(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.argmax(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.argmax(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.argmax(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.argmax(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.argmax(DOUBLE arg, DATE val) -> DOUBLE
        - main.argmax(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.argmax(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.argmax(DOUBLE arg, BLOB val) -> DOUBLE
        - main.argmax(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.argmax(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.argmax(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.argmax(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.argmax(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.argmax(DECIMAL arg, DATE val) -> DECIMAL
        - main.argmax(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.argmax(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.argmax(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_function(
            self._ARGMAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('argmax_filter')
    def argmax_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``argmax`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmax(INTEGER arg, INTEGER val) -> INTEGER
        - main.argmax(INTEGER arg, BIGINT val) -> INTEGER
        - main.argmax(INTEGER arg, HUGEINT val) -> INTEGER
        - main.argmax(INTEGER arg, DOUBLE val) -> INTEGER
        - main.argmax(INTEGER arg, VARCHAR val) -> INTEGER
        - main.argmax(INTEGER arg, DATE val) -> INTEGER
        - main.argmax(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.argmax(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.argmax(INTEGER arg, BLOB val) -> INTEGER
        - main.argmax(BIGINT arg, INTEGER val) -> BIGINT
        - main.argmax(BIGINT arg, BIGINT val) -> BIGINT
        - main.argmax(BIGINT arg, HUGEINT val) -> BIGINT
        - main.argmax(BIGINT arg, DOUBLE val) -> BIGINT
        - main.argmax(BIGINT arg, VARCHAR val) -> BIGINT
        - main.argmax(BIGINT arg, DATE val) -> BIGINT
        - main.argmax(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.argmax(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.argmax(BIGINT arg, BLOB val) -> BIGINT
        - main.argmax(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.argmax(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.argmax(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.argmax(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.argmax(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.argmax(DOUBLE arg, DATE val) -> DOUBLE
        - main.argmax(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.argmax(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.argmax(DOUBLE arg, BLOB val) -> DOUBLE
        - main.argmax(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.argmax(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.argmax(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.argmax(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.argmax(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.argmax(DECIMAL arg, DATE val) -> DECIMAL
        - main.argmax(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.argmax(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.argmax(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARGMAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARGMIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('argmin')
    def argmin(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``argmin``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmin(INTEGER arg, INTEGER val) -> INTEGER
        - main.argmin(INTEGER arg, BIGINT val) -> INTEGER
        - main.argmin(INTEGER arg, HUGEINT val) -> INTEGER
        - main.argmin(INTEGER arg, DOUBLE val) -> INTEGER
        - main.argmin(INTEGER arg, VARCHAR val) -> INTEGER
        - main.argmin(INTEGER arg, DATE val) -> INTEGER
        - main.argmin(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.argmin(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.argmin(INTEGER arg, BLOB val) -> INTEGER
        - main.argmin(BIGINT arg, INTEGER val) -> BIGINT
        - main.argmin(BIGINT arg, BIGINT val) -> BIGINT
        - main.argmin(BIGINT arg, HUGEINT val) -> BIGINT
        - main.argmin(BIGINT arg, DOUBLE val) -> BIGINT
        - main.argmin(BIGINT arg, VARCHAR val) -> BIGINT
        - main.argmin(BIGINT arg, DATE val) -> BIGINT
        - main.argmin(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.argmin(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.argmin(BIGINT arg, BLOB val) -> BIGINT
        - main.argmin(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.argmin(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.argmin(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.argmin(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.argmin(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.argmin(DOUBLE arg, DATE val) -> DOUBLE
        - main.argmin(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.argmin(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.argmin(DOUBLE arg, BLOB val) -> DOUBLE
        - main.argmin(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.argmin(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.argmin(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.argmin(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.argmin(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.argmin(DECIMAL arg, DATE val) -> DECIMAL
        - main.argmin(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.argmin(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.argmin(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_function(
            self._ARGMIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('argmin_filter')
    def argmin_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``argmin`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmin(INTEGER arg, INTEGER val) -> INTEGER
        - main.argmin(INTEGER arg, BIGINT val) -> INTEGER
        - main.argmin(INTEGER arg, HUGEINT val) -> INTEGER
        - main.argmin(INTEGER arg, DOUBLE val) -> INTEGER
        - main.argmin(INTEGER arg, VARCHAR val) -> INTEGER
        - main.argmin(INTEGER arg, DATE val) -> INTEGER
        - main.argmin(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.argmin(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.argmin(INTEGER arg, BLOB val) -> INTEGER
        - main.argmin(BIGINT arg, INTEGER val) -> BIGINT
        - main.argmin(BIGINT arg, BIGINT val) -> BIGINT
        - main.argmin(BIGINT arg, HUGEINT val) -> BIGINT
        - main.argmin(BIGINT arg, DOUBLE val) -> BIGINT
        - main.argmin(BIGINT arg, VARCHAR val) -> BIGINT
        - main.argmin(BIGINT arg, DATE val) -> BIGINT
        - main.argmin(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.argmin(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.argmin(BIGINT arg, BLOB val) -> BIGINT
        - main.argmin(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.argmin(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.argmin(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.argmin(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.argmin(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.argmin(DOUBLE arg, DATE val) -> DOUBLE
        - main.argmin(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.argmin(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.argmin(DOUBLE arg, BLOB val) -> DOUBLE
        - main.argmin(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.argmin(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.argmin(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.argmin(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.argmin(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.argmin(DECIMAL arg, DATE val) -> DECIMAL
        - main.argmin(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.argmin(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.argmin(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARGMIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _AVG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='avg',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('avg')
    def avg(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``avg``.

        Calculates the average value for all tuples in x.

        Overloads:
        - main.avg(DECIMAL x) -> DECIMAL
        - main.avg(SMALLINT x) -> DOUBLE
        - main.avg(INTEGER x) -> DOUBLE
        - main.avg(BIGINT x) -> DOUBLE
        - main.avg(HUGEINT x) -> DOUBLE
        - main.avg(INTERVAL x) -> INTERVAL
        - main.avg(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._AVG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('avg_filter')
    def avg_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``avg`` with ``FILTER``.

        Calculates the average value for all tuples in x.

        Overloads:
        - main.avg(DECIMAL x) -> DECIMAL
        - main.avg(SMALLINT x) -> DOUBLE
        - main.avg(INTEGER x) -> DOUBLE
        - main.avg(BIGINT x) -> DOUBLE
        - main.avg(HUGEINT x) -> DOUBLE
        - main.avg(INTERVAL x) -> INTERVAL
        - main.avg(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._AVG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _BIT_AND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_and',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise AND of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bit_and')
    def bit_and(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``bit_and``.

        Returns the bitwise AND of all bits in a given expression.

        Overloads:
        - main.bit_and(TINYINT arg) -> TINYINT
        - main.bit_and(SMALLINT arg) -> SMALLINT
        - main.bit_and(INTEGER arg) -> INTEGER
        - main.bit_and(BIGINT arg) -> BIGINT
        - main.bit_and(HUGEINT arg) -> HUGEINT
        - main.bit_and(UTINYINT arg) -> UTINYINT
        - main.bit_and(USMALLINT arg) -> USMALLINT
        - main.bit_and(UINTEGER arg) -> UINTEGER
        - main.bit_and(UBIGINT arg) -> UBIGINT
        """
        return call_duckdb_function(
            self._BIT_AND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('bit_and_filter')
    def bit_and_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``bit_and`` with ``FILTER``.

        Returns the bitwise AND of all bits in a given expression.

        Overloads:
        - main.bit_and(TINYINT arg) -> TINYINT
        - main.bit_and(SMALLINT arg) -> SMALLINT
        - main.bit_and(INTEGER arg) -> INTEGER
        - main.bit_and(BIGINT arg) -> BIGINT
        - main.bit_and(HUGEINT arg) -> HUGEINT
        - main.bit_and(UTINYINT arg) -> UTINYINT
        - main.bit_and(USMALLINT arg) -> USMALLINT
        - main.bit_and(UINTEGER arg) -> UINTEGER
        - main.bit_and(UBIGINT arg) -> UBIGINT
        """
        return call_duckdb_filter_function(
            predicate,
            self._BIT_AND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _BIT_OR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_or',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise OR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bit_or')
    def bit_or(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``bit_or``.

        Returns the bitwise OR of all bits in a given expression.

        Overloads:
        - main.bit_or(TINYINT arg) -> TINYINT
        - main.bit_or(SMALLINT arg) -> SMALLINT
        - main.bit_or(INTEGER arg) -> INTEGER
        - main.bit_or(BIGINT arg) -> BIGINT
        - main.bit_or(HUGEINT arg) -> HUGEINT
        - main.bit_or(UTINYINT arg) -> UTINYINT
        - main.bit_or(USMALLINT arg) -> USMALLINT
        - main.bit_or(UINTEGER arg) -> UINTEGER
        - main.bit_or(UBIGINT arg) -> UBIGINT
        """
        return call_duckdb_function(
            self._BIT_OR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('bit_or_filter')
    def bit_or_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``bit_or`` with ``FILTER``.

        Returns the bitwise OR of all bits in a given expression.

        Overloads:
        - main.bit_or(TINYINT arg) -> TINYINT
        - main.bit_or(SMALLINT arg) -> SMALLINT
        - main.bit_or(INTEGER arg) -> INTEGER
        - main.bit_or(BIGINT arg) -> BIGINT
        - main.bit_or(HUGEINT arg) -> HUGEINT
        - main.bit_or(UTINYINT arg) -> UTINYINT
        - main.bit_or(USMALLINT arg) -> USMALLINT
        - main.bit_or(UINTEGER arg) -> UINTEGER
        - main.bit_or(UBIGINT arg) -> UBIGINT
        """
        return call_duckdb_filter_function(
            predicate,
            self._BIT_OR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _BIT_XOR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_xor',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the bitwise XOR of all bits in a given expression.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bit_xor')
    def bit_xor(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``bit_xor``.

        Returns the bitwise XOR of all bits in a given expression.

        Overloads:
        - main.bit_xor(TINYINT arg) -> TINYINT
        - main.bit_xor(SMALLINT arg) -> SMALLINT
        - main.bit_xor(INTEGER arg) -> INTEGER
        - main.bit_xor(BIGINT arg) -> BIGINT
        - main.bit_xor(HUGEINT arg) -> HUGEINT
        - main.bit_xor(UTINYINT arg) -> UTINYINT
        - main.bit_xor(USMALLINT arg) -> USMALLINT
        - main.bit_xor(UINTEGER arg) -> UINTEGER
        - main.bit_xor(UBIGINT arg) -> UBIGINT
        """
        return call_duckdb_function(
            self._BIT_XOR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('bit_xor_filter')
    def bit_xor_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``bit_xor`` with ``FILTER``.

        Returns the bitwise XOR of all bits in a given expression.

        Overloads:
        - main.bit_xor(TINYINT arg) -> TINYINT
        - main.bit_xor(SMALLINT arg) -> SMALLINT
        - main.bit_xor(INTEGER arg) -> INTEGER
        - main.bit_xor(BIGINT arg) -> BIGINT
        - main.bit_xor(HUGEINT arg) -> HUGEINT
        - main.bit_xor(UTINYINT arg) -> UTINYINT
        - main.bit_xor(USMALLINT arg) -> USMALLINT
        - main.bit_xor(UINTEGER arg) -> UINTEGER
        - main.bit_xor(UBIGINT arg) -> UBIGINT
        """
        return call_duckdb_filter_function(
            predicate,
            self._BIT_XOR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _CORR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='corr',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the correlation coefficient for non-NULL pairs in a group.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('corr')
    def corr(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``corr``.

        Returns the correlation coefficient for non-NULL pairs in a group.

        Overloads:
        - main.corr(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._CORR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('corr_filter')
    def corr_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``corr`` with ``FILTER``.

        Returns the correlation coefficient for non-NULL pairs in a group.

        Overloads:
        - main.corr(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._CORR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _COUNT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='count',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the number of non-NULL values in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='count',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the number of non-NULL values in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('count')
    def count(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``count``.

        Returns the number of non-NULL values in arg.

        Overloads:
        - main.count() -> BIGINT
        - main.count(ANY arg) -> BIGINT
        """
        return call_duckdb_function(
            self._COUNT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('count_filter')
    def count_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``count`` with ``FILTER``.

        Returns the number of non-NULL values in arg.

        Overloads:
        - main.count() -> BIGINT
        - main.count(ANY arg) -> BIGINT
        """
        return call_duckdb_filter_function(
            predicate,
            self._COUNT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _COUNT_IF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='count_if',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('BOOLEAN'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Counts the total number of TRUE values for a boolean column',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('count_if')
    def count_if(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``count_if``.

        Counts the total number of TRUE values for a boolean column

        Overloads:
        - main.count_if(BOOLEAN arg) -> HUGEINT
        """
        return call_duckdb_function(
            self._COUNT_IF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('count_if_filter')
    def count_if_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``count_if`` with ``FILTER``.

        Counts the total number of TRUE values for a boolean column

        Overloads:
        - main.count_if(BOOLEAN arg) -> HUGEINT
        """
        return call_duckdb_filter_function(
            predicate,
            self._COUNT_IF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _COUNT_STAR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='count_star',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('count_star')
    def count_star(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``count_star``.

        Overloads:
        - main.count_star() -> BIGINT
        """
        return call_duckdb_function(
            self._COUNT_STAR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('count_star_filter')
    def count_star_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``count_star`` with ``FILTER``.

        Overloads:
        - main.count_star() -> BIGINT
        """
        return call_duckdb_filter_function(
            predicate,
            self._COUNT_STAR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _COUNTIF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='countif',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('BOOLEAN'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Counts the total number of TRUE values for a boolean column',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('countif')
    def countif(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``countif``.

        Counts the total number of TRUE values for a boolean column

        Overloads:
        - main.countif(BOOLEAN arg) -> HUGEINT
        """
        return call_duckdb_function(
            self._COUNTIF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('countif_filter')
    def countif_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``countif`` with ``FILTER``.

        Counts the total number of TRUE values for a boolean column

        Overloads:
        - main.countif(BOOLEAN arg) -> HUGEINT
        """
        return call_duckdb_filter_function(
            predicate,
            self._COUNTIF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _COVAR_POP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='covar_pop',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the population covariance of input values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('covar_pop')
    def covar_pop(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``covar_pop``.

        Returns the population covariance of input values.

        Overloads:
        - main.covar_pop(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._COVAR_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('covar_pop_filter')
    def covar_pop_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``covar_pop`` with ``FILTER``.

        Returns the population covariance of input values.

        Overloads:
        - main.covar_pop(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._COVAR_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _COVAR_SAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='covar_samp',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the sample covariance for non-NULL pairs in a group.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('covar_samp')
    def covar_samp(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``covar_samp``.

        Returns the sample covariance for non-NULL pairs in a group.

        Overloads:
        - main.covar_samp(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._COVAR_SAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('covar_samp_filter')
    def covar_samp_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``covar_samp`` with ``FILTER``.

        Returns the sample covariance for non-NULL pairs in a group.

        Overloads:
        - main.covar_samp(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._COVAR_SAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ENTROPY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='entropy',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the log-2 entropy of count input-values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('entropy')
    def entropy(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``entropy``.

        Returns the log-2 entropy of count input-values.

        Overloads:
        - main.entropy(ANY x) -> DOUBLE
        """
        return call_duckdb_function(
            self._ENTROPY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('entropy_filter')
    def entropy_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``entropy`` with ``FILTER``.

        Returns the log-2 entropy of count input-values.

        Overloads:
        - main.entropy(ANY x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._ENTROPY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _FAVG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='favg',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average using a more accurate floating point summation (Kahan Sum)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('favg')
    def favg(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``favg``.

        Calculates the average using a more accurate floating point summation (Kahan Sum)

        Overloads:
        - main.favg(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._FAVG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('favg_filter')
    def favg_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``favg`` with ``FILTER``.

        Calculates the average using a more accurate floating point summation (Kahan Sum)

        Overloads:
        - main.favg(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._FAVG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _FIRST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='first',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('first')
    def first(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``first``.

        Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.

        Overloads:
        - main.first(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_function(
            self._FIRST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('first_filter')
    def first_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``first`` with ``FILTER``.

        Returns the first value (NULL or non-NULL) from arg. This function is affected by ordering.

        Overloads:
        - main.first(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._FIRST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _FSUM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='fsum',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum using a more accurate floating point summation (Kahan Sum).',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('fsum')
    def fsum(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``fsum``.

        Calculates the sum using a more accurate floating point summation (Kahan Sum).

        Overloads:
        - main.fsum(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_function(
            self._FSUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('fsum_filter')
    def fsum_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``fsum`` with ``FILTER``.

        Calculates the sum using a more accurate floating point summation (Kahan Sum).

        Overloads:
        - main.fsum(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._FSUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _KAHAN_SUM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='kahan_sum',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum using a more accurate floating point summation (Kahan Sum).',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('kahan_sum')
    def kahan_sum(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``kahan_sum``.

        Calculates the sum using a more accurate floating point summation (Kahan Sum).

        Overloads:
        - main.kahan_sum(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_function(
            self._KAHAN_SUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('kahan_sum_filter')
    def kahan_sum_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``kahan_sum`` with ``FILTER``.

        Calculates the sum using a more accurate floating point summation (Kahan Sum).

        Overloads:
        - main.kahan_sum(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._KAHAN_SUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _KURTOSIS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='kurtosis',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the excess kurtosis (Fishers definition) of all input values, with a bias correction according to the sample size',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('kurtosis')
    def kurtosis(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``kurtosis``.

        Returns the excess kurtosis (Fishers definition) of all input values, with a bias correction according to the sample size

        Overloads:
        - main.kurtosis(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._KURTOSIS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('kurtosis_filter')
    def kurtosis_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``kurtosis`` with ``FILTER``.

        Returns the excess kurtosis (Fishers definition) of all input values, with a bias correction according to the sample size

        Overloads:
        - main.kurtosis(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._KURTOSIS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _KURTOSIS_POP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='kurtosis_pop',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the excess kurtosis (Fishers definition) of all input values, without bias correction',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('kurtosis_pop')
    def kurtosis_pop(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``kurtosis_pop``.

        Returns the excess kurtosis (Fishers definition) of all input values, without bias correction

        Overloads:
        - main.kurtosis_pop(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._KURTOSIS_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('kurtosis_pop_filter')
    def kurtosis_pop_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``kurtosis_pop`` with ``FILTER``.

        Returns the excess kurtosis (Fishers definition) of all input values, without bias correction

        Overloads:
        - main.kurtosis_pop(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._KURTOSIS_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _LAST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='last',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Returns the last value of a column. This function is affected by ordering.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('last')
    def last(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``last``.

        Returns the last value of a column. This function is affected by ordering.

        Overloads:
        - main.last(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_function(
            self._LAST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('last_filter')
    def last_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``last`` with ``FILTER``.

        Returns the last value of a column. This function is affected by ordering.

        Overloads:
        - main.last(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._LAST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MAD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mad',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mad',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mad',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mad',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mad',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mad',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mad',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mad',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.\t',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('mad')
    def mad(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``mad``.

        Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.	

        Overloads:
        - main.mad(DECIMAL x) -> DECIMAL
        - main.mad(FLOAT x) -> FLOAT
        - main.mad(DOUBLE x) -> DOUBLE
        - main.mad(DATE x) -> INTERVAL
        - main.mad(TIMESTAMP x) -> INTERVAL
        - main.mad(TIME x) -> INTERVAL
        - main.mad(TIMESTAMP WITH TIME ZONE x) -> INTERVAL
        - main.mad(TIME WITH TIME ZONE x) -> INTERVAL
        """
        return call_duckdb_function(
            self._MAD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('mad_filter')
    def mad_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``mad`` with ``FILTER``.

        Returns the median absolute deviation for the values within x. NULL values are ignored. Temporal types return a positive INTERVAL.	

        Overloads:
        - main.mad(DECIMAL x) -> DECIMAL
        - main.mad(FLOAT x) -> FLOAT
        - main.mad(DOUBLE x) -> DOUBLE
        - main.mad(DATE x) -> INTERVAL
        - main.mad(TIMESTAMP x) -> INTERVAL
        - main.mad(TIME x) -> INTERVAL
        - main.mad(TIMESTAMP WITH TIME ZONE x) -> INTERVAL
        - main.mad(TIME WITH TIME ZONE x) -> INTERVAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._MAD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MAX_BY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('max_by')
    def max_by(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``max_by``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.max_by(INTEGER arg, INTEGER val) -> INTEGER
        - main.max_by(INTEGER arg, BIGINT val) -> INTEGER
        - main.max_by(INTEGER arg, HUGEINT val) -> INTEGER
        - main.max_by(INTEGER arg, DOUBLE val) -> INTEGER
        - main.max_by(INTEGER arg, VARCHAR val) -> INTEGER
        - main.max_by(INTEGER arg, DATE val) -> INTEGER
        - main.max_by(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.max_by(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.max_by(INTEGER arg, BLOB val) -> INTEGER
        - main.max_by(BIGINT arg, INTEGER val) -> BIGINT
        - main.max_by(BIGINT arg, BIGINT val) -> BIGINT
        - main.max_by(BIGINT arg, HUGEINT val) -> BIGINT
        - main.max_by(BIGINT arg, DOUBLE val) -> BIGINT
        - main.max_by(BIGINT arg, VARCHAR val) -> BIGINT
        - main.max_by(BIGINT arg, DATE val) -> BIGINT
        - main.max_by(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.max_by(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.max_by(BIGINT arg, BLOB val) -> BIGINT
        - main.max_by(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.max_by(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.max_by(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.max_by(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.max_by(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.max_by(DOUBLE arg, DATE val) -> DOUBLE
        - main.max_by(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.max_by(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.max_by(DOUBLE arg, BLOB val) -> DOUBLE
        - main.max_by(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.max_by(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.max_by(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.max_by(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.max_by(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.max_by(DECIMAL arg, DATE val) -> DECIMAL
        - main.max_by(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.max_by(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.max_by(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_function(
            self._MAX_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('max_by_filter')
    def max_by_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``max_by`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.max_by(INTEGER arg, INTEGER val) -> INTEGER
        - main.max_by(INTEGER arg, BIGINT val) -> INTEGER
        - main.max_by(INTEGER arg, HUGEINT val) -> INTEGER
        - main.max_by(INTEGER arg, DOUBLE val) -> INTEGER
        - main.max_by(INTEGER arg, VARCHAR val) -> INTEGER
        - main.max_by(INTEGER arg, DATE val) -> INTEGER
        - main.max_by(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.max_by(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.max_by(INTEGER arg, BLOB val) -> INTEGER
        - main.max_by(BIGINT arg, INTEGER val) -> BIGINT
        - main.max_by(BIGINT arg, BIGINT val) -> BIGINT
        - main.max_by(BIGINT arg, HUGEINT val) -> BIGINT
        - main.max_by(BIGINT arg, DOUBLE val) -> BIGINT
        - main.max_by(BIGINT arg, VARCHAR val) -> BIGINT
        - main.max_by(BIGINT arg, DATE val) -> BIGINT
        - main.max_by(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.max_by(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.max_by(BIGINT arg, BLOB val) -> BIGINT
        - main.max_by(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.max_by(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.max_by(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.max_by(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.max_by(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.max_by(DOUBLE arg, DATE val) -> DOUBLE
        - main.max_by(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.max_by(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.max_by(DOUBLE arg, BLOB val) -> DOUBLE
        - main.max_by(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.max_by(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.max_by(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.max_by(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.max_by(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.max_by(DECIMAL arg, DATE val) -> DECIMAL
        - main.max_by(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.max_by(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.max_by(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._MAX_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MEAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mean',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Calculates the average value for all tuples in x.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('mean')
    def mean(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``mean``.

        Calculates the average value for all tuples in x.

        Overloads:
        - main.mean(DECIMAL x) -> DECIMAL
        - main.mean(SMALLINT x) -> DOUBLE
        - main.mean(INTEGER x) -> DOUBLE
        - main.mean(BIGINT x) -> DOUBLE
        - main.mean(HUGEINT x) -> DOUBLE
        - main.mean(INTERVAL x) -> INTERVAL
        - main.mean(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._MEAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('mean_filter')
    def mean_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``mean`` with ``FILTER``.

        Calculates the average value for all tuples in x.

        Overloads:
        - main.mean(DECIMAL x) -> DECIMAL
        - main.mean(SMALLINT x) -> DOUBLE
        - main.mean(INTEGER x) -> DOUBLE
        - main.mean(BIGINT x) -> DOUBLE
        - main.mean(HUGEINT x) -> DOUBLE
        - main.mean(INTERVAL x) -> INTERVAL
        - main.mean(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._MEAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MIN_BY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('min_by')
    def min_by(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``min_by``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.min_by(INTEGER arg, INTEGER val) -> INTEGER
        - main.min_by(INTEGER arg, BIGINT val) -> INTEGER
        - main.min_by(INTEGER arg, HUGEINT val) -> INTEGER
        - main.min_by(INTEGER arg, DOUBLE val) -> INTEGER
        - main.min_by(INTEGER arg, VARCHAR val) -> INTEGER
        - main.min_by(INTEGER arg, DATE val) -> INTEGER
        - main.min_by(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.min_by(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.min_by(INTEGER arg, BLOB val) -> INTEGER
        - main.min_by(BIGINT arg, INTEGER val) -> BIGINT
        - main.min_by(BIGINT arg, BIGINT val) -> BIGINT
        - main.min_by(BIGINT arg, HUGEINT val) -> BIGINT
        - main.min_by(BIGINT arg, DOUBLE val) -> BIGINT
        - main.min_by(BIGINT arg, VARCHAR val) -> BIGINT
        - main.min_by(BIGINT arg, DATE val) -> BIGINT
        - main.min_by(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.min_by(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.min_by(BIGINT arg, BLOB val) -> BIGINT
        - main.min_by(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.min_by(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.min_by(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.min_by(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.min_by(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.min_by(DOUBLE arg, DATE val) -> DOUBLE
        - main.min_by(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.min_by(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.min_by(DOUBLE arg, BLOB val) -> DOUBLE
        - main.min_by(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.min_by(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.min_by(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.min_by(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.min_by(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.min_by(DECIMAL arg, DATE val) -> DECIMAL
        - main.min_by(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.min_by(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.min_by(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_function(
            self._MIN_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('min_by_filter')
    def min_by_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``min_by`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.min_by(INTEGER arg, INTEGER val) -> INTEGER
        - main.min_by(INTEGER arg, BIGINT val) -> INTEGER
        - main.min_by(INTEGER arg, HUGEINT val) -> INTEGER
        - main.min_by(INTEGER arg, DOUBLE val) -> INTEGER
        - main.min_by(INTEGER arg, VARCHAR val) -> INTEGER
        - main.min_by(INTEGER arg, DATE val) -> INTEGER
        - main.min_by(INTEGER arg, TIMESTAMP val) -> INTEGER
        - main.min_by(INTEGER arg, TIMESTAMP WITH TIME ZONE val) -> INTEGER
        - main.min_by(INTEGER arg, BLOB val) -> INTEGER
        - main.min_by(BIGINT arg, INTEGER val) -> BIGINT
        - main.min_by(BIGINT arg, BIGINT val) -> BIGINT
        - main.min_by(BIGINT arg, HUGEINT val) -> BIGINT
        - main.min_by(BIGINT arg, DOUBLE val) -> BIGINT
        - main.min_by(BIGINT arg, VARCHAR val) -> BIGINT
        - main.min_by(BIGINT arg, DATE val) -> BIGINT
        - main.min_by(BIGINT arg, TIMESTAMP val) -> BIGINT
        - main.min_by(BIGINT arg, TIMESTAMP WITH TIME ZONE val) -> BIGINT
        - main.min_by(BIGINT arg, BLOB val) -> BIGINT
        - main.min_by(DOUBLE arg, INTEGER val) -> DOUBLE
        - main.min_by(DOUBLE arg, BIGINT val) -> DOUBLE
        - main.min_by(DOUBLE arg, HUGEINT val) -> DOUBLE
        - main.min_by(DOUBLE arg, DOUBLE val) -> DOUBLE
        - main.min_by(DOUBLE arg, VARCHAR val) -> DOUBLE
        - main.min_by(DOUBLE arg, DATE val) -> DOUBLE
        - main.min_by(DOUBLE arg, TIMESTAMP val) -> DOUBLE
        - main.min_by(DOUBLE arg, TIMESTAMP WITH TIME ZONE val) -> DOUBLE
        - main.min_by(DOUBLE arg, BLOB val) -> DOUBLE
        - main.min_by(DECIMAL arg, INTEGER val) -> DECIMAL
        - main.min_by(DECIMAL arg, BIGINT val) -> DECIMAL
        - main.min_by(DECIMAL arg, HUGEINT val) -> DECIMAL
        - main.min_by(DECIMAL arg, DOUBLE val) -> DECIMAL
        - main.min_by(DECIMAL arg, VARCHAR val) -> DECIMAL
        - main.min_by(DECIMAL arg, DATE val) -> DECIMAL
        - main.min_by(DECIMAL arg, TIMESTAMP val) -> DECIMAL
        - main.min_by(DECIMAL arg, TIMESTAMP WITH TIME ZONE val) -> DECIMAL
        - main.min_by(DECIMAL arg, BLOB val) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._MIN_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the product of all tuples in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('product')
    def product(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``product``.

        Calculates the product of all tuples in arg.

        Overloads:
        - main.product(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_function(
            self._PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('product_filter')
    def product_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``product`` with ``FILTER``.

        Calculates the product of all tuples in arg.

        Overloads:
        - main.product(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _QUANTILE_CONT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quantile_cont',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE[]')),
                        parameters=('x', 'pos'),
                        varargs=None,
                        description='Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.\t',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('quantile_cont')
    def quantile_cont(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``quantile_cont``.

        Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.	

        Overloads:
        - main.quantile_cont(DECIMAL x, DOUBLE pos) -> DECIMAL
        - main.quantile_cont(DECIMAL x, DOUBLE[] pos) -> DECIMAL
        - main.quantile_cont(TINYINT x, DOUBLE pos) -> TINYINT
        - main.quantile_cont(TINYINT x, DOUBLE[] pos) -> TINYINT
        - main.quantile_cont(SMALLINT x, DOUBLE pos) -> SMALLINT
        - main.quantile_cont(SMALLINT x, DOUBLE[] pos) -> SMALLINT
        - main.quantile_cont(INTEGER x, DOUBLE pos) -> INTEGER
        - main.quantile_cont(INTEGER x, DOUBLE[] pos) -> INTEGER
        - main.quantile_cont(BIGINT x, DOUBLE pos) -> BIGINT
        - main.quantile_cont(BIGINT x, DOUBLE[] pos) -> BIGINT
        - main.quantile_cont(HUGEINT x, DOUBLE pos) -> HUGEINT
        - main.quantile_cont(HUGEINT x, DOUBLE[] pos) -> HUGEINT
        - main.quantile_cont(FLOAT x, DOUBLE pos) -> FLOAT
        - main.quantile_cont(FLOAT x, DOUBLE[] pos) -> FLOAT
        - main.quantile_cont(DOUBLE x, DOUBLE pos) -> DOUBLE
        - main.quantile_cont(DOUBLE x, DOUBLE[] pos) -> DOUBLE
        """
        return call_duckdb_function(
            self._QUANTILE_CONT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('quantile_cont_filter')
    def quantile_cont_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``quantile_cont`` with ``FILTER``.

        Returns the interpolated quantile number between 0 and 1 . If pos is a LIST of FLOATs, then the result is a LIST of the corresponding interpolated quantiles.	

        Overloads:
        - main.quantile_cont(DECIMAL x, DOUBLE pos) -> DECIMAL
        - main.quantile_cont(DECIMAL x, DOUBLE[] pos) -> DECIMAL
        - main.quantile_cont(TINYINT x, DOUBLE pos) -> TINYINT
        - main.quantile_cont(TINYINT x, DOUBLE[] pos) -> TINYINT
        - main.quantile_cont(SMALLINT x, DOUBLE pos) -> SMALLINT
        - main.quantile_cont(SMALLINT x, DOUBLE[] pos) -> SMALLINT
        - main.quantile_cont(INTEGER x, DOUBLE pos) -> INTEGER
        - main.quantile_cont(INTEGER x, DOUBLE[] pos) -> INTEGER
        - main.quantile_cont(BIGINT x, DOUBLE pos) -> BIGINT
        - main.quantile_cont(BIGINT x, DOUBLE[] pos) -> BIGINT
        - main.quantile_cont(HUGEINT x, DOUBLE pos) -> HUGEINT
        - main.quantile_cont(HUGEINT x, DOUBLE[] pos) -> HUGEINT
        - main.quantile_cont(FLOAT x, DOUBLE pos) -> FLOAT
        - main.quantile_cont(FLOAT x, DOUBLE[] pos) -> FLOAT
        - main.quantile_cont(DOUBLE x, DOUBLE pos) -> DOUBLE
        - main.quantile_cont(DOUBLE x, DOUBLE[] pos) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._QUANTILE_CONT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _REGR_AVGX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regr_avgx',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the average of the independent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regr_avgx')
    def regr_avgx(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_avgx``.

        Returns the average of the independent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.

        Overloads:
        - main.regr_avgx(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._REGR_AVGX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('regr_avgx_filter')
    def regr_avgx_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_avgx`` with ``FILTER``.

        Returns the average of the independent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.

        Overloads:
        - main.regr_avgx(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._REGR_AVGX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _REGR_AVGY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regr_avgy',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the average of the dependent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regr_avgy')
    def regr_avgy(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_avgy``.

        Returns the average of the dependent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.

        Overloads:
        - main.regr_avgy(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._REGR_AVGY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('regr_avgy_filter')
    def regr_avgy_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_avgy`` with ``FILTER``.

        Returns the average of the dependent variable for non-NULL pairs in a group, where x is the independent variable and y is the dependent variable.

        Overloads:
        - main.regr_avgy(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._REGR_AVGY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _REGR_COUNT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regr_count',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the number of non-NULL number pairs in a group.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regr_count')
    def regr_count(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_count``.

        Returns the number of non-NULL number pairs in a group.

        Overloads:
        - main.regr_count(DOUBLE y, DOUBLE x) -> UINTEGER
        """
        return call_duckdb_function(
            self._REGR_COUNT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('regr_count_filter')
    def regr_count_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_count`` with ``FILTER``.

        Returns the number of non-NULL number pairs in a group.

        Overloads:
        - main.regr_count(DOUBLE y, DOUBLE x) -> UINTEGER
        """
        return call_duckdb_filter_function(
            predicate,
            self._REGR_COUNT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _REGR_INTERCEPT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regr_intercept',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the intercept of the univariate linear regression line for non-NULL pairs in a group.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regr_intercept')
    def regr_intercept(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_intercept``.

        Returns the intercept of the univariate linear regression line for non-NULL pairs in a group.

        Overloads:
        - main.regr_intercept(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._REGR_INTERCEPT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('regr_intercept_filter')
    def regr_intercept_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_intercept`` with ``FILTER``.

        Returns the intercept of the univariate linear regression line for non-NULL pairs in a group.

        Overloads:
        - main.regr_intercept(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._REGR_INTERCEPT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _REGR_R2_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regr_r2',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the coefficient of determination for non-NULL pairs in a group.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regr_r2')
    def regr_r2(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_r2``.

        Returns the coefficient of determination for non-NULL pairs in a group.

        Overloads:
        - main.regr_r2(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._REGR_R2_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('regr_r2_filter')
    def regr_r2_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_r2`` with ``FILTER``.

        Returns the coefficient of determination for non-NULL pairs in a group.

        Overloads:
        - main.regr_r2(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._REGR_R2_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _REGR_SLOPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regr_slope',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the slope of the linear regression line for non-NULL pairs in a group.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regr_slope')
    def regr_slope(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_slope``.

        Returns the slope of the linear regression line for non-NULL pairs in a group.

        Overloads:
        - main.regr_slope(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._REGR_SLOPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('regr_slope_filter')
    def regr_slope_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_slope`` with ``FILTER``.

        Returns the slope of the linear regression line for non-NULL pairs in a group.

        Overloads:
        - main.regr_slope(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._REGR_SLOPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _REGR_SXX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regr_sxx',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regr_sxx')
    def regr_sxx(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_sxx``.

        Overloads:
        - main.regr_sxx(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._REGR_SXX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('regr_sxx_filter')
    def regr_sxx_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_sxx`` with ``FILTER``.

        Overloads:
        - main.regr_sxx(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._REGR_SXX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _REGR_SXY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regr_sxy',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Returns the population covariance of input values',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regr_sxy')
    def regr_sxy(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_sxy``.

        Returns the population covariance of input values

        Overloads:
        - main.regr_sxy(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._REGR_SXY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('regr_sxy_filter')
    def regr_sxy_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_sxy`` with ``FILTER``.

        Returns the population covariance of input values

        Overloads:
        - main.regr_sxy(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._REGR_SXY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _REGR_SYY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regr_syy',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regr_syy')
    def regr_syy(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_syy``.

        Overloads:
        - main.regr_syy(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._REGR_SYY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('regr_syy_filter')
    def regr_syy_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``regr_syy`` with ``FILTER``.

        Overloads:
        - main.regr_syy(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._REGR_SYY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _RESERVOIR_QUANTILE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL[]'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE[]')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('DOUBLE')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('TINYINT[]'),
                        parameter_types=(parse_type('TINYINT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('DOUBLE')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT[]'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('INTEGER[]'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE[]')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('BIGINT[]'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('DOUBLE')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT[]'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('DOUBLE')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('FLOAT[]'),
                        parameter_types=(parse_type('FLOAT'), parse_type('DOUBLE[]')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE[]'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE[]')),
                        parameters=('x', 'quantile'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL[]'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DOUBLE[]'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('TINYINT[]'),
                        parameter_types=(parse_type('TINYINT'), parse_type('DOUBLE[]'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT[]'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('DOUBLE[]'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('INTEGER[]'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DOUBLE[]'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('BIGINT[]'),
                        parameter_types=(parse_type('BIGINT'), parse_type('DOUBLE[]'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT[]'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('DOUBLE[]'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('FLOAT[]'),
                        parameter_types=(parse_type('FLOAT'), parse_type('DOUBLE[]'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reservoir_quantile',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE[]'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE[]'), parse_type('INTEGER')),
                        parameters=('x', 'quantile', 'sample_size'),
                        varargs=None,
                        description='Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('reservoir_quantile')
    def reservoir_quantile(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``reservoir_quantile``.

        Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.

        Overloads:
        - main.reservoir_quantile(DECIMAL x, DOUBLE quantile) -> DECIMAL
        - main.reservoir_quantile(DECIMAL x, DOUBLE[] quantile) -> DECIMAL[]
        - main.reservoir_quantile(TINYINT x, DOUBLE quantile) -> TINYINT
        - main.reservoir_quantile(TINYINT x, DOUBLE[] quantile) -> TINYINT[]
        - main.reservoir_quantile(SMALLINT x, DOUBLE quantile) -> SMALLINT
        - main.reservoir_quantile(SMALLINT x, DOUBLE[] quantile) -> SMALLINT[]
        - main.reservoir_quantile(INTEGER x, DOUBLE quantile) -> INTEGER
        - main.reservoir_quantile(INTEGER x, DOUBLE[] quantile) -> INTEGER[]
        - main.reservoir_quantile(BIGINT x, DOUBLE quantile) -> BIGINT
        - main.reservoir_quantile(BIGINT x, DOUBLE[] quantile) -> BIGINT[]
        - main.reservoir_quantile(HUGEINT x, DOUBLE quantile) -> HUGEINT
        - main.reservoir_quantile(HUGEINT x, DOUBLE[] quantile) -> HUGEINT[]
        - main.reservoir_quantile(FLOAT x, DOUBLE quantile) -> FLOAT
        - main.reservoir_quantile(FLOAT x, DOUBLE[] quantile) -> FLOAT[]
        - main.reservoir_quantile(DOUBLE x, DOUBLE quantile) -> DOUBLE
        - main.reservoir_quantile(DOUBLE x, DOUBLE[] quantile) -> DOUBLE[]
        - main.reservoir_quantile(DECIMAL x, DOUBLE quantile, INTEGER sample_size) -> DECIMAL
        - main.reservoir_quantile(DECIMAL x, DOUBLE[] quantile, INTEGER sample_size) -> DECIMAL[]
        - main.reservoir_quantile(TINYINT x, DOUBLE quantile, INTEGER sample_size) -> TINYINT
        - main.reservoir_quantile(TINYINT x, DOUBLE[] quantile, INTEGER sample_size) -> TINYINT[]
        - main.reservoir_quantile(SMALLINT x, DOUBLE quantile, INTEGER sample_size) -> SMALLINT
        - main.reservoir_quantile(SMALLINT x, DOUBLE[] quantile, INTEGER sample_size) -> SMALLINT[]
        - main.reservoir_quantile(INTEGER x, DOUBLE quantile, INTEGER sample_size) -> INTEGER
        - main.reservoir_quantile(INTEGER x, DOUBLE[] quantile, INTEGER sample_size) -> INTEGER[]
        - main.reservoir_quantile(BIGINT x, DOUBLE quantile, INTEGER sample_size) -> BIGINT
        - main.reservoir_quantile(BIGINT x, DOUBLE[] quantile, INTEGER sample_size) -> BIGINT[]
        - main.reservoir_quantile(HUGEINT x, DOUBLE quantile, INTEGER sample_size) -> HUGEINT
        - main.reservoir_quantile(HUGEINT x, DOUBLE[] quantile, INTEGER sample_size) -> HUGEINT[]
        - main.reservoir_quantile(FLOAT x, DOUBLE quantile, INTEGER sample_size) -> FLOAT
        - main.reservoir_quantile(FLOAT x, DOUBLE[] quantile, INTEGER sample_size) -> FLOAT[]
        - main.reservoir_quantile(DOUBLE x, DOUBLE quantile, INTEGER sample_size) -> DOUBLE
        - main.reservoir_quantile(DOUBLE x, DOUBLE[] quantile, INTEGER sample_size) -> DOUBLE[]
        """
        return call_duckdb_function(
            self._RESERVOIR_QUANTILE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('reservoir_quantile_filter')
    def reservoir_quantile_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``reservoir_quantile`` with ``FILTER``.

        Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size.

        Overloads:
        - main.reservoir_quantile(DECIMAL x, DOUBLE quantile) -> DECIMAL
        - main.reservoir_quantile(DECIMAL x, DOUBLE[] quantile) -> DECIMAL[]
        - main.reservoir_quantile(TINYINT x, DOUBLE quantile) -> TINYINT
        - main.reservoir_quantile(TINYINT x, DOUBLE[] quantile) -> TINYINT[]
        - main.reservoir_quantile(SMALLINT x, DOUBLE quantile) -> SMALLINT
        - main.reservoir_quantile(SMALLINT x, DOUBLE[] quantile) -> SMALLINT[]
        - main.reservoir_quantile(INTEGER x, DOUBLE quantile) -> INTEGER
        - main.reservoir_quantile(INTEGER x, DOUBLE[] quantile) -> INTEGER[]
        - main.reservoir_quantile(BIGINT x, DOUBLE quantile) -> BIGINT
        - main.reservoir_quantile(BIGINT x, DOUBLE[] quantile) -> BIGINT[]
        - main.reservoir_quantile(HUGEINT x, DOUBLE quantile) -> HUGEINT
        - main.reservoir_quantile(HUGEINT x, DOUBLE[] quantile) -> HUGEINT[]
        - main.reservoir_quantile(FLOAT x, DOUBLE quantile) -> FLOAT
        - main.reservoir_quantile(FLOAT x, DOUBLE[] quantile) -> FLOAT[]
        - main.reservoir_quantile(DOUBLE x, DOUBLE quantile) -> DOUBLE
        - main.reservoir_quantile(DOUBLE x, DOUBLE[] quantile) -> DOUBLE[]
        - main.reservoir_quantile(DECIMAL x, DOUBLE quantile, INTEGER sample_size) -> DECIMAL
        - main.reservoir_quantile(DECIMAL x, DOUBLE[] quantile, INTEGER sample_size) -> DECIMAL[]
        - main.reservoir_quantile(TINYINT x, DOUBLE quantile, INTEGER sample_size) -> TINYINT
        - main.reservoir_quantile(TINYINT x, DOUBLE[] quantile, INTEGER sample_size) -> TINYINT[]
        - main.reservoir_quantile(SMALLINT x, DOUBLE quantile, INTEGER sample_size) -> SMALLINT
        - main.reservoir_quantile(SMALLINT x, DOUBLE[] quantile, INTEGER sample_size) -> SMALLINT[]
        - main.reservoir_quantile(INTEGER x, DOUBLE quantile, INTEGER sample_size) -> INTEGER
        - main.reservoir_quantile(INTEGER x, DOUBLE[] quantile, INTEGER sample_size) -> INTEGER[]
        - main.reservoir_quantile(BIGINT x, DOUBLE quantile, INTEGER sample_size) -> BIGINT
        - main.reservoir_quantile(BIGINT x, DOUBLE[] quantile, INTEGER sample_size) -> BIGINT[]
        - main.reservoir_quantile(HUGEINT x, DOUBLE quantile, INTEGER sample_size) -> HUGEINT
        - main.reservoir_quantile(HUGEINT x, DOUBLE[] quantile, INTEGER sample_size) -> HUGEINT[]
        - main.reservoir_quantile(FLOAT x, DOUBLE quantile, INTEGER sample_size) -> FLOAT
        - main.reservoir_quantile(FLOAT x, DOUBLE[] quantile, INTEGER sample_size) -> FLOAT[]
        - main.reservoir_quantile(DOUBLE x, DOUBLE quantile, INTEGER sample_size) -> DOUBLE
        - main.reservoir_quantile(DOUBLE x, DOUBLE[] quantile, INTEGER sample_size) -> DOUBLE[]
        """
        return call_duckdb_filter_function(
            predicate,
            self._RESERVOIR_QUANTILE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _SEM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sem',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the standard error of the mean',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sem')
    def sem(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``sem``.

        Returns the standard error of the mean

        Overloads:
        - main.sem(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._SEM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('sem_filter')
    def sem_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``sem`` with ``FILTER``.

        Returns the standard error of the mean

        Overloads:
        - main.sem(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._SEM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _SKEWNESS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='skewness',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the skewness of all input values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('skewness')
    def skewness(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``skewness``.

        Returns the skewness of all input values.

        Overloads:
        - main.skewness(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._SKEWNESS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('skewness_filter')
    def skewness_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``skewness`` with ``FILTER``.

        Returns the skewness of all input values.

        Overloads:
        - main.skewness(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._SKEWNESS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _STDDEV_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='stddev',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sample standard deviation',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('stddev')
    def stddev(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``stddev``.

        Returns the sample standard deviation

        Overloads:
        - main.stddev(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._STDDEV_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('stddev_filter')
    def stddev_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``stddev`` with ``FILTER``.

        Returns the sample standard deviation

        Overloads:
        - main.stddev(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._STDDEV_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _STDDEV_POP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='stddev_pop',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the population standard deviation.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('stddev_pop')
    def stddev_pop(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``stddev_pop``.

        Returns the population standard deviation.

        Overloads:
        - main.stddev_pop(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._STDDEV_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('stddev_pop_filter')
    def stddev_pop_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``stddev_pop`` with ``FILTER``.

        Returns the population standard deviation.

        Overloads:
        - main.stddev_pop(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._STDDEV_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _STDDEV_SAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='stddev_samp',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sample standard deviation',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('stddev_samp')
    def stddev_samp(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``stddev_samp``.

        Returns the sample standard deviation

        Overloads:
        - main.stddev_samp(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._STDDEV_SAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('stddev_samp_filter')
    def stddev_samp_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``stddev_samp`` with ``FILTER``.

        Returns the sample standard deviation

        Overloads:
        - main.stddev_samp(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._STDDEV_SAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _SUM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum value for all tuples in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('BOOLEAN'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum value for all tuples in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum value for all tuples in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum value for all tuples in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum value for all tuples in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum value for all tuples in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum value for all tuples in arg.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sum')
    def sum(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``sum``.

        Calculates the sum value for all tuples in arg.

        Overloads:
        - main.sum(DECIMAL arg) -> DECIMAL
        - main.sum(BOOLEAN arg) -> HUGEINT
        - main.sum(SMALLINT arg) -> HUGEINT
        - main.sum(INTEGER arg) -> HUGEINT
        - main.sum(BIGINT arg) -> HUGEINT
        - main.sum(HUGEINT arg) -> HUGEINT
        - main.sum(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_function(
            self._SUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('sum_filter')
    def sum_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``sum`` with ``FILTER``.

        Calculates the sum value for all tuples in arg.

        Overloads:
        - main.sum(DECIMAL arg) -> DECIMAL
        - main.sum(BOOLEAN arg) -> HUGEINT
        - main.sum(SMALLINT arg) -> HUGEINT
        - main.sum(INTEGER arg) -> HUGEINT
        - main.sum(BIGINT arg) -> HUGEINT
        - main.sum(HUGEINT arg) -> HUGEINT
        - main.sum(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._SUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _SUM_NO_OVERFLOW_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum_no_overflow',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Internal only. Calculates the sum value for all tuples in arg without overflow checks.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum_no_overflow',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Internal only. Calculates the sum value for all tuples in arg without overflow checks.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sum_no_overflow',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Internal only. Calculates the sum value for all tuples in arg without overflow checks.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sum_no_overflow')
    def sum_no_overflow(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``sum_no_overflow``.

        Internal only. Calculates the sum value for all tuples in arg without overflow checks.

        Overloads:
        - main.sum_no_overflow(INTEGER arg) -> HUGEINT
        - main.sum_no_overflow(BIGINT arg) -> HUGEINT
        - main.sum_no_overflow(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_function(
            self._SUM_NO_OVERFLOW_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('sum_no_overflow_filter')
    def sum_no_overflow_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``sum_no_overflow`` with ``FILTER``.

        Internal only. Calculates the sum value for all tuples in arg without overflow checks.

        Overloads:
        - main.sum_no_overflow(INTEGER arg) -> HUGEINT
        - main.sum_no_overflow(BIGINT arg) -> HUGEINT
        - main.sum_no_overflow(DECIMAL arg) -> DECIMAL
        """
        return call_duckdb_filter_function(
            predicate,
            self._SUM_NO_OVERFLOW_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _SUMKAHAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sumkahan',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('arg',),
                        varargs=None,
                        description='Calculates the sum using a more accurate floating point summation (Kahan Sum).',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sumkahan')
    def sumkahan(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``sumkahan``.

        Calculates the sum using a more accurate floating point summation (Kahan Sum).

        Overloads:
        - main.sumkahan(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_function(
            self._SUMKAHAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('sumkahan_filter')
    def sumkahan_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``sumkahan`` with ``FILTER``.

        Calculates the sum using a more accurate floating point summation (Kahan Sum).

        Overloads:
        - main.sumkahan(DOUBLE arg) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._SUMKAHAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _VAR_POP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='var_pop',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the population variance.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('var_pop')
    def var_pop(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``var_pop``.

        Returns the population variance.

        Overloads:
        - main.var_pop(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._VAR_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('var_pop_filter')
    def var_pop_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``var_pop`` with ``FILTER``.

        Returns the population variance.

        Overloads:
        - main.var_pop(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._VAR_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _VAR_SAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='var_samp',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sample variance of all input values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('var_samp')
    def var_samp(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``var_samp``.

        Returns the sample variance of all input values.

        Overloads:
        - main.var_samp(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._VAR_SAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('var_samp_filter')
    def var_samp_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``var_samp`` with ``FILTER``.

        Returns the sample variance of all input values.

        Overloads:
        - main.var_samp(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._VAR_SAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _VARIANCE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='variance',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sample variance of all input values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('variance')
    def variance(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``variance``.

        Returns the sample variance of all input values.

        Overloads:
        - main.variance(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._VARIANCE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('variance_filter')
    def variance_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> NumericExpression:
        """Call DuckDB function ``variance`` with ``FILTER``.

        Returns the sample variance of all input values.

        Overloads:
        - main.variance(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_filter_function(
            predicate,
            self._VARIANCE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        'any_value': 'any_value',
        'any_value_filter': 'any_value_filter',
        'approx_count_distinct': 'approx_count_distinct',
        'approx_count_distinct_filter': 'approx_count_distinct_filter',
        'approx_quantile': 'approx_quantile',
        'approx_quantile_filter': 'approx_quantile_filter',
        'arbitrary': 'arbitrary',
        'arbitrary_filter': 'arbitrary_filter',
        'arg_max': 'arg_max',
        'arg_max_filter': 'arg_max_filter',
        'arg_max_null': 'arg_max_null',
        'arg_max_null_filter': 'arg_max_null_filter',
        'arg_min': 'arg_min',
        'arg_min_filter': 'arg_min_filter',
        'arg_min_null': 'arg_min_null',
        'arg_min_null_filter': 'arg_min_null_filter',
        'argmax': 'argmax',
        'argmax_filter': 'argmax_filter',
        'argmin': 'argmin',
        'argmin_filter': 'argmin_filter',
        'avg': 'avg',
        'avg_filter': 'avg_filter',
        'bit_and': 'bit_and',
        'bit_and_filter': 'bit_and_filter',
        'bit_or': 'bit_or',
        'bit_or_filter': 'bit_or_filter',
        'bit_xor': 'bit_xor',
        'bit_xor_filter': 'bit_xor_filter',
        'corr': 'corr',
        'corr_filter': 'corr_filter',
        'count': 'count',
        'count_filter': 'count_filter',
        'count_if': 'count_if',
        'count_if_filter': 'count_if_filter',
        'count_star': 'count_star',
        'count_star_filter': 'count_star_filter',
        'countif': 'countif',
        'countif_filter': 'countif_filter',
        'covar_pop': 'covar_pop',
        'covar_pop_filter': 'covar_pop_filter',
        'covar_samp': 'covar_samp',
        'covar_samp_filter': 'covar_samp_filter',
        'entropy': 'entropy',
        'entropy_filter': 'entropy_filter',
        'favg': 'favg',
        'favg_filter': 'favg_filter',
        'first': 'first',
        'first_filter': 'first_filter',
        'fsum': 'fsum',
        'fsum_filter': 'fsum_filter',
        'kahan_sum': 'kahan_sum',
        'kahan_sum_filter': 'kahan_sum_filter',
        'kurtosis': 'kurtosis',
        'kurtosis_filter': 'kurtosis_filter',
        'kurtosis_pop': 'kurtosis_pop',
        'kurtosis_pop_filter': 'kurtosis_pop_filter',
        'last': 'last',
        'last_filter': 'last_filter',
        'mad': 'mad',
        'mad_filter': 'mad_filter',
        'max_by': 'max_by',
        'max_by_filter': 'max_by_filter',
        'mean': 'mean',
        'mean_filter': 'mean_filter',
        'min_by': 'min_by',
        'min_by_filter': 'min_by_filter',
        'product': 'product',
        'product_filter': 'product_filter',
        'quantile_cont': 'quantile_cont',
        'quantile_cont_filter': 'quantile_cont_filter',
        'regr_avgx': 'regr_avgx',
        'regr_avgx_filter': 'regr_avgx_filter',
        'regr_avgy': 'regr_avgy',
        'regr_avgy_filter': 'regr_avgy_filter',
        'regr_count': 'regr_count',
        'regr_count_filter': 'regr_count_filter',
        'regr_intercept': 'regr_intercept',
        'regr_intercept_filter': 'regr_intercept_filter',
        'regr_r2': 'regr_r2',
        'regr_r2_filter': 'regr_r2_filter',
        'regr_slope': 'regr_slope',
        'regr_slope_filter': 'regr_slope_filter',
        'regr_sxx': 'regr_sxx',
        'regr_sxx_filter': 'regr_sxx_filter',
        'regr_sxy': 'regr_sxy',
        'regr_sxy_filter': 'regr_sxy_filter',
        'regr_syy': 'regr_syy',
        'regr_syy_filter': 'regr_syy_filter',
        'reservoir_quantile': 'reservoir_quantile',
        'reservoir_quantile_filter': 'reservoir_quantile_filter',
        'sem': 'sem',
        'sem_filter': 'sem_filter',
        'skewness': 'skewness',
        'skewness_filter': 'skewness_filter',
        'stddev': 'stddev',
        'stddev_filter': 'stddev_filter',
        'stddev_pop': 'stddev_pop',
        'stddev_pop_filter': 'stddev_pop_filter',
        'stddev_samp': 'stddev_samp',
        'stddev_samp_filter': 'stddev_samp_filter',
        'sum': 'sum',
        'sum_filter': 'sum_filter',
        'sum_no_overflow': 'sum_no_overflow',
        'sum_no_overflow_filter': 'sum_no_overflow_filter',
        'sumkahan': 'sumkahan',
        'sumkahan_filter': 'sumkahan_filter',
        'var_pop': 'var_pop',
        'var_pop_filter': 'var_pop_filter',
        'var_samp': 'var_samp',
        'var_samp_filter': 'var_samp_filter',
        'variance': 'variance',
        'variance_filter': 'variance_filter',
    }
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class AggregateVarcharFunctions(_StaticFunctionNamespace):
    """DuckDB aggregate functions returning string results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'aggregate'
    return_category: ClassVar[str] = 'varchar'
    _ARG_MAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_max')
    def arg_max(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``arg_max``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_max(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.arg_max(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.arg_max(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.arg_max(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.arg_max(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.arg_max(VARCHAR arg, DATE val) -> VARCHAR
        - main.arg_max(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.arg_max(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.arg_max(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_function(
            self._ARG_MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_max_filter')
    def arg_max_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``arg_max`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_max(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.arg_max(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.arg_max(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.arg_max(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.arg_max(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.arg_max(VARCHAR arg, DATE val) -> VARCHAR
        - main.arg_max(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.arg_max(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.arg_max(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MAX_NULL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_max_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_max_null')
    def arg_max_null(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``arg_max_null``.

        Finds the row with the maximum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_max_null(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, DATE val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_function(
            self._ARG_MAX_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_max_null_filter')
    def arg_max_null_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``arg_max_null`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_max_null(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, DATE val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.arg_max_null(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MAX_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_min')
    def arg_min(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``arg_min``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_min(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.arg_min(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.arg_min(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.arg_min(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.arg_min(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.arg_min(VARCHAR arg, DATE val) -> VARCHAR
        - main.arg_min(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.arg_min(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.arg_min(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_function(
            self._ARG_MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_min_filter')
    def arg_min_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``arg_min`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.arg_min(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.arg_min(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.arg_min(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.arg_min(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.arg_min(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.arg_min(VARCHAR arg, DATE val) -> VARCHAR
        - main.arg_min(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.arg_min(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.arg_min(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARG_MIN_NULL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='arg_min_null',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('arg_min_null')
    def arg_min_null(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``arg_min_null``.

        Finds the row with the minimum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_min_null(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, DATE val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_function(
            self._ARG_MIN_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('arg_min_null_filter')
    def arg_min_null_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``arg_min_null`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the arg expression at that row.

        Overloads:
        - main.arg_min_null(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, DATE val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.arg_min_null(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARG_MIN_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARGMAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmax',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('argmax')
    def argmax(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``argmax``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmax(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.argmax(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.argmax(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.argmax(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.argmax(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.argmax(VARCHAR arg, DATE val) -> VARCHAR
        - main.argmax(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.argmax(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.argmax(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_function(
            self._ARGMAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('argmax_filter')
    def argmax_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``argmax`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmax(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.argmax(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.argmax(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.argmax(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.argmax(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.argmax(VARCHAR arg, DATE val) -> VARCHAR
        - main.argmax(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.argmax(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.argmax(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARGMAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _ARGMIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='argmin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('argmin')
    def argmin(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``argmin``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmin(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.argmin(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.argmin(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.argmin(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.argmin(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.argmin(VARCHAR arg, DATE val) -> VARCHAR
        - main.argmin(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.argmin(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.argmin(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_function(
            self._ARGMIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('argmin_filter')
    def argmin_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``argmin`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.argmin(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.argmin(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.argmin(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.argmin(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.argmin(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.argmin(VARCHAR arg, DATE val) -> VARCHAR
        - main.argmin(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.argmin(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.argmin(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._ARGMIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _GROUP_CONCAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='group_concat',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('str',),
                        varargs=None,
                        description='Concatenates the column string values with an optional separator.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='group_concat',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('str', 'arg'),
                        varargs=None,
                        description='Concatenates the column string values with an optional separator.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('group_concat')
    def group_concat(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``group_concat``.

        Concatenates the column string values with an optional separator.

        Overloads:
        - main.group_concat(ANY str) -> VARCHAR
        - main.group_concat(ANY str, VARCHAR arg) -> VARCHAR
        """
        return call_duckdb_function(
            self._GROUP_CONCAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('group_concat_filter')
    def group_concat_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``group_concat`` with ``FILTER``.

        Concatenates the column string values with an optional separator.

        Overloads:
        - main.group_concat(ANY str) -> VARCHAR
        - main.group_concat(ANY str, VARCHAR arg) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._GROUP_CONCAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _LISTAGG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='listagg',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('str',),
                        varargs=None,
                        description='Concatenates the column string values with an optional separator.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='listagg',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('str', 'arg'),
                        varargs=None,
                        description='Concatenates the column string values with an optional separator.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('listagg')
    def listagg(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``listagg``.

        Concatenates the column string values with an optional separator.

        Overloads:
        - main.listagg(ANY str) -> VARCHAR
        - main.listagg(ANY str, VARCHAR arg) -> VARCHAR
        """
        return call_duckdb_function(
            self._LISTAGG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('listagg_filter')
    def listagg_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``listagg`` with ``FILTER``.

        Concatenates the column string values with an optional separator.

        Overloads:
        - main.listagg(ANY str) -> VARCHAR
        - main.listagg(ANY str, VARCHAR arg) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._LISTAGG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MAX_BY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='max_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('max_by')
    def max_by(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``max_by``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.max_by(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.max_by(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.max_by(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.max_by(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.max_by(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.max_by(VARCHAR arg, DATE val) -> VARCHAR
        - main.max_by(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.max_by(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.max_by(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_function(
            self._MAX_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('max_by_filter')
    def max_by_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``max_by`` with ``FILTER``.

        Finds the row with the maximum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.max_by(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.max_by(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.max_by(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.max_by(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.max_by(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.max_by(VARCHAR arg, DATE val) -> VARCHAR
        - main.max_by(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.max_by(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.max_by(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._MAX_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _MIN_BY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('HUGEINT')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='min_by',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BLOB')),
                        parameters=('arg', 'val'),
                        varargs=None,
                        description='Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('min_by')
    def min_by(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``min_by``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.min_by(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.min_by(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.min_by(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.min_by(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.min_by(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.min_by(VARCHAR arg, DATE val) -> VARCHAR
        - main.min_by(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.min_by(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.min_by(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_function(
            self._MIN_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('min_by_filter')
    def min_by_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``min_by`` with ``FILTER``.

        Finds the row with the minimum val. Calculates the non-NULL arg expression at that row.

        Overloads:
        - main.min_by(VARCHAR arg, INTEGER val) -> VARCHAR
        - main.min_by(VARCHAR arg, BIGINT val) -> VARCHAR
        - main.min_by(VARCHAR arg, HUGEINT val) -> VARCHAR
        - main.min_by(VARCHAR arg, DOUBLE val) -> VARCHAR
        - main.min_by(VARCHAR arg, VARCHAR val) -> VARCHAR
        - main.min_by(VARCHAR arg, DATE val) -> VARCHAR
        - main.min_by(VARCHAR arg, TIMESTAMP val) -> VARCHAR
        - main.min_by(VARCHAR arg, TIMESTAMP WITH TIME ZONE val) -> VARCHAR
        - main.min_by(VARCHAR arg, BLOB val) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._MIN_BY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    _STRING_AGG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='string_agg',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('str',),
                        varargs=None,
                        description='Concatenates the column string values with an optional separator.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='string_agg',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'), parse_type('VARCHAR')),
                        parameters=('str', 'arg'),
                        varargs=None,
                        description='Concatenates the column string values with an optional separator.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('string_agg')
    def string_agg(self, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``string_agg``.

        Concatenates the column string values with an optional separator.

        Overloads:
        - main.string_agg(ANY str) -> VARCHAR
        - main.string_agg(ANY str, VARCHAR arg) -> VARCHAR
        """
        return call_duckdb_function(
            self._STRING_AGG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )
    @duckdb_function('string_agg_filter')
    def string_agg_filter(self, predicate: object, *operands: object, order_by: Iterable[object] | object | None = None, within_group: Iterable[object] | object | None = None, partition_by: Iterable[object] | object | None = None, over_order_by: Iterable[object] | object | None = None, frame: str | None = None) -> VarcharExpression:
        """Call DuckDB function ``string_agg`` with ``FILTER``.

        Concatenates the column string values with an optional separator.

        Overloads:
        - main.string_agg(ANY str) -> VARCHAR
        - main.string_agg(ANY str, VARCHAR arg) -> VARCHAR
        """
        return call_duckdb_filter_function(
            predicate,
            self._STRING_AGG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
            order_by=order_by,
            within_group=within_group,
            partition_by=partition_by,
            over_order_by=over_order_by,
            frame=frame,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        'arg_max': 'arg_max',
        'arg_max_filter': 'arg_max_filter',
        'arg_max_null': 'arg_max_null',
        'arg_max_null_filter': 'arg_max_null_filter',
        'arg_min': 'arg_min',
        'arg_min_filter': 'arg_min_filter',
        'arg_min_null': 'arg_min_null',
        'arg_min_null_filter': 'arg_min_null_filter',
        'argmax': 'argmax',
        'argmax_filter': 'argmax_filter',
        'argmin': 'argmin',
        'argmin_filter': 'argmin_filter',
        'group_concat': 'group_concat',
        'group_concat_filter': 'group_concat_filter',
        'listagg': 'listagg',
        'listagg_filter': 'listagg_filter',
        'max_by': 'max_by',
        'max_by_filter': 'max_by_filter',
        'min_by': 'min_by',
        'min_by_filter': 'min_by_filter',
        'string_agg': 'string_agg',
        'string_agg_filter': 'string_agg_filter',
    }
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class AggregateFunctionNamespace:
    """DuckDB aggregate function categories."""
    __slots__ = ()
    Blob: AggregateBlobFunctions = AggregateBlobFunctions()  # noqa: N802
    Boolean: AggregateBooleanFunctions = AggregateBooleanFunctions()  # noqa: N802
    Generic: AggregateGenericFunctions = AggregateGenericFunctions()  # noqa: N802
    Numeric: AggregateNumericFunctions = AggregateNumericFunctions()  # noqa: N802
    Varchar: AggregateVarcharFunctions = AggregateVarcharFunctions()  # noqa: N802
    def __dir__(self) -> list[str]:
        return sorted(name for name in self.__class__.__dict__ if not name.startswith('_'))

class ScalarBlobFunctions(_StaticFunctionNamespace):
    """DuckDB scalar functions returning binary results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'scalar'
    return_category: ClassVar[str] = 'blob'
    _CREATE_SORT_KEY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='create_sort_key',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('parameters...',),
                        varargs=parse_type('ANY'),
                        description='Constructs a binary-comparable sort key based on a set of input parameters and sort qualifiers',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('create_sort_key')
    def create_sort_key(self, *operands: object) -> BlobExpression:
        """Call DuckDB function ``create_sort_key``.

        Constructs a binary-comparable sort key based on a set of input parameters and sort qualifiers

        Overloads:
        - main.create_sort_key(ANY parameters..., ANY ...) -> BLOB
        """
        return call_duckdb_function(
            self._CREATE_SORT_KEY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ENCODE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='encode',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts the `string` to `BLOB`. Converts UTF-8 characters into literal encoding.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('encode')
    def encode(self, *operands: object) -> BlobExpression:
        """Call DuckDB function ``encode``.

        Converts the `string` to `BLOB`. Converts UTF-8 characters into literal encoding.

        Overloads:
        - main.encode(VARCHAR string) -> BLOB
        """
        return call_duckdb_function(
            self._ENCODE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FROM_BASE64_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='from_base64',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts a base64 encoded `string` to a character string (`BLOB`).',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('from_base64')
    def from_base64(self, *operands: object) -> BlobExpression:
        """Call DuckDB function ``from_base64``.

        Converts a base64 encoded `string` to a character string (`BLOB`).

        Overloads:
        - main.from_base64(VARCHAR string) -> BLOB
        """
        return call_duckdb_function(
            self._FROM_BASE64_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FROM_BINARY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='from_binary',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts a `value` from binary representation to a blob.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('from_binary')
    def from_binary(self, *operands: object) -> BlobExpression:
        """Call DuckDB function ``from_binary``.

        Converts a `value` from binary representation to a blob.

        Overloads:
        - main.from_binary(VARCHAR value) -> BLOB
        """
        return call_duckdb_function(
            self._FROM_BINARY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FROM_HEX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='from_hex',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts a `value` from hexadecimal representation to a blob.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('from_hex')
    def from_hex(self, *operands: object) -> BlobExpression:
        """Call DuckDB function ``from_hex``.

        Converts a `value` from hexadecimal representation to a blob.

        Overloads:
        - main.from_hex(VARCHAR value) -> BLOB
        """
        return call_duckdb_function(
            self._FROM_HEX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REPEAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='repeat',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('BLOB'), parse_type('BIGINT')),
                        parameters=('blob', 'count'),
                        varargs=None,
                        description='Repeats the `blob` `count` number of times.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('repeat')
    def repeat(self, *operands: object) -> BlobExpression:
        """Call DuckDB function ``repeat``.

        Repeats the `blob` `count` number of times.

        Overloads:
        - main.repeat(BLOB blob, BIGINT count) -> BLOB
        """
        return call_duckdb_function(
            self._REPEAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UNBIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='unbin',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts a `value` from binary representation to a blob.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('unbin')
    def unbin(self, *operands: object) -> BlobExpression:
        """Call DuckDB function ``unbin``.

        Converts a `value` from binary representation to a blob.

        Overloads:
        - main.unbin(VARCHAR value) -> BLOB
        """
        return call_duckdb_function(
            self._UNBIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UNHEX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='unhex',
                        function_type=function_type,
                        return_type=parse_type('BLOB'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts a `value` from hexadecimal representation to a blob.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('unhex')
    def unhex(self, *operands: object) -> BlobExpression:
        """Call DuckDB function ``unhex``.

        Converts a `value` from hexadecimal representation to a blob.

        Overloads:
        - main.unhex(VARCHAR value) -> BLOB
        """
        return call_duckdb_function(
            self._UNHEX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        'create_sort_key': 'create_sort_key',
        'encode': 'encode',
        'from_base64': 'from_base64',
        'from_binary': 'from_binary',
        'from_hex': 'from_hex',
        'repeat': 'repeat',
        'unbin': 'unbin',
        'unhex': 'unhex',
    }
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class ScalarBooleanFunctions(_StaticFunctionNamespace):
    """DuckDB scalar functions returning boolean results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'scalar'
    return_category: ClassVar[str] = 'boolean'
    _ARRAY_CONTAINS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T')),
                        parameters=('list', 'element'),
                        varargs=None,
                        description='Returns true if the list contains the element.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_contains')
    def array_contains(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``array_contains``.

        Returns true if the list contains the element.

        Overloads:
        - main.array_contains(T[] list, T element) -> BOOLEAN
        """
        return call_duckdb_function(
            self._ARRAY_CONTAINS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_HAS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_has',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T')),
                        parameters=('list', 'element'),
                        varargs=None,
                        description='Returns true if the list contains the element.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_has')
    def array_has(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``array_has``.

        Returns true if the list contains the element.

        Overloads:
        - main.array_has(T[] list, T element) -> BOOLEAN
        """
        return call_duckdb_function(
            self._ARRAY_HAS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_HAS_ALL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_has_all',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Returns true if all elements of list2 are in list1. NULLs are ignored.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_has_all')
    def array_has_all(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``array_has_all``.

        Returns true if all elements of list2 are in list1. NULLs are ignored.

        Overloads:
        - main.array_has_all(T[] list1, T[] list2) -> BOOLEAN
        """
        return call_duckdb_function(
            self._ARRAY_HAS_ALL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_HAS_ANY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_has_any',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Returns true if the lists have any element in common. NULLs are ignored.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_has_any')
    def array_has_any(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``array_has_any``.

        Returns true if the lists have any element in common. NULLs are ignored.

        Overloads:
        - main.array_has_any(T[] list1, T[] list2) -> BOOLEAN
        """
        return call_duckdb_function(
            self._ARRAY_HAS_ANY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CAN_CAST_IMPLICITLY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='can_cast_implicitly',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('source_type', 'target_type'),
                        varargs=None,
                        description='Whether or not we can implicitly cast from the source type to the other type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('can_cast_implicitly')
    def can_cast_implicitly(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``can_cast_implicitly``.

        Whether or not we can implicitly cast from the source type to the other type

        Overloads:
        - main.can_cast_implicitly(ANY source_type, ANY target_type) -> BOOLEAN
        """
        return call_duckdb_function(
            self._CAN_CAST_IMPLICITLY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CONTAINS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'search_string'),
                        varargs=None,
                        description='Returns `true` if `search_string` is found within `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('MAP(K, V)'), parse_type('K')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('STRUCT'), parse_type('ANY')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('contains')
    def contains(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``contains``.

        Returns `true` if `search_string` is found within `string`.

        Overloads:
        - main.contains(VARCHAR string, VARCHAR search_string) -> BOOLEAN
        - main.contains(T[] col0, T col1) -> BOOLEAN
        - main.contains(MAP(K, V) col0, K col1) -> BOOLEAN
        - main.contains(STRUCT col0, ANY col1) -> BOOLEAN
        """
        return call_duckdb_function(
            self._CONTAINS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ENDS_WITH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ends_with',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'search_string'),
                        varargs=None,
                        description='Returns `true` if `string` ends with `search_string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('ends_with')
    def ends_with(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``ends_with``.

        Returns `true` if `string` ends with `search_string`.

        Overloads:
        - main.ends_with(VARCHAR string, VARCHAR search_string) -> BOOLEAN
        """
        return call_duckdb_function(
            self._ENDS_WITH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_ANY_COLUMN_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_any_column_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('table', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_any_column_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'table', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_any_column_privilege')
    def has_any_column_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_any_column_privilege``.

        Overloads:
        - pg_catalog.has_any_column_privilege(ANY table, ANY privilege) -> BOOLEAN
        - pg_catalog.has_any_column_privilege(ANY user, ANY table, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_ANY_COLUMN_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_COLUMN_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_column_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('table', 'column', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_column_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None, None),
                        parameters=('user', 'table', 'column', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_column_privilege')
    def has_column_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_column_privilege``.

        Overloads:
        - pg_catalog.has_column_privilege(ANY table, ANY column, ANY privilege) -> BOOLEAN
        - pg_catalog.has_column_privilege(ANY user, ANY table, ANY column, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_COLUMN_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_DATABASE_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_database_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('database', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_database_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'database', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_database_privilege')
    def has_database_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_database_privilege``.

        Overloads:
        - pg_catalog.has_database_privilege(ANY database, ANY privilege) -> BOOLEAN
        - pg_catalog.has_database_privilege(ANY user, ANY database, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_DATABASE_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_foreign_data_wrapper_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('fdw', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_foreign_data_wrapper_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'fdw', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_foreign_data_wrapper_privilege')
    def has_foreign_data_wrapper_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_foreign_data_wrapper_privilege``.

        Overloads:
        - pg_catalog.has_foreign_data_wrapper_privilege(ANY fdw, ANY privilege) -> BOOLEAN
        - pg_catalog.has_foreign_data_wrapper_privilege(ANY user, ANY fdw, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_FUNCTION_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_function_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('function', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_function_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'function', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_function_privilege')
    def has_function_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_function_privilege``.

        Overloads:
        - pg_catalog.has_function_privilege(ANY function, ANY privilege) -> BOOLEAN
        - pg_catalog.has_function_privilege(ANY user, ANY function, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_FUNCTION_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_LANGUAGE_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_language_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('language', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_language_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'language', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_language_privilege')
    def has_language_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_language_privilege``.

        Overloads:
        - pg_catalog.has_language_privilege(ANY language, ANY privilege) -> BOOLEAN
        - pg_catalog.has_language_privilege(ANY user, ANY language, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_LANGUAGE_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_SCHEMA_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_schema_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('schema', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_schema_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'schema', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_schema_privilege')
    def has_schema_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_schema_privilege``.

        Overloads:
        - pg_catalog.has_schema_privilege(ANY schema, ANY privilege) -> BOOLEAN
        - pg_catalog.has_schema_privilege(ANY user, ANY schema, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_SCHEMA_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_SEQUENCE_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_sequence_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('sequence', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_sequence_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'sequence', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_sequence_privilege')
    def has_sequence_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_sequence_privilege``.

        Overloads:
        - pg_catalog.has_sequence_privilege(ANY sequence, ANY privilege) -> BOOLEAN
        - pg_catalog.has_sequence_privilege(ANY user, ANY sequence, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_SEQUENCE_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_SERVER_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_server_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('server', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_server_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'server', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_server_privilege')
    def has_server_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_server_privilege``.

        Overloads:
        - pg_catalog.has_server_privilege(ANY server, ANY privilege) -> BOOLEAN
        - pg_catalog.has_server_privilege(ANY user, ANY server, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_SERVER_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_TABLE_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_table_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('table', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_table_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'table', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_table_privilege')
    def has_table_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_table_privilege``.

        Overloads:
        - pg_catalog.has_table_privilege(ANY table, ANY privilege) -> BOOLEAN
        - pg_catalog.has_table_privilege(ANY user, ANY table, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_TABLE_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAS_TABLESPACE_PRIVILEGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_tablespace_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('tablespace', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='has_tablespace_privilege',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'tablespace', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('has_tablespace_privilege')
    def has_tablespace_privilege(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``has_tablespace_privilege``.

        Overloads:
        - pg_catalog.has_tablespace_privilege(ANY tablespace, ANY privilege) -> BOOLEAN
        - pg_catalog.has_tablespace_privilege(ANY user, ANY tablespace, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._HAS_TABLESPACE_PRIVILEGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ILIKE_ESCAPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ilike_escape',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'like_specifier', 'escape_character'),
                        varargs=None,
                        description='Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('ilike_escape')
    def ilike_escape(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``ilike_escape``.

        Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.

        Overloads:
        - main.ilike_escape(VARCHAR string, VARCHAR like_specifier, VARCHAR escape_character) -> BOOLEAN
        """
        return call_duckdb_function(
            self._ILIKE_ESCAPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _IN_SEARCH_PATH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='in_search_path',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('database_name', 'schema_name'),
                        varargs=None,
                        description='Returns whether or not the database/schema are in the search path',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('in_search_path')
    def in_search_path(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``in_search_path``.

        Returns whether or not the database/schema are in the search path

        Overloads:
        - main.in_search_path(VARCHAR database_name, VARCHAR schema_name) -> BOOLEAN
        """
        return call_duckdb_function(
            self._IN_SEARCH_PATH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _IS_HISTOGRAM_OTHER_BIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='is_histogram_other_bin',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('val',),
                        varargs=None,
                        description='Whether or not the provided value is the histogram "other" bin (used for values not belonging to any provided bin)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('is_histogram_other_bin')
    def is_histogram_other_bin(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``is_histogram_other_bin``.

        Whether or not the provided value is the histogram "other" bin (used for values not belonging to any provided bin)

        Overloads:
        - main.is_histogram_other_bin(ANY val) -> BOOLEAN
        """
        return call_duckdb_function(
            self._IS_HISTOGRAM_OTHER_BIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ISFINITE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isfinite',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is finite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isfinite',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is finite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isfinite',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is finite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isfinite',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is finite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isfinite',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is finite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('isfinite')
    def isfinite(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``isfinite``.

        Returns true if the floating point value is finite, false otherwise

        Overloads:
        - main.isfinite(FLOAT x) -> BOOLEAN
        - main.isfinite(DOUBLE x) -> BOOLEAN
        - main.isfinite(DATE x) -> BOOLEAN
        - main.isfinite(TIMESTAMP x) -> BOOLEAN
        - main.isfinite(TIMESTAMP WITH TIME ZONE x) -> BOOLEAN
        """
        return call_duckdb_function(
            self._ISFINITE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ISINF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isinf',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is infinite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isinf',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is infinite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isinf',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is infinite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isinf',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is infinite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isinf',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is infinite, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('isinf')
    def isinf(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``isinf``.

        Returns true if the floating point value is infinite, false otherwise

        Overloads:
        - main.isinf(FLOAT x) -> BOOLEAN
        - main.isinf(DOUBLE x) -> BOOLEAN
        - main.isinf(DATE x) -> BOOLEAN
        - main.isinf(TIMESTAMP x) -> BOOLEAN
        - main.isinf(TIMESTAMP WITH TIME ZONE x) -> BOOLEAN
        """
        return call_duckdb_function(
            self._ISINF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ISNAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isnan',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is not a number, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isnan',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns true if the floating point value is not a number, false otherwise',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('isnan')
    def isnan(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``isnan``.

        Returns true if the floating point value is not a number, false otherwise

        Overloads:
        - main.isnan(FLOAT x) -> BOOLEAN
        - main.isnan(DOUBLE x) -> BOOLEAN
        """
        return call_duckdb_function(
            self._ISNAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_CONTAINS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('JSON')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('JSON'), parse_type('JSON')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_contains')
    def json_contains(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``json_contains``.

        Overloads:
        - main.json_contains(VARCHAR col0, VARCHAR col1) -> BOOLEAN
        - main.json_contains(VARCHAR col0, JSON col1) -> BOOLEAN
        - main.json_contains(JSON col0, VARCHAR col1) -> BOOLEAN
        - main.json_contains(JSON col0, JSON col1) -> BOOLEAN
        """
        return call_duckdb_function(
            self._JSON_CONTAINS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_EXISTS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_exists',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_exists',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_exists',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_exists',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_exists')
    def json_exists(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``json_exists``.

        Overloads:
        - main.json_exists(VARCHAR col0, VARCHAR col1) -> BOOLEAN
        - main.json_exists(VARCHAR col0, VARCHAR[] col1) -> BOOLEAN[]
        - main.json_exists(JSON col0, VARCHAR col1) -> BOOLEAN
        - main.json_exists(JSON col0, VARCHAR[] col1) -> BOOLEAN[]
        """
        return call_duckdb_function(
            self._JSON_EXISTS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_VALID_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_valid',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_valid',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('JSON'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_valid')
    def json_valid(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``json_valid``.

        Overloads:
        - main.json_valid(VARCHAR col0) -> BOOLEAN
        - main.json_valid(JSON col0) -> BOOLEAN
        """
        return call_duckdb_function(
            self._JSON_VALID_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIKE_ESCAPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='like_escape',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'like_specifier', 'escape_character'),
                        varargs=None,
                        description='Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('like_escape')
    def like_escape(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``like_escape``.

        Returns `true` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.

        Overloads:
        - main.like_escape(VARCHAR string, VARCHAR like_specifier, VARCHAR escape_character) -> BOOLEAN
        """
        return call_duckdb_function(
            self._LIKE_ESCAPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_CONTAINS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T')),
                        parameters=('list', 'element'),
                        varargs=None,
                        description='Returns true if the list contains the element.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_contains')
    def list_contains(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``list_contains``.

        Returns true if the list contains the element.

        Overloads:
        - main.list_contains(T[] list, T element) -> BOOLEAN
        """
        return call_duckdb_function(
            self._LIST_CONTAINS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_HAS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_has',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T')),
                        parameters=('list', 'element'),
                        varargs=None,
                        description='Returns true if the list contains the element.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_has')
    def list_has(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``list_has``.

        Returns true if the list contains the element.

        Overloads:
        - main.list_has(T[] list, T element) -> BOOLEAN
        """
        return call_duckdb_function(
            self._LIST_HAS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_HAS_ALL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_has_all',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Returns true if all elements of list2 are in list1. NULLs are ignored.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_has_all')
    def list_has_all(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``list_has_all``.

        Returns true if all elements of list2 are in list1. NULLs are ignored.

        Overloads:
        - main.list_has_all(T[] list1, T[] list2) -> BOOLEAN
        """
        return call_duckdb_function(
            self._LIST_HAS_ALL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_HAS_ANY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_has_any',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Returns true if the lists have any element in common. NULLs are ignored.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_has_any')
    def list_has_any(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``list_has_any``.

        Returns true if the lists have any element in common. NULLs are ignored.

        Overloads:
        - main.list_has_any(T[] list1, T[] list2) -> BOOLEAN
        """
        return call_duckdb_function(
            self._LIST_HAS_ANY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_CONTAINS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('MAP(K, V)'), parse_type('K')),
                        parameters=('map', 'key'),
                        varargs=None,
                        description='Checks if a map contains a given key.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('map_contains')
    def map_contains(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``map_contains``.

        Checks if a map contains a given key.

        Overloads:
        - main.map_contains(MAP(K, V) map, K key) -> BOOLEAN
        """
        return call_duckdb_function(
            self._MAP_CONTAINS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_CONTAINS_ENTRY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_contains_entry',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('map', 'key', 'value'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='contains(map_entries("map"), main.struct_pack("key" := "key", "value" := "value"))',
                    ),
    )
    @duckdb_function('map_contains_entry')
    def map_contains_entry(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``map_contains_entry``.

        Overloads:
        - main.map_contains_entry(ANY map, ANY key, ANY value) -> BOOLEAN
        """
        return call_duckdb_function(
            self._MAP_CONTAINS_ENTRY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_CONTAINS_VALUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_contains_value',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('map', 'value'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='contains(map_values("map"), "value")',
                    ),
    )
    @duckdb_function('map_contains_value')
    def map_contains_value(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``map_contains_value``.

        Overloads:
        - main.map_contains_value(ANY map, ANY value) -> BOOLEAN
        """
        return call_duckdb_function(
            self._MAP_CONTAINS_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _NOT_ILIKE_ESCAPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='not_ilike_escape',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'like_specifier', 'escape_character'),
                        varargs=None,
                        description='Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('not_ilike_escape')
    def not_ilike_escape(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``not_ilike_escape``.

        Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-insensitive matching. `escape_character` is used to search for wildcard characters in the `string`.

        Overloads:
        - main.not_ilike_escape(VARCHAR string, VARCHAR like_specifier, VARCHAR escape_character) -> BOOLEAN
        """
        return call_duckdb_function(
            self._NOT_ILIKE_ESCAPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _NOT_LIKE_ESCAPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='not_like_escape',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'like_specifier', 'escape_character'),
                        varargs=None,
                        description='Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('not_like_escape')
    def not_like_escape(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``not_like_escape``.

        Returns `false` if the `string` matches the `like_specifier` (see Pattern Matching) using case-sensitive matching. `escape_character` is used to search for wildcard characters in the `string`.

        Overloads:
        - main.not_like_escape(VARCHAR string, VARCHAR like_specifier, VARCHAR escape_character) -> BOOLEAN
        """
        return call_duckdb_function(
            self._NOT_LIKE_ESCAPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_COLLATION_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_collation_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('collation_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_collation_is_visible')
    def pg_collation_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_collation_is_visible``.

        Overloads:
        - pg_catalog.pg_collation_is_visible(ANY collation_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_COLLATION_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_CONVERSION_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_conversion_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('conversion_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_conversion_is_visible')
    def pg_conversion_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_conversion_is_visible``.

        Overloads:
        - pg_catalog.pg_conversion_is_visible(ANY conversion_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_CONVERSION_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_FUNCTION_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_function_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('function_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_function_is_visible')
    def pg_function_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_function_is_visible``.

        Overloads:
        - pg_catalog.pg_function_is_visible(ANY function_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_FUNCTION_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_HAS_ROLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_has_role',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None),
                        parameters=('role', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_has_role',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None, None, None),
                        parameters=('user', 'role', 'privilege'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_has_role')
    def pg_has_role(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_has_role``.

        Overloads:
        - pg_catalog.pg_has_role(ANY role, ANY privilege) -> BOOLEAN
        - pg_catalog.pg_has_role(ANY user, ANY role, ANY privilege) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_HAS_ROLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_IS_OTHER_TEMP_SCHEMA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_is_other_temp_schema',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('schema_id',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('f' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_is_other_temp_schema')
    def pg_is_other_temp_schema(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_is_other_temp_schema``.

        Overloads:
        - pg_catalog.pg_is_other_temp_schema(ANY schema_id) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_IS_OTHER_TEMP_SCHEMA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_OPCLASS_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_opclass_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('opclass_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_opclass_is_visible')
    def pg_opclass_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_opclass_is_visible``.

        Overloads:
        - pg_catalog.pg_opclass_is_visible(ANY opclass_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_OPCLASS_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_OPERATOR_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_operator_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('operator_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_operator_is_visible')
    def pg_operator_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_operator_is_visible``.

        Overloads:
        - pg_catalog.pg_operator_is_visible(ANY operator_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_OPERATOR_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_OPFAMILY_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_opfamily_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('opclass_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_opfamily_is_visible')
    def pg_opfamily_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_opfamily_is_visible``.

        Overloads:
        - pg_catalog.pg_opfamily_is_visible(ANY opclass_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_OPFAMILY_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_TABLE_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_table_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('table_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_table_is_visible')
    def pg_table_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_table_is_visible``.

        Overloads:
        - pg_catalog.pg_table_is_visible(ANY table_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_TABLE_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_TS_CONFIG_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_ts_config_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('config_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_ts_config_is_visible')
    def pg_ts_config_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_ts_config_is_visible``.

        Overloads:
        - pg_catalog.pg_ts_config_is_visible(ANY config_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_TS_CONFIG_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_TS_DICT_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_ts_dict_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('dict_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_ts_dict_is_visible')
    def pg_ts_dict_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_ts_dict_is_visible``.

        Overloads:
        - pg_catalog.pg_ts_dict_is_visible(ANY dict_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_TS_DICT_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_TS_PARSER_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_ts_parser_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('parser_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_ts_parser_is_visible')
    def pg_ts_parser_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_ts_parser_is_visible``.

        Overloads:
        - pg_catalog.pg_ts_parser_is_visible(ANY parser_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_TS_PARSER_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_TS_TEMPLATE_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_ts_template_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('template_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_ts_template_is_visible')
    def pg_ts_template_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_ts_template_is_visible``.

        Overloads:
        - pg_catalog.pg_ts_template_is_visible(ANY template_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_TS_TEMPLATE_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_TYPE_IS_VISIBLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_type_is_visible',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(None,),
                        parameters=('type_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CAST('t' AS BOOLEAN)",
                    ),
    )
    @duckdb_function('pg_type_is_visible')
    def pg_type_is_visible(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``pg_type_is_visible``.

        Overloads:
        - pg_catalog.pg_type_is_visible(ANY type_oid) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PG_TYPE_IS_VISIBLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PREFIX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='prefix',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'search_string'),
                        varargs=None,
                        description='Returns `true` if `string` starts with `search_string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('prefix')
    def prefix(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``prefix``.

        Returns `true` if `string` starts with `search_string`.

        Overloads:
        - main.prefix(VARCHAR string, VARCHAR search_string) -> BOOLEAN
        """
        return call_duckdb_function(
            self._PREFIX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REGEXP_FULL_MATCH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_full_match',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex'),
                        varargs=None,
                        description='Returns `true` if the entire `string` matches the `regex`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_full_match',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'col2'),
                        varargs=None,
                        description='Returns `true` if the entire `string` matches the `regex`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regexp_full_match')
    def regexp_full_match(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``regexp_full_match``.

        Returns `true` if the entire `string` matches the `regex`. A set of optional regex `options` can be set.

        Overloads:
        - main.regexp_full_match(VARCHAR string, VARCHAR regex) -> BOOLEAN
        - main.regexp_full_match(VARCHAR string, VARCHAR regex, VARCHAR col2) -> BOOLEAN
        """
        return call_duckdb_function(
            self._REGEXP_FULL_MATCH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REGEXP_MATCHES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_matches',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex'),
                        varargs=None,
                        description='Returns `true` if `string` contains the `regex`, `false` otherwise. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_matches',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'options'),
                        varargs=None,
                        description='Returns `true` if `string` contains the `regex`, `false` otherwise. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regexp_matches')
    def regexp_matches(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``regexp_matches``.

        Returns `true` if `string` contains the `regex`, `false` otherwise. A set of optional regex `options` can be set.

        Overloads:
        - main.regexp_matches(VARCHAR string, VARCHAR regex) -> BOOLEAN
        - main.regexp_matches(VARCHAR string, VARCHAR regex, VARCHAR options) -> BOOLEAN
        """
        return call_duckdb_function(
            self._REGEXP_MATCHES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SIGNBIT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='signbit',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns whether the signbit is set or not',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='signbit',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns whether the signbit is set or not',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('signbit')
    def signbit(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``signbit``.

        Returns whether the signbit is set or not

        Overloads:
        - main.signbit(FLOAT x) -> BOOLEAN
        - main.signbit(DOUBLE x) -> BOOLEAN
        """
        return call_duckdb_function(
            self._SIGNBIT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STARTS_WITH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='starts_with',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'search_string'),
                        varargs=None,
                        description='Returns `true` if `string` begins with `search_string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('starts_with')
    def starts_with(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``starts_with``.

        Returns `true` if `string` begins with `search_string`.

        Overloads:
        - main.starts_with(VARCHAR string, VARCHAR search_string) -> BOOLEAN
        """
        return call_duckdb_function(
            self._STARTS_WITH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_CONTAINS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_contains',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('STRUCT'), parse_type('ANY')),
                        parameters=('struct', "'entry'"),
                        varargs=None,
                        description='Check if an unnamed STRUCT contains the value.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_contains')
    def struct_contains(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``struct_contains``.

        Check if an unnamed STRUCT contains the value.

        Overloads:
        - main.struct_contains(STRUCT struct, ANY 'entry') -> BOOLEAN
        """
        return call_duckdb_function(
            self._STRUCT_CONTAINS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_HAS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_has',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('STRUCT'), parse_type('ANY')),
                        parameters=('struct', "'entry'"),
                        varargs=None,
                        description='Check if an unnamed STRUCT contains the value.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_has')
    def struct_has(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``struct_has``.

        Check if an unnamed STRUCT contains the value.

        Overloads:
        - main.struct_has(STRUCT struct, ANY 'entry') -> BOOLEAN
        """
        return call_duckdb_function(
            self._STRUCT_HAS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SUFFIX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='suffix',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'search_string'),
                        varargs=None,
                        description='Returns `true` if `string` ends with `search_string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('suffix')
    def suffix(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``suffix``.

        Returns `true` if `string` ends with `search_string`.

        Overloads:
        - main.suffix(VARCHAR string, VARCHAR search_string) -> BOOLEAN
        """
        return call_duckdb_function(
            self._SUFFIX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0021_007e_007e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='!~~',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('!~~',))
    def symbol_0021_007e_007e(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``!~~``.

        Overloads:
        - main.!~~(VARCHAR col0, VARCHAR col1) -> BOOLEAN
        """
        return call_duckdb_function(
            self._0021_007e_007e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0021_007e_007e_002a_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='!~~*',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('!~~*',))
    def symbol_0021_007e_007e_002a(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``!~~*``.

        Overloads:
        - main.!~~*(VARCHAR col0, VARCHAR col1) -> BOOLEAN
        """
        return call_duckdb_function(
            self._0021_007e_007e_002a_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0026_0026_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&&',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Returns true if the lists have any element in common. NULLs are ignored.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('&&',))
    def symbol_0026_0026(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``&&``.

        Returns true if the lists have any element in common. NULLs are ignored.

        Overloads:
        - main.&&(T[] list1, T[] list2) -> BOOLEAN
        """
        return call_duckdb_function(
            self._0026_0026_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _003c_0040_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<@',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Returns true if all elements of list2 are in list1. NULLs are ignored.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('<@',))
    def symbol_003c_0040(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``<@``.

        Returns true if all elements of list2 are in list1. NULLs are ignored.

        Overloads:
        - main.<@(T[] list1, T[] list2) -> BOOLEAN
        """
        return call_duckdb_function(
            self._003c_0040_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0040_003e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@>',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('T[]'), parse_type('T[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Returns true if all elements of list2 are in list1. NULLs are ignored.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('@>',))
    def symbol_0040_003e(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``@>``.

        Returns true if all elements of list2 are in list1. NULLs are ignored.

        Overloads:
        - main.@>(T[] list1, T[] list2) -> BOOLEAN
        """
        return call_duckdb_function(
            self._0040_003e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _005e_0040_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='^@',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'search_string'),
                        varargs=None,
                        description='Returns `true` if `string` begins with `search_string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('^@',))
    def symbol_005e_0040(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``^@``.

        Returns `true` if `string` begins with `search_string`.

        Overloads:
        - main.^@(VARCHAR string, VARCHAR search_string) -> BOOLEAN
        """
        return call_duckdb_function(
            self._005e_0040_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _007e_007e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~~',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('~~',))
    def symbol_007e_007e(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``~~``.

        Overloads:
        - main.~~(VARCHAR col0, VARCHAR col1) -> BOOLEAN
        """
        return call_duckdb_function(
            self._007e_007e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _007e_007e_002a_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~~*',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('~~*',))
    def symbol_007e_007e_002a(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``~~*``.

        Overloads:
        - main.~~*(VARCHAR col0, VARCHAR col1) -> BOOLEAN
        """
        return call_duckdb_function(
            self._007e_007e_002a_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _007e_007e_007e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~~~',
                        function_type=function_type,
                        return_type=parse_type('BOOLEAN'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('~~~',))
    def symbol_007e_007e_007e(self, *operands: object) -> BooleanExpression:
        """Call DuckDB function ``~~~``.

        Overloads:
        - main.~~~(VARCHAR col0, VARCHAR col1) -> BOOLEAN
        """
        return call_duckdb_function(
            self._007e_007e_007e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        'array_contains': 'array_contains',
        'array_has': 'array_has',
        'array_has_all': 'array_has_all',
        'array_has_any': 'array_has_any',
        'can_cast_implicitly': 'can_cast_implicitly',
        'contains': 'contains',
        'ends_with': 'ends_with',
        'has_any_column_privilege': 'has_any_column_privilege',
        'has_column_privilege': 'has_column_privilege',
        'has_database_privilege': 'has_database_privilege',
        'has_foreign_data_wrapper_privilege': 'has_foreign_data_wrapper_privilege',
        'has_function_privilege': 'has_function_privilege',
        'has_language_privilege': 'has_language_privilege',
        'has_schema_privilege': 'has_schema_privilege',
        'has_sequence_privilege': 'has_sequence_privilege',
        'has_server_privilege': 'has_server_privilege',
        'has_table_privilege': 'has_table_privilege',
        'has_tablespace_privilege': 'has_tablespace_privilege',
        'ilike_escape': 'ilike_escape',
        'in_search_path': 'in_search_path',
        'is_histogram_other_bin': 'is_histogram_other_bin',
        'isfinite': 'isfinite',
        'isinf': 'isinf',
        'isnan': 'isnan',
        'json_contains': 'json_contains',
        'json_exists': 'json_exists',
        'json_valid': 'json_valid',
        'like_escape': 'like_escape',
        'list_contains': 'list_contains',
        'list_has': 'list_has',
        'list_has_all': 'list_has_all',
        'list_has_any': 'list_has_any',
        'map_contains': 'map_contains',
        'map_contains_entry': 'map_contains_entry',
        'map_contains_value': 'map_contains_value',
        'not_ilike_escape': 'not_ilike_escape',
        'not_like_escape': 'not_like_escape',
        'pg_collation_is_visible': 'pg_collation_is_visible',
        'pg_conversion_is_visible': 'pg_conversion_is_visible',
        'pg_function_is_visible': 'pg_function_is_visible',
        'pg_has_role': 'pg_has_role',
        'pg_is_other_temp_schema': 'pg_is_other_temp_schema',
        'pg_opclass_is_visible': 'pg_opclass_is_visible',
        'pg_operator_is_visible': 'pg_operator_is_visible',
        'pg_opfamily_is_visible': 'pg_opfamily_is_visible',
        'pg_table_is_visible': 'pg_table_is_visible',
        'pg_ts_config_is_visible': 'pg_ts_config_is_visible',
        'pg_ts_dict_is_visible': 'pg_ts_dict_is_visible',
        'pg_ts_parser_is_visible': 'pg_ts_parser_is_visible',
        'pg_ts_template_is_visible': 'pg_ts_template_is_visible',
        'pg_type_is_visible': 'pg_type_is_visible',
        'prefix': 'prefix',
        'regexp_full_match': 'regexp_full_match',
        'regexp_matches': 'regexp_matches',
        'signbit': 'signbit',
        'starts_with': 'starts_with',
        'struct_contains': 'struct_contains',
        'struct_has': 'struct_has',
        'suffix': 'suffix',
    }

    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {
        '!~~': 'symbol_0021_007e_007e',
        '!~~*': 'symbol_0021_007e_007e_002a',
        '&&': 'symbol_0026_0026',
        '<@': 'symbol_003c_0040',
        '@>': 'symbol_0040_003e',
        '^@': 'symbol_005e_0040',
        '~~': 'symbol_007e_007e',
        '~~*': 'symbol_007e_007e_002a',
        '~~~': 'symbol_007e_007e_007e',
    }

class ScalarGenericFunctions(_StaticFunctionNamespace):
    """DuckDB scalar functions returning generic results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'scalar'
    return_category: ClassVar[str] = 'generic'
    ___INTERNAL_COMPRESS_STRING_UHUGEINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_string_uhugeint',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_string_uhugeint')
    def __internal_compress_string_uhugeint(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``__internal_compress_string_uhugeint``.

        Overloads:
        - main.__internal_compress_string_uhugeint(VARCHAR col0) -> UHUGEINT
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_STRING_UHUGEINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_DECOMPRESS_INTEGRAL_UHUGEINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_uhugeint',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_uhugeint',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_uhugeint',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_uhugeint',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_decompress_integral_uhugeint')
    def __internal_decompress_integral_uhugeint(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``__internal_decompress_integral_uhugeint``.

        Overloads:
        - main.__internal_decompress_integral_uhugeint(UTINYINT col0, UHUGEINT col1) -> UHUGEINT
        - main.__internal_decompress_integral_uhugeint(USMALLINT col0, UHUGEINT col1) -> UHUGEINT
        - main.__internal_decompress_integral_uhugeint(UINTEGER col0, UHUGEINT col1) -> UHUGEINT
        - main.__internal_decompress_integral_uhugeint(UBIGINT col0, UHUGEINT col1) -> UHUGEINT
        """
        return call_duckdb_function(
            self.___INTERNAL_DECOMPRESS_INTEGRAL_UHUGEINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ABS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('abs')
    def abs(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``abs``.

        Absolute value

        Overloads:
        - main.abs(UHUGEINT x) -> UHUGEINT
        """
        return call_duckdb_function(
            self._ABS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ADD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY[]'),
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('DATE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('TIME'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIME')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIME'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('DATE'), parse_type('TIME')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('BIGNUM'),
                        parameter_types=(parse_type('BIGNUM'), parse_type('BIGNUM')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('add')
    def add(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``add``.

        Overloads:
        - main.add(ANY[] ...) -> ANY[]
        - main.add(UHUGEINT col0) -> UHUGEINT
        - main.add(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        - main.add(DATE col0, INTEGER col1) -> DATE
        - main.add(INTEGER col0, DATE col1) -> DATE
        - main.add(DATE col0, INTERVAL col1) -> TIMESTAMP
        - main.add(INTERVAL col0, DATE col1) -> TIMESTAMP
        - main.add(TIME col0, INTERVAL col1) -> TIME
        - main.add(INTERVAL col0, TIME col1) -> TIME
        - main.add(TIMESTAMP col0, INTERVAL col1) -> TIMESTAMP
        - main.add(INTERVAL col0, TIMESTAMP col1) -> TIMESTAMP
        - main.add(TIME WITH TIME ZONE col0, INTERVAL col1) -> TIME WITH TIME ZONE
        - main.add(INTERVAL col0, TIME WITH TIME ZONE col1) -> TIME WITH TIME ZONE
        - main.add(TIME col0, DATE col1) -> TIMESTAMP
        - main.add(DATE col0, TIME col1) -> TIMESTAMP
        - main.add(TIME WITH TIME ZONE col0, DATE col1) -> TIMESTAMP WITH TIME ZONE
        - main.add(DATE col0, TIME WITH TIME ZONE col1) -> TIMESTAMP WITH TIME ZONE
        - main.add(BIGNUM col0, BIGNUM col1) -> BIGNUM
        """
        return call_duckdb_function(
            self._ADD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _AGGREGATE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='aggregate',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'function_name'),
                        varargs=parse_type('ANY'),
                        description='Executes the aggregate function `function_name` on the elements of `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('aggregate')
    def aggregate(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``aggregate``.

        Executes the aggregate function `function_name` on the elements of `list`.

        Overloads:
        - main.aggregate(ANY[] list, VARCHAR function_name, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._AGGREGATE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _APPLY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='apply',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x)'),
                        varargs=None,
                        description='Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('apply')
    def apply(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``apply``.

        Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.

        Overloads:
        - main.apply(ANY[] list, LAMBDA lambda(x)) -> ANY[]
        """
        return call_duckdb_function(
            self._APPLY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_AGGR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_aggr',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'function_name'),
                        varargs=parse_type('ANY'),
                        description='Executes the aggregate function `function_name` on the elements of `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_aggr')
    def array_aggr(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_aggr``.

        Executes the aggregate function `function_name` on the elements of `list`.

        Overloads:
        - main.array_aggr(ANY[] list, VARCHAR function_name, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._ARRAY_AGGR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_AGGREGATE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_aggregate',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'function_name'),
                        varargs=parse_type('ANY'),
                        description='Executes the aggregate function `function_name` on the elements of `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_aggregate')
    def array_aggregate(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_aggregate``.

        Executes the aggregate function `function_name` on the elements of `list`.

        Overloads:
        - main.array_aggregate(ANY[] list, VARCHAR function_name, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._ARRAY_AGGREGATE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_APPEND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_append',
                        function_type=function_type,
                        return_type=parse_type('"NULL"[]'),
                        parameter_types=(None, None),
                        parameters=('arr', 'el'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='list_append(arr, el)',
                    ),
    )
    @duckdb_function('array_append')
    def array_append(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_append``.

        Overloads:
        - main.array_append(ANY arr, ANY el) -> "NULL"[]
        """
        return call_duckdb_function(
            self._ARRAY_APPEND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_APPLY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_apply',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x)'),
                        varargs=None,
                        description='Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_apply')
    def array_apply(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_apply``.

        Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.

        Overloads:
        - main.array_apply(ANY[] list, LAMBDA lambda(x)) -> ANY[]
        """
        return call_duckdb_function(
            self._ARRAY_APPLY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_CAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_cat',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY[]'),
                        description='Concatenates lists. `NULL` inputs are skipped. See also operator `||`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_cat')
    def array_cat(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_cat``.

        Concatenates lists. `NULL` inputs are skipped. See also operator `||`.

        Overloads:
        - main.array_cat(ANY[] ...) -> ANY[]
        """
        return call_duckdb_function(
            self._ARRAY_CAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_CONCAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_concat',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY[]'),
                        description='Concatenates lists. `NULL` inputs are skipped. See also operator `||`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_concat')
    def array_concat(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_concat``.

        Concatenates lists. `NULL` inputs are skipped. See also operator `||`.

        Overloads:
        - main.array_concat(ANY[] ...) -> ANY[]
        """
        return call_duckdb_function(
            self._ARRAY_CONCAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_DISTINCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_distinct',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Removes all duplicates and `NULL` values from a list. Does not preserve the original order.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_distinct')
    def array_distinct(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_distinct``.

        Removes all duplicates and `NULL` values from a list. Does not preserve the original order.

        Overloads:
        - main.array_distinct(T[] list) -> T[]
        """
        return call_duckdb_function(
            self._ARRAY_DISTINCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_extract',
                        function_type=function_type,
                        return_type=parse_type('T'),
                        parameter_types=(parse_type('T[]'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_extract',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('STRUCT'), parse_type('VARCHAR')),
                        parameters=('struct', 'entry'),
                        varargs=None,
                        description='Extracts the named `entry` from the `STRUCT`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_extract',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('STRUCT'), parse_type('BIGINT')),
                        parameters=('struct', 'index'),
                        varargs=None,
                        description='Extracts the entry from an unnamed `STRUCT` (tuple) using an index (1-based).',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_extract')
    def array_extract(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_extract``.

        Extracts the named `entry` from the `STRUCT`.

        Overloads:
        - main.array_extract(T[] col0, BIGINT col1) -> T
        - main.array_extract(STRUCT struct, VARCHAR entry) -> ANY
        - main.array_extract(STRUCT struct, BIGINT index) -> ANY
        """
        return call_duckdb_function(
            self._ARRAY_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_FILTER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_filter',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x)'),
                        varargs=None,
                        description="Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.",
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_filter')
    def array_filter(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_filter``.

        Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.

        Overloads:
        - main.array_filter(ANY[] list, LAMBDA lambda(x)) -> ANY[]
        """
        return call_duckdb_function(
            self._ARRAY_FILTER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_GRADE_UP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_grade_up',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_grade_up',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'col1'),
                        varargs=None,
                        description='Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_grade_up',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('list', 'col1', 'col2'),
                        varargs=None,
                        description='Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_grade_up')
    def array_grade_up(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_grade_up``.

        Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.

        Overloads:
        - main.array_grade_up(ANY[] list) -> ANY[]
        - main.array_grade_up(ANY[] list, VARCHAR col1) -> ANY[]
        - main.array_grade_up(ANY[] list, VARCHAR col1, VARCHAR col2) -> ANY[]
        """
        return call_duckdb_function(
            self._ARRAY_GRADE_UP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_INTERSECT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_intersect',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None, None),
                        parameters=('l1', 'l2'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='list_intersect(l1, l2)',
                    ),
    )
    @duckdb_function('array_intersect')
    def array_intersect(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_intersect``.

        Overloads:
        - main.array_intersect(ANY l1, ANY l2) -> "NULL"
        """
        return call_duckdb_function(
            self._ARRAY_INTERSECT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_POP_BACK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_pop_back',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('arr',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='arr[:(len(arr) - 1)]',
                    ),
    )
    @duckdb_function('array_pop_back')
    def array_pop_back(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_pop_back``.

        Overloads:
        - main.array_pop_back(ANY arr) -> "NULL"
        """
        return call_duckdb_function(
            self._ARRAY_POP_BACK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_POP_FRONT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_pop_front',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('arr',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='arr[2:]',
                    ),
    )
    @duckdb_function('array_pop_front')
    def array_pop_front(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_pop_front``.

        Overloads:
        - main.array_pop_front(ANY arr) -> "NULL"
        """
        return call_duckdb_function(
            self._ARRAY_POP_FRONT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_PREPEND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_prepend',
                        function_type=function_type,
                        return_type=parse_type('"NULL"[]'),
                        parameter_types=(None, None),
                        parameters=('el', 'arr'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='list_prepend(el, arr)',
                    ),
    )
    @duckdb_function('array_prepend')
    def array_prepend(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_prepend``.

        Overloads:
        - main.array_prepend(ANY el, ANY arr) -> "NULL"[]
        """
        return call_duckdb_function(
            self._ARRAY_PREPEND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_PUSH_BACK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_push_back',
                        function_type=function_type,
                        return_type=parse_type('"NULL"[]'),
                        parameter_types=(None, None),
                        parameters=('arr', 'e'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='list_concat(arr, list_value(e))',
                    ),
    )
    @duckdb_function('array_push_back')
    def array_push_back(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_push_back``.

        Overloads:
        - main.array_push_back(ANY arr, ANY e) -> "NULL"[]
        """
        return call_duckdb_function(
            self._ARRAY_PUSH_BACK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_PUSH_FRONT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_push_front',
                        function_type=function_type,
                        return_type=parse_type('"NULL"[]'),
                        parameter_types=(None, None),
                        parameters=('arr', 'e'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='list_concat(list_value(e), arr)',
                    ),
    )
    @duckdb_function('array_push_front')
    def array_push_front(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_push_front``.

        Overloads:
        - main.array_push_front(ANY arr, ANY e) -> "NULL"[]
        """
        return call_duckdb_function(
            self._ARRAY_PUSH_FRONT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_REDUCE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_reduce',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x,y)'),
                        varargs=None,
                        description='Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_reduce',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA'), parse_type('ANY')),
                        parameters=('list', 'lambda(x,y)', 'initial_value'),
                        varargs=None,
                        description='Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_reduce')
    def array_reduce(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_reduce``.

        Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.

        Overloads:
        - main.array_reduce(ANY[] list, LAMBDA lambda(x,y)) -> ANY
        - main.array_reduce(ANY[] list, LAMBDA lambda(x,y), ANY initial_value) -> ANY
        """
        return call_duckdb_function(
            self._ARRAY_REDUCE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_RESIZE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_resize',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('ANY')),
                        parameters=('list', 'size['),
                        varargs=None,
                        description='Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_resize',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('ANY'), parse_type('ANY')),
                        parameters=('list', 'size[', 'value]'),
                        varargs=None,
                        description='Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_resize')
    def array_resize(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_resize``.

        Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.

        Overloads:
        - main.array_resize(ANY[] list, ANY size[) -> ANY[]
        - main.array_resize(ANY[] list, ANY size[, ANY value]) -> ANY[]
        """
        return call_duckdb_function(
            self._ARRAY_RESIZE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_REVERSE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_reverse',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='list_reverse(l)',
                    ),
    )
    @duckdb_function('array_reverse')
    def array_reverse(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_reverse``.

        Overloads:
        - main.array_reverse(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._ARRAY_REVERSE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_REVERSE_SORT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_reverse_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Sorts the elements of the list in reverse order.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_reverse_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'col1'),
                        varargs=None,
                        description='Sorts the elements of the list in reverse order.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_reverse_sort')
    def array_reverse_sort(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_reverse_sort``.

        Sorts the elements of the list in reverse order.

        Overloads:
        - main.array_reverse_sort(ANY[] list) -> ANY[]
        - main.array_reverse_sort(ANY[] list, VARCHAR col1) -> ANY[]
        """
        return call_duckdb_function(
            self._ARRAY_REVERSE_SORT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_SELECT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_select',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T[]'), parse_type('BIGINT[]')),
                        parameters=('value_list', 'index_list'),
                        varargs=None,
                        description='Returns a list based on the elements selected by the `index_list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_select')
    def array_select(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_select``.

        Returns a list based on the elements selected by the `index_list`.

        Overloads:
        - main.array_select(T[] value_list, BIGINT[] index_list) -> T[]
        """
        return call_duckdb_function(
            self._ARRAY_SELECT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_SLICE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_slice',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('ANY')),
                        parameters=('list', 'begin', 'end'),
                        varargs=None,
                        description='Extracts a sublist or substring using slice conventions. Negative values are accepted.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_slice',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('list', 'begin', 'end', 'step'),
                        varargs=None,
                        description='list_slice with added step feature.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_slice')
    def array_slice(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_slice``.

        Extracts a sublist or substring using slice conventions. Negative values are accepted.

        Overloads:
        - main.array_slice(ANY list, ANY begin, ANY end) -> ANY
        - main.array_slice(ANY list, ANY begin, ANY end, BIGINT step) -> ANY
        """
        return call_duckdb_function(
            self._ARRAY_SLICE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_SORT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Sorts the elements of the list.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'col1'),
                        varargs=None,
                        description='Sorts the elements of the list.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('list', 'col1', 'col2'),
                        varargs=None,
                        description='Sorts the elements of the list.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_sort')
    def array_sort(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_sort``.

        Sorts the elements of the list.

        Overloads:
        - main.array_sort(ANY[] list) -> ANY[]
        - main.array_sort(ANY[] list, VARCHAR col1) -> ANY[]
        - main.array_sort(ANY[] list, VARCHAR col1, VARCHAR col2) -> ANY[]
        """
        return call_duckdb_function(
            self._ARRAY_SORT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_TRANSFORM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_transform',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x)'),
                        varargs=None,
                        description='Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_transform')
    def array_transform(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_transform``.

        Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.

        Overloads:
        - main.array_transform(ANY[] list, LAMBDA lambda(x)) -> ANY[]
        """
        return call_duckdb_function(
            self._ARRAY_TRANSFORM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_VALUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_value',
                        function_type=function_type,
                        return_type=parse_type('ARRAY'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Creates an `ARRAY` containing the argument values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_value')
    def array_value(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_value``.

        Creates an `ARRAY` containing the argument values.

        Overloads:
        - main.array_value(ANY ...) -> ARRAY
        """
        return call_duckdb_function(
            self._ARRAY_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_WHERE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_where',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T[]'), parse_type('BOOLEAN[]')),
                        parameters=('value_list', 'mask_list'),
                        varargs=None,
                        description='Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_where')
    def array_where(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_where``.

        Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.

        Overloads:
        - main.array_where(T[] value_list, BOOLEAN[] mask_list) -> T[]
        """
        return call_duckdb_function(
            self._ARRAY_WHERE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_ZIP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_zip',
                        function_type=function_type,
                        return_type=parse_type('STRUCT[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Zips n `LIST`s to a new `LIST` whose length will be that of the longest list. Its elements are structs of n elements from each list `list_1`, , `list_n`, missing elements are replaced with `NULL`. If `truncate` is set, all lists are truncated to the smallest list length.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_zip')
    def array_zip(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``array_zip``.

        Zips n `LIST`s to a new `LIST` whose length will be that of the longest list. Its elements are structs of n elements from each list `list_1`, , `list_n`, missing elements are replaced with `NULL`. If `truncate` is set, all lists are truncated to the smallest list length.

        Overloads:
        - main.array_zip(ANY ...) -> STRUCT[]
        """
        return call_duckdb_function(
            self._ARRAY_ZIP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _BITSTRING_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('bitstring', 'length'),
                        varargs=None,
                        description='Pads the bitstring until the specified length',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bitstring',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'), parse_type('INTEGER')),
                        parameters=('bitstring', 'length'),
                        varargs=None,
                        description='Pads the bitstring until the specified length',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bitstring')
    def bitstring(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``bitstring``.

        Pads the bitstring until the specified length

        Overloads:
        - main.bitstring(VARCHAR bitstring, INTEGER length) -> BIT
        - main.bitstring(BIT bitstring, INTEGER length) -> BIT
        """
        return call_duckdb_function(
            self._BITSTRING_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CAST_TO_TYPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='cast_to_type',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('param', 'type'),
                        varargs=None,
                        description='Casts the first argument to the type of the second argument',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('cast_to_type')
    def cast_to_type(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``cast_to_type``.

        Casts the first argument to the type of the second argument

        Overloads:
        - main.cast_to_type(ANY param, ANY type) -> ANY
        """
        return call_duckdb_function(
            self._CAST_TO_TYPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _COL_DESCRIPTION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='col_description',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None, None),
                        parameters=('table_oid', 'column_number'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='NULL',
                    ),
    )
    @duckdb_function('col_description')
    def col_description(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``col_description``.

        Overloads:
        - pg_catalog.col_description(ANY table_oid, ANY column_number) -> "NULL"
        """
        return call_duckdb_function(
            self._COL_DESCRIPTION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _COMBINE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='combine',
                        function_type=function_type,
                        return_type=parse_type('AGGREGATE_STATE<?>'),
                        parameter_types=(parse_type('AGGREGATE_STATE<?>'), parse_type('ANY')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('combine')
    def combine(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``combine``.

        Overloads:
        - main.combine(AGGREGATE_STATE<?> col0, ANY col1) -> AGGREGATE_STATE<?>
        """
        return call_duckdb_function(
            self._COMBINE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CONCAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='concat',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('value',),
                        varargs=parse_type('ANY'),
                        description='Concatenates multiple strings or lists. `NULL` inputs are skipped. See also operator `||`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('concat')
    def concat(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``concat``.

        Concatenates multiple strings or lists. `NULL` inputs are skipped. See also operator `||`.

        Overloads:
        - main.concat(ANY value, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._CONCAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CONSTANT_OR_NULL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='constant_or_null',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg1', 'arg2'),
                        varargs=parse_type('ANY'),
                        description='If arg2 is NULL, return NULL. Otherwise, return arg1.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('constant_or_null')
    def constant_or_null(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``constant_or_null``.

        If arg2 is NULL, return NULL. Otherwise, return arg1.

        Overloads:
        - main.constant_or_null(ANY arg1, ANY arg2, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._CONSTANT_OR_NULL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_DATE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_date',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('current_date')
    def current_date(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``current_date``.

        Overloads:
        - main.current_date() -> DATE
        """
        return call_duckdb_function(
            self._CURRENT_DATE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_LOCALTIME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_localtime',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('current_localtime')
    def current_localtime(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``current_localtime``.

        Overloads:
        - main.current_localtime() -> TIME
        """
        return call_duckdb_function(
            self._CURRENT_LOCALTIME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_LOCALTIMESTAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_localtimestamp',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('current_localtimestamp')
    def current_localtimestamp(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``current_localtimestamp``.

        Overloads:
        - main.current_localtimestamp() -> TIMESTAMP
        """
        return call_duckdb_function(
            self._CURRENT_LOCALTIMESTAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_SETTING_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_setting',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('setting_name',),
                        varargs=None,
                        description='Returns the current value of the configuration setting',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('current_setting')
    def current_setting(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``current_setting``.

        Returns the current value of the configuration setting

        Overloads:
        - main.current_setting(VARCHAR setting_name) -> ANY
        """
        return call_duckdb_function(
            self._CURRENT_SETTING_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATE_PART_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('DATE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('INTERVAL')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIME')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIMESTAMP')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIME_NS')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('date_part')
    def date_part(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``date_part``.

        Get subfield (equivalent to extract)

        Overloads:
        - main.date_part(VARCHAR[] ts, DATE col1) -> STRUCT()
        - main.date_part(VARCHAR[] ts, INTERVAL col1) -> STRUCT()
        - main.date_part(VARCHAR[] ts, TIME col1) -> STRUCT()
        - main.date_part(VARCHAR[] ts, TIMESTAMP col1) -> STRUCT()
        - main.date_part(VARCHAR[] ts, TIME WITH TIME ZONE col1) -> STRUCT()
        - main.date_part(VARCHAR[] ts, TIME_NS col1) -> STRUCT()
        - main.date_part(VARCHAR[] ts, TIMESTAMP WITH TIME ZONE col1) -> STRUCT()
        """
        return call_duckdb_function(
            self._DATE_PART_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATE_TRUNC_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_trunc',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('part', 'timestamp'),
                        varargs=None,
                        description='Truncate to specified precision',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_trunc',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('part', 'timestamp'),
                        varargs=None,
                        description='Truncate to specified precision',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_trunc',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('part', 'timestamp'),
                        varargs=None,
                        description='Truncate to specified precision',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('date_trunc')
    def date_trunc(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``date_trunc``.

        Truncate to specified precision

        Overloads:
        - main.date_trunc(VARCHAR part, DATE timestamp) -> TIMESTAMP
        - main.date_trunc(VARCHAR part, TIMESTAMP timestamp) -> TIMESTAMP
        - main.date_trunc(VARCHAR part, TIMESTAMP WITH TIME ZONE timestamp) -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._DATE_TRUNC_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATEPART_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('DATE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('INTERVAL')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIME')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIMESTAMP')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIME_NS')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('STRUCT()'),
                        parameter_types=(parse_type('VARCHAR[]'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('datepart')
    def datepart(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``datepart``.

        Get subfield (equivalent to extract)

        Overloads:
        - main.datepart(VARCHAR[] ts, DATE col1) -> STRUCT()
        - main.datepart(VARCHAR[] ts, INTERVAL col1) -> STRUCT()
        - main.datepart(VARCHAR[] ts, TIME col1) -> STRUCT()
        - main.datepart(VARCHAR[] ts, TIMESTAMP col1) -> STRUCT()
        - main.datepart(VARCHAR[] ts, TIME WITH TIME ZONE col1) -> STRUCT()
        - main.datepart(VARCHAR[] ts, TIME_NS col1) -> STRUCT()
        - main.datepart(VARCHAR[] ts, TIMESTAMP WITH TIME ZONE col1) -> STRUCT()
        """
        return call_duckdb_function(
            self._DATEPART_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATETRUNC_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datetrunc',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('part', 'timestamp'),
                        varargs=None,
                        description='Truncate to specified precision',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datetrunc',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('part', 'timestamp'),
                        varargs=None,
                        description='Truncate to specified precision',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datetrunc',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('part', 'timestamp'),
                        varargs=None,
                        description='Truncate to specified precision',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('datetrunc')
    def datetrunc(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``datetrunc``.

        Truncate to specified precision

        Overloads:
        - main.datetrunc(VARCHAR part, DATE timestamp) -> TIMESTAMP
        - main.datetrunc(VARCHAR part, TIMESTAMP timestamp) -> TIMESTAMP
        - main.datetrunc(VARCHAR part, TIMESTAMP WITH TIME ZONE timestamp) -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._DATETRUNC_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DIVIDE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('divide')
    def divide(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``divide``.

        Overloads:
        - main.divide(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        """
        return call_duckdb_function(
            self._DIVIDE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ELEMENT_AT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='element_at',
                        function_type=function_type,
                        return_type=parse_type('V[]'),
                        parameter_types=(parse_type('MAP(K, V)'), parse_type('K')),
                        parameters=('map', 'key'),
                        varargs=None,
                        description='Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the maps keys else an error is returned',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('element_at')
    def element_at(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``element_at``.

        Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the maps keys else an error is returned

        Overloads:
        - main.element_at(MAP(K, V) map, K key) -> V[]
        """
        return call_duckdb_function(
            self._ELEMENT_AT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ENUM_CODE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='enum_code',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('enum',),
                        varargs=None,
                        description='Returns the numeric value backing the given enum value',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('enum_code')
    def enum_code(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``enum_code``.

        Returns the numeric value backing the given enum value

        Overloads:
        - main.enum_code(ANY enum) -> ANY
        """
        return call_duckdb_function(
            self._ENUM_CODE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _EPOCH_MS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ms',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in milliseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('epoch_ms')
    def epoch_ms(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``epoch_ms``.

        Extract the epoch component in milliseconds from a temporal type

        Overloads:
        - main.epoch_ms(BIGINT temporal) -> TIMESTAMP
        """
        return call_duckdb_function(
            self._EPOCH_MS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _EQUI_WIDTH_BINS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='equi_width_bins',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BOOLEAN')),
                        parameters=('min', 'max', 'bin_count', 'nice_rounding'),
                        varargs=None,
                        description='Generates bin_count equi-width bins between the min and max. If enabled nice_rounding makes the numbers more readable/less jagged',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='equi_width_bins',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE'), parse_type('BIGINT'), parse_type('BOOLEAN')),
                        parameters=('min', 'max', 'bin_count', 'nice_rounding'),
                        varargs=None,
                        description='Generates bin_count equi-width bins between the min and max. If enabled nice_rounding makes the numbers more readable/less jagged',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='equi_width_bins',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP'), parse_type('BIGINT'), parse_type('BOOLEAN')),
                        parameters=('min', 'max', 'bin_count', 'nice_rounding'),
                        varargs=None,
                        description='Generates bin_count equi-width bins between the min and max. If enabled nice_rounding makes the numbers more readable/less jagged',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='equi_width_bins',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('BIGINT'), parse_type('BOOLEAN')),
                        parameters=('min', 'max', 'bin_count', 'nice_rounding'),
                        varargs=None,
                        description='Generates bin_count equi-width bins between the min and max. If enabled nice_rounding makes the numbers more readable/less jagged',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('equi_width_bins')
    def equi_width_bins(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``equi_width_bins``.

        Generates bin_count equi-width bins between the min and max. If enabled nice_rounding makes the numbers more readable/less jagged

        Overloads:
        - main.equi_width_bins(BIGINT min, BIGINT max, BIGINT bin_count, BOOLEAN nice_rounding) -> ANY[]
        - main.equi_width_bins(DOUBLE min, DOUBLE max, BIGINT bin_count, BOOLEAN nice_rounding) -> ANY[]
        - main.equi_width_bins(TIMESTAMP min, TIMESTAMP max, BIGINT bin_count, BOOLEAN nice_rounding) -> ANY[]
        - main.equi_width_bins(ANY min, ANY max, BIGINT bin_count, BOOLEAN nice_rounding) -> ANY[]
        """
        return call_duckdb_function(
            self._EQUI_WIDTH_BINS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ERROR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='error',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('message',),
                        varargs=None,
                        description='Throws the given error message',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('error')
    def error(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``error``.

        Throws the given error message

        Overloads:
        - main.error(VARCHAR message) -> "NULL"
        """
        return call_duckdb_function(
            self._ERROR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FILTER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='filter',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x)'),
                        varargs=None,
                        description="Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.",
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('filter')
    def filter(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``filter``.

        Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.

        Overloads:
        - main.filter(ANY[] list, LAMBDA lambda(x)) -> ANY[]
        """
        return call_duckdb_function(
            self._FILTER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FINALIZE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='finalize',
                        function_type=function_type,
                        return_type=parse_type('INVALID'),
                        parameter_types=(parse_type('AGGREGATE_STATE<?>'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('finalize')
    def finalize(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``finalize``.

        Overloads:
        - main.finalize(AGGREGATE_STATE<?> col0) -> INVALID
        """
        return call_duckdb_function(
            self._FINALIZE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FLATTEN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='flatten',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T[][]'),),
                        parameters=('nested_list',),
                        varargs=None,
                        description='Flattens a nested list by one level.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('flatten')
    def flatten(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``flatten``.

        Flattens a nested list by one level.

        Overloads:
        - main.flatten(T[][] nested_list) -> T[]
        """
        return call_duckdb_function(
            self._FLATTEN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FROM_JSON_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='from_json',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='from_json',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('from_json')
    def from_json(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``from_json``.

        Overloads:
        - main.from_json(VARCHAR col0, VARCHAR col1) -> ANY
        - main.from_json(JSON col0, VARCHAR col1) -> ANY
        """
        return call_duckdb_function(
            self._FROM_JSON_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FROM_JSON_STRICT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='from_json_strict',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='from_json_strict',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('from_json_strict')
    def from_json_strict(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``from_json_strict``.

        Overloads:
        - main.from_json_strict(VARCHAR col0, VARCHAR col1) -> ANY
        - main.from_json_strict(JSON col0, VARCHAR col1) -> ANY
        """
        return call_duckdb_function(
            self._FROM_JSON_STRICT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GENERATE_SERIES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='generate_series',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP[]'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP'), parse_type('INTERVAL')),
                        parameters=('start', 'stop', 'step'),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is inclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='generate_series',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE[]'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTERVAL')),
                        parameters=('start', 'stop', 'step'),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is inclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('generate_series')
    def generate_series(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``generate_series``.

        Creates a list of values between `start` and `stop` - the stop parameter is inclusive.

        Overloads:
        - main.generate_series(TIMESTAMP start, TIMESTAMP stop, INTERVAL step) -> TIMESTAMP[]
        - main.generate_series(TIMESTAMP WITH TIME ZONE start, TIMESTAMP WITH TIME ZONE stop, INTERVAL step) -> TIMESTAMP WITH TIME ZONE[]
        """
        return call_duckdb_function(
            self._GENERATE_SERIES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GENERATE_SUBSCRIPTS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='generate_subscripts',
                        function_type=function_type,
                        return_type=None,
                        parameter_types=(None, None),
                        parameters=('arr', 'dim'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='unnest(generate_series(1, array_length(arr, dim)))',
                    ),
    )
    @duckdb_function('generate_subscripts')
    def generate_subscripts(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``generate_subscripts``.

        Overloads:
        - main.generate_subscripts(ANY arr, ANY dim) -> ANY
        """
        return call_duckdb_function(
            self._GENERATE_SUBSCRIPTS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GET_CURRENT_TIME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='get_current_time',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('get_current_time')
    def get_current_time(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``get_current_time``.

        Overloads:
        - main.get_current_time() -> TIME WITH TIME ZONE
        """
        return call_duckdb_function(
            self._GET_CURRENT_TIME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GET_CURRENT_TIMESTAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='get_current_timestamp',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the current timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('get_current_timestamp')
    def get_current_timestamp(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``get_current_timestamp``.

        Returns the current timestamp

        Overloads:
        - main.get_current_timestamp() -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._GET_CURRENT_TIMESTAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GETVARIABLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='getvariable',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('getvariable')
    def getvariable(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``getvariable``.

        Overloads:
        - main.getvariable(VARCHAR col0) -> ANY
        """
        return call_duckdb_function(
            self._GETVARIABLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GRADE_UP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='grade_up',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='grade_up',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'col1'),
                        varargs=None,
                        description='Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='grade_up',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('list', 'col1', 'col2'),
                        varargs=None,
                        description='Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('grade_up')
    def grade_up(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``grade_up``.

        Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.

        Overloads:
        - main.grade_up(ANY[] list) -> ANY[]
        - main.grade_up(ANY[] list, VARCHAR col1) -> ANY[]
        - main.grade_up(ANY[] list, VARCHAR col1, VARCHAR col2) -> ANY[]
        """
        return call_duckdb_function(
            self._GRADE_UP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GREATEST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='greatest',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg1',),
                        varargs=parse_type('ANY'),
                        description='Returns the largest value. For strings lexicographical ordering is used. Note that lowercase characters are considered larger than uppercase characters and collations are not supported.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('greatest')
    def greatest(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``greatest``.

        Returns the largest value. For strings lexicographical ordering is used. Note that lowercase characters are considered larger than uppercase characters and collations are not supported.

        Overloads:
        - main.greatest(ANY arg1, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._GREATEST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _INET_CLIENT_ADDR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='inet_client_addr',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='NULL',
                    ),
    )
    @duckdb_function('inet_client_addr')
    def inet_client_addr(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``inet_client_addr``.

        Overloads:
        - pg_catalog.inet_client_addr() -> "NULL"
        """
        return call_duckdb_function(
            self._INET_CLIENT_ADDR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _INET_CLIENT_PORT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='inet_client_port',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='NULL',
                    ),
    )
    @duckdb_function('inet_client_port')
    def inet_client_port(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``inet_client_port``.

        Overloads:
        - pg_catalog.inet_client_port() -> "NULL"
        """
        return call_duckdb_function(
            self._INET_CLIENT_PORT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _INET_SERVER_ADDR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='inet_server_addr',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='NULL',
                    ),
    )
    @duckdb_function('inet_server_addr')
    def inet_server_addr(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``inet_server_addr``.

        Overloads:
        - pg_catalog.inet_server_addr() -> "NULL"
        """
        return call_duckdb_function(
            self._INET_SERVER_ADDR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _INET_SERVER_PORT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='inet_server_port',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='NULL',
                    ),
    )
    @duckdb_function('inet_server_port')
    def inet_server_port(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``inet_server_port``.

        Overloads:
        - pg_catalog.inet_server_port() -> "NULL"
        """
        return call_duckdb_function(
            self._INET_SERVER_PORT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_TRANSFORM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_transform',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_transform',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_transform')
    def json_transform(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``json_transform``.

        Overloads:
        - main.json_transform(VARCHAR col0, VARCHAR col1) -> ANY
        - main.json_transform(JSON col0, VARCHAR col1) -> ANY
        """
        return call_duckdb_function(
            self._JSON_TRANSFORM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_TRANSFORM_STRICT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_transform_strict',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_transform_strict',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_transform_strict')
    def json_transform_strict(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``json_transform_strict``.

        Overloads:
        - main.json_transform_strict(VARCHAR col0, VARCHAR col1) -> ANY
        - main.json_transform_strict(JSON col0, VARCHAR col1) -> ANY
        """
        return call_duckdb_function(
            self._JSON_TRANSFORM_STRICT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LAST_DAY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='last_day',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Returns the last day of the month',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='last_day',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Returns the last day of the month',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='last_day',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Returns the last day of the month',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('last_day')
    def last_day(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``last_day``.

        Returns the last day of the month

        Overloads:
        - main.last_day(DATE ts) -> DATE
        - main.last_day(TIMESTAMP ts) -> DATE
        - main.last_day(TIMESTAMP WITH TIME ZONE ts) -> DATE
        """
        return call_duckdb_function(
            self._LAST_DAY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LEAST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='least',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('arg1',),
                        varargs=parse_type('ANY'),
                        description='Returns the smallest value. For strings lexicographical ordering is used. Note that uppercase characters are considered smaller than lowercase characters, and collations are not supported.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('least')
    def least(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``least``.

        Returns the smallest value. For strings lexicographical ordering is used. Note that uppercase characters are considered smaller than lowercase characters, and collations are not supported.

        Overloads:
        - main.least(ANY arg1, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._LEAST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_AGGR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_aggr',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'function_name'),
                        varargs=parse_type('ANY'),
                        description='Executes the aggregate function `function_name` on the elements of `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_aggr')
    def list_aggr(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_aggr``.

        Executes the aggregate function `function_name` on the elements of `list`.

        Overloads:
        - main.list_aggr(ANY[] list, VARCHAR function_name, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._LIST_AGGR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_AGGREGATE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_aggregate',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'function_name'),
                        varargs=parse_type('ANY'),
                        description='Executes the aggregate function `function_name` on the elements of `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_aggregate')
    def list_aggregate(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_aggregate``.

        Executes the aggregate function `function_name` on the elements of `list`.

        Overloads:
        - main.list_aggregate(ANY[] list, VARCHAR function_name, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._LIST_AGGREGATE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_ANY_VALUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_any_value',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'any_value')",
                    ),
    )
    @duckdb_function('list_any_value')
    def list_any_value(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_any_value``.

        Overloads:
        - main.list_any_value(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_ANY_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_APPEND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_append',
                        function_type=function_type,
                        return_type=parse_type('"NULL"[]'),
                        parameter_types=(None, None),
                        parameters=('l', 'e'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='list_concat(l, list_value(e))',
                    ),
    )
    @duckdb_function('list_append')
    def list_append(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_append``.

        Overloads:
        - main.list_append(ANY l, ANY e) -> "NULL"[]
        """
        return call_duckdb_function(
            self._LIST_APPEND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_APPLY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_apply',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x)'),
                        varargs=None,
                        description='Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_apply')
    def list_apply(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_apply``.

        Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.

        Overloads:
        - main.list_apply(ANY[] list, LAMBDA lambda(x)) -> ANY[]
        """
        return call_duckdb_function(
            self._LIST_APPLY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_APPROX_COUNT_DISTINCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_approx_count_distinct',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'approx_count_distinct')",
                    ),
    )
    @duckdb_function('list_approx_count_distinct')
    def list_approx_count_distinct(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_approx_count_distinct``.

        Overloads:
        - main.list_approx_count_distinct(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_APPROX_COUNT_DISTINCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_AVG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_avg',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'avg')",
                    ),
    )
    @duckdb_function('list_avg')
    def list_avg(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_avg``.

        Overloads:
        - main.list_avg(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_AVG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_BIT_AND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_bit_and',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'bit_and')",
                    ),
    )
    @duckdb_function('list_bit_and')
    def list_bit_and(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_bit_and``.

        Overloads:
        - main.list_bit_and(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_BIT_AND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_BIT_OR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_bit_or',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'bit_or')",
                    ),
    )
    @duckdb_function('list_bit_or')
    def list_bit_or(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_bit_or``.

        Overloads:
        - main.list_bit_or(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_BIT_OR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_BIT_XOR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_bit_xor',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'bit_xor')",
                    ),
    )
    @duckdb_function('list_bit_xor')
    def list_bit_xor(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_bit_xor``.

        Overloads:
        - main.list_bit_xor(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_BIT_XOR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_BOOL_AND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_bool_and',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'bool_and')",
                    ),
    )
    @duckdb_function('list_bool_and')
    def list_bool_and(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_bool_and``.

        Overloads:
        - main.list_bool_and(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_BOOL_AND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_BOOL_OR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_bool_or',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'bool_or')",
                    ),
    )
    @duckdb_function('list_bool_or')
    def list_bool_or(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_bool_or``.

        Overloads:
        - main.list_bool_or(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_BOOL_OR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_CAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_cat',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY[]'),
                        description='Concatenates lists. `NULL` inputs are skipped. See also operator `||`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_cat')
    def list_cat(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_cat``.

        Concatenates lists. `NULL` inputs are skipped. See also operator `||`.

        Overloads:
        - main.list_cat(ANY[] ...) -> ANY[]
        """
        return call_duckdb_function(
            self._LIST_CAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_CONCAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_concat',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY[]'),
                        description='Concatenates lists. `NULL` inputs are skipped. See also operator `||`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_concat')
    def list_concat(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_concat``.

        Concatenates lists. `NULL` inputs are skipped. See also operator `||`.

        Overloads:
        - main.list_concat(ANY[] ...) -> ANY[]
        """
        return call_duckdb_function(
            self._LIST_CONCAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_COUNT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_count',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'count')",
                    ),
    )
    @duckdb_function('list_count')
    def list_count(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_count``.

        Overloads:
        - main.list_count(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_COUNT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_DISTINCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_distinct',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Removes all duplicates and `NULL` values from a list. Does not preserve the original order.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_distinct')
    def list_distinct(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_distinct``.

        Removes all duplicates and `NULL` values from a list. Does not preserve the original order.

        Overloads:
        - main.list_distinct(T[] list) -> T[]
        """
        return call_duckdb_function(
            self._LIST_DISTINCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_ELEMENT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_element',
                        function_type=function_type,
                        return_type=parse_type('T'),
                        parameter_types=(parse_type('T[]'), parse_type('BIGINT')),
                        parameters=('list', 'index'),
                        varargs=None,
                        description='Extract the `index`th (1-based) value from the list.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_element')
    def list_element(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_element``.

        Extract the `index`th (1-based) value from the list.

        Overloads:
        - main.list_element(T[] list, BIGINT index) -> T
        """
        return call_duckdb_function(
            self._LIST_ELEMENT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_ENTROPY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_entropy',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'entropy')",
                    ),
    )
    @duckdb_function('list_entropy')
    def list_entropy(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_entropy``.

        Overloads:
        - main.list_entropy(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_ENTROPY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_extract',
                        function_type=function_type,
                        return_type=parse_type('T'),
                        parameter_types=(parse_type('T[]'), parse_type('BIGINT')),
                        parameters=('list', 'index'),
                        varargs=None,
                        description='Extract the `index`th (1-based) value from the list.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_extract')
    def list_extract(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_extract``.

        Extract the `index`th (1-based) value from the list.

        Overloads:
        - main.list_extract(T[] list, BIGINT index) -> T
        """
        return call_duckdb_function(
            self._LIST_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_FILTER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_filter',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x)'),
                        varargs=None,
                        description="Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.",
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_filter')
    def list_filter(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_filter``.

        Constructs a list from those elements of the input `list` for which the `lambda` function returns `true`. DuckDB must be able to cast the `lambda` function's return type to `BOOL`. The return type of `list_filter` is the same as the input list's.

        Overloads:
        - main.list_filter(ANY[] list, LAMBDA lambda(x)) -> ANY[]
        """
        return call_duckdb_function(
            self._LIST_FILTER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_FIRST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_first',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'first')",
                    ),
    )
    @duckdb_function('list_first')
    def list_first(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_first``.

        Overloads:
        - main.list_first(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_FIRST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_GRADE_UP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_grade_up',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_grade_up',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'col1'),
                        varargs=None,
                        description='Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_grade_up',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('list', 'col1', 'col2'),
                        varargs=None,
                        description='Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_grade_up')
    def list_grade_up(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_grade_up``.

        Works like list_sort, but the results are the indexes that correspond to the position in the original list instead of the actual values.

        Overloads:
        - main.list_grade_up(ANY[] list) -> ANY[]
        - main.list_grade_up(ANY[] list, VARCHAR col1) -> ANY[]
        - main.list_grade_up(ANY[] list, VARCHAR col1, VARCHAR col2) -> ANY[]
        """
        return call_duckdb_function(
            self._LIST_GRADE_UP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_HISTOGRAM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_histogram',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'histogram')",
                    ),
    )
    @duckdb_function('list_histogram')
    def list_histogram(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_histogram``.

        Overloads:
        - main.list_histogram(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_HISTOGRAM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_INTERSECT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_intersect',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None, None),
                        parameters=('l1', 'l2'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='list_filter(list_distinct(l1), (lambda variable_intersect: list_contains(l2, variable_intersect)))',
                    ),
    )
    @duckdb_function('list_intersect')
    def list_intersect(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_intersect``.

        Overloads:
        - main.list_intersect(ANY l1, ANY l2) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_INTERSECT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_KURTOSIS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_kurtosis',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'kurtosis')",
                    ),
    )
    @duckdb_function('list_kurtosis')
    def list_kurtosis(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_kurtosis``.

        Overloads:
        - main.list_kurtosis(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_KURTOSIS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_KURTOSIS_POP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_kurtosis_pop',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'kurtosis_pop')",
                    ),
    )
    @duckdb_function('list_kurtosis_pop')
    def list_kurtosis_pop(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_kurtosis_pop``.

        Overloads:
        - main.list_kurtosis_pop(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_KURTOSIS_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_LAST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_last',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'last')",
                    ),
    )
    @duckdb_function('list_last')
    def list_last(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_last``.

        Overloads:
        - main.list_last(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_LAST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_MAD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_mad',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'mad')",
                    ),
    )
    @duckdb_function('list_mad')
    def list_mad(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_mad``.

        Overloads:
        - main.list_mad(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_MAD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_MAX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_max',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'max')",
                    ),
    )
    @duckdb_function('list_max')
    def list_max(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_max``.

        Overloads:
        - main.list_max(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_MAX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_MEDIAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_median',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'median')",
                    ),
    )
    @duckdb_function('list_median')
    def list_median(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_median``.

        Overloads:
        - main.list_median(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_MEDIAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_MIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_min',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'min')",
                    ),
    )
    @duckdb_function('list_min')
    def list_min(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_min``.

        Overloads:
        - main.list_min(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_MIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_MODE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_mode',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'mode')",
                    ),
    )
    @duckdb_function('list_mode')
    def list_mode(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_mode``.

        Overloads:
        - main.list_mode(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_MODE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_PACK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_pack',
                        function_type=function_type,
                        return_type=parse_type('"NULL"[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Creates a LIST containing the argument values.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_pack',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T'),),
                        parameters=('any',),
                        varargs=parse_type('T'),
                        description='Creates a LIST containing the argument values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_pack')
    def list_pack(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_pack``.

        Creates a LIST containing the argument values.

        Overloads:
        - main.list_pack() -> "NULL"[]
        - main.list_pack(T any, T ...) -> T[]
        """
        return call_duckdb_function(
            self._LIST_PACK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_PREPEND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_prepend',
                        function_type=function_type,
                        return_type=parse_type('"NULL"[]'),
                        parameter_types=(None, None),
                        parameters=('e', 'l'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='list_concat(list_value(e), l)',
                    ),
    )
    @duckdb_function('list_prepend')
    def list_prepend(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_prepend``.

        Overloads:
        - main.list_prepend(ANY e, ANY l) -> "NULL"[]
        """
        return call_duckdb_function(
            self._LIST_PREPEND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_product',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'product')",
                    ),
    )
    @duckdb_function('list_product')
    def list_product(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_product``.

        Overloads:
        - main.list_product(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_REDUCE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_reduce',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x,y)'),
                        varargs=None,
                        description='Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_reduce',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA'), parse_type('ANY')),
                        parameters=('list', 'lambda(x,y)', 'initial_value'),
                        varargs=None,
                        description='Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_reduce')
    def list_reduce(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_reduce``.

        Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.

        Overloads:
        - main.list_reduce(ANY[] list, LAMBDA lambda(x,y)) -> ANY
        - main.list_reduce(ANY[] list, LAMBDA lambda(x,y), ANY initial_value) -> ANY
        """
        return call_duckdb_function(
            self._LIST_REDUCE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_RESIZE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_resize',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('ANY')),
                        parameters=('list', 'size['),
                        varargs=None,
                        description='Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_resize',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('ANY'), parse_type('ANY')),
                        parameters=('list', 'size[', 'value]'),
                        varargs=None,
                        description='Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_resize')
    def list_resize(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_resize``.

        Resizes the `list` to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set.

        Overloads:
        - main.list_resize(ANY[] list, ANY size[) -> ANY[]
        - main.list_resize(ANY[] list, ANY size[, ANY value]) -> ANY[]
        """
        return call_duckdb_function(
            self._LIST_RESIZE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_REVERSE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_reverse',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='l[:-:-1]',
                    ),
    )
    @duckdb_function('list_reverse')
    def list_reverse(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_reverse``.

        Overloads:
        - main.list_reverse(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_REVERSE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_REVERSE_SORT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_reverse_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Sorts the elements of the list in reverse order.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_reverse_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'col1'),
                        varargs=None,
                        description='Sorts the elements of the list in reverse order.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_reverse_sort')
    def list_reverse_sort(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_reverse_sort``.

        Sorts the elements of the list in reverse order.

        Overloads:
        - main.list_reverse_sort(ANY[] list) -> ANY[]
        - main.list_reverse_sort(ANY[] list, VARCHAR col1) -> ANY[]
        """
        return call_duckdb_function(
            self._LIST_REVERSE_SORT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_SELECT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_select',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T[]'), parse_type('BIGINT[]')),
                        parameters=('value_list', 'index_list'),
                        varargs=None,
                        description='Returns a list based on the elements selected by the `index_list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_select')
    def list_select(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_select``.

        Returns a list based on the elements selected by the `index_list`.

        Overloads:
        - main.list_select(T[] value_list, BIGINT[] index_list) -> T[]
        """
        return call_duckdb_function(
            self._LIST_SELECT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_SEM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_sem',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'sem')",
                    ),
    )
    @duckdb_function('list_sem')
    def list_sem(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_sem``.

        Overloads:
        - main.list_sem(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_SEM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_SKEWNESS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_skewness',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'skewness')",
                    ),
    )
    @duckdb_function('list_skewness')
    def list_skewness(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_skewness``.

        Overloads:
        - main.list_skewness(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_SKEWNESS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_SLICE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_slice',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('ANY')),
                        parameters=('list', 'begin', 'end'),
                        varargs=None,
                        description='Extracts a sublist or substring using slice conventions. Negative values are accepted.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_slice',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('ANY'), parse_type('BIGINT')),
                        parameters=('list', 'begin', 'end', 'step'),
                        varargs=None,
                        description='list_slice with added step feature.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_slice')
    def list_slice(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_slice``.

        Extracts a sublist or substring using slice conventions. Negative values are accepted.

        Overloads:
        - main.list_slice(ANY list, ANY begin, ANY end) -> ANY
        - main.list_slice(ANY list, ANY begin, ANY end, BIGINT step) -> ANY
        """
        return call_duckdb_function(
            self._LIST_SLICE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_SORT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Sorts the elements of the list.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR')),
                        parameters=('list', 'col1'),
                        varargs=None,
                        description='Sorts the elements of the list.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_sort',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('list', 'col1', 'col2'),
                        varargs=None,
                        description='Sorts the elements of the list.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_sort')
    def list_sort(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_sort``.

        Sorts the elements of the list.

        Overloads:
        - main.list_sort(ANY[] list) -> ANY[]
        - main.list_sort(ANY[] list, VARCHAR col1) -> ANY[]
        - main.list_sort(ANY[] list, VARCHAR col1, VARCHAR col2) -> ANY[]
        """
        return call_duckdb_function(
            self._LIST_SORT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_STDDEV_POP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_stddev_pop',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'stddev_pop')",
                    ),
    )
    @duckdb_function('list_stddev_pop')
    def list_stddev_pop(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_stddev_pop``.

        Overloads:
        - main.list_stddev_pop(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_STDDEV_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_STDDEV_SAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_stddev_samp',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'stddev_samp')",
                    ),
    )
    @duckdb_function('list_stddev_samp')
    def list_stddev_samp(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_stddev_samp``.

        Overloads:
        - main.list_stddev_samp(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_STDDEV_SAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_STRING_AGG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_string_agg',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'string_agg')",
                    ),
    )
    @duckdb_function('list_string_agg')
    def list_string_agg(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_string_agg``.

        Overloads:
        - main.list_string_agg(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_STRING_AGG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_SUM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_sum',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'sum')",
                    ),
    )
    @duckdb_function('list_sum')
    def list_sum(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_sum``.

        Overloads:
        - main.list_sum(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_SUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_TRANSFORM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_transform',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x)'),
                        varargs=None,
                        description='Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_transform')
    def list_transform(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_transform``.

        Returns a list that is the result of applying the `lambda` function to each element of the input `list`. The return type is defined by the return type of the `lambda` function.

        Overloads:
        - main.list_transform(ANY[] list, LAMBDA lambda(x)) -> ANY[]
        """
        return call_duckdb_function(
            self._LIST_TRANSFORM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_VALUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_value',
                        function_type=function_type,
                        return_type=parse_type('"NULL"[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Creates a LIST containing the argument values.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_value',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T'),),
                        parameters=('any',),
                        varargs=parse_type('T'),
                        description='Creates a LIST containing the argument values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_value')
    def list_value(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_value``.

        Creates a LIST containing the argument values.

        Overloads:
        - main.list_value() -> "NULL"[]
        - main.list_value(T any, T ...) -> T[]
        """
        return call_duckdb_function(
            self._LIST_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_VAR_POP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_var_pop',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'var_pop')",
                    ),
    )
    @duckdb_function('list_var_pop')
    def list_var_pop(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_var_pop``.

        Overloads:
        - main.list_var_pop(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_VAR_POP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_VAR_SAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_var_samp',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None,),
                        parameters=('l',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(l, 'var_samp')",
                    ),
    )
    @duckdb_function('list_var_samp')
    def list_var_samp(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_var_samp``.

        Overloads:
        - main.list_var_samp(ANY l) -> "NULL"
        """
        return call_duckdb_function(
            self._LIST_VAR_SAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_WHERE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_where',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T[]'), parse_type('BOOLEAN[]')),
                        parameters=('value_list', 'mask_list'),
                        varargs=None,
                        description='Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_where')
    def list_where(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_where``.

        Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`.

        Overloads:
        - main.list_where(T[] value_list, BOOLEAN[] mask_list) -> T[]
        """
        return call_duckdb_function(
            self._LIST_WHERE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_ZIP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_zip',
                        function_type=function_type,
                        return_type=parse_type('STRUCT[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Zips n `LIST`s to a new `LIST` whose length will be that of the longest list. Its elements are structs of n elements from each list `list_1`, , `list_n`, missing elements are replaced with `NULL`. If `truncate` is set, all lists are truncated to the smallest list length.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_zip')
    def list_zip(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``list_zip``.

        Zips n `LIST`s to a new `LIST` whose length will be that of the longest list. Its elements are structs of n elements from each list `list_1`, , `list_n`, missing elements are replaced with `NULL`. If `truncate` is set, all lists are truncated to the smallest list length.

        Overloads:
        - main.list_zip(ANY ...) -> STRUCT[]
        """
        return call_duckdb_function(
            self._LIST_ZIP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAKE_DATE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_date',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_date',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('STRUCT("year" BIGINT, "month" BIGINT, "day" BIGINT)'),),
                        parameters=('date-struct',),
                        varargs=None,
                        description='The date for the given struct.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_date',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('year', 'month', 'day'),
                        varargs=None,
                        description='The date for the given parts.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('make_date')
    def make_date(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``make_date``.

        The date for the given struct.

        Overloads:
        - main.make_date(INTEGER col0) -> DATE
        - main.make_date(STRUCT("year" BIGINT, "month" BIGINT, "day" BIGINT) date-struct) -> DATE
        - main.make_date(BIGINT year, BIGINT month, BIGINT day) -> DATE
        """
        return call_duckdb_function(
            self._MAKE_DATE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAKE_TIME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_time',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('hour', 'minute', 'seconds'),
                        varargs=None,
                        description='The time for the given parts',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('make_time')
    def make_time(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``make_time``.

        The time for the given parts

        Overloads:
        - main.make_time(BIGINT hour, BIGINT minute, DOUBLE seconds) -> TIME
        """
        return call_duckdb_function(
            self._MAKE_TIME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAKE_TIMESTAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_timestamp',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('year',),
                        varargs=None,
                        description='The timestamp for the given parts',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_timestamp',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('year', 'month', 'day', 'hour', 'minute', 'seconds'),
                        varargs=None,
                        description='The timestamp for the given parts',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('make_timestamp')
    def make_timestamp(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``make_timestamp``.

        The timestamp for the given parts

        Overloads:
        - main.make_timestamp(BIGINT year) -> TIMESTAMP
        - main.make_timestamp(BIGINT year, BIGINT month, BIGINT day, BIGINT hour, BIGINT minute, DOUBLE seconds) -> TIMESTAMP
        """
        return call_duckdb_function(
            self._MAKE_TIMESTAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAKE_TIMESTAMP_MS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_timestamp_ms',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('nanos',),
                        varargs=None,
                        description='The timestamp for the given microseconds since the epoch',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('make_timestamp_ms')
    def make_timestamp_ms(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``make_timestamp_ms``.

        The timestamp for the given microseconds since the epoch

        Overloads:
        - main.make_timestamp_ms(BIGINT nanos) -> TIMESTAMP
        """
        return call_duckdb_function(
            self._MAKE_TIMESTAMP_MS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAKE_TIMESTAMP_NS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_timestamp_ns',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP_NS'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('nanos',),
                        varargs=None,
                        description='The timestamp for the given nanoseconds since epoch',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('make_timestamp_ns')
    def make_timestamp_ns(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``make_timestamp_ns``.

        The timestamp for the given nanoseconds since epoch

        Overloads:
        - main.make_timestamp_ns(BIGINT nanos) -> TIMESTAMP_NS
        """
        return call_duckdb_function(
            self._MAKE_TIMESTAMP_NS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAKE_TIMESTAMPTZ_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_timestamptz',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_timestamptz',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1', 'col2', 'col3', 'col4', 'col5'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='make_timestamptz',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT'), parse_type('DOUBLE'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1', 'col2', 'col3', 'col4', 'col5', 'col6'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('make_timestamptz')
    def make_timestamptz(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``make_timestamptz``.

        Overloads:
        - main.make_timestamptz(BIGINT col0) -> TIMESTAMP WITH TIME ZONE
        - main.make_timestamptz(BIGINT col0, BIGINT col1, BIGINT col2, BIGINT col3, BIGINT col4, DOUBLE col5) -> TIMESTAMP WITH TIME ZONE
        - main.make_timestamptz(BIGINT col0, BIGINT col1, BIGINT col2, BIGINT col3, BIGINT col4, DOUBLE col5, VARCHAR col6) -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._MAKE_TIMESTAMPTZ_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map',
                        function_type=function_type,
                        return_type=parse_type('MAP("NULL", "NULL")'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Creates a map from a set of keys and values',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map',
                        function_type=function_type,
                        return_type=parse_type('MAP(K, V)'),
                        parameter_types=(parse_type('K[]'), parse_type('V[]')),
                        parameters=('keys', 'values'),
                        varargs=None,
                        description='Creates a map from a set of keys and values',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('map')
    def map(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``map``.

        Creates a map from a set of keys and values

        Overloads:
        - main.map() -> MAP("NULL", "NULL")
        - main.map(K[] keys, V[] values) -> MAP(K, V)
        """
        return call_duckdb_function(
            self._MAP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_CONCAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_concat',
                        function_type=function_type,
                        return_type=parse_type('LIST'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Returns a map created from merging the input maps, on key collision the value is taken from the last map with that key',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('map_concat')
    def map_concat(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``map_concat``.

        Returns a map created from merging the input maps, on key collision the value is taken from the last map with that key

        Overloads:
        - main.map_concat(ANY ...) -> LIST
        """
        return call_duckdb_function(
            self._MAP_CONCAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_ENTRIES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_entries',
                        function_type=function_type,
                        return_type=parse_type('STRUCT("key" K, "value" V)[]'),
                        parameter_types=(parse_type('MAP(K, V)'),),
                        parameters=('map',),
                        varargs=None,
                        description='Returns the map entries as a list of keys/values',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('map_entries')
    def map_entries(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``map_entries``.

        Returns the map entries as a list of keys/values

        Overloads:
        - main.map_entries(MAP(K, V) map) -> STRUCT("key" K, "value" V)[]
        """
        return call_duckdb_function(
            self._MAP_ENTRIES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_extract',
                        function_type=function_type,
                        return_type=parse_type('V[]'),
                        parameter_types=(parse_type('MAP(K, V)'), parse_type('K')),
                        parameters=('map', 'key'),
                        varargs=None,
                        description='Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the maps keys else an error is returned',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('map_extract')
    def map_extract(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``map_extract``.

        Returns a list containing the value for a given key or an empty list if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the maps keys else an error is returned

        Overloads:
        - main.map_extract(MAP(K, V) map, K key) -> V[]
        """
        return call_duckdb_function(
            self._MAP_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_EXTRACT_VALUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_extract_value',
                        function_type=function_type,
                        return_type=parse_type('V'),
                        parameter_types=(parse_type('MAP(K, V)'), parse_type('K')),
                        parameters=('map', 'key'),
                        varargs=None,
                        description='Returns the value for a given key or NULL if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the maps keys else an error is returned',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('map_extract_value')
    def map_extract_value(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``map_extract_value``.

        Returns the value for a given key or NULL if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the maps keys else an error is returned

        Overloads:
        - main.map_extract_value(MAP(K, V) map, K key) -> V
        """
        return call_duckdb_function(
            self._MAP_EXTRACT_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_FROM_ENTRIES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_from_entries',
                        function_type=function_type,
                        return_type=parse_type('MAP(K, V)'),
                        parameter_types=(parse_type('STRUCT(K, V)[]'),),
                        parameters=('map',),
                        varargs=None,
                        description='Returns a map created from the entries of the array',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('map_from_entries')
    def map_from_entries(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``map_from_entries``.

        Returns a map created from the entries of the array

        Overloads:
        - main.map_from_entries(STRUCT(K, V)[] map) -> MAP(K, V)
        """
        return call_duckdb_function(
            self._MAP_FROM_ENTRIES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_KEYS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_keys',
                        function_type=function_type,
                        return_type=parse_type('K[]'),
                        parameter_types=(parse_type('MAP(K, V)'),),
                        parameters=('map',),
                        varargs=None,
                        description='Returns the keys of a map as a list',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('map_keys')
    def map_keys(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``map_keys``.

        Returns the keys of a map as a list

        Overloads:
        - main.map_keys(MAP(K, V) map) -> K[]
        """
        return call_duckdb_function(
            self._MAP_KEYS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_VALUES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='map_values',
                        function_type=function_type,
                        return_type=parse_type('V[]'),
                        parameter_types=(parse_type('MAP(K, V)'),),
                        parameters=('map',),
                        varargs=None,
                        description='Returns the values of a map as a list',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('map_values')
    def map_values(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``map_values``.

        Returns the values of a map as a list

        Overloads:
        - main.map_values(MAP(K, V) map) -> V[]
        """
        return call_duckdb_function(
            self._MAP_VALUES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MD5_NUMBER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='md5_number',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Returns the MD5 hash of the `string` as a `HUGEINT`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='md5_number',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Returns the MD5 hash of the `blob` as a `HUGEINT`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('md5_number')
    def md5_number(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``md5_number``.

        Returns the MD5 hash of the `string` as a `HUGEINT`.

        Overloads:
        - main.md5_number(VARCHAR string) -> UHUGEINT
        - main.md5_number(BLOB blob) -> UHUGEINT
        """
        return call_duckdb_function(
            self._MD5_NUMBER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MOD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('mod')
    def mod(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``mod``.

        Overloads:
        - main.mod(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        """
        return call_duckdb_function(
            self._MOD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MULTIPLY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('multiply')
    def multiply(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``multiply``.

        Overloads:
        - main.multiply(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        """
        return call_duckdb_function(
            self._MULTIPLY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _NOW_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='now',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the current timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('now')
    def now(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``now``.

        Returns the current timestamp

        Overloads:
        - main.now() -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._NOW_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _NULLIF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nullif',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None, None),
                        parameters=('a', 'b'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='CASE  WHEN ((a = b)) THEN (NULL) ELSE a END',
                    ),
    )
    @duckdb_function('nullif')
    def nullif(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``nullif``.

        Overloads:
        - main.nullif(ANY a, ANY b) -> "NULL"
        """
        return call_duckdb_function(
            self._NULLIF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _OBJ_DESCRIPTION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='obj_description',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None, None),
                        parameters=('object_oid', 'catalog_name'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='NULL',
                    ),
    )
    @duckdb_function('obj_description')
    def obj_description(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``obj_description``.

        Overloads:
        - pg_catalog.obj_description(ANY object_oid, ANY catalog_name) -> "NULL"
        """
        return call_duckdb_function(
            self._OBJ_DESCRIPTION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PARSE_DUCKDB_LOG_MESSAGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_duckdb_log_message',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('type', 'message'),
                        varargs=None,
                        description='Parse the message into the expected logical type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('parse_duckdb_log_message')
    def parse_duckdb_log_message(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``parse_duckdb_log_message``.

        Parse the message into the expected logical type

        Overloads:
        - main.parse_duckdb_log_message(VARCHAR type, VARCHAR message) -> ANY
        """
        return call_duckdb_function(
            self._PARSE_DUCKDB_LOG_MESSAGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_CONF_LOAD_TIME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_conf_load_time',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='current_timestamp',
                    ),
    )
    @duckdb_function('pg_conf_load_time')
    def pg_conf_load_time(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``pg_conf_load_time``.

        Overloads:
        - pg_catalog.pg_conf_load_time() -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._PG_CONF_LOAD_TIME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_GET_EXPR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_get_expr',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None, None),
                        parameters=('pg_node_tree', 'relation_oid'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='pg_node_tree',
                    ),
    )
    @duckdb_function('pg_get_expr')
    def pg_get_expr(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``pg_get_expr``.

        Overloads:
        - pg_catalog.pg_get_expr(ANY pg_node_tree, ANY relation_oid) -> "NULL"
        """
        return call_duckdb_function(
            self._PG_GET_EXPR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_POSTMASTER_START_TIME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_postmaster_start_time',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='current_timestamp',
                    ),
    )
    @duckdb_function('pg_postmaster_start_time')
    def pg_postmaster_start_time(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``pg_postmaster_start_time``.

        Overloads:
        - pg_catalog.pg_postmaster_start_time() -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._PG_POSTMASTER_START_TIME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _RANGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='range',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP[]'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP'), parse_type('INTERVAL')),
                        parameters=('start', 'stop', 'step'),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is exclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='range',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE[]'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTERVAL')),
                        parameters=('start', 'stop', 'step'),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is exclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('range')
    def range(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``range``.

        Creates a list of values between `start` and `stop` - the stop parameter is exclusive.

        Overloads:
        - main.range(TIMESTAMP start, TIMESTAMP stop, INTERVAL step) -> TIMESTAMP[]
        - main.range(TIMESTAMP WITH TIME ZONE start, TIMESTAMP WITH TIME ZONE stop, INTERVAL step) -> TIMESTAMP WITH TIME ZONE[]
        """
        return call_duckdb_function(
            self._RANGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REDUCE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reduce',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA')),
                        parameters=('list', 'lambda(x,y)'),
                        varargs=None,
                        description='Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reduce',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY[]'), parse_type('LAMBDA'), parse_type('ANY')),
                        parameters=('list', 'lambda(x,y)', 'initial_value'),
                        varargs=None,
                        description='Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('reduce')
    def reduce(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``reduce``.

        Reduces all elements of the input `list` into a single scalar value by executing the `lambda` function on a running result and the next list element. The `lambda` function has an optional `initial_value` argument.

        Overloads:
        - main.reduce(ANY[] list, LAMBDA lambda(x,y)) -> ANY
        - main.reduce(ANY[] list, LAMBDA lambda(x,y), ANY initial_value) -> ANY
        """
        return call_duckdb_function(
            self._REDUCE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REGEXP_SPLIT_TO_TABLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_split_to_table',
                        function_type=function_type,
                        return_type=None,
                        parameter_types=(None, None),
                        parameters=('text', 'pattern'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='unnest(string_split_regex("text", pattern))',
                    ),
    )
    @duckdb_function('regexp_split_to_table')
    def regexp_split_to_table(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``regexp_split_to_table``.

        Overloads:
        - main.regexp_split_to_table(ANY text, ANY pattern) -> ANY
        """
        return call_duckdb_function(
            self._REGEXP_SPLIT_TO_TABLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REMAP_STRUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='remap_struct',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('ANY'), parse_type('ANY')),
                        parameters=('input', 'target_type', 'mapping', 'defaults'),
                        varargs=None,
                        description='Map a struct to another struct type, potentially re-ordering, renaming and casting members and filling in defaults for missing values',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('remap_struct')
    def remap_struct(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``remap_struct``.

        Map a struct to another struct type, potentially re-ordering, renaming and casting members and filling in defaults for missing values

        Overloads:
        - main.remap_struct(ANY input, ANY target_type, ANY mapping, ANY defaults) -> ANY
        """
        return call_duckdb_function(
            self._REMAP_STRUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REPEAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='repeat',
                        function_type=function_type,
                        return_type=parse_type('T[]'),
                        parameter_types=(parse_type('T[]'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('repeat')
    def repeat(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``repeat``.

        Overloads:
        - main.repeat(T[] col0, BIGINT col1) -> T[]
        """
        return call_duckdb_function(
            self._REPEAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REPLACE_TYPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='replace_type',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY'), parse_type('ANY')),
                        parameters=('param', 'type1', 'type2'),
                        varargs=None,
                        description='Casts all fields of type1 to type2',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('replace_type')
    def replace_type(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``replace_type``.

        Casts all fields of type1 to type2

        Overloads:
        - main.replace_type(ANY param, ANY type1, ANY type2) -> ANY
        """
        return call_duckdb_function(
            self._REPLACE_TYPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ROW_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='row',
                        function_type=function_type,
                        return_type=parse_type('STRUCT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Create an unnamed STRUCT (tuple) containing the argument values.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('row')
    def row(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``row``.

        Create an unnamed STRUCT (tuple) containing the argument values.

        Overloads:
        - main.row(ANY ...) -> STRUCT
        """
        return call_duckdb_function(
            self._ROW_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SET_BIT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='set_bit',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'), parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('bitstring', 'index', 'new_value'),
                        varargs=None,
                        description='Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('set_bit')
    def set_bit(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``set_bit``.

        Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring

        Overloads:
        - main.set_bit(BIT bitstring, INTEGER index, INTEGER new_value) -> BIT
        """
        return call_duckdb_function(
            self._SET_BIT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SETSEED_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='setseed',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('col0',),
                        varargs=None,
                        description='Sets the seed to be used for the random function',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('setseed')
    def setseed(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``setseed``.

        Sets the seed to be used for the random function

        Overloads:
        - main.setseed(DOUBLE col0) -> "NULL"
        """
        return call_duckdb_function(
            self._SETSEED_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SHOBJ_DESCRIPTION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='shobj_description',
                        function_type=function_type,
                        return_type=parse_type('"NULL"'),
                        parameter_types=(None, None),
                        parameters=('object_oid', 'catalog_name'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='NULL',
                    ),
    )
    @duckdb_function('shobj_description')
    def shobj_description(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``shobj_description``.

        Overloads:
        - pg_catalog.shobj_description(ANY object_oid, ANY catalog_name) -> "NULL"
        """
        return call_duckdb_function(
            self._SHOBJ_DESCRIPTION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRPTIME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strptime',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('text', 'format'),
                        varargs=None,
                        description='Converts the `string` text to timestamp according to the format string. Throws an error on failure. To return `NULL` on failure, use try_strptime.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strptime',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('text', 'format-list'),
                        varargs=None,
                        description='Converts the `string` text to timestamp applying the format strings in the list until one succeeds. Throws an error on failure. To return `NULL` on failure, use try_strptime.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('strptime')
    def strptime(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``strptime``.

        Converts the `string` text to timestamp according to the format string. Throws an error on failure. To return `NULL` on failure, use try_strptime.

        Overloads:
        - main.strptime(VARCHAR text, VARCHAR format) -> TIMESTAMP
        - main.strptime(VARCHAR text, VARCHAR[] format-list) -> TIMESTAMP
        """
        return call_duckdb_function(
            self._STRPTIME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_CONCAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_concat',
                        function_type=function_type,
                        return_type=parse_type('STRUCT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Merge the multiple STRUCTs into a single STRUCT.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_concat')
    def struct_concat(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``struct_concat``.

        Merge the multiple STRUCTs into a single STRUCT.

        Overloads:
        - main.struct_concat(ANY ...) -> STRUCT
        """
        return call_duckdb_function(
            self._STRUCT_CONCAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_extract',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('STRUCT'), parse_type('VARCHAR')),
                        parameters=('struct', "'entry'"),
                        varargs=None,
                        description='Extract the named entry from the STRUCT.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_extract',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('STRUCT'), parse_type('BIGINT')),
                        parameters=('struct', "'entry'"),
                        varargs=None,
                        description='Extract the named entry from the STRUCT.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_extract')
    def struct_extract(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``struct_extract``.

        Extract the named entry from the STRUCT.

        Overloads:
        - main.struct_extract(STRUCT struct, VARCHAR 'entry') -> ANY
        - main.struct_extract(STRUCT struct, BIGINT 'entry') -> ANY
        """
        return call_duckdb_function(
            self._STRUCT_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_EXTRACT_AT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_extract_at',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('STRUCT'), parse_type('BIGINT')),
                        parameters=('struct', "'entry'"),
                        varargs=None,
                        description='Extract the entry from the STRUCT by position (starts at 1!).',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_extract_at')
    def struct_extract_at(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``struct_extract_at``.

        Extract the entry from the STRUCT by position (starts at 1!).

        Overloads:
        - main.struct_extract_at(STRUCT struct, BIGINT 'entry') -> ANY
        """
        return call_duckdb_function(
            self._STRUCT_EXTRACT_AT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_INSERT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_insert',
                        function_type=function_type,
                        return_type=parse_type('STRUCT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Adds field(s)/value(s) to an existing STRUCT with the argument values. The entry name(s) will be the bound variable name(s)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_insert')
    def struct_insert(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``struct_insert``.

        Adds field(s)/value(s) to an existing STRUCT with the argument values. The entry name(s) will be the bound variable name(s)

        Overloads:
        - main.struct_insert(ANY ...) -> STRUCT
        """
        return call_duckdb_function(
            self._STRUCT_INSERT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_PACK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_pack',
                        function_type=function_type,
                        return_type=parse_type('STRUCT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Create a STRUCT containing the argument values. The entry name will be the bound variable name.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_pack')
    def struct_pack(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``struct_pack``.

        Create a STRUCT containing the argument values. The entry name will be the bound variable name.

        Overloads:
        - main.struct_pack(ANY ...) -> STRUCT
        """
        return call_duckdb_function(
            self._STRUCT_PACK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_UPDATE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_update',
                        function_type=function_type,
                        return_type=parse_type('STRUCT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Changes field(s)/value(s) to an existing STRUCT with the argument values. The entry name(s) will be the bound variable name(s)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_update')
    def struct_update(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``struct_update``.

        Changes field(s)/value(s) to an existing STRUCT with the argument values. The entry name(s) will be the bound variable name(s)

        Overloads:
        - main.struct_update(ANY ...) -> STRUCT
        """
        return call_duckdb_function(
            self._STRUCT_UPDATE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SUBTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('BIGNUM'),
                        parameter_types=(parse_type('BIGNUM'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('BIGNUM'),
                        parameter_types=(parse_type('BIGNUM'), parse_type('BIGNUM')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('DATE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('TIME'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('subtract')
    def subtract(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``subtract``.

        Overloads:
        - main.subtract(UHUGEINT col0) -> UHUGEINT
        - main.subtract(BIGNUM col0) -> BIGNUM
        - main.subtract(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        - main.subtract(BIGNUM col0, BIGNUM col1) -> BIGNUM
        - main.subtract(DATE col0, INTEGER col1) -> DATE
        - main.subtract(DATE col0, INTERVAL col1) -> TIMESTAMP
        - main.subtract(TIME col0, INTERVAL col1) -> TIME
        - main.subtract(TIMESTAMP col0, INTERVAL col1) -> TIMESTAMP
        - main.subtract(TIME WITH TIME ZONE col0, INTERVAL col1) -> TIME WITH TIME ZONE
        """
        return call_duckdb_function(
            self._SUBTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TIME_BUCKET_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('DATE')),
                        parameters=('bucket_width', 'timestamp'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP')),
                        parameters=('bucket_width', 'timestamp'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('bucket_width', 'timestamp'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('DATE'), parse_type('DATE')),
                        parameters=('bucket_width', 'timestamp', 'origin'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('DATE'), parse_type('INTERVAL')),
                        parameters=('bucket_width', 'timestamp', 'origin'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP'), parse_type('INTERVAL')),
                        parameters=('bucket_width', 'timestamp', 'origin'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('bucket_width', 'timestamp', 'origin'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTERVAL')),
                        parameters=('bucket_width', 'timestamp', 'origin'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('bucket_width', 'timestamp', 'origin'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='time_bucket',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('bucket_width', 'timestamp', 'origin'),
                        varargs=None,
                        description='Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('time_bucket')
    def time_bucket(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``time_bucket``.

        Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03 00:00:00+00 for buckets that do not include a month or year interval, and to 2000-01-01 00:00:00+00 for month and year buckets

        Overloads:
        - main.time_bucket(INTERVAL bucket_width, DATE timestamp) -> DATE
        - main.time_bucket(INTERVAL bucket_width, TIMESTAMP timestamp) -> TIMESTAMP
        - main.time_bucket(INTERVAL bucket_width, TIMESTAMP WITH TIME ZONE timestamp) -> TIMESTAMP WITH TIME ZONE
        - main.time_bucket(INTERVAL bucket_width, DATE timestamp, DATE origin) -> DATE
        - main.time_bucket(INTERVAL bucket_width, DATE timestamp, INTERVAL origin) -> DATE
        - main.time_bucket(INTERVAL bucket_width, TIMESTAMP timestamp, INTERVAL origin) -> TIMESTAMP
        - main.time_bucket(INTERVAL bucket_width, TIMESTAMP timestamp, TIMESTAMP origin) -> TIMESTAMP
        - main.time_bucket(INTERVAL bucket_width, TIMESTAMP WITH TIME ZONE timestamp, INTERVAL origin) -> TIMESTAMP WITH TIME ZONE
        - main.time_bucket(INTERVAL bucket_width, TIMESTAMP WITH TIME ZONE timestamp, TIMESTAMP WITH TIME ZONE origin) -> TIMESTAMP WITH TIME ZONE
        - main.time_bucket(INTERVAL bucket_width, TIMESTAMP WITH TIME ZONE timestamp, VARCHAR origin) -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._TIME_BUCKET_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TIMEZONE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Extract the timezone component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Extract the timezone component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Extract the timezone component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Extract the timezone component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('timezone')
    def timezone(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``timezone``.

        Extract the timezone component from a date or timestamp

        Overloads:
        - main.timezone(INTERVAL ts, TIME WITH TIME ZONE col1) -> TIME WITH TIME ZONE
        - main.timezone(VARCHAR ts, TIMESTAMP col1) -> TIMESTAMP WITH TIME ZONE
        - main.timezone(VARCHAR ts, TIMESTAMP WITH TIME ZONE col1) -> TIMESTAMP
        - main.timezone(VARCHAR ts, TIME WITH TIME ZONE col1) -> TIME WITH TIME ZONE
        """
        return call_duckdb_function(
            self._TIMEZONE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_TIMESTAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_timestamp',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('sec',),
                        varargs=None,
                        description='Converts secs since epoch to a timestamp with time zone',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_timestamp')
    def to_timestamp(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``to_timestamp``.

        Converts secs since epoch to a timestamp with time zone

        Overloads:
        - main.to_timestamp(DOUBLE sec) -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._TO_TIMESTAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TODAY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='today',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('today')
    def today(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``today``.

        Overloads:
        - main.today() -> DATE
        """
        return call_duckdb_function(
            self._TODAY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TRANSACTION_TIMESTAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='transaction_timestamp',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the current timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('transaction_timestamp')
    def transaction_timestamp(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``transaction_timestamp``.

        Returns the current timestamp

        Overloads:
        - main.transaction_timestamp() -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._TRANSACTION_TIMESTAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TRUNC_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('trunc')
    def trunc(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``trunc``.

        Truncates the number

        Overloads:
        - main.trunc(UHUGEINT x) -> UHUGEINT
        - main.trunc(UHUGEINT x, INTEGER col1) -> UHUGEINT
        """
        return call_duckdb_function(
            self._TRUNC_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TRY_STRPTIME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='try_strptime',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('text', 'format'),
                        varargs=None,
                        description='Converts the `string` text to timestamp according to the format string. Returns `NULL` on failure.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='try_strptime',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('text', 'format'),
                        varargs=None,
                        description='Converts the `string` text to timestamp according to the format string. Returns `NULL` on failure.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('try_strptime')
    def try_strptime(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``try_strptime``.

        Converts the `string` text to timestamp according to the format string. Returns `NULL` on failure.

        Overloads:
        - main.try_strptime(VARCHAR text, VARCHAR format) -> TIMESTAMP
        - main.try_strptime(VARCHAR text, VARCHAR[] format) -> TIMESTAMP
        """
        return call_duckdb_function(
            self._TRY_STRPTIME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UNION_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='union_extract',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('UNION'), parse_type('VARCHAR')),
                        parameters=('union', 'tag'),
                        varargs=None,
                        description='Extract the value with the named tags from the union. NULL if the tag is not currently selected',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('union_extract')
    def union_extract(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``union_extract``.

        Extract the value with the named tags from the union. NULL if the tag is not currently selected

        Overloads:
        - main.union_extract(UNION union, VARCHAR tag) -> ANY
        """
        return call_duckdb_function(
            self._UNION_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UNION_TAG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='union_tag',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('UNION'),),
                        parameters=('union',),
                        varargs=None,
                        description='Retrieve the currently selected tag of the union as an ENUM',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('union_tag')
    def union_tag(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``union_tag``.

        Retrieve the currently selected tag of the union as an ENUM

        Overloads:
        - main.union_tag(UNION union) -> ANY
        """
        return call_duckdb_function(
            self._UNION_TAG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UNION_VALUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='union_value',
                        function_type=function_type,
                        return_type=parse_type('UNION'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Create a single member UNION containing the argument value. The tag of the value will be the bound variable name',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('union_value')
    def union_value(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``union_value``.

        Create a single member UNION containing the argument value. The tag of the value will be the bound variable name

        Overloads:
        - main.union_value(ANY ...) -> UNION
        """
        return call_duckdb_function(
            self._UNION_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UNPIVOT_LIST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='unpivot_list',
                        function_type=function_type,
                        return_type=parse_type('LIST'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description='Identical to list_value, but generated as part of unpivot for better error messages.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('unpivot_list')
    def unpivot_list(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``unpivot_list``.

        Identical to list_value, but generated as part of unpivot for better error messages.

        Overloads:
        - main.unpivot_list(ANY ...) -> LIST
        """
        return call_duckdb_function(
            self._UNPIVOT_LIST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UUID_EXTRACT_TIMESTAMP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='uuid_extract_timestamp',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('UUID'),),
                        parameters=('uuid',),
                        varargs=None,
                        description='Extract the timestamp for the given UUID v7.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('uuid_extract_timestamp')
    def uuid_extract_timestamp(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``uuid_extract_timestamp``.

        Extract the timestamp for the given UUID v7.

        Overloads:
        - main.uuid_extract_timestamp(UUID uuid) -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._UUID_EXTRACT_TIMESTAMP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _VARIANT_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='variant_extract',
                        function_type=function_type,
                        return_type=parse_type('VARIANT'),
                        parameter_types=(parse_type('VARIANT'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='variant_extract',
                        function_type=function_type,
                        return_type=parse_type('VARIANT'),
                        parameter_types=(parse_type('VARIANT'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('variant_extract')
    def variant_extract(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``variant_extract``.

        Overloads:
        - main.variant_extract(VARIANT col0, VARCHAR col1) -> VARIANT
        - main.variant_extract(VARIANT col0, UINTEGER col1) -> VARIANT
        """
        return call_duckdb_function(
            self._VARIANT_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _WRITE_LOG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='write_log',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=parse_type('ANY'),
                        description='Writes to the logger',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('write_log')
    def write_log(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``write_log``.

        Writes to the logger

        Overloads:
        - main.write_log(VARCHAR string, ANY ...) -> ANY
        """
        return call_duckdb_function(
            self._WRITE_LOG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _XOR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'), parse_type('BIT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('xor')
    def xor(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``xor``.

        Bitwise XOR

        Overloads:
        - main.xor(UHUGEINT left, UHUGEINT right) -> UHUGEINT
        - main.xor(BIT left, BIT right) -> BIT
        """
        return call_duckdb_function(
            self._XOR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0025_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('%',))
    def symbol_0025(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``%``.

        Overloads:
        - main.%(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        """
        return call_duckdb_function(
            self._0025_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0026_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'), parse_type('BIT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('&',))
    def symbol_0026(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``&``.

        Bitwise AND

        Overloads:
        - main.&(UHUGEINT left, UHUGEINT right) -> UHUGEINT
        - main.&(BIT left, BIT right) -> BIT
        """
        return call_duckdb_function(
            self._0026_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002a_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('*',))
    def symbol_002a(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``*``.

        Overloads:
        - main.*(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        """
        return call_duckdb_function(
            self._002a_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002b_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('ANY[]'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY[]'),
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('INTEGER'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('DATE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('TIME'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIME')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIME'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('DATE'), parse_type('TIME')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('DATE'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('BIGNUM'),
                        parameter_types=(parse_type('BIGNUM'), parse_type('BIGNUM')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('+',))
    def symbol_002b(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``+``.

        Overloads:
        - main.+(ANY[] ...) -> ANY[]
        - main.+(UHUGEINT col0) -> UHUGEINT
        - main.+(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        - main.+(DATE col0, INTEGER col1) -> DATE
        - main.+(INTEGER col0, DATE col1) -> DATE
        - main.+(DATE col0, INTERVAL col1) -> TIMESTAMP
        - main.+(INTERVAL col0, DATE col1) -> TIMESTAMP
        - main.+(TIME col0, INTERVAL col1) -> TIME
        - main.+(INTERVAL col0, TIME col1) -> TIME
        - main.+(TIMESTAMP col0, INTERVAL col1) -> TIMESTAMP
        - main.+(INTERVAL col0, TIMESTAMP col1) -> TIMESTAMP
        - main.+(TIME WITH TIME ZONE col0, INTERVAL col1) -> TIME WITH TIME ZONE
        - main.+(INTERVAL col0, TIME WITH TIME ZONE col1) -> TIME WITH TIME ZONE
        - main.+(TIME col0, DATE col1) -> TIMESTAMP
        - main.+(DATE col0, TIME col1) -> TIMESTAMP
        - main.+(TIME WITH TIME ZONE col0, DATE col1) -> TIMESTAMP WITH TIME ZONE
        - main.+(DATE col0, TIME WITH TIME ZONE col1) -> TIMESTAMP WITH TIME ZONE
        - main.+(BIGNUM col0, BIGNUM col1) -> BIGNUM
        - main.+(TIMESTAMP WITH TIME ZONE col0, INTERVAL col1) -> TIMESTAMP WITH TIME ZONE
        - main.+(INTERVAL col0, TIMESTAMP WITH TIME ZONE col1) -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._002b_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002d_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('BIGNUM'),
                        parameter_types=(parse_type('BIGNUM'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('BIGNUM'),
                        parameter_types=(parse_type('BIGNUM'), parse_type('BIGNUM')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('DATE'),
                        parameter_types=(parse_type('DATE'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('DATE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('TIME'),
                        parameter_types=(parse_type('TIME'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('TIME WITH TIME ZONE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('TIMESTAMP WITH TIME ZONE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('-',))
    def symbol_002d(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``-``.

        Overloads:
        - main.-(UHUGEINT col0) -> UHUGEINT
        - main.-(BIGNUM col0) -> BIGNUM
        - main.-(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        - main.-(BIGNUM col0, BIGNUM col1) -> BIGNUM
        - main.-(DATE col0, INTEGER col1) -> DATE
        - main.-(DATE col0, INTERVAL col1) -> TIMESTAMP
        - main.-(TIME col0, INTERVAL col1) -> TIME
        - main.-(TIMESTAMP col0, INTERVAL col1) -> TIMESTAMP
        - main.-(TIME WITH TIME ZONE col0, INTERVAL col1) -> TIME WITH TIME ZONE
        - main.-(TIMESTAMP WITH TIME ZONE col0, INTERVAL col1) -> TIMESTAMP WITH TIME ZONE
        """
        return call_duckdb_function(
            self._002d_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002f_002f_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('//',))
    def symbol_002f_002f(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``//``.

        Overloads:
        - main.//(UHUGEINT col0, UHUGEINT col1) -> UHUGEINT
        """
        return call_duckdb_function(
            self._002f_002f_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _003c_003c_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'), parse_type('INTEGER')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('<<',))
    def symbol_003c_003c(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``<<``.

        Bitwise shift left

        Overloads:
        - main.<<(UHUGEINT input, UHUGEINT col1) -> UHUGEINT
        - main.<<(BIT input, INTEGER col1) -> BIT
        """
        return call_duckdb_function(
            self._003c_003c_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _003e_003e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'), parse_type('INTEGER')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('>>',))
    def symbol_003e_003e(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``>>``.

        Bitwise shift right

        Overloads:
        - main.>>(UHUGEINT input, UHUGEINT col1) -> UHUGEINT
        - main.>>(BIT input, INTEGER col1) -> BIT
        """
        return call_duckdb_function(
            self._003e_003e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0040_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('@',))
    def symbol_0040(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``@``.

        Absolute value

        Overloads:
        - main.@(UHUGEINT x) -> UHUGEINT
        """
        return call_duckdb_function(
            self._0040_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _007c_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'), parse_type('BIT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('|',))
    def symbol_007c(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``|``.

        Bitwise OR

        Overloads:
        - main.|(UHUGEINT left, UHUGEINT right) -> UHUGEINT
        - main.|(BIT left, BIT right) -> BIT
        """
        return call_duckdb_function(
            self._007c_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _007c_007c_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='||',
                        function_type=function_type,
                        return_type=parse_type('ANY'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('arg1', 'arg2'),
                        varargs=None,
                        description='Concatenates two strings, lists, or blobs. Any `NULL` input results in `NULL`. See also `concat(arg1, arg2, ...)` and `list_concat(list1, list2, ...)`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('||',))
    def symbol_007c_007c(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``||``.

        Concatenates two strings, lists, or blobs. Any `NULL` input results in `NULL`. See also `concat(arg1, arg2, ...)` and `list_concat(list1, list2, ...)`.

        Overloads:
        - main.||(ANY arg1, ANY arg2) -> ANY
        """
        return call_duckdb_function(
            self._007c_007c_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _007e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('UHUGEINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('BIT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('~',))
    def symbol_007e(self, *operands: object) -> TypedExpression:
        """Call DuckDB function ``~``.

        Bitwise NOT

        Overloads:
        - main.~(UHUGEINT input) -> UHUGEINT
        - main.~(BIT input) -> BIT
        """
        return call_duckdb_function(
            self._007e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        '__internal_compress_string_uhugeint': '__internal_compress_string_uhugeint',
        '__internal_decompress_integral_uhugeint': '__internal_decompress_integral_uhugeint',
        'abs': 'abs',
        'add': 'add',
        'aggregate': 'aggregate',
        'apply': 'apply',
        'array_aggr': 'array_aggr',
        'array_aggregate': 'array_aggregate',
        'array_append': 'array_append',
        'array_apply': 'array_apply',
        'array_cat': 'array_cat',
        'array_concat': 'array_concat',
        'array_distinct': 'array_distinct',
        'array_extract': 'array_extract',
        'array_filter': 'array_filter',
        'array_grade_up': 'array_grade_up',
        'array_intersect': 'array_intersect',
        'array_pop_back': 'array_pop_back',
        'array_pop_front': 'array_pop_front',
        'array_prepend': 'array_prepend',
        'array_push_back': 'array_push_back',
        'array_push_front': 'array_push_front',
        'array_reduce': 'array_reduce',
        'array_resize': 'array_resize',
        'array_reverse': 'array_reverse',
        'array_reverse_sort': 'array_reverse_sort',
        'array_select': 'array_select',
        'array_slice': 'array_slice',
        'array_sort': 'array_sort',
        'array_transform': 'array_transform',
        'array_value': 'array_value',
        'array_where': 'array_where',
        'array_zip': 'array_zip',
        'bitstring': 'bitstring',
        'cast_to_type': 'cast_to_type',
        'col_description': 'col_description',
        'combine': 'combine',
        'concat': 'concat',
        'constant_or_null': 'constant_or_null',
        'current_date': 'current_date',
        'current_localtime': 'current_localtime',
        'current_localtimestamp': 'current_localtimestamp',
        'current_setting': 'current_setting',
        'date_part': 'date_part',
        'date_trunc': 'date_trunc',
        'datepart': 'datepart',
        'datetrunc': 'datetrunc',
        'divide': 'divide',
        'element_at': 'element_at',
        'enum_code': 'enum_code',
        'epoch_ms': 'epoch_ms',
        'equi_width_bins': 'equi_width_bins',
        'error': 'error',
        'filter': 'filter',
        'finalize': 'finalize',
        'flatten': 'flatten',
        'from_json': 'from_json',
        'from_json_strict': 'from_json_strict',
        'generate_series': 'generate_series',
        'generate_subscripts': 'generate_subscripts',
        'get_current_time': 'get_current_time',
        'get_current_timestamp': 'get_current_timestamp',
        'getvariable': 'getvariable',
        'grade_up': 'grade_up',
        'greatest': 'greatest',
        'inet_client_addr': 'inet_client_addr',
        'inet_client_port': 'inet_client_port',
        'inet_server_addr': 'inet_server_addr',
        'inet_server_port': 'inet_server_port',
        'json_transform': 'json_transform',
        'json_transform_strict': 'json_transform_strict',
        'last_day': 'last_day',
        'least': 'least',
        'list_aggr': 'list_aggr',
        'list_aggregate': 'list_aggregate',
        'list_any_value': 'list_any_value',
        'list_append': 'list_append',
        'list_apply': 'list_apply',
        'list_approx_count_distinct': 'list_approx_count_distinct',
        'list_avg': 'list_avg',
        'list_bit_and': 'list_bit_and',
        'list_bit_or': 'list_bit_or',
        'list_bit_xor': 'list_bit_xor',
        'list_bool_and': 'list_bool_and',
        'list_bool_or': 'list_bool_or',
        'list_cat': 'list_cat',
        'list_concat': 'list_concat',
        'list_count': 'list_count',
        'list_distinct': 'list_distinct',
        'list_element': 'list_element',
        'list_entropy': 'list_entropy',
        'list_extract': 'list_extract',
        'list_filter': 'list_filter',
        'list_first': 'list_first',
        'list_grade_up': 'list_grade_up',
        'list_histogram': 'list_histogram',
        'list_intersect': 'list_intersect',
        'list_kurtosis': 'list_kurtosis',
        'list_kurtosis_pop': 'list_kurtosis_pop',
        'list_last': 'list_last',
        'list_mad': 'list_mad',
        'list_max': 'list_max',
        'list_median': 'list_median',
        'list_min': 'list_min',
        'list_mode': 'list_mode',
        'list_pack': 'list_pack',
        'list_prepend': 'list_prepend',
        'list_product': 'list_product',
        'list_reduce': 'list_reduce',
        'list_resize': 'list_resize',
        'list_reverse': 'list_reverse',
        'list_reverse_sort': 'list_reverse_sort',
        'list_select': 'list_select',
        'list_sem': 'list_sem',
        'list_skewness': 'list_skewness',
        'list_slice': 'list_slice',
        'list_sort': 'list_sort',
        'list_stddev_pop': 'list_stddev_pop',
        'list_stddev_samp': 'list_stddev_samp',
        'list_string_agg': 'list_string_agg',
        'list_sum': 'list_sum',
        'list_transform': 'list_transform',
        'list_value': 'list_value',
        'list_var_pop': 'list_var_pop',
        'list_var_samp': 'list_var_samp',
        'list_where': 'list_where',
        'list_zip': 'list_zip',
        'make_date': 'make_date',
        'make_time': 'make_time',
        'make_timestamp': 'make_timestamp',
        'make_timestamp_ms': 'make_timestamp_ms',
        'make_timestamp_ns': 'make_timestamp_ns',
        'make_timestamptz': 'make_timestamptz',
        'map': 'map',
        'map_concat': 'map_concat',
        'map_entries': 'map_entries',
        'map_extract': 'map_extract',
        'map_extract_value': 'map_extract_value',
        'map_from_entries': 'map_from_entries',
        'map_keys': 'map_keys',
        'map_values': 'map_values',
        'md5_number': 'md5_number',
        'mod': 'mod',
        'multiply': 'multiply',
        'now': 'now',
        'nullif': 'nullif',
        'obj_description': 'obj_description',
        'parse_duckdb_log_message': 'parse_duckdb_log_message',
        'pg_conf_load_time': 'pg_conf_load_time',
        'pg_get_expr': 'pg_get_expr',
        'pg_postmaster_start_time': 'pg_postmaster_start_time',
        'range': 'range',
        'reduce': 'reduce',
        'regexp_split_to_table': 'regexp_split_to_table',
        'remap_struct': 'remap_struct',
        'repeat': 'repeat',
        'replace_type': 'replace_type',
        'row': 'row',
        'set_bit': 'set_bit',
        'setseed': 'setseed',
        'shobj_description': 'shobj_description',
        'strptime': 'strptime',
        'struct_concat': 'struct_concat',
        'struct_extract': 'struct_extract',
        'struct_extract_at': 'struct_extract_at',
        'struct_insert': 'struct_insert',
        'struct_pack': 'struct_pack',
        'struct_update': 'struct_update',
        'subtract': 'subtract',
        'time_bucket': 'time_bucket',
        'timezone': 'timezone',
        'to_timestamp': 'to_timestamp',
        'today': 'today',
        'transaction_timestamp': 'transaction_timestamp',
        'trunc': 'trunc',
        'try_strptime': 'try_strptime',
        'union_extract': 'union_extract',
        'union_tag': 'union_tag',
        'union_value': 'union_value',
        'unpivot_list': 'unpivot_list',
        'uuid_extract_timestamp': 'uuid_extract_timestamp',
        'variant_extract': 'variant_extract',
        'write_log': 'write_log',
        'xor': 'xor',
    }

    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {
        '%': 'symbol_0025',
        '&': 'symbol_0026',
        '*': 'symbol_002a',
        '+': 'symbol_002b',
        '-': 'symbol_002d',
        '//': 'symbol_002f_002f',
        '<<': 'symbol_003c_003c',
        '>>': 'symbol_003e_003e',
        '@': 'symbol_0040',
        '|': 'symbol_007c',
        '||': 'symbol_007c_007c',
        '~': 'symbol_007e',
    }

class ScalarNumericFunctions(_StaticFunctionNamespace):
    """DuckDB scalar functions returning numeric results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'scalar'
    return_category: ClassVar[str] = 'numeric'
    ___INTERNAL_COMPRESS_INTEGRAL_UBIGINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_ubigint',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_ubigint',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_integral_ubigint')
    def __internal_compress_integral_ubigint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_compress_integral_ubigint``.

        Overloads:
        - main.__internal_compress_integral_ubigint(HUGEINT col0, HUGEINT col1) -> UBIGINT
        - main.__internal_compress_integral_ubigint(UHUGEINT col0, UHUGEINT col1) -> UBIGINT
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_INTEGRAL_UBIGINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_COMPRESS_INTEGRAL_UINTEGER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_uinteger',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_uinteger',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_uinteger',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_uinteger',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_integral_uinteger')
    def __internal_compress_integral_uinteger(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_compress_integral_uinteger``.

        Overloads:
        - main.__internal_compress_integral_uinteger(BIGINT col0, BIGINT col1) -> UINTEGER
        - main.__internal_compress_integral_uinteger(HUGEINT col0, HUGEINT col1) -> UINTEGER
        - main.__internal_compress_integral_uinteger(UBIGINT col0, UBIGINT col1) -> UINTEGER
        - main.__internal_compress_integral_uinteger(UHUGEINT col0, UHUGEINT col1) -> UINTEGER
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_INTEGRAL_UINTEGER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_COMPRESS_INTEGRAL_USMALLINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_usmallint',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_usmallint',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_usmallint',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_usmallint',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_usmallint',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_usmallint',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_integral_usmallint')
    def __internal_compress_integral_usmallint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_compress_integral_usmallint``.

        Overloads:
        - main.__internal_compress_integral_usmallint(INTEGER col0, INTEGER col1) -> USMALLINT
        - main.__internal_compress_integral_usmallint(BIGINT col0, BIGINT col1) -> USMALLINT
        - main.__internal_compress_integral_usmallint(HUGEINT col0, HUGEINT col1) -> USMALLINT
        - main.__internal_compress_integral_usmallint(UINTEGER col0, UINTEGER col1) -> USMALLINT
        - main.__internal_compress_integral_usmallint(UBIGINT col0, UBIGINT col1) -> USMALLINT
        - main.__internal_compress_integral_usmallint(UHUGEINT col0, UHUGEINT col1) -> USMALLINT
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_INTEGRAL_USMALLINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_COMPRESS_INTEGRAL_UTINYINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_utinyint',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_utinyint',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_utinyint',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_utinyint',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_utinyint',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_utinyint',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_utinyint',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_integral_utinyint',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UHUGEINT'), parse_type('UHUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_integral_utinyint')
    def __internal_compress_integral_utinyint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_compress_integral_utinyint``.

        Overloads:
        - main.__internal_compress_integral_utinyint(SMALLINT col0, SMALLINT col1) -> UTINYINT
        - main.__internal_compress_integral_utinyint(INTEGER col0, INTEGER col1) -> UTINYINT
        - main.__internal_compress_integral_utinyint(BIGINT col0, BIGINT col1) -> UTINYINT
        - main.__internal_compress_integral_utinyint(HUGEINT col0, HUGEINT col1) -> UTINYINT
        - main.__internal_compress_integral_utinyint(USMALLINT col0, USMALLINT col1) -> UTINYINT
        - main.__internal_compress_integral_utinyint(UINTEGER col0, UINTEGER col1) -> UTINYINT
        - main.__internal_compress_integral_utinyint(UBIGINT col0, UBIGINT col1) -> UTINYINT
        - main.__internal_compress_integral_utinyint(UHUGEINT col0, UHUGEINT col1) -> UTINYINT
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_INTEGRAL_UTINYINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_COMPRESS_STRING_HUGEINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_string_hugeint',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_string_hugeint')
    def __internal_compress_string_hugeint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_compress_string_hugeint``.

        Overloads:
        - main.__internal_compress_string_hugeint(VARCHAR col0) -> HUGEINT
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_STRING_HUGEINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_COMPRESS_STRING_UBIGINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_string_ubigint',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_string_ubigint')
    def __internal_compress_string_ubigint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_compress_string_ubigint``.

        Overloads:
        - main.__internal_compress_string_ubigint(VARCHAR col0) -> UBIGINT
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_STRING_UBIGINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_COMPRESS_STRING_UINTEGER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_string_uinteger',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_string_uinteger')
    def __internal_compress_string_uinteger(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_compress_string_uinteger``.

        Overloads:
        - main.__internal_compress_string_uinteger(VARCHAR col0) -> UINTEGER
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_STRING_UINTEGER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_COMPRESS_STRING_USMALLINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_string_usmallint',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_string_usmallint')
    def __internal_compress_string_usmallint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_compress_string_usmallint``.

        Overloads:
        - main.__internal_compress_string_usmallint(VARCHAR col0) -> USMALLINT
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_STRING_USMALLINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_COMPRESS_STRING_UTINYINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_compress_string_utinyint',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_compress_string_utinyint')
    def __internal_compress_string_utinyint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_compress_string_utinyint``.

        Overloads:
        - main.__internal_compress_string_utinyint(VARCHAR col0) -> UTINYINT
        """
        return call_duckdb_function(
            self.___INTERNAL_COMPRESS_STRING_UTINYINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_DECOMPRESS_INTEGRAL_BIGINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_bigint',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_bigint',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_bigint',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_decompress_integral_bigint')
    def __internal_decompress_integral_bigint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_decompress_integral_bigint``.

        Overloads:
        - main.__internal_decompress_integral_bigint(UTINYINT col0, BIGINT col1) -> BIGINT
        - main.__internal_decompress_integral_bigint(USMALLINT col0, BIGINT col1) -> BIGINT
        - main.__internal_decompress_integral_bigint(UINTEGER col0, BIGINT col1) -> BIGINT
        """
        return call_duckdb_function(
            self.___INTERNAL_DECOMPRESS_INTEGRAL_BIGINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_DECOMPRESS_INTEGRAL_HUGEINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_hugeint',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_hugeint',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_hugeint',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_hugeint',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_decompress_integral_hugeint')
    def __internal_decompress_integral_hugeint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_decompress_integral_hugeint``.

        Overloads:
        - main.__internal_decompress_integral_hugeint(UTINYINT col0, HUGEINT col1) -> HUGEINT
        - main.__internal_decompress_integral_hugeint(USMALLINT col0, HUGEINT col1) -> HUGEINT
        - main.__internal_decompress_integral_hugeint(UINTEGER col0, HUGEINT col1) -> HUGEINT
        - main.__internal_decompress_integral_hugeint(UBIGINT col0, HUGEINT col1) -> HUGEINT
        """
        return call_duckdb_function(
            self.___INTERNAL_DECOMPRESS_INTEGRAL_HUGEINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_DECOMPRESS_INTEGRAL_INTEGER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_integer',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_integer',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_decompress_integral_integer')
    def __internal_decompress_integral_integer(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_decompress_integral_integer``.

        Overloads:
        - main.__internal_decompress_integral_integer(UTINYINT col0, INTEGER col1) -> INTEGER
        - main.__internal_decompress_integral_integer(USMALLINT col0, INTEGER col1) -> INTEGER
        """
        return call_duckdb_function(
            self.___INTERNAL_DECOMPRESS_INTEGRAL_INTEGER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_DECOMPRESS_INTEGRAL_SMALLINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_smallint',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_decompress_integral_smallint')
    def __internal_decompress_integral_smallint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_decompress_integral_smallint``.

        Overloads:
        - main.__internal_decompress_integral_smallint(UTINYINT col0, SMALLINT col1) -> SMALLINT
        """
        return call_duckdb_function(
            self.___INTERNAL_DECOMPRESS_INTEGRAL_SMALLINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_DECOMPRESS_INTEGRAL_UBIGINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_ubigint',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_ubigint',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_ubigint',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_decompress_integral_ubigint')
    def __internal_decompress_integral_ubigint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_decompress_integral_ubigint``.

        Overloads:
        - main.__internal_decompress_integral_ubigint(UTINYINT col0, UBIGINT col1) -> UBIGINT
        - main.__internal_decompress_integral_ubigint(USMALLINT col0, UBIGINT col1) -> UBIGINT
        - main.__internal_decompress_integral_ubigint(UINTEGER col0, UBIGINT col1) -> UBIGINT
        """
        return call_duckdb_function(
            self.___INTERNAL_DECOMPRESS_INTEGRAL_UBIGINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_DECOMPRESS_INTEGRAL_UINTEGER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_uinteger',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_uinteger',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_decompress_integral_uinteger')
    def __internal_decompress_integral_uinteger(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_decompress_integral_uinteger``.

        Overloads:
        - main.__internal_decompress_integral_uinteger(UTINYINT col0, UINTEGER col1) -> UINTEGER
        - main.__internal_decompress_integral_uinteger(USMALLINT col0, UINTEGER col1) -> UINTEGER
        """
        return call_duckdb_function(
            self.___INTERNAL_DECOMPRESS_INTEGRAL_UINTEGER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    ___INTERNAL_DECOMPRESS_INTEGRAL_USMALLINT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_integral_usmallint',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_decompress_integral_usmallint')
    def __internal_decompress_integral_usmallint(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``__internal_decompress_integral_usmallint``.

        Overloads:
        - main.__internal_decompress_integral_usmallint(UTINYINT col0, USMALLINT col1) -> USMALLINT
        """
        return call_duckdb_function(
            self.___INTERNAL_DECOMPRESS_INTEGRAL_USMALLINT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ABS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='abs',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('abs')
    def abs(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``abs``.

        Absolute value

        Overloads:
        - main.abs(TINYINT x) -> TINYINT
        - main.abs(SMALLINT x) -> SMALLINT
        - main.abs(INTEGER x) -> INTEGER
        - main.abs(BIGINT x) -> BIGINT
        - main.abs(HUGEINT x) -> HUGEINT
        - main.abs(FLOAT x) -> FLOAT
        - main.abs(DOUBLE x) -> DOUBLE
        - main.abs(DECIMAL x) -> DECIMAL
        - main.abs(UTINYINT x) -> UTINYINT
        - main.abs(USMALLINT x) -> USMALLINT
        - main.abs(UINTEGER x) -> UINTEGER
        - main.abs(UBIGINT x) -> UBIGINT
        """
        return call_duckdb_function(
            self._ABS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ACOS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='acos',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the arccosine of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('acos')
    def acos(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``acos``.

        Computes the arccosine of x

        Overloads:
        - main.acos(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._ACOS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ACOSH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='acosh',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the inverse hyperbolic cos of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('acosh')
    def acosh(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``acosh``.

        Computes the inverse hyperbolic cos of x

        Overloads:
        - main.acosh(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._ACOSH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ADD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DECIMAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='add',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('add')
    def add(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``add``.

        Overloads:
        - main.add(TINYINT col0) -> TINYINT
        - main.add(SMALLINT col0) -> SMALLINT
        - main.add(INTEGER col0) -> INTEGER
        - main.add(BIGINT col0) -> BIGINT
        - main.add(HUGEINT col0) -> HUGEINT
        - main.add(FLOAT col0) -> FLOAT
        - main.add(DOUBLE col0) -> DOUBLE
        - main.add(DECIMAL col0) -> DECIMAL
        - main.add(UTINYINT col0) -> UTINYINT
        - main.add(USMALLINT col0) -> USMALLINT
        - main.add(UINTEGER col0) -> UINTEGER
        - main.add(UBIGINT col0) -> UBIGINT
        - main.add(TINYINT col0, TINYINT col1) -> TINYINT
        - main.add(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.add(INTEGER col0, INTEGER col1) -> INTEGER
        - main.add(BIGINT col0, BIGINT col1) -> BIGINT
        - main.add(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.add(FLOAT col0, FLOAT col1) -> FLOAT
        - main.add(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.add(DECIMAL col0, DECIMAL col1) -> DECIMAL
        - main.add(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.add(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.add(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.add(UBIGINT col0, UBIGINT col1) -> UBIGINT
        - main.add(INTERVAL col0, INTERVAL col1) -> INTERVAL
        """
        return call_duckdb_function(
            self._ADD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _AGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='age',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('timestamp',),
                        varargs=None,
                        description='Subtract arguments, resulting in the time difference between the two timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='age',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('timestamp',),
                        varargs=None,
                        description='Subtract arguments, resulting in the time difference between the two timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='age',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('timestamp', 'timestamp'),
                        varargs=None,
                        description='Subtract arguments, resulting in the time difference between the two timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='age',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('timestamp', 'timestamp'),
                        varargs=None,
                        description='Subtract arguments, resulting in the time difference between the two timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('age')
    def age(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``age``.

        Subtract arguments, resulting in the time difference between the two timestamps

        Overloads:
        - main.age(TIMESTAMP timestamp) -> INTERVAL
        - main.age(TIMESTAMP WITH TIME ZONE timestamp) -> INTERVAL
        - main.age(TIMESTAMP timestamp, TIMESTAMP timestamp) -> INTERVAL
        - main.age(TIMESTAMP WITH TIME ZONE timestamp, TIMESTAMP WITH TIME ZONE timestamp) -> INTERVAL
        """
        return call_duckdb_function(
            self._AGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_COSINE_DISTANCE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_cosine_distance',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[ANY]'), parse_type('FLOAT[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the cosine distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_cosine_distance',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[ANY]'), parse_type('DOUBLE[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the cosine distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_cosine_distance')
    def array_cosine_distance(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_cosine_distance``.

        Computes the cosine distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.

        Overloads:
        - main.array_cosine_distance(FLOAT[ANY] array1, FLOAT[ANY] array2) -> FLOAT
        - main.array_cosine_distance(DOUBLE[ANY] array1, DOUBLE[ANY] array2) -> DOUBLE
        """
        return call_duckdb_function(
            self._ARRAY_COSINE_DISTANCE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_COSINE_SIMILARITY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_cosine_similarity',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[ANY]'), parse_type('FLOAT[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the cosine similarity between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_cosine_similarity',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[ANY]'), parse_type('DOUBLE[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the cosine similarity between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_cosine_similarity')
    def array_cosine_similarity(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_cosine_similarity``.

        Computes the cosine similarity between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.

        Overloads:
        - main.array_cosine_similarity(FLOAT[ANY] array1, FLOAT[ANY] array2) -> FLOAT
        - main.array_cosine_similarity(DOUBLE[ANY] array1, DOUBLE[ANY] array2) -> DOUBLE
        """
        return call_duckdb_function(
            self._ARRAY_COSINE_SIMILARITY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_CROSS_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_cross_product',
                        function_type=function_type,
                        return_type=parse_type('FLOAT[3]'),
                        parameter_types=(parse_type('FLOAT[3]'), parse_type('FLOAT[3]')),
                        parameters=('array', 'array'),
                        varargs=None,
                        description='Computes the cross product of two arrays of size 3. The array elements can not be `NULL`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_cross_product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE[3]'),
                        parameter_types=(parse_type('DOUBLE[3]'), parse_type('DOUBLE[3]')),
                        parameters=('array', 'array'),
                        varargs=None,
                        description='Computes the cross product of two arrays of size 3. The array elements can not be `NULL`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_cross_product')
    def array_cross_product(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_cross_product``.

        Computes the cross product of two arrays of size 3. The array elements can not be `NULL`.

        Overloads:
        - main.array_cross_product(FLOAT[3] array, FLOAT[3] array) -> FLOAT[3]
        - main.array_cross_product(DOUBLE[3] array, DOUBLE[3] array) -> DOUBLE[3]
        """
        return call_duckdb_function(
            self._ARRAY_CROSS_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_DISTANCE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_distance',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[ANY]'), parse_type('FLOAT[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_distance',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[ANY]'), parse_type('DOUBLE[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_distance')
    def array_distance(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_distance``.

        Computes the distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.

        Overloads:
        - main.array_distance(FLOAT[ANY] array1, FLOAT[ANY] array2) -> FLOAT
        - main.array_distance(DOUBLE[ANY] array1, DOUBLE[ANY] array2) -> DOUBLE
        """
        return call_duckdb_function(
            self._ARRAY_DISTANCE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_DOT_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_dot_product',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[ANY]'), parse_type('FLOAT[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_dot_product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[ANY]'), parse_type('DOUBLE[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_dot_product')
    def array_dot_product(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_dot_product``.

        Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.

        Overloads:
        - main.array_dot_product(FLOAT[ANY] array1, FLOAT[ANY] array2) -> FLOAT
        - main.array_dot_product(DOUBLE[ANY] array1, DOUBLE[ANY] array2) -> DOUBLE
        """
        return call_duckdb_function(
            self._ARRAY_DOT_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_INDEXOF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_indexof',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('T[]'), parse_type('T')),
                        parameters=('list', 'element'),
                        varargs=None,
                        description='Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_indexof')
    def array_indexof(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_indexof``.

        Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.

        Overloads:
        - main.array_indexof(T[] list, T element) -> INTEGER
        """
        return call_duckdb_function(
            self._ARRAY_INDEXOF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_INNER_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_inner_product',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[ANY]'), parse_type('FLOAT[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_inner_product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[ANY]'), parse_type('DOUBLE[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_inner_product')
    def array_inner_product(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_inner_product``.

        Computes the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.

        Overloads:
        - main.array_inner_product(FLOAT[ANY] array1, FLOAT[ANY] array2) -> FLOAT
        - main.array_inner_product(DOUBLE[ANY] array1, DOUBLE[ANY] array2) -> DOUBLE
        """
        return call_duckdb_function(
            self._ARRAY_INNER_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_LENGTH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Returns the length of the `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('ANY[]'), parse_type('BIGINT')),
                        parameters=('list', 'dimension'),
                        varargs=None,
                        description='`array_length` for lists with dimensions other than 1 not implemented',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_length')
    def array_length(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_length``.

        Returns the length of the `list`.

        Overloads:
        - main.array_length(ANY[] list) -> BIGINT
        - main.array_length(ANY[] list, BIGINT dimension) -> BIGINT
        """
        return call_duckdb_function(
            self._ARRAY_LENGTH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_NEGATIVE_DOT_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_negative_dot_product',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[ANY]'), parse_type('FLOAT[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_negative_dot_product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[ANY]'), parse_type('DOUBLE[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_negative_dot_product')
    def array_negative_dot_product(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_negative_dot_product``.

        Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.

        Overloads:
        - main.array_negative_dot_product(FLOAT[ANY] array1, FLOAT[ANY] array2) -> FLOAT
        - main.array_negative_dot_product(DOUBLE[ANY] array1, DOUBLE[ANY] array2) -> DOUBLE
        """
        return call_duckdb_function(
            self._ARRAY_NEGATIVE_DOT_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_NEGATIVE_INNER_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_negative_inner_product',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[ANY]'), parse_type('FLOAT[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_negative_inner_product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[ANY]'), parse_type('DOUBLE[ANY]')),
                        parameters=('array1', 'array2'),
                        varargs=None,
                        description='Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_negative_inner_product')
    def array_negative_inner_product(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_negative_inner_product``.

        Computes the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments.

        Overloads:
        - main.array_negative_inner_product(FLOAT[ANY] array1, FLOAT[ANY] array2) -> FLOAT
        - main.array_negative_inner_product(DOUBLE[ANY] array1, DOUBLE[ANY] array2) -> DOUBLE
        """
        return call_duckdb_function(
            self._ARRAY_NEGATIVE_INNER_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_POSITION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_position',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('T[]'), parse_type('T')),
                        parameters=('list', 'element'),
                        varargs=None,
                        description='Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_position')
    def array_position(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_position``.

        Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.

        Overloads:
        - main.array_position(T[] list, T element) -> INTEGER
        """
        return call_duckdb_function(
            self._ARRAY_POSITION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_UNIQUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_unique',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Counts the unique elements of a `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_unique')
    def array_unique(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``array_unique``.

        Counts the unique elements of a `list`.

        Overloads:
        - main.array_unique(ANY[] list) -> UBIGINT
        """
        return call_duckdb_function(
            self._ARRAY_UNIQUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ASCII_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ascii',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Returns an integer that represents the Unicode code point of the first character of the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('ascii')
    def ascii(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``ascii``.

        Returns an integer that represents the Unicode code point of the first character of the `string`.

        Overloads:
        - main.ascii(VARCHAR string) -> INTEGER
        """
        return call_duckdb_function(
            self._ASCII_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ASIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='asin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the arcsine of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('asin')
    def asin(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``asin``.

        Computes the arcsine of x

        Overloads:
        - main.asin(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._ASIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ASINH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='asinh',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the inverse hyperbolic sin of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('asinh')
    def asinh(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``asinh``.

        Computes the inverse hyperbolic sin of x

        Overloads:
        - main.asinh(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._ASINH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ATAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='atan',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the arctangent of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('atan')
    def atan(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``atan``.

        Computes the arctangent of x

        Overloads:
        - main.atan(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._ATAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ATAN2_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='atan2',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('y', 'x'),
                        varargs=None,
                        description='Computes the arctangent (y, x)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('atan2')
    def atan2(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``atan2``.

        Computes the arctangent (y, x)

        Overloads:
        - main.atan2(DOUBLE y, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._ATAN2_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ATANH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='atanh',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the inverse hyperbolic tan of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('atanh')
    def atanh(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``atanh``.

        Computes the inverse hyperbolic tan of x

        Overloads:
        - main.atanh(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._ATANH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _BIT_COUNT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_count',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the number of bits that are set',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_count',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the number of bits that are set',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_count',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the number of bits that are set',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_count',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the number of bits that are set',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_count',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the number of bits that are set',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_count',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the number of bits that are set',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bit_count')
    def bit_count(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``bit_count``.

        Returns the number of bits that are set

        Overloads:
        - main.bit_count(TINYINT x) -> TINYINT
        - main.bit_count(SMALLINT x) -> TINYINT
        - main.bit_count(INTEGER x) -> TINYINT
        - main.bit_count(BIGINT x) -> TINYINT
        - main.bit_count(HUGEINT x) -> TINYINT
        - main.bit_count(BIT x) -> BIGINT
        """
        return call_duckdb_function(
            self._BIT_COUNT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _BIT_LENGTH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Number of bits in a `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('bit',),
                        varargs=None,
                        description='Returns the bit-length of the `bit` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bit_length')
    def bit_length(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``bit_length``.

        Number of bits in a `string`.

        Overloads:
        - main.bit_length(VARCHAR string) -> BIGINT
        - main.bit_length(BIT bit) -> BIGINT
        """
        return call_duckdb_function(
            self._BIT_LENGTH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _BIT_POSITION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bit_position',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('BIT'), parse_type('BIT')),
                        parameters=('substring', 'bitstring'),
                        varargs=None,
                        description='Returns first starting index of the specified substring within bits, or zero if it is not present. The first (leftmost) bit is indexed 1',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bit_position')
    def bit_position(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``bit_position``.

        Returns first starting index of the specified substring within bits, or zero if it is not present. The first (leftmost) bit is indexed 1

        Overloads:
        - main.bit_position(BIT substring, BIT bitstring) -> INTEGER
        """
        return call_duckdb_function(
            self._BIT_POSITION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CARDINALITY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='cardinality',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('map',),
                        varargs=parse_type('ANY'),
                        description='Returns the size of the map (or the number of entries in the map)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('cardinality')
    def cardinality(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``cardinality``.

        Returns the size of the map (or the number of entries in the map)

        Overloads:
        - main.cardinality(ANY map, ANY ...) -> UBIGINT
        """
        return call_duckdb_function(
            self._CARDINALITY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CBRT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='cbrt',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the cube root of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('cbrt')
    def cbrt(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``cbrt``.

        Returns the cube root of x

        Overloads:
        - main.cbrt(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._CBRT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CEIL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ceil',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds the number up',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ceil',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds the number up',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ceil',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds the number up',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('ceil')
    def ceil(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``ceil``.

        Rounds the number up

        Overloads:
        - main.ceil(FLOAT x) -> FLOAT
        - main.ceil(DOUBLE x) -> DOUBLE
        - main.ceil(DECIMAL x) -> DECIMAL
        """
        return call_duckdb_function(
            self._CEIL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CEILING_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ceiling',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds the number up',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ceiling',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds the number up',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ceiling',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds the number up',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('ceiling')
    def ceiling(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``ceiling``.

        Rounds the number up

        Overloads:
        - main.ceiling(FLOAT x) -> FLOAT
        - main.ceiling(DOUBLE x) -> DOUBLE
        - main.ceiling(DECIMAL x) -> DECIMAL
        """
        return call_duckdb_function(
            self._CEILING_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CENTURY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='century',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the century component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='century',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the century component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='century',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the century component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='century',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the century component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('century')
    def century(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``century``.

        Extract the century component from a date or timestamp

        Overloads:
        - main.century(DATE ts) -> BIGINT
        - main.century(INTERVAL ts) -> BIGINT
        - main.century(TIMESTAMP ts) -> BIGINT
        - main.century(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._CENTURY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CHAR_LENGTH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='char_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Number of characters in `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='char_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('bit',),
                        varargs=None,
                        description='Returns the bit-length of the `bit` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='char_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Returns the length of the `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('char_length')
    def char_length(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``char_length``.

        Number of characters in `string`.

        Overloads:
        - main.char_length(VARCHAR string) -> BIGINT
        - main.char_length(BIT bit) -> BIGINT
        - main.char_length(ANY[] list) -> BIGINT
        """
        return call_duckdb_function(
            self._CHAR_LENGTH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CHARACTER_LENGTH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='character_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Number of characters in `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='character_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('bit',),
                        varargs=None,
                        description='Returns the bit-length of the `bit` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='character_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Returns the length of the `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('character_length')
    def character_length(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``character_length``.

        Number of characters in `string`.

        Overloads:
        - main.character_length(VARCHAR string) -> BIGINT
        - main.character_length(BIT bit) -> BIGINT
        - main.character_length(ANY[] list) -> BIGINT
        """
        return call_duckdb_function(
            self._CHARACTER_LENGTH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _COS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='cos',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the cos of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('cos')
    def cos(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``cos``.

        Computes the cos of x

        Overloads:
        - main.cos(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._COS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _COSH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='cosh',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the hyperbolic cos of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('cosh')
    def cosh(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``cosh``.

        Computes the hyperbolic cos of x

        Overloads:
        - main.cosh(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._COSH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _COT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='cot',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the cotangent of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('cot')
    def cot(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``cot``.

        Computes the cotangent of x

        Overloads:
        - main.cot(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._COT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_CONNECTION_ID_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_connection_id',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Get the current connection_id',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('current_connection_id')
    def current_connection_id(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``current_connection_id``.

        Get the current connection_id

        Overloads:
        - main.current_connection_id() -> UBIGINT
        """
        return call_duckdb_function(
            self._CURRENT_CONNECTION_ID_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_QUERY_ID_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_query_id',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Get the current query_id',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('current_query_id')
    def current_query_id(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``current_query_id``.

        Get the current query_id

        Overloads:
        - main.current_query_id() -> UBIGINT
        """
        return call_duckdb_function(
            self._CURRENT_QUERY_ID_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_TRANSACTION_ID_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_transaction_id',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Get the current global transaction_id',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('current_transaction_id')
    def current_transaction_id(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``current_transaction_id``.

        Get the current global transaction_id

        Overloads:
        - main.current_transaction_id() -> UBIGINT
        """
        return call_duckdb_function(
            self._CURRENT_TRANSACTION_ID_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRVAL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='currval',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=("'sequence_name'",),
                        varargs=None,
                        description='Return the current value of the sequence. Note that nextval must be called at least once prior to calling currval.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('currval')
    def currval(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``currval``.

        Return the current value of the sequence. Note that nextval must be called at least once prior to calling currval.

        Overloads:
        - main.currval(VARCHAR 'sequence_name') -> BIGINT
        """
        return call_duckdb_function(
            self._CURRVAL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DAMERAU_LEVENSHTEIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='damerau_levenshtein',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('s1', 's2'),
                        varargs=None,
                        description='Extension of Levenshtein distance to also include transposition of adjacent characters as an allowed edit operation. In other words, the minimum number of edit operations (insertions, deletions, substitutions or transpositions) required to change one string to another. Characters of different cases (e.g., `a` and `A`) are considered different.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('damerau_levenshtein')
    def damerau_levenshtein(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``damerau_levenshtein``.

        Extension of Levenshtein distance to also include transposition of adjacent characters as an allowed edit operation. In other words, the minimum number of edit operations (insertions, deletions, substitutions or transpositions) required to change one string to another. Characters of different cases (e.g., `a` and `A`) are considered different.

        Overloads:
        - main.damerau_levenshtein(VARCHAR s1, VARCHAR s2) -> BIGINT
        """
        return call_duckdb_function(
            self._DAMERAU_LEVENSHTEIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATE_ADD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_add',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(None, None),
                        parameters=('date', 'interval'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='(date + "interval")',
                    ),
    )
    @duckdb_function('date_add')
    def date_add(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``date_add``.

        Overloads:
        - main.date_add(ANY date, ANY interval) -> BIGINT
        """
        return call_duckdb_function(
            self._DATE_ADD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATE_DIFF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_diff',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE'), parse_type('DATE')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of partition boundaries between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_diff',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME'), parse_type('TIME')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of partition boundaries between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_diff',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of partition boundaries between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_diff',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of partition boundaries between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('date_diff')
    def date_diff(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``date_diff``.

        The number of partition boundaries between the timestamps

        Overloads:
        - main.date_diff(VARCHAR part, DATE startdate, DATE enddate) -> BIGINT
        - main.date_diff(VARCHAR part, TIME startdate, TIME enddate) -> BIGINT
        - main.date_diff(VARCHAR part, TIMESTAMP startdate, TIMESTAMP enddate) -> BIGINT
        - main.date_diff(VARCHAR part, TIMESTAMP WITH TIME ZONE startdate, TIMESTAMP WITH TIME ZONE enddate) -> BIGINT
        """
        return call_duckdb_function(
            self._DATE_DIFF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATE_PART_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTERVAL')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME_NS')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_part',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('date_part')
    def date_part(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``date_part``.

        Get subfield (equivalent to extract)

        Overloads:
        - main.date_part(VARCHAR ts, DATE col1) -> BIGINT
        - main.date_part(VARCHAR ts, INTERVAL col1) -> BIGINT
        - main.date_part(VARCHAR ts, TIME col1) -> BIGINT
        - main.date_part(VARCHAR ts, TIMESTAMP col1) -> BIGINT
        - main.date_part(VARCHAR ts, TIME WITH TIME ZONE col1) -> BIGINT
        - main.date_part(VARCHAR ts, TIME_NS col1) -> BIGINT
        - main.date_part(VARCHAR ts, TIMESTAMP WITH TIME ZONE col1) -> BIGINT
        """
        return call_duckdb_function(
            self._DATE_PART_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATE_SUB_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_sub',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE'), parse_type('DATE')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of complete partitions between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_sub',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME'), parse_type('TIME')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of complete partitions between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_sub',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of complete partitions between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_sub',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of complete partitions between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('date_sub')
    def date_sub(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``date_sub``.

        The number of complete partitions between the timestamps

        Overloads:
        - main.date_sub(VARCHAR part, DATE startdate, DATE enddate) -> BIGINT
        - main.date_sub(VARCHAR part, TIME startdate, TIME enddate) -> BIGINT
        - main.date_sub(VARCHAR part, TIMESTAMP startdate, TIMESTAMP enddate) -> BIGINT
        - main.date_sub(VARCHAR part, TIMESTAMP WITH TIME ZONE startdate, TIMESTAMP WITH TIME ZONE enddate) -> BIGINT
        """
        return call_duckdb_function(
            self._DATE_SUB_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATE_TRUNC_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='date_trunc',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTERVAL')),
                        parameters=('part', 'timestamp'),
                        varargs=None,
                        description='Truncate to specified precision',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('date_trunc')
    def date_trunc(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``date_trunc``.

        Truncate to specified precision

        Overloads:
        - main.date_trunc(VARCHAR part, INTERVAL timestamp) -> INTERVAL
        """
        return call_duckdb_function(
            self._DATE_TRUNC_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATEDIFF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datediff',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE'), parse_type('DATE')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of partition boundaries between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datediff',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME'), parse_type('TIME')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of partition boundaries between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datediff',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of partition boundaries between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datediff',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of partition boundaries between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('datediff')
    def datediff(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``datediff``.

        The number of partition boundaries between the timestamps

        Overloads:
        - main.datediff(VARCHAR part, DATE startdate, DATE enddate) -> BIGINT
        - main.datediff(VARCHAR part, TIME startdate, TIME enddate) -> BIGINT
        - main.datediff(VARCHAR part, TIMESTAMP startdate, TIMESTAMP enddate) -> BIGINT
        - main.datediff(VARCHAR part, TIMESTAMP WITH TIME ZONE startdate, TIMESTAMP WITH TIME ZONE enddate) -> BIGINT
        """
        return call_duckdb_function(
            self._DATEDIFF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATEPART_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTERVAL')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME_NS')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datepart',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('ts', 'col1'),
                        varargs=None,
                        description='Get subfield (equivalent to extract)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('datepart')
    def datepart(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``datepart``.

        Get subfield (equivalent to extract)

        Overloads:
        - main.datepart(VARCHAR ts, DATE col1) -> BIGINT
        - main.datepart(VARCHAR ts, INTERVAL col1) -> BIGINT
        - main.datepart(VARCHAR ts, TIME col1) -> BIGINT
        - main.datepart(VARCHAR ts, TIMESTAMP col1) -> BIGINT
        - main.datepart(VARCHAR ts, TIME WITH TIME ZONE col1) -> BIGINT
        - main.datepart(VARCHAR ts, TIME_NS col1) -> BIGINT
        - main.datepart(VARCHAR ts, TIMESTAMP WITH TIME ZONE col1) -> BIGINT
        """
        return call_duckdb_function(
            self._DATEPART_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATESUB_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datesub',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE'), parse_type('DATE')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of complete partitions between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datesub',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIME'), parse_type('TIME')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of complete partitions between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datesub',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of complete partitions between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datesub',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('part', 'startdate', 'enddate'),
                        varargs=None,
                        description='The number of complete partitions between the timestamps',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('datesub')
    def datesub(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``datesub``.

        The number of complete partitions between the timestamps

        Overloads:
        - main.datesub(VARCHAR part, DATE startdate, DATE enddate) -> BIGINT
        - main.datesub(VARCHAR part, TIME startdate, TIME enddate) -> BIGINT
        - main.datesub(VARCHAR part, TIMESTAMP startdate, TIMESTAMP enddate) -> BIGINT
        - main.datesub(VARCHAR part, TIMESTAMP WITH TIME ZONE startdate, TIMESTAMP WITH TIME ZONE enddate) -> BIGINT
        """
        return call_duckdb_function(
            self._DATESUB_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DATETRUNC_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='datetrunc',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTERVAL')),
                        parameters=('part', 'timestamp'),
                        varargs=None,
                        description='Truncate to specified precision',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('datetrunc')
    def datetrunc(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``datetrunc``.

        Truncate to specified precision

        Overloads:
        - main.datetrunc(VARCHAR part, INTERVAL timestamp) -> INTERVAL
        """
        return call_duckdb_function(
            self._DATETRUNC_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DAY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='day',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the day component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='day',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the day component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='day',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the day component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='day',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the day component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('day')
    def day(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``day``.

        Extract the day component from a date or timestamp

        Overloads:
        - main.day(DATE ts) -> BIGINT
        - main.day(INTERVAL ts) -> BIGINT
        - main.day(TIMESTAMP ts) -> BIGINT
        - main.day(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._DAY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DAYOFMONTH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofmonth',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofmonth component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofmonth',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofmonth component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofmonth',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofmonth component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofmonth',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofmonth component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('dayofmonth')
    def dayofmonth(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``dayofmonth``.

        Extract the dayofmonth component from a date or timestamp

        Overloads:
        - main.dayofmonth(DATE ts) -> BIGINT
        - main.dayofmonth(INTERVAL ts) -> BIGINT
        - main.dayofmonth(TIMESTAMP ts) -> BIGINT
        - main.dayofmonth(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._DAYOFMONTH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DAYOFWEEK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofweek',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofweek component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofweek',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofweek component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofweek',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofweek component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofweek',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofweek component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('dayofweek')
    def dayofweek(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``dayofweek``.

        Extract the dayofweek component from a date or timestamp

        Overloads:
        - main.dayofweek(DATE ts) -> BIGINT
        - main.dayofweek(INTERVAL ts) -> BIGINT
        - main.dayofweek(TIMESTAMP ts) -> BIGINT
        - main.dayofweek(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._DAYOFWEEK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DAYOFYEAR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayofyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the dayofyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('dayofyear')
    def dayofyear(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``dayofyear``.

        Extract the dayofyear component from a date or timestamp

        Overloads:
        - main.dayofyear(DATE ts) -> BIGINT
        - main.dayofyear(INTERVAL ts) -> BIGINT
        - main.dayofyear(TIMESTAMP ts) -> BIGINT
        - main.dayofyear(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._DAYOFYEAR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DECADE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='decade',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the decade component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='decade',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the decade component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='decade',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the decade component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='decade',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the decade component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('decade')
    def decade(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``decade``.

        Extract the decade component from a date or timestamp

        Overloads:
        - main.decade(DATE ts) -> BIGINT
        - main.decade(INTERVAL ts) -> BIGINT
        - main.decade(TIMESTAMP ts) -> BIGINT
        - main.decade(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._DECADE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DEGREES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='degrees',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Converts radians to degrees',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('degrees')
    def degrees(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``degrees``.

        Converts radians to degrees

        Overloads:
        - main.degrees(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._DEGREES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DIVIDE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='divide',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('divide')
    def divide(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``divide``.

        Overloads:
        - main.divide(TINYINT col0, TINYINT col1) -> TINYINT
        - main.divide(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.divide(INTEGER col0, INTEGER col1) -> INTEGER
        - main.divide(BIGINT col0, BIGINT col1) -> BIGINT
        - main.divide(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.divide(FLOAT col0, FLOAT col1) -> FLOAT
        - main.divide(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.divide(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.divide(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.divide(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.divide(UBIGINT col0, UBIGINT col1) -> UBIGINT
        """
        return call_duckdb_function(
            self._DIVIDE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _EDITDIST3_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='editdist3',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('s1', 's2'),
                        varargs=None,
                        description='The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('editdist3')
    def editdist3(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``editdist3``.

        The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.

        Overloads:
        - main.editdist3(VARCHAR s1, VARCHAR s2) -> BIGINT
        """
        return call_duckdb_function(
            self._EDITDIST3_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _EPOCH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('epoch')
    def epoch(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``epoch``.

        Extract the epoch component from a temporal type

        Overloads:
        - main.epoch(DATE temporal) -> DOUBLE
        - main.epoch(INTERVAL temporal) -> DOUBLE
        - main.epoch(TIME temporal) -> DOUBLE
        - main.epoch(TIMESTAMP temporal) -> DOUBLE
        - main.epoch(TIME WITH TIME ZONE temporal) -> DOUBLE
        - main.epoch(TIME_NS temporal) -> DOUBLE
        - main.epoch(TIMESTAMP WITH TIME ZONE temporal) -> DOUBLE
        """
        return call_duckdb_function(
            self._EPOCH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _EPOCH_MS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ms',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in milliseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ms',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in milliseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ms',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in milliseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ms',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in milliseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ms',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in milliseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ms',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in milliseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ms',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in milliseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('epoch_ms')
    def epoch_ms(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``epoch_ms``.

        Extract the epoch component in milliseconds from a temporal type

        Overloads:
        - main.epoch_ms(DATE temporal) -> BIGINT
        - main.epoch_ms(TIMESTAMP temporal) -> BIGINT
        - main.epoch_ms(INTERVAL temporal) -> BIGINT
        - main.epoch_ms(TIME temporal) -> BIGINT
        - main.epoch_ms(TIME_NS temporal) -> BIGINT
        - main.epoch_ms(TIME WITH TIME ZONE temporal) -> BIGINT
        - main.epoch_ms(TIMESTAMP WITH TIME ZONE temporal) -> BIGINT
        """
        return call_duckdb_function(
            self._EPOCH_MS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _EPOCH_NS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ns',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in nanoseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ns',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in nanoseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ns',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in nanoseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ns',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in nanoseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ns',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in nanoseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ns',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in nanoseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ns',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in nanoseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_ns',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP_NS'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in nanoseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('epoch_ns')
    def epoch_ns(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``epoch_ns``.

        Extract the epoch component in nanoseconds from a temporal type

        Overloads:
        - main.epoch_ns(DATE temporal) -> BIGINT
        - main.epoch_ns(TIMESTAMP temporal) -> BIGINT
        - main.epoch_ns(INTERVAL temporal) -> BIGINT
        - main.epoch_ns(TIME temporal) -> BIGINT
        - main.epoch_ns(TIME_NS temporal) -> BIGINT
        - main.epoch_ns(TIME WITH TIME ZONE temporal) -> BIGINT
        - main.epoch_ns(TIMESTAMP WITH TIME ZONE temporal) -> BIGINT
        - main.epoch_ns(TIMESTAMP_NS temporal) -> BIGINT
        """
        return call_duckdb_function(
            self._EPOCH_NS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _EPOCH_US_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_us',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in microseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_us',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in microseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_us',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in microseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_us',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in microseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_us',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in microseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_us',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in microseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='epoch_us',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('temporal',),
                        varargs=None,
                        description='Extract the epoch component in microseconds from a temporal type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('epoch_us')
    def epoch_us(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``epoch_us``.

        Extract the epoch component in microseconds from a temporal type

        Overloads:
        - main.epoch_us(DATE temporal) -> BIGINT
        - main.epoch_us(TIMESTAMP temporal) -> BIGINT
        - main.epoch_us(INTERVAL temporal) -> BIGINT
        - main.epoch_us(TIME temporal) -> BIGINT
        - main.epoch_us(TIME_NS temporal) -> BIGINT
        - main.epoch_us(TIME WITH TIME ZONE temporal) -> BIGINT
        - main.epoch_us(TIMESTAMP WITH TIME ZONE temporal) -> BIGINT
        """
        return call_duckdb_function(
            self._EPOCH_US_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ERA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='era',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the era component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='era',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the era component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='era',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the era component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='era',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the era component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('era')
    def era(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``era``.

        Extract the era component from a date or timestamp

        Overloads:
        - main.era(DATE ts) -> BIGINT
        - main.era(INTERVAL ts) -> BIGINT
        - main.era(TIMESTAMP ts) -> BIGINT
        - main.era(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._ERA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _EVEN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='even',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds x to next even number by rounding away from zero',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('even')
    def even(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``even``.

        Rounds x to next even number by rounding away from zero

        Overloads:
        - main.even(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._EVEN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _EXP_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='exp',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes e to the power of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('exp')
    def exp(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``exp``.

        Computes e to the power of x

        Overloads:
        - main.exp(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._EXP_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FACTORIAL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='factorial',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Factorial of x. Computes the product of the current integer and all integers below it',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('factorial')
    def factorial(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``factorial``.

        Factorial of x. Computes the product of the current integer and all integers below it

        Overloads:
        - main.factorial(INTEGER x) -> HUGEINT
        """
        return call_duckdb_function(
            self._FACTORIAL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FDIV_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='fdiv',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(None, None),
                        parameters=('x', 'y'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='floor((x / y))',
                    ),
    )
    @duckdb_function('fdiv')
    def fdiv(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``fdiv``.

        Overloads:
        - main.fdiv(ANY x, ANY y) -> DOUBLE
        """
        return call_duckdb_function(
            self._FDIV_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FLOOR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='floor',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds the number down',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='floor',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds the number down',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='floor',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds the number down',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('floor')
    def floor(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``floor``.

        Rounds the number down

        Overloads:
        - main.floor(FLOAT x) -> FLOAT
        - main.floor(DOUBLE x) -> DOUBLE
        - main.floor(DECIMAL x) -> DECIMAL
        """
        return call_duckdb_function(
            self._FLOOR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FMOD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='fmod',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(None, None),
                        parameters=('x', 'y'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='(x - (y * floor((x / y))))',
                    ),
    )
    @duckdb_function('fmod')
    def fmod(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``fmod``.

        Overloads:
        - main.fmod(ANY x, ANY y) -> DOUBLE
        """
        return call_duckdb_function(
            self._FMOD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GAMMA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='gamma',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Interpolation of (x-1) factorial (so decimal inputs are allowed)',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('gamma')
    def gamma(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``gamma``.

        Interpolation of (x-1) factorial (so decimal inputs are allowed)

        Overloads:
        - main.gamma(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._GAMMA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GCD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='gcd',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes the greatest common divisor of x and y',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='gcd',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes the greatest common divisor of x and y',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('gcd')
    def gcd(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``gcd``.

        Computes the greatest common divisor of x and y

        Overloads:
        - main.gcd(BIGINT x, BIGINT y) -> BIGINT
        - main.gcd(HUGEINT x, HUGEINT y) -> HUGEINT
        """
        return call_duckdb_function(
            self._GCD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GENERATE_SERIES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='generate_series',
                        function_type=function_type,
                        return_type=parse_type('BIGINT[]'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('start',),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is inclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='generate_series',
                        function_type=function_type,
                        return_type=parse_type('BIGINT[]'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('start', 'stop'),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is inclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='generate_series',
                        function_type=function_type,
                        return_type=parse_type('BIGINT[]'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('start', 'stop', 'step'),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is inclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('generate_series')
    def generate_series(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``generate_series``.

        Creates a list of values between `start` and `stop` - the stop parameter is inclusive.

        Overloads:
        - main.generate_series(BIGINT start) -> BIGINT[]
        - main.generate_series(BIGINT start, BIGINT stop) -> BIGINT[]
        - main.generate_series(BIGINT start, BIGINT stop, BIGINT step) -> BIGINT[]
        """
        return call_duckdb_function(
            self._GENERATE_SERIES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GEOMEAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='geomean',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(None,),
                        parameters=('x',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='exp(avg(ln(x)))',
                    ),
    )
    @duckdb_function('geomean')
    def geomean(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``geomean``.

        Overloads:
        - main.geomean(ANY x) -> DOUBLE
        """
        return call_duckdb_function(
            self._GEOMEAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GEOMETRIC_MEAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='geometric_mean',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(None,),
                        parameters=('x',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='geomean(x)',
                    ),
    )
    @duckdb_function('geometric_mean')
    def geometric_mean(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``geometric_mean``.

        Overloads:
        - main.geometric_mean(ANY x) -> DOUBLE
        """
        return call_duckdb_function(
            self._GEOMETRIC_MEAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GET_BIT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='get_bit',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('BIT'), parse_type('INTEGER')),
                        parameters=('bitstring', 'index'),
                        varargs=None,
                        description='Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('get_bit')
    def get_bit(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``get_bit``.

        Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0

        Overloads:
        - main.get_bit(BIT bitstring, INTEGER index) -> INTEGER
        """
        return call_duckdb_function(
            self._GET_BIT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GET_BLOCK_SIZE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='get_block_size',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(None,),
                        parameters=('db_name',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='(SELECT block_size FROM pragma_database_size() WHERE (database_name = db_name))',
                    ),
    )
    @duckdb_function('get_block_size')
    def get_block_size(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``get_block_size``.

        Overloads:
        - main.get_block_size(ANY db_name) -> BIGINT
        """
        return call_duckdb_function(
            self._GET_BLOCK_SIZE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GREATEST_COMMON_DIVISOR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='greatest_common_divisor',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes the greatest common divisor of x and y',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='greatest_common_divisor',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes the greatest common divisor of x and y',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('greatest_common_divisor')
    def greatest_common_divisor(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``greatest_common_divisor``.

        Computes the greatest common divisor of x and y

        Overloads:
        - main.greatest_common_divisor(BIGINT x, BIGINT y) -> BIGINT
        - main.greatest_common_divisor(HUGEINT x, HUGEINT y) -> HUGEINT
        """
        return call_duckdb_function(
            self._GREATEST_COMMON_DIVISOR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HAMMING_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hamming',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('s1', 's2'),
                        varargs=None,
                        description='The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('hamming')
    def hamming(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``hamming``.

        The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.

        Overloads:
        - main.hamming(VARCHAR s1, VARCHAR s2) -> BIGINT
        """
        return call_duckdb_function(
            self._HAMMING_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HASH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hash',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('value',),
                        varargs=parse_type('ANY'),
                        description='Returns a `UBIGINT` with the hash of the `value`. Note that this is not a cryptographic hash.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('hash')
    def hash(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``hash``.

        Returns a `UBIGINT` with the hash of the `value`. Note that this is not a cryptographic hash.

        Overloads:
        - main.hash(ANY value, ANY ...) -> UBIGINT
        """
        return call_duckdb_function(
            self._HASH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HOUR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('hour')
    def hour(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``hour``.

        Extract the hour component from a date or timestamp

        Overloads:
        - main.hour(DATE ts) -> BIGINT
        - main.hour(INTERVAL ts) -> BIGINT
        - main.hour(TIME ts) -> BIGINT
        - main.hour(TIMESTAMP ts) -> BIGINT
        - main.hour(TIME WITH TIME ZONE ts) -> BIGINT
        - main.hour(TIME_NS ts) -> BIGINT
        - main.hour(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._HOUR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _INSTR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='instr',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'search_string'),
                        varargs=None,
                        description='Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('instr')
    def instr(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``instr``.

        Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.

        Overloads:
        - main.instr(VARCHAR string, VARCHAR search_string) -> BIGINT
        """
        return call_duckdb_function(
            self._INSTR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ISODOW_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isodow',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the isodow component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isodow',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the isodow component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isodow',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the isodow component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isodow',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the isodow component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('isodow')
    def isodow(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``isodow``.

        Extract the isodow component from a date or timestamp

        Overloads:
        - main.isodow(DATE ts) -> BIGINT
        - main.isodow(INTERVAL ts) -> BIGINT
        - main.isodow(TIMESTAMP ts) -> BIGINT
        - main.isodow(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._ISODOW_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ISOYEAR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isoyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the isoyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isoyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the isoyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isoyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the isoyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='isoyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the isoyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('isoyear')
    def isoyear(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``isoyear``.

        Extract the isoyear component from a date or timestamp

        Overloads:
        - main.isoyear(DATE ts) -> BIGINT
        - main.isoyear(INTERVAL ts) -> BIGINT
        - main.isoyear(TIMESTAMP ts) -> BIGINT
        - main.isoyear(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._ISOYEAR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JACCARD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='jaccard',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('s1', 's2'),
                        varargs=None,
                        description='The Jaccard similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('jaccard')
    def jaccard(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``jaccard``.

        The Jaccard similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1.

        Overloads:
        - main.jaccard(VARCHAR s1, VARCHAR s2) -> DOUBLE
        """
        return call_duckdb_function(
            self._JACCARD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JARO_SIMILARITY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='jaro_similarity',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('s1', 's2'),
                        varargs=None,
                        description='The Jaro similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='jaro_similarity',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('s1', 's2', 'score_cutoff'),
                        varargs=None,
                        description='The Jaro similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('jaro_similarity')
    def jaro_similarity(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``jaro_similarity``.

        The Jaro similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.

        Overloads:
        - main.jaro_similarity(VARCHAR s1, VARCHAR s2) -> DOUBLE
        - main.jaro_similarity(VARCHAR s1, VARCHAR s2, DOUBLE score_cutoff) -> DOUBLE
        """
        return call_duckdb_function(
            self._JARO_SIMILARITY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JARO_WINKLER_SIMILARITY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='jaro_winkler_similarity',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('s1', 's2'),
                        varargs=None,
                        description='The Jaro-Winkler similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='jaro_winkler_similarity',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('DOUBLE')),
                        parameters=('s1', 's2', 'score_cutoff'),
                        varargs=None,
                        description='The Jaro-Winkler similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('jaro_winkler_similarity')
    def jaro_winkler_similarity(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``jaro_winkler_similarity``.

        The Jaro-Winkler similarity between two strings. Characters of different cases (e.g., `a` and `A`) are considered different. Returns a number between 0 and 1. For similarity < `score_cutoff`, 0 is returned instead. `score_cutoff` defaults to 0.

        Overloads:
        - main.jaro_winkler_similarity(VARCHAR s1, VARCHAR s2) -> DOUBLE
        - main.jaro_winkler_similarity(VARCHAR s1, VARCHAR s2, DOUBLE score_cutoff) -> DOUBLE
        """
        return call_duckdb_function(
            self._JARO_WINKLER_SIMILARITY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_ARRAY_LENGTH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_array_length',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_array_length',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('JSON'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_array_length',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_array_length',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_array_length',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_array_length',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_array_length')
    def json_array_length(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``json_array_length``.

        Overloads:
        - main.json_array_length(VARCHAR col0) -> UBIGINT
        - main.json_array_length(JSON col0) -> UBIGINT
        - main.json_array_length(VARCHAR col0, VARCHAR col1) -> UBIGINT
        - main.json_array_length(VARCHAR col0, VARCHAR[] col1) -> UBIGINT[]
        - main.json_array_length(JSON col0, VARCHAR col1) -> UBIGINT
        - main.json_array_length(JSON col0, VARCHAR[] col1) -> UBIGINT[]
        """
        return call_duckdb_function(
            self._JSON_ARRAY_LENGTH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JULIAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='julian',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the Julian Day number from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='julian',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the Julian Day number from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='julian',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the Julian Day number from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('julian')
    def julian(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``julian``.

        Extract the Julian Day number from a date or timestamp

        Overloads:
        - main.julian(DATE ts) -> DOUBLE
        - main.julian(TIMESTAMP ts) -> DOUBLE
        - main.julian(TIMESTAMP WITH TIME ZONE ts) -> DOUBLE
        """
        return call_duckdb_function(
            self._JULIAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LCM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='lcm',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes the least common multiple of x and y',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='lcm',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes the least common multiple of x and y',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('lcm')
    def lcm(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``lcm``.

        Computes the least common multiple of x and y

        Overloads:
        - main.lcm(BIGINT x, BIGINT y) -> BIGINT
        - main.lcm(HUGEINT x, HUGEINT y) -> HUGEINT
        """
        return call_duckdb_function(
            self._LCM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LEAST_COMMON_MULTIPLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='least_common_multiple',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes the least common multiple of x and y',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='least_common_multiple',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes the least common multiple of x and y',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('least_common_multiple')
    def least_common_multiple(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``least_common_multiple``.

        Computes the least common multiple of x and y

        Overloads:
        - main.least_common_multiple(BIGINT x, BIGINT y) -> BIGINT
        - main.least_common_multiple(HUGEINT x, HUGEINT y) -> HUGEINT
        """
        return call_duckdb_function(
            self._LEAST_COMMON_MULTIPLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LEN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='len',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Number of characters in `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='len',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('bit',),
                        varargs=None,
                        description='Returns the bit-length of the `bit` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='len',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Returns the length of the `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('len')
    def len(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``len``.

        Number of characters in `string`.

        Overloads:
        - main.len(VARCHAR string) -> BIGINT
        - main.len(BIT bit) -> BIGINT
        - main.len(ANY[] list) -> BIGINT
        """
        return call_duckdb_function(
            self._LEN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LENGTH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Number of characters in `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('bit',),
                        varargs=None,
                        description='Returns the bit-length of the `bit` argument.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Returns the length of the `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('length')
    def length(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``length``.

        Number of characters in `string`.

        Overloads:
        - main.length(VARCHAR string) -> BIGINT
        - main.length(BIT bit) -> BIGINT
        - main.length(ANY[] list) -> BIGINT
        """
        return call_duckdb_function(
            self._LENGTH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LENGTH_GRAPHEME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='length_grapheme',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Number of grapheme clusters in `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('length_grapheme')
    def length_grapheme(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``length_grapheme``.

        Number of grapheme clusters in `string`.

        Overloads:
        - main.length_grapheme(VARCHAR string) -> BIGINT
        """
        return call_duckdb_function(
            self._LENGTH_GRAPHEME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LEVENSHTEIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='levenshtein',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('s1', 's2'),
                        varargs=None,
                        description='The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('levenshtein')
    def levenshtein(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``levenshtein``.

        The minimum number of single-character edits (insertions, deletions or substitutions) required to change one string to the other. Characters of different cases (e.g., `a` and `A`) are considered different.

        Overloads:
        - main.levenshtein(VARCHAR s1, VARCHAR s2) -> BIGINT
        """
        return call_duckdb_function(
            self._LEVENSHTEIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LGAMMA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='lgamma',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the log of the gamma function',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('lgamma')
    def lgamma(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``lgamma``.

        Computes the log of the gamma function

        Overloads:
        - main.lgamma(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._LGAMMA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_COSINE_DISTANCE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_cosine_distance',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[]'), parse_type('FLOAT[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the cosine distance between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_cosine_distance',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[]'), parse_type('DOUBLE[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the cosine distance between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_cosine_distance')
    def list_cosine_distance(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_cosine_distance``.

        Computes the cosine distance between two same-sized lists.

        Overloads:
        - main.list_cosine_distance(FLOAT[] list1, FLOAT[] list2) -> FLOAT
        - main.list_cosine_distance(DOUBLE[] list1, DOUBLE[] list2) -> DOUBLE
        """
        return call_duckdb_function(
            self._LIST_COSINE_DISTANCE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_COSINE_SIMILARITY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_cosine_similarity',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[]'), parse_type('FLOAT[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the cosine similarity between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_cosine_similarity',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[]'), parse_type('DOUBLE[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the cosine similarity between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_cosine_similarity')
    def list_cosine_similarity(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_cosine_similarity``.

        Computes the cosine similarity between two same-sized lists.

        Overloads:
        - main.list_cosine_similarity(FLOAT[] list1, FLOAT[] list2) -> FLOAT
        - main.list_cosine_similarity(DOUBLE[] list1, DOUBLE[] list2) -> DOUBLE
        """
        return call_duckdb_function(
            self._LIST_COSINE_SIMILARITY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_DISTANCE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_distance',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[]'), parse_type('FLOAT[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_distance',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[]'), parse_type('DOUBLE[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_distance')
    def list_distance(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_distance``.

        Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.

        Overloads:
        - main.list_distance(FLOAT[] list1, FLOAT[] list2) -> FLOAT
        - main.list_distance(DOUBLE[] list1, DOUBLE[] list2) -> DOUBLE
        """
        return call_duckdb_function(
            self._LIST_DISTANCE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_DOT_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_dot_product',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[]'), parse_type('FLOAT[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the inner product between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_dot_product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[]'), parse_type('DOUBLE[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the inner product between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_dot_product')
    def list_dot_product(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_dot_product``.

        Computes the inner product between two same-sized lists.

        Overloads:
        - main.list_dot_product(FLOAT[] list1, FLOAT[] list2) -> FLOAT
        - main.list_dot_product(DOUBLE[] list1, DOUBLE[] list2) -> DOUBLE
        """
        return call_duckdb_function(
            self._LIST_DOT_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_INDEXOF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_indexof',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('T[]'), parse_type('T')),
                        parameters=('list', 'element'),
                        varargs=None,
                        description='Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_indexof')
    def list_indexof(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_indexof``.

        Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.

        Overloads:
        - main.list_indexof(T[] list, T element) -> INTEGER
        """
        return call_duckdb_function(
            self._LIST_INDEXOF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_INNER_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_inner_product',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[]'), parse_type('FLOAT[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the inner product between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_inner_product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[]'), parse_type('DOUBLE[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the inner product between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_inner_product')
    def list_inner_product(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_inner_product``.

        Computes the inner product between two same-sized lists.

        Overloads:
        - main.list_inner_product(FLOAT[] list1, FLOAT[] list2) -> FLOAT
        - main.list_inner_product(DOUBLE[] list1, DOUBLE[] list2) -> DOUBLE
        """
        return call_duckdb_function(
            self._LIST_INNER_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_NEGATIVE_DOT_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_negative_dot_product',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[]'), parse_type('FLOAT[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the negative inner product between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_negative_dot_product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[]'), parse_type('DOUBLE[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the negative inner product between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_negative_dot_product')
    def list_negative_dot_product(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_negative_dot_product``.

        Computes the negative inner product between two same-sized lists.

        Overloads:
        - main.list_negative_dot_product(FLOAT[] list1, FLOAT[] list2) -> FLOAT
        - main.list_negative_dot_product(DOUBLE[] list1, DOUBLE[] list2) -> DOUBLE
        """
        return call_duckdb_function(
            self._LIST_NEGATIVE_DOT_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_NEGATIVE_INNER_PRODUCT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_negative_inner_product',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[]'), parse_type('FLOAT[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the negative inner product between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_negative_inner_product',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[]'), parse_type('DOUBLE[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the negative inner product between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_negative_inner_product')
    def list_negative_inner_product(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_negative_inner_product``.

        Computes the negative inner product between two same-sized lists.

        Overloads:
        - main.list_negative_inner_product(FLOAT[] list1, FLOAT[] list2) -> FLOAT
        - main.list_negative_inner_product(DOUBLE[] list1, DOUBLE[] list2) -> DOUBLE
        """
        return call_duckdb_function(
            self._LIST_NEGATIVE_INNER_PRODUCT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_POSITION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_position',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('T[]'), parse_type('T')),
                        parameters=('list', 'element'),
                        varargs=None,
                        description='Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_position')
    def list_position(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_position``.

        Returns the index of the `element` if the `list` contains the `element`. If the `element` is not found, it returns `NULL`.

        Overloads:
        - main.list_position(T[] list, T element) -> INTEGER
        """
        return call_duckdb_function(
            self._LIST_POSITION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_UNIQUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_unique',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('ANY[]'),),
                        parameters=('list',),
                        varargs=None,
                        description='Counts the unique elements of a `list`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_unique')
    def list_unique(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``list_unique``.

        Counts the unique elements of a `list`.

        Overloads:
        - main.list_unique(ANY[] list) -> UBIGINT
        """
        return call_duckdb_function(
            self._LIST_UNIQUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ln',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the natural logarithm of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('ln')
    def ln(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``ln``.

        Computes the natural logarithm of x

        Overloads:
        - main.ln(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._LN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LOG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='log',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('b',),
                        varargs=None,
                        description='Computes the logarithm of x to base b. b may be omitted, in which case the default 10',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='log',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('b', 'x'),
                        varargs=None,
                        description='Computes the logarithm of x to base b. b may be omitted, in which case the default 10',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('log')
    def log(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``log``.

        Computes the logarithm of x to base b. b may be omitted, in which case the default 10

        Overloads:
        - main.log(DOUBLE b) -> DOUBLE
        - main.log(DOUBLE b, DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._LOG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LOG10_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='log10',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the 10-log of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('log10')
    def log10(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``log10``.

        Computes the 10-log of x

        Overloads:
        - main.log10(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._LOG10_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LOG2_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='log2',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the 2-log of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('log2')
    def log2(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``log2``.

        Computes the 2-log of x

        Overloads:
        - main.log2(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._LOG2_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MAP_TO_PG_OID_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='map_to_pg_oid',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(None,),
                        parameters=('type_name',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CASE  WHEN ((type_name = 'bool')) THEN (16) WHEN ((type_name = 'int16')) THEN (21) WHEN ((type_name = 'int')) THEN (23) WHEN ((type_name = 'bigint')) THEN (20) WHEN ((type_name = 'date')) THEN (1082) WHEN ((type_name = 'time')) THEN (1083) WHEN ((type_name = 'datetime')) THEN (1114) WHEN ((type_name = 'dec')) THEN (1700) WHEN ((type_name = 'float')) THEN (700) WHEN ((type_name = 'double')) THEN (701) WHEN ((type_name = 'bpchar')) THEN (1043) WHEN ((type_name = 'binary')) THEN (17) WHEN ((type_name = 'interval')) THEN (1186) WHEN ((type_name = 'timestamptz')) THEN (1184) WHEN ((type_name = 'timetz')) THEN (1266) WHEN ((type_name = 'bit')) THEN (1560) WHEN ((type_name = 'guid')) THEN (2950) ELSE NULL END",
                    ),
    )
    @duckdb_function('map_to_pg_oid')
    def map_to_pg_oid(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``map_to_pg_oid``.

        Overloads:
        - pg_catalog.map_to_pg_oid(ANY type_name) -> INTEGER
        """
        return call_duckdb_function(
            self._MAP_TO_PG_OID_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MD5_NUMBER_LOWER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='md5_number_lower',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(None,),
                        parameters=('param',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='CAST(CAST(CAST(CAST(md5_number(param) AS BIT) AS VARCHAR)[:64] AS BIT) AS UBIGINT)',
                    ),
    )
    @duckdb_function('md5_number_lower')
    def md5_number_lower(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``md5_number_lower``.

        Overloads:
        - main.md5_number_lower(ANY param) -> UBIGINT
        """
        return call_duckdb_function(
            self._MD5_NUMBER_LOWER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MD5_NUMBER_UPPER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='md5_number_upper',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(None,),
                        parameters=('param',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='CAST(CAST(CAST(CAST(md5_number(param) AS BIT) AS VARCHAR)[65:] AS BIT) AS UBIGINT)',
                    ),
    )
    @duckdb_function('md5_number_upper')
    def md5_number_upper(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``md5_number_upper``.

        Overloads:
        - main.md5_number_upper(ANY param) -> UBIGINT
        """
        return call_duckdb_function(
            self._MD5_NUMBER_UPPER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MICROSECOND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='microsecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the microsecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='microsecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the microsecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='microsecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the microsecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='microsecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the microsecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='microsecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the microsecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='microsecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the microsecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='microsecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the microsecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('microsecond')
    def microsecond(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``microsecond``.

        Extract the microsecond component from a date or timestamp

        Overloads:
        - main.microsecond(DATE ts) -> BIGINT
        - main.microsecond(INTERVAL ts) -> BIGINT
        - main.microsecond(TIME ts) -> BIGINT
        - main.microsecond(TIMESTAMP ts) -> BIGINT
        - main.microsecond(TIME WITH TIME ZONE ts) -> BIGINT
        - main.microsecond(TIME_NS ts) -> BIGINT
        - main.microsecond(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._MICROSECOND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MILLENNIUM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millennium',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millennium component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millennium',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millennium component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millennium',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millennium component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millennium',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millennium component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('millennium')
    def millennium(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``millennium``.

        Extract the millennium component from a date or timestamp

        Overloads:
        - main.millennium(DATE ts) -> BIGINT
        - main.millennium(INTERVAL ts) -> BIGINT
        - main.millennium(TIMESTAMP ts) -> BIGINT
        - main.millennium(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._MILLENNIUM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MILLISECOND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millisecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millisecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millisecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millisecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millisecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millisecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millisecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millisecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millisecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millisecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millisecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millisecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='millisecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the millisecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('millisecond')
    def millisecond(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``millisecond``.

        Extract the millisecond component from a date or timestamp

        Overloads:
        - main.millisecond(DATE ts) -> BIGINT
        - main.millisecond(INTERVAL ts) -> BIGINT
        - main.millisecond(TIME ts) -> BIGINT
        - main.millisecond(TIMESTAMP ts) -> BIGINT
        - main.millisecond(TIME WITH TIME ZONE ts) -> BIGINT
        - main.millisecond(TIME_NS ts) -> BIGINT
        - main.millisecond(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._MILLISECOND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MINUTE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('minute')
    def minute(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``minute``.

        Extract the minute component from a date or timestamp

        Overloads:
        - main.minute(DATE ts) -> BIGINT
        - main.minute(INTERVAL ts) -> BIGINT
        - main.minute(TIME ts) -> BIGINT
        - main.minute(TIMESTAMP ts) -> BIGINT
        - main.minute(TIME WITH TIME ZONE ts) -> BIGINT
        - main.minute(TIME_NS ts) -> BIGINT
        - main.minute(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._MINUTE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MISMATCHES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mismatches',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('s1', 's2'),
                        varargs=None,
                        description='The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('mismatches')
    def mismatches(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``mismatches``.

        The Hamming distance between to strings, i.e., the number of positions with different characters for two strings of equal length. Strings must be of equal length. Characters of different cases (e.g., `a` and `A`) are considered different.

        Overloads:
        - main.mismatches(VARCHAR s1, VARCHAR s2) -> BIGINT
        """
        return call_duckdb_function(
            self._MISMATCHES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MOD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DECIMAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='mod',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('mod')
    def mod(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``mod``.

        Overloads:
        - main.mod(TINYINT col0, TINYINT col1) -> TINYINT
        - main.mod(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.mod(INTEGER col0, INTEGER col1) -> INTEGER
        - main.mod(BIGINT col0, BIGINT col1) -> BIGINT
        - main.mod(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.mod(FLOAT col0, FLOAT col1) -> FLOAT
        - main.mod(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.mod(DECIMAL col0, DECIMAL col1) -> DECIMAL
        - main.mod(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.mod(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.mod(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.mod(UBIGINT col0, UBIGINT col1) -> UBIGINT
        """
        return call_duckdb_function(
            self._MOD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MONTH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='month',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the month component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='month',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the month component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='month',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the month component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='month',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the month component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('month')
    def month(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``month``.

        Extract the month component from a date or timestamp

        Overloads:
        - main.month(DATE ts) -> BIGINT
        - main.month(INTERVAL ts) -> BIGINT
        - main.month(TIMESTAMP ts) -> BIGINT
        - main.month(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._MONTH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MULTIPLY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DECIMAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='multiply',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('multiply')
    def multiply(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``multiply``.

        Overloads:
        - main.multiply(TINYINT col0, TINYINT col1) -> TINYINT
        - main.multiply(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.multiply(INTEGER col0, INTEGER col1) -> INTEGER
        - main.multiply(BIGINT col0, BIGINT col1) -> BIGINT
        - main.multiply(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.multiply(FLOAT col0, FLOAT col1) -> FLOAT
        - main.multiply(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.multiply(DECIMAL col0, DECIMAL col1) -> DECIMAL
        - main.multiply(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.multiply(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.multiply(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.multiply(UBIGINT col0, UBIGINT col1) -> UBIGINT
        - main.multiply(INTERVAL col0, DOUBLE col1) -> INTERVAL
        - main.multiply(DOUBLE col0, INTERVAL col1) -> INTERVAL
        - main.multiply(BIGINT col0, INTERVAL col1) -> INTERVAL
        - main.multiply(INTERVAL col0, BIGINT col1) -> INTERVAL
        """
        return call_duckdb_function(
            self._MULTIPLY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _NANOSECOND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nanosecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('tsns',),
                        varargs=None,
                        description='Extract the nanosecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nanosecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('tsns',),
                        varargs=None,
                        description='Extract the nanosecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nanosecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('tsns',),
                        varargs=None,
                        description='Extract the nanosecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nanosecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('tsns',),
                        varargs=None,
                        description='Extract the nanosecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nanosecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('tsns',),
                        varargs=None,
                        description='Extract the nanosecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nanosecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('tsns',),
                        varargs=None,
                        description='Extract the nanosecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nanosecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP_NS'),),
                        parameters=('tsns',),
                        varargs=None,
                        description='Extract the nanosecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nanosecond',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('tsns',),
                        varargs=None,
                        description='Extract the nanosecond component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('nanosecond')
    def nanosecond(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``nanosecond``.

        Extract the nanosecond component from a date or timestamp

        Overloads:
        - main.nanosecond(DATE tsns) -> BIGINT
        - main.nanosecond(TIMESTAMP tsns) -> BIGINT
        - main.nanosecond(INTERVAL tsns) -> BIGINT
        - main.nanosecond(TIME tsns) -> BIGINT
        - main.nanosecond(TIME_NS tsns) -> BIGINT
        - main.nanosecond(TIME WITH TIME ZONE tsns) -> BIGINT
        - main.nanosecond(TIMESTAMP_NS tsns) -> BIGINT
        - main.nanosecond(TIMESTAMP WITH TIME ZONE tsns) -> BIGINT
        """
        return call_duckdb_function(
            self._NANOSECOND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _NEXTAFTER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nextafter',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Returns the next floating point value after x in the direction of y',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nextafter',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Returns the next floating point value after x in the direction of y',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('nextafter')
    def nextafter(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``nextafter``.

        Returns the next floating point value after x in the direction of y

        Overloads:
        - main.nextafter(DOUBLE x, DOUBLE y) -> DOUBLE
        - main.nextafter(FLOAT x, FLOAT y) -> FLOAT
        """
        return call_duckdb_function(
            self._NEXTAFTER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _NEXTVAL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nextval',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=("'sequence_name'",),
                        varargs=None,
                        description='Return the following value of the sequence.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('nextval')
    def nextval(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``nextval``.

        Return the following value of the sequence.

        Overloads:
        - main.nextval(VARCHAR 'sequence_name') -> BIGINT
        """
        return call_duckdb_function(
            self._NEXTVAL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _NORMALIZED_INTERVAL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='normalized_interval',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('interval',),
                        varargs=None,
                        description='Normalizes an INTERVAL to an equivalent interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('normalized_interval')
    def normalized_interval(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``normalized_interval``.

        Normalizes an INTERVAL to an equivalent interval

        Overloads:
        - main.normalized_interval(INTERVAL interval) -> INTERVAL
        """
        return call_duckdb_function(
            self._NORMALIZED_INTERVAL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _OCTET_LENGTH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='octet_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Number of bytes in `blob`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='octet_length',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIT'),),
                        parameters=('bitstring',),
                        varargs=None,
                        description='Returns the number of bytes in the `bitstring`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('octet_length')
    def octet_length(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``octet_length``.

        Number of bytes in `blob`.

        Overloads:
        - main.octet_length(BLOB blob) -> BIGINT
        - main.octet_length(BIT bitstring) -> BIGINT
        """
        return call_duckdb_function(
            self._OCTET_LENGTH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ORD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ord',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('ord')
    def ord(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``ord``.

        Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.

        Overloads:
        - main.ord(VARCHAR string) -> INTEGER
        """
        return call_duckdb_function(
            self._ORD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_MY_TEMP_SCHEMA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_my_temp_schema',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='0',
                    ),
    )
    @duckdb_function('pg_my_temp_schema')
    def pg_my_temp_schema(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``pg_my_temp_schema``.

        Overloads:
        - pg_catalog.pg_my_temp_schema() -> INTEGER
        """
        return call_duckdb_function(
            self._PG_MY_TEMP_SCHEMA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PI_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='pi',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the value of pi',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('pi')
    def pi(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``pi``.

        Returns the value of pi

        Overloads:
        - main.pi() -> DOUBLE
        """
        return call_duckdb_function(
            self._PI_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _POSITION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='position',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'search_string'),
                        varargs=None,
                        description='Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('position')
    def position(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``position``.

        Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.

        Overloads:
        - main.position(VARCHAR string, VARCHAR search_string) -> BIGINT
        """
        return call_duckdb_function(
            self._POSITION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _POW_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='pow',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes x to the power of y',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('pow')
    def pow(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``pow``.

        Computes x to the power of y

        Overloads:
        - main.pow(DOUBLE x, DOUBLE y) -> DOUBLE
        """
        return call_duckdb_function(
            self._POW_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _POWER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='power',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes x to the power of y',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('power')
    def power(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``power``.

        Computes x to the power of y

        Overloads:
        - main.power(DOUBLE x, DOUBLE y) -> DOUBLE
        """
        return call_duckdb_function(
            self._POWER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _QUARTER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quarter',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the quarter component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quarter',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the quarter component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quarter',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the quarter component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='quarter',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the quarter component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('quarter')
    def quarter(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``quarter``.

        Extract the quarter component from a date or timestamp

        Overloads:
        - main.quarter(DATE ts) -> BIGINT
        - main.quarter(INTERVAL ts) -> BIGINT
        - main.quarter(TIMESTAMP ts) -> BIGINT
        - main.quarter(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._QUARTER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _RADIANS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='radians',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Converts degrees to radians',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('radians')
    def radians(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``radians``.

        Converts degrees to radians

        Overloads:
        - main.radians(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._RADIANS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _RANDOM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='random',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns a random number between 0 and 1',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('random')
    def random(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``random``.

        Returns a random number between 0 and 1

        Overloads:
        - main.random() -> DOUBLE
        """
        return call_duckdb_function(
            self._RANDOM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _RANGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='range',
                        function_type=function_type,
                        return_type=parse_type('BIGINT[]'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('start',),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is exclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='range',
                        function_type=function_type,
                        return_type=parse_type('BIGINT[]'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('start', 'stop'),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is exclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='range',
                        function_type=function_type,
                        return_type=parse_type('BIGINT[]'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('start', 'stop', 'step'),
                        varargs=None,
                        description='Creates a list of values between `start` and `stop` - the stop parameter is exclusive.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('range')
    def range(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``range``.

        Creates a list of values between `start` and `stop` - the stop parameter is exclusive.

        Overloads:
        - main.range(BIGINT start) -> BIGINT[]
        - main.range(BIGINT start, BIGINT stop) -> BIGINT[]
        - main.range(BIGINT start, BIGINT stop, BIGINT step) -> BIGINT[]
        """
        return call_duckdb_function(
            self._RANGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ROUND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('INTEGER')),
                        parameters=('x', 'precision'),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('INTEGER')),
                        parameters=('x', 'precision'),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('x', 'precision'),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('x', 'precision'),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('INTEGER')),
                        parameters=('x', 'precision'),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('INTEGER')),
                        parameters=('x', 'precision'),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'precision'),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('x', 'precision'),
                        varargs=None,
                        description='Rounds x to s decimal places',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('round')
    def round(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``round``.

        Rounds x to s decimal places

        Overloads:
        - main.round(TINYINT x) -> TINYINT
        - main.round(SMALLINT x) -> SMALLINT
        - main.round(INTEGER x) -> INTEGER
        - main.round(BIGINT x) -> BIGINT
        - main.round(HUGEINT x) -> HUGEINT
        - main.round(FLOAT x) -> FLOAT
        - main.round(DOUBLE x) -> DOUBLE
        - main.round(DECIMAL x) -> DECIMAL
        - main.round(TINYINT x, INTEGER precision) -> TINYINT
        - main.round(SMALLINT x, INTEGER precision) -> SMALLINT
        - main.round(INTEGER x, INTEGER precision) -> INTEGER
        - main.round(BIGINT x, INTEGER precision) -> BIGINT
        - main.round(HUGEINT x, INTEGER precision) -> HUGEINT
        - main.round(FLOAT x, INTEGER precision) -> FLOAT
        - main.round(DOUBLE x, INTEGER precision) -> DOUBLE
        - main.round(DECIMAL x, INTEGER precision) -> DECIMAL
        """
        return call_duckdb_function(
            self._ROUND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ROUND_EVEN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='round_even',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(None, None),
                        parameters=('x', 'n'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='CASE  WHEN ((((abs(x) * power(10, (n + 1))) % 10) = 5)) THEN ((round((x / 2), n) * 2)) ELSE round(x, n) END',
                    ),
    )
    @duckdb_function('round_even')
    def round_even(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``round_even``.

        Overloads:
        - main.round_even(ANY x, ANY n) -> DOUBLE
        """
        return call_duckdb_function(
            self._ROUND_EVEN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ROUNDBANKERS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='roundbankers',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(None, None),
                        parameters=('x', 'n'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='round_even(x, n)',
                    ),
    )
    @duckdb_function('roundbankers')
    def roundbankers(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``roundbankers``.

        Overloads:
        - main.roundbankers(ANY x, ANY n) -> DOUBLE
        """
        return call_duckdb_function(
            self._ROUNDBANKERS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SECOND_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='second',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the second component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='second',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the second component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='second',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the second component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='second',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the second component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='second',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the second component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='second',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIME_NS'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the second component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='second',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the second component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('second')
    def second(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``second``.

        Extract the second component from a date or timestamp

        Overloads:
        - main.second(DATE ts) -> BIGINT
        - main.second(INTERVAL ts) -> BIGINT
        - main.second(TIME ts) -> BIGINT
        - main.second(TIMESTAMP ts) -> BIGINT
        - main.second(TIME WITH TIME ZONE ts) -> BIGINT
        - main.second(TIME_NS ts) -> BIGINT
        - main.second(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._SECOND_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SIGN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sign',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the sign of x as -1, 0 or 1',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sign')
    def sign(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``sign``.

        Returns the sign of x as -1, 0 or 1

        Overloads:
        - main.sign(TINYINT x) -> TINYINT
        - main.sign(SMALLINT x) -> TINYINT
        - main.sign(INTEGER x) -> TINYINT
        - main.sign(BIGINT x) -> TINYINT
        - main.sign(HUGEINT x) -> TINYINT
        - main.sign(FLOAT x) -> TINYINT
        - main.sign(DOUBLE x) -> TINYINT
        - main.sign(UTINYINT x) -> TINYINT
        - main.sign(USMALLINT x) -> TINYINT
        - main.sign(UINTEGER x) -> TINYINT
        - main.sign(UBIGINT x) -> TINYINT
        - main.sign(UHUGEINT x) -> TINYINT
        """
        return call_duckdb_function(
            self._SIGN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sin',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the sin of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sin')
    def sin(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``sin``.

        Computes the sin of x

        Overloads:
        - main.sin(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._SIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SINH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sinh',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the hyperbolic sin of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sinh')
    def sinh(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``sinh``.

        Computes the hyperbolic sin of x

        Overloads:
        - main.sinh(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._SINH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SQRT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sqrt',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Returns the square root of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sqrt')
    def sqrt(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``sqrt``.

        Returns the square root of x

        Overloads:
        - main.sqrt(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._SQRT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRLEN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strlen',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Number of bytes in `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('strlen')
    def strlen(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``strlen``.

        Number of bytes in `string`.

        Overloads:
        - main.strlen(VARCHAR string) -> BIGINT
        """
        return call_duckdb_function(
            self._STRLEN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRPOS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strpos',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'search_string'),
                        varargs=None,
                        description='Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('strpos')
    def strpos(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``strpos``.

        Returns location of first occurrence of `search_string` in `string`, counting from 1. Returns 0 if no match found.

        Overloads:
        - main.strpos(VARCHAR string, VARCHAR search_string) -> BIGINT
        """
        return call_duckdb_function(
            self._STRPOS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_INDEXOF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_indexof',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('STRUCT'), parse_type('ANY')),
                        parameters=('struct', "'entry'"),
                        varargs=None,
                        description='Get the position of the entry in an unnamed STRUCT, starting at 1.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_indexof')
    def struct_indexof(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``struct_indexof``.

        Get the position of the entry in an unnamed STRUCT, starting at 1.

        Overloads:
        - main.struct_indexof(STRUCT struct, ANY 'entry') -> INTEGER
        """
        return call_duckdb_function(
            self._STRUCT_INDEXOF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRUCT_POSITION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='struct_position',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('STRUCT'), parse_type('ANY')),
                        parameters=('struct', "'entry'"),
                        varargs=None,
                        description='Get the position of the entry in an unnamed STRUCT, starting at 1.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('struct_position')
    def struct_position(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``struct_position``.

        Get the position of the entry in an unnamed STRUCT, starting at 1.

        Overloads:
        - main.struct_position(STRUCT struct, ANY 'entry') -> INTEGER
        """
        return call_duckdb_function(
            self._STRUCT_POSITION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SUBTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DECIMAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='subtract',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('subtract')
    def subtract(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``subtract``.

        Overloads:
        - main.subtract(TINYINT col0) -> TINYINT
        - main.subtract(SMALLINT col0) -> SMALLINT
        - main.subtract(INTEGER col0) -> INTEGER
        - main.subtract(BIGINT col0) -> BIGINT
        - main.subtract(HUGEINT col0) -> HUGEINT
        - main.subtract(FLOAT col0) -> FLOAT
        - main.subtract(DOUBLE col0) -> DOUBLE
        - main.subtract(DECIMAL col0) -> DECIMAL
        - main.subtract(UTINYINT col0) -> UTINYINT
        - main.subtract(USMALLINT col0) -> USMALLINT
        - main.subtract(UINTEGER col0) -> UINTEGER
        - main.subtract(UBIGINT col0) -> UBIGINT
        - main.subtract(INTERVAL col0) -> INTERVAL
        - main.subtract(TINYINT col0, TINYINT col1) -> TINYINT
        - main.subtract(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.subtract(INTEGER col0, INTEGER col1) -> INTEGER
        - main.subtract(BIGINT col0, BIGINT col1) -> BIGINT
        - main.subtract(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.subtract(FLOAT col0, FLOAT col1) -> FLOAT
        - main.subtract(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.subtract(DECIMAL col0, DECIMAL col1) -> DECIMAL
        - main.subtract(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.subtract(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.subtract(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.subtract(UBIGINT col0, UBIGINT col1) -> UBIGINT
        - main.subtract(DATE col0, DATE col1) -> BIGINT
        - main.subtract(TIMESTAMP col0, TIMESTAMP col1) -> INTERVAL
        - main.subtract(INTERVAL col0, INTERVAL col1) -> INTERVAL
        """
        return call_duckdb_function(
            self._SUBTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='tan',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the tan of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('tan')
    def tan(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``tan``.

        Computes the tan of x

        Overloads:
        - main.tan(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._TAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TANH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='tanh',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Computes the hyperbolic tan of x',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('tanh')
    def tanh(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``tanh``.

        Computes the hyperbolic tan of x

        Overloads:
        - main.tanh(DOUBLE x) -> DOUBLE
        """
        return call_duckdb_function(
            self._TANH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TIMETZ_BYTE_COMPARABLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timetz_byte_comparable',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('TIME WITH TIME ZONE'),),
                        parameters=('time_tz',),
                        varargs=None,
                        description='Converts a TIME WITH TIME ZONE to an integer sort key',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('timetz_byte_comparable')
    def timetz_byte_comparable(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``timetz_byte_comparable``.

        Converts a TIME WITH TIME ZONE to an integer sort key

        Overloads:
        - main.timetz_byte_comparable(TIME WITH TIME ZONE time_tz) -> UBIGINT
        """
        return call_duckdb_function(
            self._TIMETZ_BYTE_COMPARABLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TIMEZONE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('timezone')
    def timezone(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``timezone``.

        Extract the timezone component from a date or timestamp

        Overloads:
        - main.timezone(DATE ts) -> BIGINT
        - main.timezone(INTERVAL ts) -> BIGINT
        - main.timezone(TIMESTAMP ts) -> BIGINT
        - main.timezone(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._TIMEZONE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TIMEZONE_HOUR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone_hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone_hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone_hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone_hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone_hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone_hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone_hour',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone_hour component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('timezone_hour')
    def timezone_hour(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``timezone_hour``.

        Extract the timezone_hour component from a date or timestamp

        Overloads:
        - main.timezone_hour(DATE ts) -> BIGINT
        - main.timezone_hour(INTERVAL ts) -> BIGINT
        - main.timezone_hour(TIMESTAMP ts) -> BIGINT
        - main.timezone_hour(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._TIMEZONE_HOUR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TIMEZONE_MINUTE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone_minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone_minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone_minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone_minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone_minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone_minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='timezone_minute',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the timezone_minute component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('timezone_minute')
    def timezone_minute(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``timezone_minute``.

        Extract the timezone_minute component from a date or timestamp

        Overloads:
        - main.timezone_minute(DATE ts) -> BIGINT
        - main.timezone_minute(INTERVAL ts) -> BIGINT
        - main.timezone_minute(TIMESTAMP ts) -> BIGINT
        - main.timezone_minute(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._TIMEZONE_MINUTE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_CENTURIES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_centuries',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a century interval',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_centuries',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a century interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_centuries')
    def to_centuries(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_centuries``.

        Construct a century interval

        Overloads:
        - main.to_centuries(INTEGER integer) -> INTERVAL
        - main.to_centuries(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_CENTURIES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_DAYS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_days',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a day interval',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_days',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a day interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_days')
    def to_days(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_days``.

        Construct a day interval

        Overloads:
        - main.to_days(INTEGER integer) -> INTERVAL
        - main.to_days(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_DAYS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_DECADES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_decades',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a decade interval',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_decades',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a decade interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_decades')
    def to_decades(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_decades``.

        Construct a decade interval

        Overloads:
        - main.to_decades(INTEGER integer) -> INTERVAL
        - main.to_decades(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_DECADES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_HOURS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_hours',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a hour interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_hours')
    def to_hours(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_hours``.

        Construct a hour interval

        Overloads:
        - main.to_hours(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_HOURS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_MICROSECONDS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_microseconds',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a microsecond interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_microseconds')
    def to_microseconds(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_microseconds``.

        Construct a microsecond interval

        Overloads:
        - main.to_microseconds(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_MICROSECONDS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_MILLENNIA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_millennia',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a millenium interval',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_millennia',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a millenium interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_millennia')
    def to_millennia(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_millennia``.

        Construct a millenium interval

        Overloads:
        - main.to_millennia(INTEGER integer) -> INTERVAL
        - main.to_millennia(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_MILLENNIA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_MILLISECONDS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_milliseconds',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('double',),
                        varargs=None,
                        description='Construct a millisecond interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_milliseconds')
    def to_milliseconds(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_milliseconds``.

        Construct a millisecond interval

        Overloads:
        - main.to_milliseconds(DOUBLE double) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_MILLISECONDS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_MINUTES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_minutes',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a minute interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_minutes')
    def to_minutes(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_minutes``.

        Construct a minute interval

        Overloads:
        - main.to_minutes(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_MINUTES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_MONTHS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_months',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a month interval',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_months',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a month interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_months')
    def to_months(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_months``.

        Construct a month interval

        Overloads:
        - main.to_months(INTEGER integer) -> INTERVAL
        - main.to_months(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_MONTHS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_QUARTERS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_quarters',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a quarter interval',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_quarters',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a quarter interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_quarters')
    def to_quarters(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_quarters``.

        Construct a quarter interval

        Overloads:
        - main.to_quarters(INTEGER integer) -> INTERVAL
        - main.to_quarters(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_QUARTERS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_SECONDS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_seconds',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('double',),
                        varargs=None,
                        description='Construct a second interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_seconds')
    def to_seconds(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_seconds``.

        Construct a second interval

        Overloads:
        - main.to_seconds(DOUBLE double) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_SECONDS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_WEEKS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_weeks',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a week interval',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_weeks',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a week interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_weeks')
    def to_weeks(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_weeks``.

        Construct a week interval

        Overloads:
        - main.to_weeks(INTEGER integer) -> INTERVAL
        - main.to_weeks(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_WEEKS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_YEARS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_years',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a year interval',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_years',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Construct a year interval',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_years')
    def to_years(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``to_years``.

        Construct a year interval

        Overloads:
        - main.to_years(INTEGER integer) -> INTERVAL
        - main.to_years(BIGINT integer) -> INTERVAL
        """
        return call_duckdb_function(
            self._TO_YEARS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TRUNC_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trunc',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('INTEGER')),
                        parameters=('x', 'col1'),
                        varargs=None,
                        description='Truncates the number',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('trunc')
    def trunc(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``trunc``.

        Truncates the number

        Overloads:
        - main.trunc(TINYINT x) -> TINYINT
        - main.trunc(SMALLINT x) -> SMALLINT
        - main.trunc(INTEGER x) -> INTEGER
        - main.trunc(BIGINT x) -> BIGINT
        - main.trunc(HUGEINT x) -> HUGEINT
        - main.trunc(FLOAT x) -> FLOAT
        - main.trunc(DOUBLE x) -> DOUBLE
        - main.trunc(DECIMAL x) -> DECIMAL
        - main.trunc(UTINYINT x) -> UTINYINT
        - main.trunc(USMALLINT x) -> USMALLINT
        - main.trunc(UINTEGER x) -> UINTEGER
        - main.trunc(UBIGINT x) -> UBIGINT
        - main.trunc(TINYINT x, INTEGER col1) -> TINYINT
        - main.trunc(SMALLINT x, INTEGER col1) -> SMALLINT
        - main.trunc(INTEGER x, INTEGER col1) -> INTEGER
        - main.trunc(BIGINT x, INTEGER col1) -> BIGINT
        - main.trunc(HUGEINT x, INTEGER col1) -> HUGEINT
        - main.trunc(FLOAT x, INTEGER col1) -> FLOAT
        - main.trunc(DOUBLE x, INTEGER col1) -> DOUBLE
        - main.trunc(DECIMAL x, INTEGER col1) -> DECIMAL
        - main.trunc(UTINYINT x, INTEGER col1) -> UTINYINT
        - main.trunc(USMALLINT x, INTEGER col1) -> USMALLINT
        - main.trunc(UINTEGER x, INTEGER col1) -> UINTEGER
        - main.trunc(UBIGINT x, INTEGER col1) -> UBIGINT
        """
        return call_duckdb_function(
            self._TRUNC_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TXID_CURRENT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='txid_current',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the current transactions ID (a BIGINT). It will assign a new one if the current transaction does not have one already',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('txid_current')
    def txid_current(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``txid_current``.

        Returns the current transactions ID (a BIGINT). It will assign a new one if the current transaction does not have one already

        Overloads:
        - main.txid_current() -> UBIGINT
        """
        return call_duckdb_function(
            self._TXID_CURRENT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UNICODE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='unicode',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('unicode')
    def unicode(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``unicode``.

        Returns an `INTEGER` representing the `unicode` codepoint of the first character in the `string`.

        Overloads:
        - main.unicode(VARCHAR string) -> INTEGER
        """
        return call_duckdb_function(
            self._UNICODE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UUID_EXTRACT_VERSION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='uuid_extract_version',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UUID'),),
                        parameters=('uuid',),
                        varargs=None,
                        description='Extract a version for the given UUID.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('uuid_extract_version')
    def uuid_extract_version(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``uuid_extract_version``.

        Extract a version for the given UUID.

        Overloads:
        - main.uuid_extract_version(UUID uuid) -> UINTEGER
        """
        return call_duckdb_function(
            self._UUID_EXTRACT_VERSION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _WAVG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='wavg',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(None, None),
                        parameters=('value', 'weight'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='weighted_avg("value", weight)',
                    ),
    )
    @duckdb_function('wavg')
    def wavg(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``wavg``.

        Overloads:
        - main.wavg(ANY value, ANY weight) -> DOUBLE
        """
        return call_duckdb_function(
            self._WAVG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _WEEK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='week',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the week component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='week',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the week component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='week',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the week component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='week',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the week component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('week')
    def week(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``week``.

        Extract the week component from a date or timestamp

        Overloads:
        - main.week(DATE ts) -> BIGINT
        - main.week(INTERVAL ts) -> BIGINT
        - main.week(TIMESTAMP ts) -> BIGINT
        - main.week(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._WEEK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _WEEKDAY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='weekday',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the weekday component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='weekday',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the weekday component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='weekday',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the weekday component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='weekday',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the weekday component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('weekday')
    def weekday(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``weekday``.

        Extract the weekday component from a date or timestamp

        Overloads:
        - main.weekday(DATE ts) -> BIGINT
        - main.weekday(INTERVAL ts) -> BIGINT
        - main.weekday(TIMESTAMP ts) -> BIGINT
        - main.weekday(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._WEEKDAY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _WEEKOFYEAR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='weekofyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the weekofyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='weekofyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the weekofyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='weekofyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the weekofyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='weekofyear',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the weekofyear component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('weekofyear')
    def weekofyear(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``weekofyear``.

        Extract the weekofyear component from a date or timestamp

        Overloads:
        - main.weekofyear(DATE ts) -> BIGINT
        - main.weekofyear(INTERVAL ts) -> BIGINT
        - main.weekofyear(TIMESTAMP ts) -> BIGINT
        - main.weekofyear(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._WEEKOFYEAR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _WEIGHTED_AVG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='weighted_avg',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(None, None),
                        parameters=('value', 'weight'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='(sum(("value" * weight)) / sum(CASE  WHEN (("value" IS NOT NULL)) THEN (weight) ELSE 0 END))',
                    ),
    )
    @duckdb_function('weighted_avg')
    def weighted_avg(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``weighted_avg``.

        Overloads:
        - main.weighted_avg(ANY value, ANY weight) -> DOUBLE
        """
        return call_duckdb_function(
            self._WEIGHTED_AVG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _XOR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='xor',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise XOR',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('xor')
    def xor(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``xor``.

        Bitwise XOR

        Overloads:
        - main.xor(TINYINT left, TINYINT right) -> TINYINT
        - main.xor(SMALLINT left, SMALLINT right) -> SMALLINT
        - main.xor(INTEGER left, INTEGER right) -> INTEGER
        - main.xor(BIGINT left, BIGINT right) -> BIGINT
        - main.xor(HUGEINT left, HUGEINT right) -> HUGEINT
        - main.xor(UTINYINT left, UTINYINT right) -> UTINYINT
        - main.xor(USMALLINT left, USMALLINT right) -> USMALLINT
        - main.xor(UINTEGER left, UINTEGER right) -> UINTEGER
        - main.xor(UBIGINT left, UBIGINT right) -> UBIGINT
        """
        return call_duckdb_function(
            self._XOR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _YEAR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='year',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the year component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='year',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the year component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='year',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the year component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='year',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the year component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('year')
    def year(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``year``.

        Extract the year component from a date or timestamp

        Overloads:
        - main.year(DATE ts) -> BIGINT
        - main.year(INTERVAL ts) -> BIGINT
        - main.year(TIMESTAMP ts) -> BIGINT
        - main.year(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._YEAR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _YEARWEEK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='yearweek',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the yearweek component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='yearweek',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the yearweek component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='yearweek',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the yearweek component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='yearweek',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='Extract the yearweek component from a date or timestamp',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('yearweek')
    def yearweek(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``yearweek``.

        Extract the yearweek component from a date or timestamp

        Overloads:
        - main.yearweek(DATE ts) -> BIGINT
        - main.yearweek(INTERVAL ts) -> BIGINT
        - main.yearweek(TIMESTAMP ts) -> BIGINT
        - main.yearweek(TIMESTAMP WITH TIME ZONE ts) -> BIGINT
        """
        return call_duckdb_function(
            self._YEARWEEK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0021_005f_005f_0070_006f_0073_0074_0066_0069_0078_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='!__postfix',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Factorial of x. Computes the product of the current integer and all integers below it',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('!__postfix',))
    def symbol_0021_005f_005f_0070_006f_0073_0074_0066_0069_0078(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``!__postfix``.

        Factorial of x. Computes the product of the current integer and all integers below it

        Overloads:
        - main.!__postfix(INTEGER x) -> HUGEINT
        """
        return call_duckdb_function(
            self._0021_005f_005f_0070_006f_0073_0074_0066_0069_0078_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0025_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DECIMAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='%',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('%',))
    def symbol_0025(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``%``.

        Overloads:
        - main.%(TINYINT col0, TINYINT col1) -> TINYINT
        - main.%(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.%(INTEGER col0, INTEGER col1) -> INTEGER
        - main.%(BIGINT col0, BIGINT col1) -> BIGINT
        - main.%(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.%(FLOAT col0, FLOAT col1) -> FLOAT
        - main.%(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.%(DECIMAL col0, DECIMAL col1) -> DECIMAL
        - main.%(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.%(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.%(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.%(UBIGINT col0, UBIGINT col1) -> UBIGINT
        """
        return call_duckdb_function(
            self._0025_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0026_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='&',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise AND',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('&',))
    def symbol_0026(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``&``.

        Bitwise AND

        Overloads:
        - main.&(TINYINT left, TINYINT right) -> TINYINT
        - main.&(SMALLINT left, SMALLINT right) -> SMALLINT
        - main.&(INTEGER left, INTEGER right) -> INTEGER
        - main.&(BIGINT left, BIGINT right) -> BIGINT
        - main.&(HUGEINT left, HUGEINT right) -> HUGEINT
        - main.&(UTINYINT left, UTINYINT right) -> UTINYINT
        - main.&(USMALLINT left, USMALLINT right) -> USMALLINT
        - main.&(UINTEGER left, UINTEGER right) -> UINTEGER
        - main.&(UBIGINT left, UBIGINT right) -> UBIGINT
        """
        return call_duckdb_function(
            self._0026_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002a_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DECIMAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='*',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('*',))
    def symbol_002a(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``*``.

        Overloads:
        - main.*(TINYINT col0, TINYINT col1) -> TINYINT
        - main.*(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.*(INTEGER col0, INTEGER col1) -> INTEGER
        - main.*(BIGINT col0, BIGINT col1) -> BIGINT
        - main.*(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.*(FLOAT col0, FLOAT col1) -> FLOAT
        - main.*(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.*(DECIMAL col0, DECIMAL col1) -> DECIMAL
        - main.*(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.*(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.*(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.*(UBIGINT col0, UBIGINT col1) -> UBIGINT
        - main.*(INTERVAL col0, DOUBLE col1) -> INTERVAL
        - main.*(DOUBLE col0, INTERVAL col1) -> INTERVAL
        - main.*(BIGINT col0, INTERVAL col1) -> INTERVAL
        - main.*(INTERVAL col0, BIGINT col1) -> INTERVAL
        """
        return call_duckdb_function(
            self._002a_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002a_002a_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='**',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes x to the power of y',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('**',))
    def symbol_002a_002a(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``**``.

        Computes x to the power of y

        Overloads:
        - main.**(DOUBLE x, DOUBLE y) -> DOUBLE
        """
        return call_duckdb_function(
            self._002a_002a_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002b_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DECIMAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='+',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('+',))
    def symbol_002b(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``+``.

        Overloads:
        - main.+(TINYINT col0) -> TINYINT
        - main.+(SMALLINT col0) -> SMALLINT
        - main.+(INTEGER col0) -> INTEGER
        - main.+(BIGINT col0) -> BIGINT
        - main.+(HUGEINT col0) -> HUGEINT
        - main.+(FLOAT col0) -> FLOAT
        - main.+(DOUBLE col0) -> DOUBLE
        - main.+(DECIMAL col0) -> DECIMAL
        - main.+(UTINYINT col0) -> UTINYINT
        - main.+(USMALLINT col0) -> USMALLINT
        - main.+(UINTEGER col0) -> UINTEGER
        - main.+(UBIGINT col0) -> UBIGINT
        - main.+(TINYINT col0, TINYINT col1) -> TINYINT
        - main.+(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.+(INTEGER col0, INTEGER col1) -> INTEGER
        - main.+(BIGINT col0, BIGINT col1) -> BIGINT
        - main.+(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.+(FLOAT col0, FLOAT col1) -> FLOAT
        - main.+(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.+(DECIMAL col0, DECIMAL col1) -> DECIMAL
        - main.+(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.+(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.+(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.+(UBIGINT col0, UBIGINT col1) -> UBIGINT
        - main.+(INTERVAL col0, INTERVAL col1) -> INTERVAL
        """
        return call_duckdb_function(
            self._002b_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002d_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'), parse_type('DECIMAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('DATE'), parse_type('DATE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('TIMESTAMP')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('INTERVAL')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='-',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('TIMESTAMP WITH TIME ZONE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('-',))
    def symbol_002d(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``-``.

        Overloads:
        - main.-(TINYINT col0) -> TINYINT
        - main.-(SMALLINT col0) -> SMALLINT
        - main.-(INTEGER col0) -> INTEGER
        - main.-(BIGINT col0) -> BIGINT
        - main.-(HUGEINT col0) -> HUGEINT
        - main.-(FLOAT col0) -> FLOAT
        - main.-(DOUBLE col0) -> DOUBLE
        - main.-(DECIMAL col0) -> DECIMAL
        - main.-(UTINYINT col0) -> UTINYINT
        - main.-(USMALLINT col0) -> USMALLINT
        - main.-(UINTEGER col0) -> UINTEGER
        - main.-(UBIGINT col0) -> UBIGINT
        - main.-(INTERVAL col0) -> INTERVAL
        - main.-(TINYINT col0, TINYINT col1) -> TINYINT
        - main.-(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.-(INTEGER col0, INTEGER col1) -> INTEGER
        - main.-(BIGINT col0, BIGINT col1) -> BIGINT
        - main.-(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.-(FLOAT col0, FLOAT col1) -> FLOAT
        - main.-(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.-(DECIMAL col0, DECIMAL col1) -> DECIMAL
        - main.-(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.-(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.-(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.-(UBIGINT col0, UBIGINT col1) -> UBIGINT
        - main.-(DATE col0, DATE col1) -> BIGINT
        - main.-(TIMESTAMP col0, TIMESTAMP col1) -> INTERVAL
        - main.-(INTERVAL col0, INTERVAL col1) -> INTERVAL
        - main.-(TIMESTAMP WITH TIME ZONE col0, TIMESTAMP WITH TIME ZONE col1) -> INTERVAL
        """
        return call_duckdb_function(
            self._002d_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002f_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='/',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='/',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='/',
                        function_type=function_type,
                        return_type=parse_type('INTERVAL'),
                        parameter_types=(parse_type('INTERVAL'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('/',))
    def symbol_002f(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``/``.

        Overloads:
        - main./(FLOAT col0, FLOAT col1) -> FLOAT
        - main./(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main./(INTERVAL col0, DOUBLE col1) -> INTERVAL
        """
        return call_duckdb_function(
            self._002f_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002f_002f_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'), parse_type('FLOAT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='//',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('//',))
    def symbol_002f_002f(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``//``.

        Overloads:
        - main.//(TINYINT col0, TINYINT col1) -> TINYINT
        - main.//(SMALLINT col0, SMALLINT col1) -> SMALLINT
        - main.//(INTEGER col0, INTEGER col1) -> INTEGER
        - main.//(BIGINT col0, BIGINT col1) -> BIGINT
        - main.//(HUGEINT col0, HUGEINT col1) -> HUGEINT
        - main.//(FLOAT col0, FLOAT col1) -> FLOAT
        - main.//(DOUBLE col0, DOUBLE col1) -> DOUBLE
        - main.//(UTINYINT col0, UTINYINT col1) -> UTINYINT
        - main.//(USMALLINT col0, USMALLINT col1) -> USMALLINT
        - main.//(UINTEGER col0, UINTEGER col1) -> UINTEGER
        - main.//(UBIGINT col0, UBIGINT col1) -> UBIGINT
        """
        return call_duckdb_function(
            self._002f_002f_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _003c_002d_003e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<->',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[]'), parse_type('FLOAT[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<->',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[]'), parse_type('DOUBLE[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('<->',))
    def symbol_003c_002d_003e(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``<->``.

        Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length.

        Overloads:
        - main.<->(FLOAT[] list1, FLOAT[] list2) -> FLOAT
        - main.<->(DOUBLE[] list1, DOUBLE[] list2) -> DOUBLE
        """
        return call_duckdb_function(
            self._003c_002d_003e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _003c_003c_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<<',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift left',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('<<',))
    def symbol_003c_003c(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``<<``.

        Bitwise shift left

        Overloads:
        - main.<<(TINYINT input, TINYINT col1) -> TINYINT
        - main.<<(SMALLINT input, SMALLINT col1) -> SMALLINT
        - main.<<(INTEGER input, INTEGER col1) -> INTEGER
        - main.<<(BIGINT input, BIGINT col1) -> BIGINT
        - main.<<(HUGEINT input, HUGEINT col1) -> HUGEINT
        - main.<<(UTINYINT input, UTINYINT col1) -> UTINYINT
        - main.<<(USMALLINT input, USMALLINT col1) -> USMALLINT
        - main.<<(UINTEGER input, UINTEGER col1) -> UINTEGER
        - main.<<(UBIGINT input, UBIGINT col1) -> UBIGINT
        """
        return call_duckdb_function(
            self._003c_003c_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _003c_003d_003e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<=>',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT[]'), parse_type('FLOAT[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the cosine distance between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='<=>',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE[]'), parse_type('DOUBLE[]')),
                        parameters=('list1', 'list2'),
                        varargs=None,
                        description='Computes the cosine distance between two same-sized lists.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('<=>',))
    def symbol_003c_003d_003e(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``<=>``.

        Computes the cosine distance between two same-sized lists.

        Overloads:
        - main.<=>(FLOAT[] list1, FLOAT[] list2) -> FLOAT
        - main.<=>(DOUBLE[] list1, DOUBLE[] list2) -> DOUBLE
        """
        return call_duckdb_function(
            self._003c_003d_003e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _003e_003e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='>>',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('input', 'col1'),
                        varargs=None,
                        description='Bitwise shift right',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('>>',))
    def symbol_003e_003e(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``>>``.

        Bitwise shift right

        Overloads:
        - main.>>(TINYINT input, TINYINT col1) -> TINYINT
        - main.>>(SMALLINT input, SMALLINT col1) -> SMALLINT
        - main.>>(INTEGER input, INTEGER col1) -> INTEGER
        - main.>>(BIGINT input, BIGINT col1) -> BIGINT
        - main.>>(HUGEINT input, HUGEINT col1) -> HUGEINT
        - main.>>(UTINYINT input, UTINYINT col1) -> UTINYINT
        - main.>>(USMALLINT input, USMALLINT col1) -> USMALLINT
        - main.>>(UINTEGER input, UINTEGER col1) -> UINTEGER
        - main.>>(UBIGINT input, UBIGINT col1) -> UBIGINT
        """
        return call_duckdb_function(
            self._003e_003e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _0040_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('FLOAT'),
                        parameter_types=(parse_type('FLOAT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('DECIMAL'),
                        parameter_types=(parse_type('DECIMAL'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='@',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('x',),
                        varargs=None,
                        description='Absolute value',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('@',))
    def symbol_0040(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``@``.

        Absolute value

        Overloads:
        - main.@(TINYINT x) -> TINYINT
        - main.@(SMALLINT x) -> SMALLINT
        - main.@(INTEGER x) -> INTEGER
        - main.@(BIGINT x) -> BIGINT
        - main.@(HUGEINT x) -> HUGEINT
        - main.@(FLOAT x) -> FLOAT
        - main.@(DOUBLE x) -> DOUBLE
        - main.@(DECIMAL x) -> DECIMAL
        - main.@(UTINYINT x) -> UTINYINT
        - main.@(USMALLINT x) -> USMALLINT
        - main.@(UINTEGER x) -> UINTEGER
        - main.@(UBIGINT x) -> UBIGINT
        """
        return call_duckdb_function(
            self._0040_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _005e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='^',
                        function_type=function_type,
                        return_type=parse_type('DOUBLE'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('x', 'y'),
                        varargs=None,
                        description='Computes x to the power of y',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('^',))
    def symbol_005e(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``^``.

        Computes x to the power of y

        Overloads:
        - main.^(DOUBLE x, DOUBLE y) -> DOUBLE
        """
        return call_duckdb_function(
            self._005e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _007c_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'), parse_type('TINYINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'), parse_type('SMALLINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'), parse_type('HUGEINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'), parse_type('UTINYINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'), parse_type('USMALLINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'), parse_type('UINTEGER')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='|',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'), parse_type('UBIGINT')),
                        parameters=('left', 'right'),
                        varargs=None,
                        description='Bitwise OR',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('|',))
    def symbol_007c(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``|``.

        Bitwise OR

        Overloads:
        - main.|(TINYINT left, TINYINT right) -> TINYINT
        - main.|(SMALLINT left, SMALLINT right) -> SMALLINT
        - main.|(INTEGER left, INTEGER right) -> INTEGER
        - main.|(BIGINT left, BIGINT right) -> BIGINT
        - main.|(HUGEINT left, HUGEINT right) -> HUGEINT
        - main.|(UTINYINT left, UTINYINT right) -> UTINYINT
        - main.|(USMALLINT left, USMALLINT right) -> USMALLINT
        - main.|(UINTEGER left, UINTEGER right) -> UINTEGER
        - main.|(UBIGINT left, UBIGINT right) -> UBIGINT
        """
        return call_duckdb_function(
            self._007c_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _007e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('TINYINT'),
                        parameter_types=(parse_type('TINYINT'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('SMALLINT'),
                        parameter_types=(parse_type('SMALLINT'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('INTEGER'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('BIGINT'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('HUGEINT'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('UTINYINT'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('USMALLINT'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('UINTEGER'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='~',
                        function_type=function_type,
                        return_type=parse_type('UBIGINT'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('input',),
                        varargs=None,
                        description='Bitwise NOT',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('~',))
    def symbol_007e(self, *operands: object) -> NumericExpression:
        """Call DuckDB function ``~``.

        Bitwise NOT

        Overloads:
        - main.~(TINYINT input) -> TINYINT
        - main.~(SMALLINT input) -> SMALLINT
        - main.~(INTEGER input) -> INTEGER
        - main.~(BIGINT input) -> BIGINT
        - main.~(HUGEINT input) -> HUGEINT
        - main.~(UTINYINT input) -> UTINYINT
        - main.~(USMALLINT input) -> USMALLINT
        - main.~(UINTEGER input) -> UINTEGER
        - main.~(UBIGINT input) -> UBIGINT
        """
        return call_duckdb_function(
            self._007e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        '__internal_compress_integral_ubigint': '__internal_compress_integral_ubigint',
        '__internal_compress_integral_uinteger': '__internal_compress_integral_uinteger',
        '__internal_compress_integral_usmallint': '__internal_compress_integral_usmallint',
        '__internal_compress_integral_utinyint': '__internal_compress_integral_utinyint',
        '__internal_compress_string_hugeint': '__internal_compress_string_hugeint',
        '__internal_compress_string_ubigint': '__internal_compress_string_ubigint',
        '__internal_compress_string_uinteger': '__internal_compress_string_uinteger',
        '__internal_compress_string_usmallint': '__internal_compress_string_usmallint',
        '__internal_compress_string_utinyint': '__internal_compress_string_utinyint',
        '__internal_decompress_integral_bigint': '__internal_decompress_integral_bigint',
        '__internal_decompress_integral_hugeint': '__internal_decompress_integral_hugeint',
        '__internal_decompress_integral_integer': '__internal_decompress_integral_integer',
        '__internal_decompress_integral_smallint': '__internal_decompress_integral_smallint',
        '__internal_decompress_integral_ubigint': '__internal_decompress_integral_ubigint',
        '__internal_decompress_integral_uinteger': '__internal_decompress_integral_uinteger',
        '__internal_decompress_integral_usmallint': '__internal_decompress_integral_usmallint',
        'abs': 'abs',
        'acos': 'acos',
        'acosh': 'acosh',
        'add': 'add',
        'age': 'age',
        'array_cosine_distance': 'array_cosine_distance',
        'array_cosine_similarity': 'array_cosine_similarity',
        'array_cross_product': 'array_cross_product',
        'array_distance': 'array_distance',
        'array_dot_product': 'array_dot_product',
        'array_indexof': 'array_indexof',
        'array_inner_product': 'array_inner_product',
        'array_length': 'array_length',
        'array_negative_dot_product': 'array_negative_dot_product',
        'array_negative_inner_product': 'array_negative_inner_product',
        'array_position': 'array_position',
        'array_unique': 'array_unique',
        'ascii': 'ascii',
        'asin': 'asin',
        'asinh': 'asinh',
        'atan': 'atan',
        'atan2': 'atan2',
        'atanh': 'atanh',
        'bit_count': 'bit_count',
        'bit_length': 'bit_length',
        'bit_position': 'bit_position',
        'cardinality': 'cardinality',
        'cbrt': 'cbrt',
        'ceil': 'ceil',
        'ceiling': 'ceiling',
        'century': 'century',
        'char_length': 'char_length',
        'character_length': 'character_length',
        'cos': 'cos',
        'cosh': 'cosh',
        'cot': 'cot',
        'current_connection_id': 'current_connection_id',
        'current_query_id': 'current_query_id',
        'current_transaction_id': 'current_transaction_id',
        'currval': 'currval',
        'damerau_levenshtein': 'damerau_levenshtein',
        'date_add': 'date_add',
        'date_diff': 'date_diff',
        'date_part': 'date_part',
        'date_sub': 'date_sub',
        'date_trunc': 'date_trunc',
        'datediff': 'datediff',
        'datepart': 'datepart',
        'datesub': 'datesub',
        'datetrunc': 'datetrunc',
        'day': 'day',
        'dayofmonth': 'dayofmonth',
        'dayofweek': 'dayofweek',
        'dayofyear': 'dayofyear',
        'decade': 'decade',
        'degrees': 'degrees',
        'divide': 'divide',
        'editdist3': 'editdist3',
        'epoch': 'epoch',
        'epoch_ms': 'epoch_ms',
        'epoch_ns': 'epoch_ns',
        'epoch_us': 'epoch_us',
        'era': 'era',
        'even': 'even',
        'exp': 'exp',
        'factorial': 'factorial',
        'fdiv': 'fdiv',
        'floor': 'floor',
        'fmod': 'fmod',
        'gamma': 'gamma',
        'gcd': 'gcd',
        'generate_series': 'generate_series',
        'geomean': 'geomean',
        'geometric_mean': 'geometric_mean',
        'get_bit': 'get_bit',
        'get_block_size': 'get_block_size',
        'greatest_common_divisor': 'greatest_common_divisor',
        'hamming': 'hamming',
        'hash': 'hash',
        'hour': 'hour',
        'instr': 'instr',
        'isodow': 'isodow',
        'isoyear': 'isoyear',
        'jaccard': 'jaccard',
        'jaro_similarity': 'jaro_similarity',
        'jaro_winkler_similarity': 'jaro_winkler_similarity',
        'json_array_length': 'json_array_length',
        'julian': 'julian',
        'lcm': 'lcm',
        'least_common_multiple': 'least_common_multiple',
        'len': 'len',
        'length': 'length',
        'length_grapheme': 'length_grapheme',
        'levenshtein': 'levenshtein',
        'lgamma': 'lgamma',
        'list_cosine_distance': 'list_cosine_distance',
        'list_cosine_similarity': 'list_cosine_similarity',
        'list_distance': 'list_distance',
        'list_dot_product': 'list_dot_product',
        'list_indexof': 'list_indexof',
        'list_inner_product': 'list_inner_product',
        'list_negative_dot_product': 'list_negative_dot_product',
        'list_negative_inner_product': 'list_negative_inner_product',
        'list_position': 'list_position',
        'list_unique': 'list_unique',
        'ln': 'ln',
        'log': 'log',
        'log10': 'log10',
        'log2': 'log2',
        'map_to_pg_oid': 'map_to_pg_oid',
        'md5_number_lower': 'md5_number_lower',
        'md5_number_upper': 'md5_number_upper',
        'microsecond': 'microsecond',
        'millennium': 'millennium',
        'millisecond': 'millisecond',
        'minute': 'minute',
        'mismatches': 'mismatches',
        'mod': 'mod',
        'month': 'month',
        'multiply': 'multiply',
        'nanosecond': 'nanosecond',
        'nextafter': 'nextafter',
        'nextval': 'nextval',
        'normalized_interval': 'normalized_interval',
        'octet_length': 'octet_length',
        'ord': 'ord',
        'pg_my_temp_schema': 'pg_my_temp_schema',
        'pi': 'pi',
        'position': 'position',
        'pow': 'pow',
        'power': 'power',
        'quarter': 'quarter',
        'radians': 'radians',
        'random': 'random',
        'range': 'range',
        'round': 'round',
        'round_even': 'round_even',
        'roundbankers': 'roundbankers',
        'second': 'second',
        'sign': 'sign',
        'sin': 'sin',
        'sinh': 'sinh',
        'sqrt': 'sqrt',
        'strlen': 'strlen',
        'strpos': 'strpos',
        'struct_indexof': 'struct_indexof',
        'struct_position': 'struct_position',
        'subtract': 'subtract',
        'tan': 'tan',
        'tanh': 'tanh',
        'timetz_byte_comparable': 'timetz_byte_comparable',
        'timezone': 'timezone',
        'timezone_hour': 'timezone_hour',
        'timezone_minute': 'timezone_minute',
        'to_centuries': 'to_centuries',
        'to_days': 'to_days',
        'to_decades': 'to_decades',
        'to_hours': 'to_hours',
        'to_microseconds': 'to_microseconds',
        'to_millennia': 'to_millennia',
        'to_milliseconds': 'to_milliseconds',
        'to_minutes': 'to_minutes',
        'to_months': 'to_months',
        'to_quarters': 'to_quarters',
        'to_seconds': 'to_seconds',
        'to_weeks': 'to_weeks',
        'to_years': 'to_years',
        'trunc': 'trunc',
        'txid_current': 'txid_current',
        'unicode': 'unicode',
        'uuid_extract_version': 'uuid_extract_version',
        'wavg': 'wavg',
        'week': 'week',
        'weekday': 'weekday',
        'weekofyear': 'weekofyear',
        'weighted_avg': 'weighted_avg',
        'xor': 'xor',
        'year': 'year',
        'yearweek': 'yearweek',
    }

    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {
        '!__postfix': 'symbol_0021_005f_005f_0070_006f_0073_0074_0066_0069_0078',
        '%': 'symbol_0025',
        '&': 'symbol_0026',
        '*': 'symbol_002a',
        '**': 'symbol_002a_002a',
        '+': 'symbol_002b',
        '-': 'symbol_002d',
        '/': 'symbol_002f',
        '//': 'symbol_002f_002f',
        '<->': 'symbol_003c_002d_003e',
        '<<': 'symbol_003c_003c',
        '<=>': 'symbol_003c_003d_003e',
        '>>': 'symbol_003e_003e',
        '@': 'symbol_0040',
        '^': 'symbol_005e',
        '|': 'symbol_007c',
        '~': 'symbol_007e',
    }

class ScalarVarcharFunctions(_StaticFunctionNamespace):
    """DuckDB scalar functions returning string results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'scalar'
    return_category: ClassVar[str] = 'varchar'
    ___INTERNAL_DECOMPRESS_STRING_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UTINYINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('USMALLINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UINTEGER'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='__internal_decompress_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('__internal_decompress_string')
    def __internal_decompress_string(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``__internal_decompress_string``.

        Overloads:
        - main.__internal_decompress_string(UTINYINT col0) -> VARCHAR
        - main.__internal_decompress_string(USMALLINT col0) -> VARCHAR
        - main.__internal_decompress_string(UINTEGER col0) -> VARCHAR
        - main.__internal_decompress_string(UBIGINT col0) -> VARCHAR
        - main.__internal_decompress_string(UHUGEINT col0) -> VARCHAR
        - main.__internal_decompress_string(HUGEINT col0) -> VARCHAR
        """
        return call_duckdb_function(
            self.___INTERNAL_DECOMPRESS_STRING_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ALIAS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='alias',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('expr',),
                        varargs=None,
                        description='Returns the name of a given expression',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('alias')
    def alias(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``alias``.

        Returns the name of a given expression

        Overloads:
        - main.alias(ANY expr) -> VARCHAR
        """
        return call_duckdb_function(
            self._ALIAS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_extract',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('string', 'index'),
                        varargs=None,
                        description='Extracts a single character from a `string` using a (1-based) `index`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_extract')
    def array_extract(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``array_extract``.

        Extracts a single character from a `string` using a (1-based) `index`.

        Overloads:
        - main.array_extract(VARCHAR string, BIGINT index) -> VARCHAR
        """
        return call_duckdb_function(
            self._ARRAY_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_TO_JSON_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_to_json',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('array_to_json')
    def array_to_json(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``array_to_json``.

        Overloads:
        - main.array_to_json(ANY ...) -> JSON
        """
        return call_duckdb_function(
            self._ARRAY_TO_JSON_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_TO_STRING_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_to_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None, None),
                        parameters=('arr', 'sep'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(CAST(arr AS VARCHAR[]), 'string_agg', sep)",
                    ),
    )
    @duckdb_function('array_to_string')
    def array_to_string(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``array_to_string``.

        Overloads:
        - main.array_to_string(ANY arr, ANY sep) -> VARCHAR
        """
        return call_duckdb_function(
            self._ARRAY_TO_STRING_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ARRAY_TO_STRING_COMMA_DEFAULT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='array_to_string_comma_default',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None, None),
                        parameters=('arr', 'sep'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="list_aggr(CAST(arr AS VARCHAR[]), 'string_agg', sep)",
                    ),
    )
    @duckdb_function('array_to_string_comma_default')
    def array_to_string_comma_default(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``array_to_string_comma_default``.

        Overloads:
        - main.array_to_string_comma_default(ANY arr, ANY sep) -> VARCHAR
        """
        return call_duckdb_function(
            self._ARRAY_TO_STRING_COMMA_DEFAULT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _BAR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bar',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('x', 'min', 'max'),
                        varargs=None,
                        description='Draws a band whose width is proportional to (`x - min`) and equal to `width` characters when `x` = `max`. `width` defaults to 80.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bar',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('DOUBLE'), parse_type('DOUBLE'), parse_type('DOUBLE'), parse_type('DOUBLE')),
                        parameters=('x', 'min', 'max', 'width'),
                        varargs=None,
                        description='Draws a band whose width is proportional to (`x - min`) and equal to `width` characters when `x` = `max`. `width` defaults to 80.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bar')
    def bar(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``bar``.

        Draws a band whose width is proportional to (`x - min`) and equal to `width` characters when `x` = `max`. `width` defaults to 80.

        Overloads:
        - main.bar(DOUBLE x, DOUBLE min, DOUBLE max) -> VARCHAR
        - main.bar(DOUBLE x, DOUBLE min, DOUBLE max, DOUBLE width) -> VARCHAR
        """
        return call_duckdb_function(
            self._BAR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _BASE64_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='base64',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Converts a `blob` to a base64 encoded string.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('base64')
    def base64(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``base64``.

        Converts a `blob` to a base64 encoded string.

        Overloads:
        - main.base64(BLOB blob) -> VARCHAR
        """
        return call_duckdb_function(
            self._BASE64_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _BIN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts the `string` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGNUM'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='bin',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('bin')
    def bin(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``bin``.

        Converts the `string` to binary representation.

        Overloads:
        - main.bin(VARCHAR string) -> VARCHAR
        - main.bin(BIGNUM value) -> VARCHAR
        - main.bin(UBIGINT value) -> VARCHAR
        - main.bin(BIGINT value) -> VARCHAR
        - main.bin(HUGEINT value) -> VARCHAR
        - main.bin(UHUGEINT value) -> VARCHAR
        """
        return call_duckdb_function(
            self._BIN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CHR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='chr',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('INTEGER'),),
                        parameters=('code_point',),
                        varargs=None,
                        description='Returns a character which is corresponding the ASCII code value or Unicode code point.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('chr')
    def chr(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``chr``.

        Returns a character which is corresponding the ASCII code value or Unicode code point.

        Overloads:
        - main.chr(INTEGER code_point) -> VARCHAR
        """
        return call_duckdb_function(
            self._CHR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CONCAT_WS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='concat_ws',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('ANY')),
                        parameters=('separator', 'string'),
                        varargs=parse_type('ANY'),
                        description='Concatenates many strings, separated by `separator`. `NULL` inputs are skipped.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('concat_ws')
    def concat_ws(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``concat_ws``.

        Concatenates many strings, separated by `separator`. `NULL` inputs are skipped.

        Overloads:
        - main.concat_ws(VARCHAR separator, ANY string, ANY ...) -> VARCHAR
        """
        return call_duckdb_function(
            self._CONCAT_WS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_CATALOG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_catalog',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='main.current_database()',
                    ),
    )
    @duckdb_function('current_catalog')
    def current_catalog(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``current_catalog``.

        Overloads:
        - main.current_catalog() -> VARCHAR
        """
        return call_duckdb_function(
            self._CURRENT_CATALOG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_DATABASE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_database',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the name of the currently active database',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='current_database',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='"system".main.current_database()',
                    ),
    )
    @duckdb_function('current_database')
    def current_database(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``current_database``.

        Returns the name of the currently active database

        Overloads:
        - main.current_database() -> VARCHAR
        - pg_catalog.current_database() -> VARCHAR
        """
        return call_duckdb_function(
            self._CURRENT_DATABASE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_QUERY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_query',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the current query as a string',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='current_query',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='"system".main.current_query()',
                    ),
    )
    @duckdb_function('current_query')
    def current_query(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``current_query``.

        Returns the current query as a string

        Overloads:
        - main.current_query() -> VARCHAR
        - pg_catalog.current_query() -> VARCHAR
        """
        return call_duckdb_function(
            self._CURRENT_QUERY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_ROLE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_role',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="'duckdb'",
                    ),
    )
    @duckdb_function('current_role')
    def current_role(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``current_role``.

        Overloads:
        - main.current_role() -> VARCHAR
        """
        return call_duckdb_function(
            self._CURRENT_ROLE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_SCHEMA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_schema',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the name of the currently active schema. Default is main',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='current_schema',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='"system".main.current_schema()',
                    ),
    )
    @duckdb_function('current_schema')
    def current_schema(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``current_schema``.

        Returns the name of the currently active schema. Default is main

        Overloads:
        - main.current_schema() -> VARCHAR
        - pg_catalog.current_schema() -> VARCHAR
        """
        return call_duckdb_function(
            self._CURRENT_SCHEMA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_SCHEMAS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_schemas',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('BOOLEAN'),),
                        parameters=('include_implicit',),
                        varargs=None,
                        description='Returns list of schemas. Pass a parameter of True to include implicit schemas',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='current_schemas',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(None,),
                        parameters=('include_implicit',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='"system".main.current_schemas(include_implicit)',
                    ),
    )
    @duckdb_function('current_schemas')
    def current_schemas(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``current_schemas``.

        Returns list of schemas. Pass a parameter of True to include implicit schemas

        Overloads:
        - main.current_schemas(BOOLEAN include_implicit) -> VARCHAR[]
        - pg_catalog.current_schemas(ANY include_implicit) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._CURRENT_SCHEMAS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _CURRENT_USER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='current_user',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="'duckdb'",
                    ),
    )
    @duckdb_function('current_user')
    def current_user(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``current_user``.

        Overloads:
        - main.current_user() -> VARCHAR
        """
        return call_duckdb_function(
            self._CURRENT_USER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DAYNAME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayname',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='The (English) name of the weekday',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayname',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='The (English) name of the weekday',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='dayname',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='The (English) name of the weekday',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('dayname')
    def dayname(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``dayname``.

        The (English) name of the weekday

        Overloads:
        - main.dayname(DATE ts) -> VARCHAR
        - main.dayname(TIMESTAMP ts) -> VARCHAR
        - main.dayname(TIMESTAMP WITH TIME ZONE ts) -> VARCHAR
        """
        return call_duckdb_function(
            self._DAYNAME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _DECODE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='decode',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Converts `blob` to `VARCHAR`. Fails if `blob` is not valid UTF-8.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('decode')
    def decode(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``decode``.

        Converts `blob` to `VARCHAR`. Fails if `blob` is not valid UTF-8.

        Overloads:
        - main.decode(BLOB blob) -> VARCHAR
        """
        return call_duckdb_function(
            self._DECODE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ENUM_FIRST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='enum_first',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('enum',),
                        varargs=None,
                        description='Returns the first value of the input enum type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('enum_first')
    def enum_first(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``enum_first``.

        Returns the first value of the input enum type

        Overloads:
        - main.enum_first(ANY enum) -> VARCHAR
        """
        return call_duckdb_function(
            self._ENUM_FIRST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ENUM_LAST_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='enum_last',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('enum',),
                        varargs=None,
                        description='Returns the last value of the input enum type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('enum_last')
    def enum_last(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``enum_last``.

        Returns the last value of the input enum type

        Overloads:
        - main.enum_last(ANY enum) -> VARCHAR
        """
        return call_duckdb_function(
            self._ENUM_LAST_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ENUM_RANGE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='enum_range',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('enum',),
                        varargs=None,
                        description='Returns all values of the input enum type as an array',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('enum_range')
    def enum_range(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``enum_range``.

        Returns all values of the input enum type as an array

        Overloads:
        - main.enum_range(ANY enum) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._ENUM_RANGE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ENUM_RANGE_BOUNDARY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='enum_range_boundary',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('ANY'), parse_type('ANY')),
                        parameters=('start', 'end'),
                        varargs=None,
                        description='Returns the range between the two given enum values as an array. The values must be of the same enum type. When the first parameter is NULL, the result starts with the first value of the enum type. When the second parameter is NULL, the result ends with the last value of the enum type',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('enum_range_boundary')
    def enum_range_boundary(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``enum_range_boundary``.

        Returns the range between the two given enum values as an array. The values must be of the same enum type. When the first parameter is NULL, the result starts with the first value of the enum type. When the second parameter is NULL, the result ends with the last value of the enum type

        Overloads:
        - main.enum_range_boundary(ANY start, ANY end) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._ENUM_RANGE_BOUNDARY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FORMAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='format',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('format',),
                        varargs=parse_type('ANY'),
                        description='Formats a string using the fmt syntax.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('format')
    def format(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``format``.

        Formats a string using the fmt syntax.

        Overloads:
        - main.format(VARCHAR format, ANY ...) -> VARCHAR
        """
        return call_duckdb_function(
            self._FORMAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FORMATREADABLEDECIMALSIZE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='formatReadableDecimalSize',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Converts `integer` to a human-readable representation using units based on powers of 10 (KB, MB, GB, etc.).',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('formatReadableDecimalSize')
    def formatReadableDecimalSize(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``formatReadableDecimalSize``.

        Converts `integer` to a human-readable representation using units based on powers of 10 (KB, MB, GB, etc.).

        Overloads:
        - main.formatReadableDecimalSize(BIGINT integer) -> VARCHAR
        """
        return call_duckdb_function(
            self._FORMATREADABLEDECIMALSIZE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FORMATREADABLESIZE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='formatReadableSize',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('formatReadableSize')
    def formatReadableSize(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``formatReadableSize``.

        Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).

        Overloads:
        - main.formatReadableSize(BIGINT integer) -> VARCHAR
        """
        return call_duckdb_function(
            self._FORMATREADABLESIZE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FORMAT_BYTES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='format_bytes',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('integer',),
                        varargs=None,
                        description='Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('format_bytes')
    def format_bytes(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``format_bytes``.

        Converts `integer` to a human-readable representation using units based on powers of 2 (KiB, MiB, GiB, etc.).

        Overloads:
        - main.format_bytes(BIGINT integer) -> VARCHAR
        """
        return call_duckdb_function(
            self._FORMAT_BYTES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FORMAT_PG_TYPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='format_pg_type',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None, None),
                        parameters=('logical_type', 'type_name'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="CASE  WHEN ((upper(logical_type) = 'FLOAT')) THEN ('float4') WHEN ((upper(logical_type) = 'DOUBLE')) THEN ('float8') WHEN ((upper(logical_type) = 'DECIMAL')) THEN ('numeric') WHEN ((upper(logical_type) = 'ENUM')) THEN (lower(type_name)) WHEN ((upper(logical_type) = 'VARCHAR')) THEN ('varchar') WHEN ((upper(logical_type) = 'BLOB')) THEN ('bytea') WHEN ((upper(logical_type) = 'TIMESTAMP')) THEN ('timestamp') WHEN ((upper(logical_type) = 'TIME')) THEN ('time') WHEN ((upper(logical_type) = 'TIMESTAMP WITH TIME ZONE')) THEN ('timestamptz') WHEN ((upper(logical_type) = 'TIME WITH TIME ZONE')) THEN ('timetz') WHEN ((upper(logical_type) = 'SMALLINT')) THEN ('int2') WHEN ((upper(logical_type) = 'INTEGER')) THEN ('int4') WHEN ((upper(logical_type) = 'BIGINT')) THEN ('int8') WHEN ((upper(logical_type) = 'BOOLEAN')) THEN ('bool') ELSE lower(logical_type) END",
                    ),
    )
    @duckdb_function('format_pg_type')
    def format_pg_type(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``format_pg_type``.

        Overloads:
        - pg_catalog.format_pg_type(ANY logical_type, ANY type_name) -> VARCHAR
        """
        return call_duckdb_function(
            self._FORMAT_PG_TYPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _FORMAT_TYPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='format_type',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None, None),
                        parameters=('type_oid', 'typemod'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="((SELECT format_pg_type(logical_type, type_name) FROM duckdb_types() AS t WHERE (t.type_oid = type_oid)) || CASE  WHEN ((typemod > 0)) THEN (concat('(', (typemod // 1000), ',', (typemod % 1000), ')')) ELSE '' END)",
                    ),
    )
    @duckdb_function('format_type')
    def format_type(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``format_type``.

        Overloads:
        - pg_catalog.format_type(ANY type_oid, ANY typemod) -> VARCHAR
        """
        return call_duckdb_function(
            self._FORMAT_TYPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _GEN_RANDOM_UUID_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='gen_random_uuid',
                        function_type=function_type,
                        return_type=parse_type('UUID'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns a random UUID v4 similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('gen_random_uuid')
    def gen_random_uuid(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``gen_random_uuid``.

        Returns a random UUID v4 similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687

        Overloads:
        - main.gen_random_uuid() -> UUID
        """
        return call_duckdb_function(
            self._GEN_RANDOM_UUID_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _HEX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts the `string` to hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGNUM'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Converts `blob` to `VARCHAR` using hexadecimal encoding.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('hex')
    def hex(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``hex``.

        Converts the `string` to hexadecimal representation.

        Overloads:
        - main.hex(VARCHAR string) -> VARCHAR
        - main.hex(BIGNUM value) -> VARCHAR
        - main.hex(BLOB blob) -> VARCHAR
        - main.hex(BIGINT value) -> VARCHAR
        - main.hex(UBIGINT value) -> VARCHAR
        - main.hex(HUGEINT value) -> VARCHAR
        - main.hex(UHUGEINT value) -> VARCHAR
        """
        return call_duckdb_function(
            self._HEX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_AF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_af',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_af')
    def icu_collate_af(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_af``.

        Overloads:
        - main.icu_collate_af(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_AF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_AM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_am',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_am')
    def icu_collate_am(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_am``.

        Overloads:
        - main.icu_collate_am(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_AM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_AR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ar',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ar')
    def icu_collate_ar(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ar``.

        Overloads:
        - main.icu_collate_ar(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_AR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_AR_SA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ar_sa',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ar_sa')
    def icu_collate_ar_sa(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ar_sa``.

        Overloads:
        - main.icu_collate_ar_sa(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_AR_SA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_AS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_as',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_as')
    def icu_collate_as(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_as``.

        Overloads:
        - main.icu_collate_as(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_AS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_AZ_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_az',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_az')
    def icu_collate_az(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_az``.

        Overloads:
        - main.icu_collate_az(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_AZ_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_BE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_be',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_be')
    def icu_collate_be(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_be``.

        Overloads:
        - main.icu_collate_be(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_BE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_BG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_bg',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_bg')
    def icu_collate_bg(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_bg``.

        Overloads:
        - main.icu_collate_bg(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_BG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_BN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_bn',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_bn')
    def icu_collate_bn(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_bn``.

        Overloads:
        - main.icu_collate_bn(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_BN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_BO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_bo',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_bo')
    def icu_collate_bo(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_bo``.

        Overloads:
        - main.icu_collate_bo(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_BO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_BR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_br',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_br')
    def icu_collate_br(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_br``.

        Overloads:
        - main.icu_collate_br(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_BR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_BS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_bs',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_bs')
    def icu_collate_bs(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_bs``.

        Overloads:
        - main.icu_collate_bs(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_BS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_CA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ca',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ca')
    def icu_collate_ca(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ca``.

        Overloads:
        - main.icu_collate_ca(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_CA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_CEB_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ceb',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ceb')
    def icu_collate_ceb(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ceb``.

        Overloads:
        - main.icu_collate_ceb(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_CEB_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_CHR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_chr',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_chr')
    def icu_collate_chr(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_chr``.

        Overloads:
        - main.icu_collate_chr(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_CHR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_CS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_cs',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_cs')
    def icu_collate_cs(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_cs``.

        Overloads:
        - main.icu_collate_cs(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_CS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_CY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_cy',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_cy')
    def icu_collate_cy(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_cy``.

        Overloads:
        - main.icu_collate_cy(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_CY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_DA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_da',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_da')
    def icu_collate_da(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_da``.

        Overloads:
        - main.icu_collate_da(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_DA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_DE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_de',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_de')
    def icu_collate_de(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_de``.

        Overloads:
        - main.icu_collate_de(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_DE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_DE_AT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_de_at',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_de_at')
    def icu_collate_de_at(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_de_at``.

        Overloads:
        - main.icu_collate_de_at(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_DE_AT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_DSB_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_dsb',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_dsb')
    def icu_collate_dsb(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_dsb``.

        Overloads:
        - main.icu_collate_dsb(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_DSB_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_DZ_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_dz',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_dz')
    def icu_collate_dz(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_dz``.

        Overloads:
        - main.icu_collate_dz(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_DZ_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_EE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ee',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ee')
    def icu_collate_ee(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ee``.

        Overloads:
        - main.icu_collate_ee(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_EE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_EL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_el',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_el')
    def icu_collate_el(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_el``.

        Overloads:
        - main.icu_collate_el(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_EL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_EN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_en',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_en')
    def icu_collate_en(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_en``.

        Overloads:
        - main.icu_collate_en(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_EN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_EN_US_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_en_us',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_en_us')
    def icu_collate_en_us(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_en_us``.

        Overloads:
        - main.icu_collate_en_us(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_EN_US_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_EO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_eo',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_eo')
    def icu_collate_eo(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_eo``.

        Overloads:
        - main.icu_collate_eo(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_EO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ES_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_es',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_es')
    def icu_collate_es(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_es``.

        Overloads:
        - main.icu_collate_es(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ES_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ET_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_et',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_et')
    def icu_collate_et(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_et``.

        Overloads:
        - main.icu_collate_et(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ET_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_FA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_fa',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_fa')
    def icu_collate_fa(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_fa``.

        Overloads:
        - main.icu_collate_fa(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_FA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_FA_AF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_fa_af',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_fa_af')
    def icu_collate_fa_af(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_fa_af``.

        Overloads:
        - main.icu_collate_fa_af(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_FA_AF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_FF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ff',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ff')
    def icu_collate_ff(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ff``.

        Overloads:
        - main.icu_collate_ff(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_FF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_FI_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_fi',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_fi')
    def icu_collate_fi(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_fi``.

        Overloads:
        - main.icu_collate_fi(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_FI_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_FIL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_fil',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_fil')
    def icu_collate_fil(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_fil``.

        Overloads:
        - main.icu_collate_fil(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_FIL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_FO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_fo',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_fo')
    def icu_collate_fo(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_fo``.

        Overloads:
        - main.icu_collate_fo(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_FO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_FR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_fr',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_fr')
    def icu_collate_fr(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_fr``.

        Overloads:
        - main.icu_collate_fr(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_FR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_FR_CA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_fr_ca',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_fr_ca')
    def icu_collate_fr_ca(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_fr_ca``.

        Overloads:
        - main.icu_collate_fr_ca(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_FR_CA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_FY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_fy',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_fy')
    def icu_collate_fy(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_fy``.

        Overloads:
        - main.icu_collate_fy(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_FY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_GA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ga',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ga')
    def icu_collate_ga(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ga``.

        Overloads:
        - main.icu_collate_ga(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_GA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_GL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_gl',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_gl')
    def icu_collate_gl(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_gl``.

        Overloads:
        - main.icu_collate_gl(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_GL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_GU_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_gu',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_gu')
    def icu_collate_gu(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_gu``.

        Overloads:
        - main.icu_collate_gu(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_GU_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_HA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ha',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ha')
    def icu_collate_ha(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ha``.

        Overloads:
        - main.icu_collate_ha(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_HA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_HAW_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_haw',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_haw')
    def icu_collate_haw(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_haw``.

        Overloads:
        - main.icu_collate_haw(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_HAW_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_HE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_he',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_he')
    def icu_collate_he(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_he``.

        Overloads:
        - main.icu_collate_he(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_HE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_HE_IL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_he_il',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_he_il')
    def icu_collate_he_il(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_he_il``.

        Overloads:
        - main.icu_collate_he_il(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_HE_IL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_HI_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_hi',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_hi')
    def icu_collate_hi(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_hi``.

        Overloads:
        - main.icu_collate_hi(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_HI_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_HR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_hr',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_hr')
    def icu_collate_hr(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_hr``.

        Overloads:
        - main.icu_collate_hr(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_HR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_HSB_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_hsb',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_hsb')
    def icu_collate_hsb(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_hsb``.

        Overloads:
        - main.icu_collate_hsb(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_HSB_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_HU_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_hu',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_hu')
    def icu_collate_hu(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_hu``.

        Overloads:
        - main.icu_collate_hu(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_HU_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_HY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_hy',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_hy')
    def icu_collate_hy(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_hy``.

        Overloads:
        - main.icu_collate_hy(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_HY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ID_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_id',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_id')
    def icu_collate_id(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_id``.

        Overloads:
        - main.icu_collate_id(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ID_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ID_ID_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_id_id',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_id_id')
    def icu_collate_id_id(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_id_id``.

        Overloads:
        - main.icu_collate_id_id(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ID_ID_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_IG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ig',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ig')
    def icu_collate_ig(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ig``.

        Overloads:
        - main.icu_collate_ig(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_IG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_IS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_is',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_is')
    def icu_collate_is(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_is``.

        Overloads:
        - main.icu_collate_is(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_IS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_IT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_it',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_it')
    def icu_collate_it(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_it``.

        Overloads:
        - main.icu_collate_it(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_IT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_JA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ja',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ja')
    def icu_collate_ja(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ja``.

        Overloads:
        - main.icu_collate_ja(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_JA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_KA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ka',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ka')
    def icu_collate_ka(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ka``.

        Overloads:
        - main.icu_collate_ka(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_KA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_KK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_kk',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_kk')
    def icu_collate_kk(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_kk``.

        Overloads:
        - main.icu_collate_kk(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_KK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_KL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_kl',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_kl')
    def icu_collate_kl(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_kl``.

        Overloads:
        - main.icu_collate_kl(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_KL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_KM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_km',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_km')
    def icu_collate_km(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_km``.

        Overloads:
        - main.icu_collate_km(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_KM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_KN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_kn',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_kn')
    def icu_collate_kn(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_kn``.

        Overloads:
        - main.icu_collate_kn(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_KN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_KO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ko',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ko')
    def icu_collate_ko(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ko``.

        Overloads:
        - main.icu_collate_ko(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_KO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_KOK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_kok',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_kok')
    def icu_collate_kok(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_kok``.

        Overloads:
        - main.icu_collate_kok(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_KOK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_KU_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ku',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ku')
    def icu_collate_ku(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ku``.

        Overloads:
        - main.icu_collate_ku(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_KU_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_KY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ky',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ky')
    def icu_collate_ky(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ky``.

        Overloads:
        - main.icu_collate_ky(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_KY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_LB_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_lb',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_lb')
    def icu_collate_lb(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_lb``.

        Overloads:
        - main.icu_collate_lb(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_LB_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_LKT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_lkt',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_lkt')
    def icu_collate_lkt(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_lkt``.

        Overloads:
        - main.icu_collate_lkt(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_LKT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_LN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ln',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ln')
    def icu_collate_ln(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ln``.

        Overloads:
        - main.icu_collate_ln(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_LN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_LO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_lo',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_lo')
    def icu_collate_lo(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_lo``.

        Overloads:
        - main.icu_collate_lo(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_LO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_LT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_lt',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_lt')
    def icu_collate_lt(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_lt``.

        Overloads:
        - main.icu_collate_lt(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_LT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_LV_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_lv',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_lv')
    def icu_collate_lv(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_lv``.

        Overloads:
        - main.icu_collate_lv(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_LV_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_MK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_mk',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_mk')
    def icu_collate_mk(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_mk``.

        Overloads:
        - main.icu_collate_mk(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_MK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ML_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ml',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ml')
    def icu_collate_ml(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ml``.

        Overloads:
        - main.icu_collate_ml(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ML_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_MN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_mn',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_mn')
    def icu_collate_mn(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_mn``.

        Overloads:
        - main.icu_collate_mn(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_MN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_MR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_mr',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_mr')
    def icu_collate_mr(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_mr``.

        Overloads:
        - main.icu_collate_mr(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_MR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_MS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ms',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ms')
    def icu_collate_ms(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ms``.

        Overloads:
        - main.icu_collate_ms(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_MS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_MT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_mt',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_mt')
    def icu_collate_mt(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_mt``.

        Overloads:
        - main.icu_collate_mt(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_MT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_MY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_my',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_my')
    def icu_collate_my(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_my``.

        Overloads:
        - main.icu_collate_my(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_MY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_NB_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_nb',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_nb')
    def icu_collate_nb(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_nb``.

        Overloads:
        - main.icu_collate_nb(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_NB_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_NB_NO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_nb_no',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_nb_no')
    def icu_collate_nb_no(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_nb_no``.

        Overloads:
        - main.icu_collate_nb_no(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_NB_NO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_NE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ne',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ne')
    def icu_collate_ne(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ne``.

        Overloads:
        - main.icu_collate_ne(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_NE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_NL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_nl',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_nl')
    def icu_collate_nl(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_nl``.

        Overloads:
        - main.icu_collate_nl(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_NL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_NN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_nn',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_nn')
    def icu_collate_nn(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_nn``.

        Overloads:
        - main.icu_collate_nn(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_NN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_NOACCENT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_noaccent',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_noaccent')
    def icu_collate_noaccent(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_noaccent``.

        Overloads:
        - main.icu_collate_noaccent(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_NOACCENT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_OM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_om',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_om')
    def icu_collate_om(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_om``.

        Overloads:
        - main.icu_collate_om(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_OM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_OR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_or',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_or')
    def icu_collate_or(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_or``.

        Overloads:
        - main.icu_collate_or(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_OR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_PA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_pa',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_pa')
    def icu_collate_pa(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_pa``.

        Overloads:
        - main.icu_collate_pa(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_PA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_PA_IN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_pa_in',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_pa_in')
    def icu_collate_pa_in(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_pa_in``.

        Overloads:
        - main.icu_collate_pa_in(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_PA_IN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_PL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_pl',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_pl')
    def icu_collate_pl(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_pl``.

        Overloads:
        - main.icu_collate_pl(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_PL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_PS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ps',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ps')
    def icu_collate_ps(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ps``.

        Overloads:
        - main.icu_collate_ps(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_PS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_PT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_pt',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_pt')
    def icu_collate_pt(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_pt``.

        Overloads:
        - main.icu_collate_pt(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_PT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_RO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ro',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ro')
    def icu_collate_ro(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ro``.

        Overloads:
        - main.icu_collate_ro(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_RO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_RU_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ru',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ru')
    def icu_collate_ru(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ru``.

        Overloads:
        - main.icu_collate_ru(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_RU_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sa',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sa')
    def icu_collate_sa(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sa``.

        Overloads:
        - main.icu_collate_sa(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_se',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_se')
    def icu_collate_se(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_se``.

        Overloads:
        - main.icu_collate_se(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SI_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_si',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_si')
    def icu_collate_si(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_si``.

        Overloads:
        - main.icu_collate_si(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SI_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sk',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sk')
    def icu_collate_sk(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sk``.

        Overloads:
        - main.icu_collate_sk(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sl',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sl')
    def icu_collate_sl(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sl``.

        Overloads:
        - main.icu_collate_sl(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SMN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_smn',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_smn')
    def icu_collate_smn(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_smn``.

        Overloads:
        - main.icu_collate_smn(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SMN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SQ_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sq',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sq')
    def icu_collate_sq(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sq``.

        Overloads:
        - main.icu_collate_sq(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SQ_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sr',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sr')
    def icu_collate_sr(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sr``.

        Overloads:
        - main.icu_collate_sr(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SR_BA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sr_ba',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sr_ba')
    def icu_collate_sr_ba(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sr_ba``.

        Overloads:
        - main.icu_collate_sr_ba(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SR_BA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SR_ME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sr_me',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sr_me')
    def icu_collate_sr_me(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sr_me``.

        Overloads:
        - main.icu_collate_sr_me(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SR_ME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SR_RS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sr_rs',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sr_rs')
    def icu_collate_sr_rs(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sr_rs``.

        Overloads:
        - main.icu_collate_sr_rs(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SR_RS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SV_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sv',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sv')
    def icu_collate_sv(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sv``.

        Overloads:
        - main.icu_collate_sv(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SV_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_SW_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_sw',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_sw')
    def icu_collate_sw(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_sw``.

        Overloads:
        - main.icu_collate_sw(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_SW_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_TA_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ta',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ta')
    def icu_collate_ta(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ta``.

        Overloads:
        - main.icu_collate_ta(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_TA_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_TE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_te',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_te')
    def icu_collate_te(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_te``.

        Overloads:
        - main.icu_collate_te(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_TE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_TH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_th',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_th')
    def icu_collate_th(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_th``.

        Overloads:
        - main.icu_collate_th(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_TH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_TK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_tk',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_tk')
    def icu_collate_tk(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_tk``.

        Overloads:
        - main.icu_collate_tk(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_TK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_TO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_to',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_to')
    def icu_collate_to(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_to``.

        Overloads:
        - main.icu_collate_to(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_TO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_TR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_tr',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_tr')
    def icu_collate_tr(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_tr``.

        Overloads:
        - main.icu_collate_tr(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_TR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_UG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ug',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ug')
    def icu_collate_ug(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ug``.

        Overloads:
        - main.icu_collate_ug(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_UG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_UK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_uk',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_uk')
    def icu_collate_uk(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_uk``.

        Overloads:
        - main.icu_collate_uk(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_UK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_UR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_ur',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_ur')
    def icu_collate_ur(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_ur``.

        Overloads:
        - main.icu_collate_ur(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_UR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_UZ_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_uz',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_uz')
    def icu_collate_uz(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_uz``.

        Overloads:
        - main.icu_collate_uz(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_UZ_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_VI_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_vi',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_vi')
    def icu_collate_vi(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_vi``.

        Overloads:
        - main.icu_collate_vi(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_VI_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_WAE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_wae',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_wae')
    def icu_collate_wae(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_wae``.

        Overloads:
        - main.icu_collate_wae(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_WAE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_WO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_wo',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_wo')
    def icu_collate_wo(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_wo``.

        Overloads:
        - main.icu_collate_wo(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_WO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_XH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_xh',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_xh')
    def icu_collate_xh(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_xh``.

        Overloads:
        - main.icu_collate_xh(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_XH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_YI_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_yi',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_yi')
    def icu_collate_yi(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_yi``.

        Overloads:
        - main.icu_collate_yi(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_YI_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_YO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_yo',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_yo')
    def icu_collate_yo(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_yo``.

        Overloads:
        - main.icu_collate_yo(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_YO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_YUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_yue',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_yue')
    def icu_collate_yue(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_yue``.

        Overloads:
        - main.icu_collate_yue(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_YUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_YUE_CN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_yue_cn',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_yue_cn')
    def icu_collate_yue_cn(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_yue_cn``.

        Overloads:
        - main.icu_collate_yue_cn(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_YUE_CN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ZH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_zh',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_zh')
    def icu_collate_zh(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_zh``.

        Overloads:
        - main.icu_collate_zh(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ZH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ZH_CN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_zh_cn',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_zh_cn')
    def icu_collate_zh_cn(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_zh_cn``.

        Overloads:
        - main.icu_collate_zh_cn(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ZH_CN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ZH_HK_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_zh_hk',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_zh_hk')
    def icu_collate_zh_hk(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_zh_hk``.

        Overloads:
        - main.icu_collate_zh_hk(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ZH_HK_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ZH_MO_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_zh_mo',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_zh_mo')
    def icu_collate_zh_mo(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_zh_mo``.

        Overloads:
        - main.icu_collate_zh_mo(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ZH_MO_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ZH_SG_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_zh_sg',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_zh_sg')
    def icu_collate_zh_sg(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_zh_sg``.

        Overloads:
        - main.icu_collate_zh_sg(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ZH_SG_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ZH_TW_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_zh_tw',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_zh_tw')
    def icu_collate_zh_tw(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_zh_tw``.

        Overloads:
        - main.icu_collate_zh_tw(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ZH_TW_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_COLLATE_ZU_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_collate_zu',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_collate_zu')
    def icu_collate_zu(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_collate_zu``.

        Overloads:
        - main.icu_collate_zu(VARCHAR col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_COLLATE_ZU_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ICU_SORT_KEY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='icu_sort_key',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('icu_sort_key')
    def icu_sort_key(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``icu_sort_key``.

        Overloads:
        - main.icu_sort_key(VARCHAR col0, VARCHAR col1) -> VARCHAR
        """
        return call_duckdb_function(
            self._ICU_SORT_KEY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(None,),
                        parameters=('x',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="json_extract(x, '$')",
                    ),
    )
    @duckdb_function('json')
    def json(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json``.

        Overloads:
        - main.json(ANY x) -> JSON
        """
        return call_duckdb_function(
            self._JSON_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_ARRAY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_array',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_array')
    def json_array(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_array``.

        Overloads:
        - main.json_array(ANY ...) -> JSON
        """
        return call_duckdb_function(
            self._JSON_ARRAY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_DESERIALIZE_SQL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_deserialize_sql',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_deserialize_sql')
    def json_deserialize_sql(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_deserialize_sql``.

        Overloads:
        - main.json_deserialize_sql(JSON col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._JSON_DESERIALIZE_SQL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract',
                        function_type=function_type,
                        return_type=parse_type('JSON[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('JSON'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract',
                        function_type=function_type,
                        return_type=parse_type('JSON[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_extract')
    def json_extract(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_extract``.

        Overloads:
        - main.json_extract(VARCHAR col0, BIGINT col1) -> JSON
        - main.json_extract(VARCHAR col0, VARCHAR col1) -> JSON
        - main.json_extract(VARCHAR col0, VARCHAR[] col1) -> JSON[]
        - main.json_extract(JSON col0, BIGINT col1) -> JSON
        - main.json_extract(JSON col0, VARCHAR col1) -> JSON
        - main.json_extract(JSON col0, VARCHAR[] col1) -> JSON[]
        """
        return call_duckdb_function(
            self._JSON_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_EXTRACT_PATH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path',
                        function_type=function_type,
                        return_type=parse_type('JSON[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('JSON'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path',
                        function_type=function_type,
                        return_type=parse_type('JSON[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_extract_path')
    def json_extract_path(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_extract_path``.

        Overloads:
        - main.json_extract_path(VARCHAR col0, BIGINT col1) -> JSON
        - main.json_extract_path(VARCHAR col0, VARCHAR col1) -> JSON
        - main.json_extract_path(VARCHAR col0, VARCHAR[] col1) -> JSON[]
        - main.json_extract_path(JSON col0, BIGINT col1) -> JSON
        - main.json_extract_path(JSON col0, VARCHAR col1) -> JSON
        - main.json_extract_path(JSON col0, VARCHAR[] col1) -> JSON[]
        """
        return call_duckdb_function(
            self._JSON_EXTRACT_PATH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_EXTRACT_PATH_TEXT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path_text',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path_text',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path_text',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path_text',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path_text',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_path_text',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_extract_path_text')
    def json_extract_path_text(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_extract_path_text``.

        Overloads:
        - main.json_extract_path_text(VARCHAR col0, BIGINT col1) -> VARCHAR
        - main.json_extract_path_text(VARCHAR col0, VARCHAR col1) -> VARCHAR
        - main.json_extract_path_text(VARCHAR col0, VARCHAR[] col1) -> VARCHAR[]
        - main.json_extract_path_text(JSON col0, BIGINT col1) -> VARCHAR
        - main.json_extract_path_text(JSON col0, VARCHAR col1) -> VARCHAR
        - main.json_extract_path_text(JSON col0, VARCHAR[] col1) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._JSON_EXTRACT_PATH_TEXT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_EXTRACT_STRING_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_extract_string',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_extract_string')
    def json_extract_string(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_extract_string``.

        Overloads:
        - main.json_extract_string(VARCHAR col0, BIGINT col1) -> VARCHAR
        - main.json_extract_string(VARCHAR col0, VARCHAR col1) -> VARCHAR
        - main.json_extract_string(VARCHAR col0, VARCHAR[] col1) -> VARCHAR[]
        - main.json_extract_string(JSON col0, BIGINT col1) -> VARCHAR
        - main.json_extract_string(JSON col0, VARCHAR col1) -> VARCHAR
        - main.json_extract_string(JSON col0, VARCHAR[] col1) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._JSON_EXTRACT_STRING_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_GROUP_ARRAY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_group_array',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(None,),
                        parameters=('x',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='CAST(((\'[\' || string_agg(CASE  WHEN ((x IS NULL)) THEN (CAST(\'null\' AS "JSON")) ELSE to_json(x) END, \',\')) || \']\') AS "JSON")',
                    ),
    )
    @duckdb_function('json_group_array')
    def json_group_array(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_group_array``.

        Overloads:
        - main.json_group_array(ANY x) -> JSON
        """
        return call_duckdb_function(
            self._JSON_GROUP_ARRAY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_GROUP_OBJECT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_group_object',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(None, None),
                        parameters=('n', 'v'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='CAST(((\'{\' || string_agg(((to_json(CAST(n AS VARCHAR)) || \':\') || CASE  WHEN ((v IS NULL)) THEN (CAST(\'null\' AS "JSON")) ELSE to_json(v) END), \',\')) || \'}\') AS "JSON")',
                    ),
    )
    @duckdb_function('json_group_object')
    def json_group_object(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_group_object``.

        Overloads:
        - main.json_group_object(ANY n, ANY v) -> JSON
        """
        return call_duckdb_function(
            self._JSON_GROUP_OBJECT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_GROUP_STRUCTURE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_group_structure',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(None,),
                        parameters=('x',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='(json_structure(json_group_array(x)) -> 0)',
                    ),
    )
    @duckdb_function('json_group_structure')
    def json_group_structure(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_group_structure``.

        Overloads:
        - main.json_group_structure(ANY x) -> JSON
        """
        return call_duckdb_function(
            self._JSON_GROUP_STRUCTURE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_KEYS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_keys',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_keys',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('JSON'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_keys',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_keys',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[][]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_keys',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_keys',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[][]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_keys')
    def json_keys(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_keys``.

        Overloads:
        - main.json_keys(VARCHAR col0) -> VARCHAR[]
        - main.json_keys(JSON col0) -> VARCHAR[]
        - main.json_keys(VARCHAR col0, VARCHAR col1) -> VARCHAR[]
        - main.json_keys(VARCHAR col0, VARCHAR[] col1) -> VARCHAR[][]
        - main.json_keys(JSON col0, VARCHAR col1) -> VARCHAR[]
        - main.json_keys(JSON col0, VARCHAR[] col1) -> VARCHAR[][]
        """
        return call_duckdb_function(
            self._JSON_KEYS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_MERGE_PATCH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_merge_patch',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('JSON'), parse_type('JSON')),
                        parameters=('col0', 'col1'),
                        varargs=parse_type('JSON'),
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_merge_patch')
    def json_merge_patch(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_merge_patch``.

        Overloads:
        - main.json_merge_patch(JSON col0, JSON col1, JSON ...) -> JSON
        """
        return call_duckdb_function(
            self._JSON_MERGE_PATCH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_OBJECT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_object',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_object')
    def json_object(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_object``.

        Overloads:
        - main.json_object(ANY ...) -> JSON
        """
        return call_duckdb_function(
            self._JSON_OBJECT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_PRETTY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_pretty',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_pretty')
    def json_pretty(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_pretty``.

        Overloads:
        - main.json_pretty(JSON col0) -> VARCHAR
        """
        return call_duckdb_function(
            self._JSON_PRETTY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_QUOTE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_quote',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_quote')
    def json_quote(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_quote``.

        Overloads:
        - main.json_quote(ANY ...) -> JSON
        """
        return call_duckdb_function(
            self._JSON_QUOTE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_SERIALIZE_PLAN_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_plan',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_plan',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_plan',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN'), parse_type('BOOLEAN')),
                        parameters=('col0', 'col1', 'col2'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_plan',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN'), parse_type('BOOLEAN'), parse_type('BOOLEAN')),
                        parameters=('col0', 'col1', 'col2', 'col3'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_plan',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN'), parse_type('BOOLEAN'), parse_type('BOOLEAN'), parse_type('BOOLEAN')),
                        parameters=('col0', 'col1', 'col2', 'col3', 'col4'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_serialize_plan')
    def json_serialize_plan(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_serialize_plan``.

        Overloads:
        - main.json_serialize_plan(VARCHAR col0) -> JSON
        - main.json_serialize_plan(VARCHAR col0, BOOLEAN col1) -> JSON
        - main.json_serialize_plan(VARCHAR col0, BOOLEAN col1, BOOLEAN col2) -> JSON
        - main.json_serialize_plan(VARCHAR col0, BOOLEAN col1, BOOLEAN col2, BOOLEAN col3) -> JSON
        - main.json_serialize_plan(VARCHAR col0, BOOLEAN col1, BOOLEAN col2, BOOLEAN col3, BOOLEAN col4) -> JSON
        """
        return call_duckdb_function(
            self._JSON_SERIALIZE_PLAN_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_SERIALIZE_SQL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_sql',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_sql',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_sql',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN'), parse_type('BOOLEAN')),
                        parameters=('col0', 'col1', 'col2'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_sql',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN'), parse_type('BOOLEAN'), parse_type('BOOLEAN')),
                        parameters=('col0', 'col1', 'col2', 'col3'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_serialize_sql',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN'), parse_type('BOOLEAN'), parse_type('BOOLEAN'), parse_type('BOOLEAN')),
                        parameters=('col0', 'col1', 'col2', 'col3', 'col4'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_serialize_sql')
    def json_serialize_sql(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_serialize_sql``.

        Overloads:
        - main.json_serialize_sql(VARCHAR col0) -> JSON
        - main.json_serialize_sql(VARCHAR col0, BOOLEAN col1) -> JSON
        - main.json_serialize_sql(VARCHAR col0, BOOLEAN col1, BOOLEAN col2) -> JSON
        - main.json_serialize_sql(VARCHAR col0, BOOLEAN col1, BOOLEAN col2, BOOLEAN col3) -> JSON
        - main.json_serialize_sql(VARCHAR col0, BOOLEAN col1, BOOLEAN col2, BOOLEAN col3, BOOLEAN col4) -> JSON
        """
        return call_duckdb_function(
            self._JSON_SERIALIZE_SQL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_STRUCTURE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_structure',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_structure',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(parse_type('JSON'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_structure')
    def json_structure(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_structure``.

        Overloads:
        - main.json_structure(VARCHAR col0) -> JSON
        - main.json_structure(JSON col0) -> JSON
        """
        return call_duckdb_function(
            self._JSON_STRUCTURE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_TYPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_type',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_type',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'),),
                        parameters=('col0',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_type',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_type',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_type',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_type',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_type')
    def json_type(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_type``.

        Overloads:
        - main.json_type(VARCHAR col0) -> VARCHAR
        - main.json_type(JSON col0) -> VARCHAR
        - main.json_type(VARCHAR col0, VARCHAR col1) -> VARCHAR
        - main.json_type(VARCHAR col0, VARCHAR[] col1) -> VARCHAR[]
        - main.json_type(JSON col0, VARCHAR col1) -> VARCHAR
        - main.json_type(JSON col0, VARCHAR[] col1) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._JSON_TYPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _JSON_VALUE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_value',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_value',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_value',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_value',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_value',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='json_value',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('json_value')
    def json_value(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``json_value``.

        Overloads:
        - main.json_value(VARCHAR col0, BIGINT col1) -> VARCHAR
        - main.json_value(VARCHAR col0, VARCHAR col1) -> VARCHAR
        - main.json_value(VARCHAR col0, VARCHAR[] col1) -> VARCHAR[]
        - main.json_value(JSON col0, BIGINT col1) -> VARCHAR
        - main.json_value(JSON col0, VARCHAR col1) -> VARCHAR
        - main.json_value(JSON col0, VARCHAR[] col1) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._JSON_VALUE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LCASE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='lcase',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts `string` to lower case.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('lcase')
    def lcase(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``lcase``.

        Converts `string` to lower case.

        Overloads:
        - main.lcase(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._LCASE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LEFT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='left',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('string', 'count'),
                        varargs=None,
                        description='Extracts the left-most count characters.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('left')
    def left(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``left``.

        Extracts the left-most count characters.

        Overloads:
        - main.left(VARCHAR string, BIGINT count) -> VARCHAR
        """
        return call_duckdb_function(
            self._LEFT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LEFT_GRAPHEME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='left_grapheme',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('string', 'count'),
                        varargs=None,
                        description='Extracts the left-most count grapheme clusters.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('left_grapheme')
    def left_grapheme(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``left_grapheme``.

        Extracts the left-most count grapheme clusters.

        Overloads:
        - main.left_grapheme(VARCHAR string, BIGINT count) -> VARCHAR
        """
        return call_duckdb_function(
            self._LEFT_GRAPHEME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_ELEMENT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_element',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('list', 'index'),
                        varargs=None,
                        description='Extract the `index`th (1-based) value from the list.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_element')
    def list_element(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``list_element``.

        Extract the `index`th (1-based) value from the list.

        Overloads:
        - main.list_element(VARCHAR list, BIGINT index) -> VARCHAR
        """
        return call_duckdb_function(
            self._LIST_ELEMENT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LIST_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='list_extract',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('list', 'index'),
                        varargs=None,
                        description='Extract the `index`th (1-based) value from the list.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('list_extract')
    def list_extract(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``list_extract``.

        Extract the `index`th (1-based) value from the list.

        Overloads:
        - main.list_extract(VARCHAR list, BIGINT index) -> VARCHAR
        """
        return call_duckdb_function(
            self._LIST_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LOWER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='lower',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts `string` to lower case.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('lower')
    def lower(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``lower``.

        Converts `string` to lower case.

        Overloads:
        - main.lower(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._LOWER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LPAD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='lpad',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('string', 'count', 'character'),
                        varargs=None,
                        description='Pads the `string` with the `character` on the left until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('lpad')
    def lpad(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``lpad``.

        Pads the `string` with the `character` on the left until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.

        Overloads:
        - main.lpad(VARCHAR string, INTEGER count, VARCHAR character) -> VARCHAR
        """
        return call_duckdb_function(
            self._LPAD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _LTRIM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ltrim',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Removes any occurrences of any of the `characters` from the left side of the `string`. `characters` defaults to `space`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ltrim',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'characters'),
                        varargs=None,
                        description='Removes any occurrences of any of the `characters` from the left side of the `string`. `characters` defaults to `space`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('ltrim')
    def ltrim(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``ltrim``.

        Removes any occurrences of any of the `characters` from the left side of the `string`. `characters` defaults to `space`.

        Overloads:
        - main.ltrim(VARCHAR string) -> VARCHAR
        - main.ltrim(VARCHAR string, VARCHAR characters) -> VARCHAR
        """
        return call_duckdb_function(
            self._LTRIM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MD5_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='md5',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Returns the MD5 hash of the `string` as a `VARCHAR`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='md5',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Returns the MD5 hash of the `blob` as a `VARCHAR`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('md5')
    def md5(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``md5``.

        Returns the MD5 hash of the `string` as a `VARCHAR`.

        Overloads:
        - main.md5(VARCHAR string) -> VARCHAR
        - main.md5(BLOB blob) -> VARCHAR
        """
        return call_duckdb_function(
            self._MD5_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _MONTHNAME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='monthname',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('DATE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='The (English) name of the month',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='monthname',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('TIMESTAMP'),),
                        parameters=('ts',),
                        varargs=None,
                        description='The (English) name of the month',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='monthname',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'),),
                        parameters=('ts',),
                        varargs=None,
                        description='The (English) name of the month',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('monthname')
    def monthname(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``monthname``.

        The (English) name of the month

        Overloads:
        - main.monthname(DATE ts) -> VARCHAR
        - main.monthname(TIMESTAMP ts) -> VARCHAR
        - main.monthname(TIMESTAMP WITH TIME ZONE ts) -> VARCHAR
        """
        return call_duckdb_function(
            self._MONTHNAME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _NFC_NORMALIZE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='nfc_normalize',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts `string` to Unicode NFC normalized string. Useful for comparisons and ordering if text data is mixed between NFC normalized and not.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('nfc_normalize')
    def nfc_normalize(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``nfc_normalize``.

        Converts `string` to Unicode NFC normalized string. Useful for comparisons and ordering if text data is mixed between NFC normalized and not.

        Overloads:
        - main.nfc_normalize(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._NFC_NORMALIZE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PARSE_DIRNAME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_dirname',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('path',),
                        varargs=None,
                        description='Returns the top-level directory name from the given `path`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_dirname',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('path', 'separator'),
                        varargs=None,
                        description='Returns the top-level directory name from the given `path`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('parse_dirname')
    def parse_dirname(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``parse_dirname``.

        Returns the top-level directory name from the given `path`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

        Overloads:
        - main.parse_dirname(VARCHAR path) -> VARCHAR
        - main.parse_dirname(VARCHAR path, VARCHAR separator) -> VARCHAR
        """
        return call_duckdb_function(
            self._PARSE_DIRNAME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PARSE_DIRPATH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_dirpath',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('path',),
                        varargs=None,
                        description="Returns the head of the `path` (the pathname until the last slash) similarly to Python's `os.path.dirname`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.",
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_dirpath',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('path', 'separator'),
                        varargs=None,
                        description="Returns the head of the `path` (the pathname until the last slash) similarly to Python's `os.path.dirname`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.",
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('parse_dirpath')
    def parse_dirpath(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``parse_dirpath``.

        Returns the head of the `path` (the pathname until the last slash) similarly to Python's `os.path.dirname`. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

        Overloads:
        - main.parse_dirpath(VARCHAR path) -> VARCHAR
        - main.parse_dirpath(VARCHAR path, VARCHAR separator) -> VARCHAR
        """
        return call_duckdb_function(
            self._PARSE_DIRPATH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PARSE_FILENAME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_filename',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description="Returns the last component of the `path` similarly to Python's `os.path.basename` function. If `trim_extension` is `true`, the file extension will be removed (defaults to `false`). `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.",
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_filename',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'trim_extension'),
                        varargs=None,
                        description="Returns the last component of the `path` similarly to Python's `os.path.basename` function. If `trim_extension` is `true`, the file extension will be removed (defaults to `false`). `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.",
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_filename',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN')),
                        parameters=('string', 'trim_extension'),
                        varargs=None,
                        description="Returns the last component of the `path` similarly to Python's `os.path.basename` function. If `trim_extension` is `true`, the file extension will be removed (defaults to `false`). `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.",
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_filename',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BOOLEAN'), parse_type('VARCHAR')),
                        parameters=('string', 'trim_extension', 'separator'),
                        varargs=None,
                        description="Returns the last component of the `path` similarly to Python's `os.path.basename` function. If `trim_extension` is `true`, the file extension will be removed (defaults to `false`). `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.",
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('parse_filename')
    def parse_filename(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``parse_filename``.

        Returns the last component of the `path` similarly to Python's `os.path.basename` function. If `trim_extension` is `true`, the file extension will be removed (defaults to `false`). `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

        Overloads:
        - main.parse_filename(VARCHAR string) -> VARCHAR
        - main.parse_filename(VARCHAR string, VARCHAR trim_extension) -> VARCHAR
        - main.parse_filename(VARCHAR string, BOOLEAN trim_extension) -> VARCHAR
        - main.parse_filename(VARCHAR string, BOOLEAN trim_extension, VARCHAR separator) -> VARCHAR
        """
        return call_duckdb_function(
            self._PARSE_FILENAME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PARSE_PATH_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_path',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('path',),
                        varargs=None,
                        description="Returns a list of the components (directories and filename) in the `path` similarly to Python's `pathlib.parts` function. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.",
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='parse_path',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('path', 'separator'),
                        varargs=None,
                        description="Returns a list of the components (directories and filename) in the `path` similarly to Python's `pathlib.parts` function. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.",
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('parse_path')
    def parse_path(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``parse_path``.

        Returns a list of the components (directories and filename) in the `path` similarly to Python's `pathlib.parts` function. `separator` options: `system`, `both_slash` (default), `forward_slash`, `backslash`.

        Overloads:
        - main.parse_path(VARCHAR path) -> VARCHAR[]
        - main.parse_path(VARCHAR path, VARCHAR separator) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._PARSE_PATH_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_GET_CONSTRAINTDEF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_get_constraintdef',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None,),
                        parameters=('constraint_oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='(SELECT constraint_text FROM duckdb_constraints() AS d_constraint WHERE ((d_constraint.table_oid = (constraint_oid // 1000000)) AND (d_constraint.constraint_index = (constraint_oid % 1000000))))',
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_get_constraintdef',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None, None),
                        parameters=('constraint_oid', 'pretty_bool'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='pg_get_constraintdef(constraint_oid)',
                    ),
    )
    @duckdb_function('pg_get_constraintdef')
    def pg_get_constraintdef(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``pg_get_constraintdef``.

        Overloads:
        - pg_catalog.pg_get_constraintdef(ANY constraint_oid) -> VARCHAR
        - pg_catalog.pg_get_constraintdef(ANY constraint_oid, ANY pretty_bool) -> VARCHAR
        """
        return call_duckdb_function(
            self._PG_GET_CONSTRAINTDEF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_GET_VIEWDEF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_get_viewdef',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None,),
                        parameters=('oid',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='(SELECT "sql" FROM duckdb_views() AS v WHERE (v.view_oid = oid))',
                    ),
    )
    @duckdb_function('pg_get_viewdef')
    def pg_get_viewdef(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``pg_get_viewdef``.

        Overloads:
        - pg_catalog.pg_get_viewdef(ANY oid) -> VARCHAR
        """
        return call_duckdb_function(
            self._PG_GET_VIEWDEF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_SIZE_PRETTY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_size_pretty',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None,),
                        parameters=('bytes',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='format_bytes(bytes)',
                    ),
    )
    @duckdb_function('pg_size_pretty')
    def pg_size_pretty(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``pg_size_pretty``.

        Overloads:
        - pg_catalog.pg_size_pretty(ANY bytes) -> VARCHAR
        """
        return call_duckdb_function(
            self._PG_SIZE_PRETTY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PG_TYPEOF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='pg_catalog',
                        function_name='pg_typeof',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None,),
                        parameters=('expression',),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='lower(typeof(expression))',
                    ),
    )
    @duckdb_function('pg_typeof')
    def pg_typeof(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``pg_typeof``.

        Overloads:
        - pg_catalog.pg_typeof(ANY expression) -> VARCHAR
        """
        return call_duckdb_function(
            self._PG_TYPEOF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _PRINTF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='printf',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('format',),
                        varargs=parse_type('ANY'),
                        description='Formats a `string` using printf syntax.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('printf')
    def printf(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``printf``.

        Formats a `string` using printf syntax.

        Overloads:
        - main.printf(VARCHAR format, ANY ...) -> VARCHAR
        """
        return call_duckdb_function(
            self._PRINTF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REGEXP_ESCAPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_escape',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description="Escapes special patterns to turn `string` into a regular expression similarly to Python's `re.escape` function.",
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regexp_escape')
    def regexp_escape(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``regexp_escape``.

        Escapes special patterns to turn `string` into a regular expression similarly to Python's `re.escape` function.

        Overloads:
        - main.regexp_escape(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._REGEXP_ESCAPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REGEXP_EXTRACT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_extract',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex'),
                        varargs=None,
                        description='If `string` contains the `regex` pattern, returns the capturing group specified by optional parameter `group`; otherwise, returns the empty string. The `group` must be a constant value. If no `group` is given, it defaults to 0. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_extract',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('string', 'regex', 'group'),
                        varargs=None,
                        description='If `string` contains the `regex` pattern, returns the capturing group specified by optional parameter `group`; otherwise, returns the empty string. The `group` must be a constant value. If no `group` is given, it defaults to 0. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_extract',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('string', 'regex', 'name_list'),
                        varargs=None,
                        description='If `string` contains the `regex` pattern, returns the capturing groups as a struct with corresponding names from `name_list`; otherwise, returns a struct with the same keys and empty strings as values. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_extract',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'group', 'options'),
                        varargs=None,
                        description='If `string` contains the `regex` pattern, returns the capturing group specified by optional parameter `group`; otherwise, returns the empty string. The `group` must be a constant value. If no `group` is given, it defaults to 0. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_extract',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR[]'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'name_list', 'options'),
                        varargs=None,
                        description='If `string` contains the `regex` pattern, returns the capturing groups as a struct with corresponding names from `name_list`; otherwise, returns a struct with the same keys and empty strings as values. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regexp_extract')
    def regexp_extract(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``regexp_extract``.

        If `string` contains the `regex` pattern, returns the capturing group specified by optional parameter `group`; otherwise, returns the empty string. The `group` must be a constant value. If no `group` is given, it defaults to 0. A set of optional regex `options` can be set.

        Overloads:
        - main.regexp_extract(VARCHAR string, VARCHAR regex) -> VARCHAR
        - main.regexp_extract(VARCHAR string, VARCHAR regex, INTEGER group) -> VARCHAR
        - main.regexp_extract(VARCHAR string, VARCHAR regex, VARCHAR[] name_list) -> VARCHAR
        - main.regexp_extract(VARCHAR string, VARCHAR regex, INTEGER group, VARCHAR options) -> VARCHAR
        - main.regexp_extract(VARCHAR string, VARCHAR regex, VARCHAR[] name_list, VARCHAR options) -> VARCHAR
        """
        return call_duckdb_function(
            self._REGEXP_EXTRACT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REGEXP_EXTRACT_ALL_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_extract_all',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex'),
                        varargs=None,
                        description='Finds non-overlapping occurrences of the `regex` in the `string` and returns the corresponding values of the capturing `group`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_extract_all',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('INTEGER')),
                        parameters=('string', 'regex', 'group'),
                        varargs=None,
                        description='Finds non-overlapping occurrences of the `regex` in the `string` and returns the corresponding values of the capturing `group`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_extract_all',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'group', 'options'),
                        varargs=None,
                        description='Finds non-overlapping occurrences of the `regex` in the `string` and returns the corresponding values of the capturing `group`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regexp_extract_all')
    def regexp_extract_all(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``regexp_extract_all``.

        Finds non-overlapping occurrences of the `regex` in the `string` and returns the corresponding values of the capturing `group`. A set of optional regex `options` can be set.

        Overloads:
        - main.regexp_extract_all(VARCHAR string, VARCHAR regex) -> VARCHAR[]
        - main.regexp_extract_all(VARCHAR string, VARCHAR regex, INTEGER group) -> VARCHAR[]
        - main.regexp_extract_all(VARCHAR string, VARCHAR regex, INTEGER group, VARCHAR options) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._REGEXP_EXTRACT_ALL_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REGEXP_REPLACE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_replace',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'replacement'),
                        varargs=None,
                        description='If `string` contains the `regex`, replaces the matching part with `replacement`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_replace',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'replacement', 'options'),
                        varargs=None,
                        description='If `string` contains the `regex`, replaces the matching part with `replacement`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regexp_replace')
    def regexp_replace(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``regexp_replace``.

        If `string` contains the `regex`, replaces the matching part with `replacement`. A set of optional regex `options` can be set.

        Overloads:
        - main.regexp_replace(VARCHAR string, VARCHAR regex, VARCHAR replacement) -> VARCHAR
        - main.regexp_replace(VARCHAR string, VARCHAR regex, VARCHAR replacement, VARCHAR options) -> VARCHAR
        """
        return call_duckdb_function(
            self._REGEXP_REPLACE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REGEXP_SPLIT_TO_ARRAY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_split_to_array',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex'),
                        varargs=None,
                        description='Splits the `string` along the `regex`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='regexp_split_to_array',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'options'),
                        varargs=None,
                        description='Splits the `string` along the `regex`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('regexp_split_to_array')
    def regexp_split_to_array(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``regexp_split_to_array``.

        Splits the `string` along the `regex`. A set of optional regex `options` can be set.

        Overloads:
        - main.regexp_split_to_array(VARCHAR string, VARCHAR regex) -> VARCHAR[]
        - main.regexp_split_to_array(VARCHAR string, VARCHAR regex, VARCHAR options) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._REGEXP_SPLIT_TO_ARRAY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REPEAT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='repeat',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('string', 'count'),
                        varargs=None,
                        description='Repeats the `string` `count` number of times.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('repeat')
    def repeat(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``repeat``.

        Repeats the `string` `count` number of times.

        Overloads:
        - main.repeat(VARCHAR string, BIGINT count) -> VARCHAR
        """
        return call_duckdb_function(
            self._REPEAT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REPLACE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='replace',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'source', 'target'),
                        varargs=None,
                        description='Replaces any occurrences of the `source` with `target` in `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('replace')
    def replace(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``replace``.

        Replaces any occurrences of the `source` with `target` in `string`.

        Overloads:
        - main.replace(VARCHAR string, VARCHAR source, VARCHAR target) -> VARCHAR
        """
        return call_duckdb_function(
            self._REPLACE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _REVERSE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='reverse',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Reverses the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('reverse')
    def reverse(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``reverse``.

        Reverses the `string`.

        Overloads:
        - main.reverse(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._REVERSE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _RIGHT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='right',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('string', 'count'),
                        varargs=None,
                        description='Extract the right-most `count` characters.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('right')
    def right(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``right``.

        Extract the right-most `count` characters.

        Overloads:
        - main.right(VARCHAR string, BIGINT count) -> VARCHAR
        """
        return call_duckdb_function(
            self._RIGHT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _RIGHT_GRAPHEME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='right_grapheme',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('string', 'count'),
                        varargs=None,
                        description='Extracts the right-most `count` grapheme clusters.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('right_grapheme')
    def right_grapheme(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``right_grapheme``.

        Extracts the right-most `count` grapheme clusters.

        Overloads:
        - main.right_grapheme(VARCHAR string, BIGINT count) -> VARCHAR
        """
        return call_duckdb_function(
            self._RIGHT_GRAPHEME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _ROW_TO_JSON_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='row_to_json',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('row_to_json')
    def row_to_json(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``row_to_json``.

        Overloads:
        - main.row_to_json(ANY ...) -> JSON
        """
        return call_duckdb_function(
            self._ROW_TO_JSON_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _RPAD_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='rpad',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('INTEGER'), parse_type('VARCHAR')),
                        parameters=('string', 'count', 'character'),
                        varargs=None,
                        description='Pads the `string` with the `character` on the right until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('rpad')
    def rpad(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``rpad``.

        Pads the `string` with the `character` on the right until it has `count` characters. Truncates the `string` on the right if it has more than `count` characters.

        Overloads:
        - main.rpad(VARCHAR string, INTEGER count, VARCHAR character) -> VARCHAR
        """
        return call_duckdb_function(
            self._RPAD_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _RTRIM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='rtrim',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Removes any occurrences of any of the `characters` from the right side of the `string`. `characters` defaults to `space`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='rtrim',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'characters'),
                        varargs=None,
                        description='Removes any occurrences of any of the `characters` from the right side of the `string`. `characters` defaults to `space`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('rtrim')
    def rtrim(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``rtrim``.

        Removes any occurrences of any of the `characters` from the right side of the `string`. `characters` defaults to `space`.

        Overloads:
        - main.rtrim(VARCHAR string) -> VARCHAR
        - main.rtrim(VARCHAR string, VARCHAR characters) -> VARCHAR
        """
        return call_duckdb_function(
            self._RTRIM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SESSION_USER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='session_user',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition="'duckdb'",
                    ),
    )
    @duckdb_function('session_user')
    def session_user(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``session_user``.

        Overloads:
        - main.session_user() -> VARCHAR
        """
        return call_duckdb_function(
            self._SESSION_USER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SHA1_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sha1',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('value',),
                        varargs=None,
                        description='Returns a `VARCHAR` with the SHA-1 hash of the `value`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sha1',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Returns a `VARCHAR` with the SHA-1 hash of the `blob`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sha1')
    def sha1(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``sha1``.

        Returns a `VARCHAR` with the SHA-1 hash of the `value`.

        Overloads:
        - main.sha1(VARCHAR value) -> VARCHAR
        - main.sha1(BLOB blob) -> VARCHAR
        """
        return call_duckdb_function(
            self._SHA1_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SHA256_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sha256',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('value',),
                        varargs=None,
                        description='Returns a `VARCHAR` with the SHA-256 hash of the `value`',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='sha256',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Returns a `VARCHAR` with the SHA-256 hash of the `blob`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('sha256')
    def sha256(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``sha256``.

        Returns a `VARCHAR` with the SHA-256 hash of the `value`

        Overloads:
        - main.sha256(VARCHAR value) -> VARCHAR
        - main.sha256(BLOB blob) -> VARCHAR
        """
        return call_duckdb_function(
            self._SHA256_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SPLIT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='split',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'separator'),
                        varargs=None,
                        description='Splits the `string` along the `separator`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('split')
    def split(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``split``.

        Splits the `string` along the `separator`.

        Overloads:
        - main.split(VARCHAR string, VARCHAR separator) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._SPLIT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SPLIT_PART_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='split_part',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(None, None, None),
                        parameters=('string', 'delimiter', 'position'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='CASE  WHEN (((string IS NOT NULL) AND ("delimiter" IS NOT NULL) AND ("position" IS NOT NULL))) THEN (COALESCE(string_split(string, "delimiter")["position"], \'\')) ELSE NULL END',
                    ),
    )
    @duckdb_function('split_part')
    def split_part(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``split_part``.

        Overloads:
        - main.split_part(ANY string, ANY delimiter, ANY position) -> VARCHAR
        """
        return call_duckdb_function(
            self._SPLIT_PART_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STATS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='stats',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('expression',),
                        varargs=None,
                        description='Returns a string with statistics about the expression. Expression can be a column, constant, or SQL expression',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('stats')
    def stats(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``stats``.

        Returns a string with statistics about the expression. Expression can be a column, constant, or SQL expression

        Overloads:
        - main.stats(ANY expression) -> VARCHAR
        """
        return call_duckdb_function(
            self._STATS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STR_SPLIT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='str_split',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'separator'),
                        varargs=None,
                        description='Splits the `string` along the `separator`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('str_split')
    def str_split(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``str_split``.

        Splits the `string` along the `separator`.

        Overloads:
        - main.str_split(VARCHAR string, VARCHAR separator) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._STR_SPLIT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STR_SPLIT_REGEX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='str_split_regex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex'),
                        varargs=None,
                        description='Splits the `string` along the `regex`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='str_split_regex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'options'),
                        varargs=None,
                        description='Splits the `string` along the `regex`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('str_split_regex')
    def str_split_regex(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``str_split_regex``.

        Splits the `string` along the `regex`. A set of optional regex `options` can be set.

        Overloads:
        - main.str_split_regex(VARCHAR string, VARCHAR regex) -> VARCHAR[]
        - main.str_split_regex(VARCHAR string, VARCHAR regex, VARCHAR options) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._STR_SPLIT_REGEX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRFTIME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strftime',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('DATE'), parse_type('VARCHAR')),
                        parameters=('data', 'format'),
                        varargs=None,
                        description='Converts a `date` to a string according to the format string.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strftime',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('TIMESTAMP'), parse_type('VARCHAR')),
                        parameters=('data', 'format'),
                        varargs=None,
                        description='Converts a `date` to a string according to the format string.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strftime',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('TIMESTAMP_NS'), parse_type('VARCHAR')),
                        parameters=('data', 'format'),
                        varargs=None,
                        description='Converts a `date` to a string according to the format string.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strftime',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('DATE')),
                        parameters=('data', 'format'),
                        varargs=None,
                        description='Converts a `date` to a string according to the format string.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strftime',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP')),
                        parameters=('data', 'format'),
                        varargs=None,
                        description='Converts a `date` to a string according to the format string.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strftime',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('TIMESTAMP_NS')),
                        parameters=('data', 'format'),
                        varargs=None,
                        description='Converts a `date` to a string according to the format string.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strftime',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('TIMESTAMP WITH TIME ZONE'), parse_type('VARCHAR')),
                        parameters=('data', 'format'),
                        varargs=None,
                        description='Converts a `date` to a string according to the format string.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('strftime')
    def strftime(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``strftime``.

        Converts a `date` to a string according to the format string.

        Overloads:
        - main.strftime(DATE data, VARCHAR format) -> VARCHAR
        - main.strftime(TIMESTAMP data, VARCHAR format) -> VARCHAR
        - main.strftime(TIMESTAMP_NS data, VARCHAR format) -> VARCHAR
        - main.strftime(VARCHAR data, DATE format) -> VARCHAR
        - main.strftime(VARCHAR data, TIMESTAMP format) -> VARCHAR
        - main.strftime(VARCHAR data, TIMESTAMP_NS format) -> VARCHAR
        - main.strftime(TIMESTAMP WITH TIME ZONE data, VARCHAR format) -> VARCHAR
        """
        return call_duckdb_function(
            self._STRFTIME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRING_SPLIT_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='string_split',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'separator'),
                        varargs=None,
                        description='Splits the `string` along the `separator`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('string_split')
    def string_split(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``string_split``.

        Splits the `string` along the `separator`.

        Overloads:
        - main.string_split(VARCHAR string, VARCHAR separator) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._STRING_SPLIT_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRING_SPLIT_REGEX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='string_split_regex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex'),
                        varargs=None,
                        description='Splits the `string` along the `regex`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='string_split_regex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'regex', 'options'),
                        varargs=None,
                        description='Splits the `string` along the `regex`. A set of optional regex `options` can be set.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('string_split_regex')
    def string_split_regex(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``string_split_regex``.

        Splits the `string` along the `regex`. A set of optional regex `options` can be set.

        Overloads:
        - main.string_split_regex(VARCHAR string, VARCHAR regex) -> VARCHAR[]
        - main.string_split_regex(VARCHAR string, VARCHAR regex, VARCHAR options) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._STRING_SPLIT_REGEX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRING_TO_ARRAY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='string_to_array',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'separator'),
                        varargs=None,
                        description='Splits the `string` along the `separator`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('string_to_array')
    def string_to_array(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``string_to_array``.

        Splits the `string` along the `separator`.

        Overloads:
        - main.string_to_array(VARCHAR string, VARCHAR separator) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._STRING_TO_ARRAY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _STRIP_ACCENTS_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='strip_accents',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Strips accents from `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('strip_accents')
    def strip_accents(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``strip_accents``.

        Strips accents from `string`.

        Overloads:
        - main.strip_accents(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._STRIP_ACCENTS_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SUBSTR_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='substr',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('string', 'start'),
                        varargs=None,
                        description='Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='substr',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('string', 'start', 'length'),
                        varargs=None,
                        description='Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('substr')
    def substr(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``substr``.

        Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.

        Overloads:
        - main.substr(VARCHAR string, BIGINT start) -> VARCHAR
        - main.substr(VARCHAR string, BIGINT start, BIGINT length) -> VARCHAR
        """
        return call_duckdb_function(
            self._SUBSTR_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SUBSTRING_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='substring',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('string', 'start'),
                        varargs=None,
                        description='Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='substring',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('string', 'start', 'length'),
                        varargs=None,
                        description='Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('substring')
    def substring(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``substring``.

        Extracts substring starting from character `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` characters instead. Note that a `start` value of `1` refers to the first character of the `string`.

        Overloads:
        - main.substring(VARCHAR string, BIGINT start) -> VARCHAR
        - main.substring(VARCHAR string, BIGINT start, BIGINT length) -> VARCHAR
        """
        return call_duckdb_function(
            self._SUBSTRING_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _SUBSTRING_GRAPHEME_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='substring_grapheme',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('string', 'start'),
                        varargs=None,
                        description='Extracts substring starting from grapheme clusters `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` grapheme clusters instead. Note that a `start` value of `1` refers to the `first` character of the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='substring_grapheme',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT'), parse_type('BIGINT')),
                        parameters=('string', 'start', 'length'),
                        varargs=None,
                        description='Extracts substring starting from grapheme clusters `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` grapheme clusters instead. Note that a `start` value of `1` refers to the `first` character of the `string`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('substring_grapheme')
    def substring_grapheme(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``substring_grapheme``.

        Extracts substring starting from grapheme clusters `start` up to the end of the string. If optional argument `length` is set, extracts a substring of `length` grapheme clusters instead. Note that a `start` value of `1` refers to the `first` character of the `string`.

        Overloads:
        - main.substring_grapheme(VARCHAR string, BIGINT start) -> VARCHAR
        - main.substring_grapheme(VARCHAR string, BIGINT start, BIGINT length) -> VARCHAR
        """
        return call_duckdb_function(
            self._SUBSTRING_GRAPHEME_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_BASE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_base',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER')),
                        parameters=('number', 'radix'),
                        varargs=None,
                        description='Converts `number` to a string in the given base `radix`, optionally padding with leading zeros to `min_length`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_base',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGINT'), parse_type('INTEGER'), parse_type('INTEGER')),
                        parameters=('number', 'radix', 'min_length'),
                        varargs=None,
                        description='Converts `number` to a string in the given base `radix`, optionally padding with leading zeros to `min_length`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_base')
    def to_base(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``to_base``.

        Converts `number` to a string in the given base `radix`, optionally padding with leading zeros to `min_length`.

        Overloads:
        - main.to_base(BIGINT number, INTEGER radix) -> VARCHAR
        - main.to_base(BIGINT number, INTEGER radix, INTEGER min_length) -> VARCHAR
        """
        return call_duckdb_function(
            self._TO_BASE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_BASE64_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_base64',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Converts a `blob` to a base64 encoded string.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_base64')
    def to_base64(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``to_base64``.

        Converts a `blob` to a base64 encoded string.

        Overloads:
        - main.to_base64(BLOB blob) -> VARCHAR
        """
        return call_duckdb_function(
            self._TO_BASE64_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_BINARY_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_binary',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts the `string` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_binary',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGNUM'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_binary',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_binary',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_binary',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_binary',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to binary representation.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_binary')
    def to_binary(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``to_binary``.

        Converts the `string` to binary representation.

        Overloads:
        - main.to_binary(VARCHAR string) -> VARCHAR
        - main.to_binary(BIGNUM value) -> VARCHAR
        - main.to_binary(UBIGINT value) -> VARCHAR
        - main.to_binary(BIGINT value) -> VARCHAR
        - main.to_binary(HUGEINT value) -> VARCHAR
        - main.to_binary(UHUGEINT value) -> VARCHAR
        """
        return call_duckdb_function(
            self._TO_BINARY_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_HEX_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts the `string` to hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGNUM'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BLOB'),),
                        parameters=('blob',),
                        varargs=None,
                        description='Converts `blob` to `VARCHAR` using hexadecimal encoding.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('BIGINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UBIGINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('HUGEINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_hex',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('UHUGEINT'),),
                        parameters=('value',),
                        varargs=None,
                        description='Converts the `value` to `VARCHAR` using hexadecimal representation.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_hex')
    def to_hex(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``to_hex``.

        Converts the `string` to hexadecimal representation.

        Overloads:
        - main.to_hex(VARCHAR string) -> VARCHAR
        - main.to_hex(BIGNUM value) -> VARCHAR
        - main.to_hex(BLOB blob) -> VARCHAR
        - main.to_hex(BIGINT value) -> VARCHAR
        - main.to_hex(UBIGINT value) -> VARCHAR
        - main.to_hex(HUGEINT value) -> VARCHAR
        - main.to_hex(UHUGEINT value) -> VARCHAR
        """
        return call_duckdb_function(
            self._TO_HEX_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TO_JSON_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='to_json',
                        function_type=function_type,
                        return_type=parse_type('JSON'),
                        parameter_types=(),
                        parameters=(),
                        varargs=parse_type('ANY'),
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('to_json')
    def to_json(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``to_json``.

        Overloads:
        - main.to_json(ANY ...) -> JSON
        """
        return call_duckdb_function(
            self._TO_JSON_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TRANSLATE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='translate',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'from', 'to'),
                        varargs=None,
                        description='Replaces each character in `string` that matches a character in the `from` set with the corresponding character in the `to` set. If `from` is longer than `to`, occurrences of the extra characters in `from` are deleted.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('translate')
    def translate(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``translate``.

        Replaces each character in `string` that matches a character in the `from` set with the corresponding character in the `to` set. If `from` is longer than `to`, occurrences of the extra characters in `from` are deleted.

        Overloads:
        - main.translate(VARCHAR string, VARCHAR from, VARCHAR to) -> VARCHAR
        """
        return call_duckdb_function(
            self._TRANSLATE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TRIM_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trim',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Removes any occurrences of any of the `characters` from either side of the `string`. `characters` defaults to `space`.',
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='trim',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('string', 'characters'),
                        varargs=None,
                        description='Removes any occurrences of any of the `characters` from either side of the `string`. `characters` defaults to `space`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('trim')
    def trim(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``trim``.

        Removes any occurrences of any of the `characters` from either side of the `string`. `characters` defaults to `space`.

        Overloads:
        - main.trim(VARCHAR string) -> VARCHAR
        - main.trim(VARCHAR string, VARCHAR characters) -> VARCHAR
        """
        return call_duckdb_function(
            self._TRIM_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _TYPEOF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='typeof',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('expression',),
                        varargs=None,
                        description='Returns the name of the data type of the result of the expression',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('typeof')
    def typeof(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``typeof``.

        Returns the name of the data type of the result of the expression

        Overloads:
        - main.typeof(ANY expression) -> VARCHAR
        """
        return call_duckdb_function(
            self._TYPEOF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UCASE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='ucase',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts `string` to upper case.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('ucase')
    def ucase(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``ucase``.

        Converts `string` to upper case.

        Overloads:
        - main.ucase(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._UCASE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UPPER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='upper',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Converts `string` to upper case.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('upper')
    def upper(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``upper``.

        Converts `string` to upper case.

        Overloads:
        - main.upper(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._UPPER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _URL_DECODE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='url_decode',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Decodes a URL from a representation using Percent-Encoding.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('url_decode')
    def url_decode(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``url_decode``.

        Decodes a URL from a representation using Percent-Encoding.

        Overloads:
        - main.url_decode(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._URL_DECODE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _URL_ENCODE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='url_encode',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'),),
                        parameters=('string',),
                        varargs=None,
                        description='Encodes a URL to a representation using Percent-Encoding.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('url_encode')
    def url_encode(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``url_encode``.

        Encodes a URL to a representation using Percent-Encoding.

        Overloads:
        - main.url_encode(VARCHAR string) -> VARCHAR
        """
        return call_duckdb_function(
            self._URL_ENCODE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _USER_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='user',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition='current_user',
                    ),
    )
    @duckdb_function('user')
    def user(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``user``.

        Overloads:
        - main.user() -> VARCHAR
        """
        return call_duckdb_function(
            self._USER_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UUID_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='uuid',
                        function_type=function_type,
                        return_type=parse_type('UUID'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns a random UUID v4 similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('uuid')
    def uuid(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``uuid``.

        Returns a random UUID v4 similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687

        Overloads:
        - main.uuid() -> UUID
        """
        return call_duckdb_function(
            self._UUID_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UUIDV4_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='uuidv4',
                        function_type=function_type,
                        return_type=parse_type('UUID'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns a random UUIDv4 similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('uuidv4')
    def uuidv4(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``uuidv4``.

        Returns a random UUIDv4 similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687

        Overloads:
        - main.uuidv4() -> UUID
        """
        return call_duckdb_function(
            self._UUIDV4_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _UUIDV7_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='uuidv7',
                        function_type=function_type,
                        return_type=parse_type('UUID'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns a random UUID v7 similar to this: 019482e4-1441-7aad-8127-eec99573b0a0',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('uuidv7')
    def uuidv7(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``uuidv7``.

        Returns a random UUID v7 similar to this: 019482e4-1441-7aad-8127-eec99573b0a0

        Overloads:
        - main.uuidv7() -> UUID
        """
        return call_duckdb_function(
            self._UUIDV7_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _VARIANT_TYPEOF_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='variant_typeof',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARIANT'),),
                        parameters=('input_variant',),
                        varargs=None,
                        description='Returns the internal type of the `input_variant`.',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('variant_typeof')
    def variant_typeof(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``variant_typeof``.

        Returns the internal type of the `input_variant`.

        Overloads:
        - main.variant_typeof(VARIANT input_variant) -> VARCHAR
        """
        return call_duckdb_function(
            self._VARIANT_TYPEOF_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _VECTOR_TYPE_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='vector_type',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('ANY'),),
                        parameters=('col',),
                        varargs=None,
                        description='Returns the VectorType of a given column',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('vector_type')
    def vector_type(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``vector_type``.

        Returns the VectorType of a given column

        Overloads:
        - main.vector_type(ANY col) -> VARCHAR
        """
        return call_duckdb_function(
            self._VECTOR_TYPE_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _VERSION_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='version',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(),
                        parameters=(),
                        varargs=None,
                        description='Returns the currently active version of DuckDB in this format: v0.3.2\t',
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function('version')
    def version(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``version``.

        Returns the currently active version of DuckDB in this format: v0.3.2	

        Overloads:
        - main.version() -> VARCHAR
        """
        return call_duckdb_function(
            self._VERSION_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )
    _002d_003e_003e_SIGNATURES: ClassVar[tuple[DuckDBFunctionDefinition, ...]] = (
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='->>',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='->>',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='->>',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('VARCHAR'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='->>',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'), parse_type('BIGINT')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='->>',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
                    DuckDBFunctionDefinition(
                        schema_name='main',
                        function_name='->>',
                        function_type=function_type,
                        return_type=parse_type('VARCHAR[]'),
                        parameter_types=(parse_type('JSON'), parse_type('VARCHAR[]')),
                        parameters=('col0', 'col1'),
                        varargs=None,
                        description=None,
                        comment=None,
                        macro_definition=None,
                    ),
    )
    @duckdb_function(symbols=('->>',))
    def symbol_002d_003e_003e(self, *operands: object) -> VarcharExpression:
        """Call DuckDB function ``->>``.

        Overloads:
        - main.->>(VARCHAR col0, BIGINT col1) -> VARCHAR
        - main.->>(VARCHAR col0, VARCHAR col1) -> VARCHAR
        - main.->>(VARCHAR col0, VARCHAR[] col1) -> VARCHAR[]
        - main.->>(JSON col0, BIGINT col1) -> VARCHAR
        - main.->>(JSON col0, VARCHAR col1) -> VARCHAR
        - main.->>(JSON col0, VARCHAR[] col1) -> VARCHAR[]
        """
        return call_duckdb_function(
            self._002d_003e_003e_SIGNATURES,
            return_category=self.return_category,
            operands=operands,
        )

    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {
        '__internal_decompress_string': '__internal_decompress_string',
        'alias': 'alias',
        'array_extract': 'array_extract',
        'array_to_json': 'array_to_json',
        'array_to_string': 'array_to_string',
        'array_to_string_comma_default': 'array_to_string_comma_default',
        'bar': 'bar',
        'base64': 'base64',
        'bin': 'bin',
        'chr': 'chr',
        'concat_ws': 'concat_ws',
        'current_catalog': 'current_catalog',
        'current_database': 'current_database',
        'current_query': 'current_query',
        'current_role': 'current_role',
        'current_schema': 'current_schema',
        'current_schemas': 'current_schemas',
        'current_user': 'current_user',
        'dayname': 'dayname',
        'decode': 'decode',
        'enum_first': 'enum_first',
        'enum_last': 'enum_last',
        'enum_range': 'enum_range',
        'enum_range_boundary': 'enum_range_boundary',
        'format': 'format',
        'formatReadableDecimalSize': 'formatReadableDecimalSize',
        'formatReadableSize': 'formatReadableSize',
        'format_bytes': 'format_bytes',
        'format_pg_type': 'format_pg_type',
        'format_type': 'format_type',
        'gen_random_uuid': 'gen_random_uuid',
        'hex': 'hex',
        'icu_collate_af': 'icu_collate_af',
        'icu_collate_am': 'icu_collate_am',
        'icu_collate_ar': 'icu_collate_ar',
        'icu_collate_ar_sa': 'icu_collate_ar_sa',
        'icu_collate_as': 'icu_collate_as',
        'icu_collate_az': 'icu_collate_az',
        'icu_collate_be': 'icu_collate_be',
        'icu_collate_bg': 'icu_collate_bg',
        'icu_collate_bn': 'icu_collate_bn',
        'icu_collate_bo': 'icu_collate_bo',
        'icu_collate_br': 'icu_collate_br',
        'icu_collate_bs': 'icu_collate_bs',
        'icu_collate_ca': 'icu_collate_ca',
        'icu_collate_ceb': 'icu_collate_ceb',
        'icu_collate_chr': 'icu_collate_chr',
        'icu_collate_cs': 'icu_collate_cs',
        'icu_collate_cy': 'icu_collate_cy',
        'icu_collate_da': 'icu_collate_da',
        'icu_collate_de': 'icu_collate_de',
        'icu_collate_de_at': 'icu_collate_de_at',
        'icu_collate_dsb': 'icu_collate_dsb',
        'icu_collate_dz': 'icu_collate_dz',
        'icu_collate_ee': 'icu_collate_ee',
        'icu_collate_el': 'icu_collate_el',
        'icu_collate_en': 'icu_collate_en',
        'icu_collate_en_us': 'icu_collate_en_us',
        'icu_collate_eo': 'icu_collate_eo',
        'icu_collate_es': 'icu_collate_es',
        'icu_collate_et': 'icu_collate_et',
        'icu_collate_fa': 'icu_collate_fa',
        'icu_collate_fa_af': 'icu_collate_fa_af',
        'icu_collate_ff': 'icu_collate_ff',
        'icu_collate_fi': 'icu_collate_fi',
        'icu_collate_fil': 'icu_collate_fil',
        'icu_collate_fo': 'icu_collate_fo',
        'icu_collate_fr': 'icu_collate_fr',
        'icu_collate_fr_ca': 'icu_collate_fr_ca',
        'icu_collate_fy': 'icu_collate_fy',
        'icu_collate_ga': 'icu_collate_ga',
        'icu_collate_gl': 'icu_collate_gl',
        'icu_collate_gu': 'icu_collate_gu',
        'icu_collate_ha': 'icu_collate_ha',
        'icu_collate_haw': 'icu_collate_haw',
        'icu_collate_he': 'icu_collate_he',
        'icu_collate_he_il': 'icu_collate_he_il',
        'icu_collate_hi': 'icu_collate_hi',
        'icu_collate_hr': 'icu_collate_hr',
        'icu_collate_hsb': 'icu_collate_hsb',
        'icu_collate_hu': 'icu_collate_hu',
        'icu_collate_hy': 'icu_collate_hy',
        'icu_collate_id': 'icu_collate_id',
        'icu_collate_id_id': 'icu_collate_id_id',
        'icu_collate_ig': 'icu_collate_ig',
        'icu_collate_is': 'icu_collate_is',
        'icu_collate_it': 'icu_collate_it',
        'icu_collate_ja': 'icu_collate_ja',
        'icu_collate_ka': 'icu_collate_ka',
        'icu_collate_kk': 'icu_collate_kk',
        'icu_collate_kl': 'icu_collate_kl',
        'icu_collate_km': 'icu_collate_km',
        'icu_collate_kn': 'icu_collate_kn',
        'icu_collate_ko': 'icu_collate_ko',
        'icu_collate_kok': 'icu_collate_kok',
        'icu_collate_ku': 'icu_collate_ku',
        'icu_collate_ky': 'icu_collate_ky',
        'icu_collate_lb': 'icu_collate_lb',
        'icu_collate_lkt': 'icu_collate_lkt',
        'icu_collate_ln': 'icu_collate_ln',
        'icu_collate_lo': 'icu_collate_lo',
        'icu_collate_lt': 'icu_collate_lt',
        'icu_collate_lv': 'icu_collate_lv',
        'icu_collate_mk': 'icu_collate_mk',
        'icu_collate_ml': 'icu_collate_ml',
        'icu_collate_mn': 'icu_collate_mn',
        'icu_collate_mr': 'icu_collate_mr',
        'icu_collate_ms': 'icu_collate_ms',
        'icu_collate_mt': 'icu_collate_mt',
        'icu_collate_my': 'icu_collate_my',
        'icu_collate_nb': 'icu_collate_nb',
        'icu_collate_nb_no': 'icu_collate_nb_no',
        'icu_collate_ne': 'icu_collate_ne',
        'icu_collate_nl': 'icu_collate_nl',
        'icu_collate_nn': 'icu_collate_nn',
        'icu_collate_noaccent': 'icu_collate_noaccent',
        'icu_collate_om': 'icu_collate_om',
        'icu_collate_or': 'icu_collate_or',
        'icu_collate_pa': 'icu_collate_pa',
        'icu_collate_pa_in': 'icu_collate_pa_in',
        'icu_collate_pl': 'icu_collate_pl',
        'icu_collate_ps': 'icu_collate_ps',
        'icu_collate_pt': 'icu_collate_pt',
        'icu_collate_ro': 'icu_collate_ro',
        'icu_collate_ru': 'icu_collate_ru',
        'icu_collate_sa': 'icu_collate_sa',
        'icu_collate_se': 'icu_collate_se',
        'icu_collate_si': 'icu_collate_si',
        'icu_collate_sk': 'icu_collate_sk',
        'icu_collate_sl': 'icu_collate_sl',
        'icu_collate_smn': 'icu_collate_smn',
        'icu_collate_sq': 'icu_collate_sq',
        'icu_collate_sr': 'icu_collate_sr',
        'icu_collate_sr_ba': 'icu_collate_sr_ba',
        'icu_collate_sr_me': 'icu_collate_sr_me',
        'icu_collate_sr_rs': 'icu_collate_sr_rs',
        'icu_collate_sv': 'icu_collate_sv',
        'icu_collate_sw': 'icu_collate_sw',
        'icu_collate_ta': 'icu_collate_ta',
        'icu_collate_te': 'icu_collate_te',
        'icu_collate_th': 'icu_collate_th',
        'icu_collate_tk': 'icu_collate_tk',
        'icu_collate_to': 'icu_collate_to',
        'icu_collate_tr': 'icu_collate_tr',
        'icu_collate_ug': 'icu_collate_ug',
        'icu_collate_uk': 'icu_collate_uk',
        'icu_collate_ur': 'icu_collate_ur',
        'icu_collate_uz': 'icu_collate_uz',
        'icu_collate_vi': 'icu_collate_vi',
        'icu_collate_wae': 'icu_collate_wae',
        'icu_collate_wo': 'icu_collate_wo',
        'icu_collate_xh': 'icu_collate_xh',
        'icu_collate_yi': 'icu_collate_yi',
        'icu_collate_yo': 'icu_collate_yo',
        'icu_collate_yue': 'icu_collate_yue',
        'icu_collate_yue_cn': 'icu_collate_yue_cn',
        'icu_collate_zh': 'icu_collate_zh',
        'icu_collate_zh_cn': 'icu_collate_zh_cn',
        'icu_collate_zh_hk': 'icu_collate_zh_hk',
        'icu_collate_zh_mo': 'icu_collate_zh_mo',
        'icu_collate_zh_sg': 'icu_collate_zh_sg',
        'icu_collate_zh_tw': 'icu_collate_zh_tw',
        'icu_collate_zu': 'icu_collate_zu',
        'icu_sort_key': 'icu_sort_key',
        'json': 'json',
        'json_array': 'json_array',
        'json_deserialize_sql': 'json_deserialize_sql',
        'json_extract': 'json_extract',
        'json_extract_path': 'json_extract_path',
        'json_extract_path_text': 'json_extract_path_text',
        'json_extract_string': 'json_extract_string',
        'json_group_array': 'json_group_array',
        'json_group_object': 'json_group_object',
        'json_group_structure': 'json_group_structure',
        'json_keys': 'json_keys',
        'json_merge_patch': 'json_merge_patch',
        'json_object': 'json_object',
        'json_pretty': 'json_pretty',
        'json_quote': 'json_quote',
        'json_serialize_plan': 'json_serialize_plan',
        'json_serialize_sql': 'json_serialize_sql',
        'json_structure': 'json_structure',
        'json_type': 'json_type',
        'json_value': 'json_value',
        'lcase': 'lcase',
        'left': 'left',
        'left_grapheme': 'left_grapheme',
        'list_element': 'list_element',
        'list_extract': 'list_extract',
        'lower': 'lower',
        'lpad': 'lpad',
        'ltrim': 'ltrim',
        'md5': 'md5',
        'monthname': 'monthname',
        'nfc_normalize': 'nfc_normalize',
        'parse_dirname': 'parse_dirname',
        'parse_dirpath': 'parse_dirpath',
        'parse_filename': 'parse_filename',
        'parse_path': 'parse_path',
        'pg_get_constraintdef': 'pg_get_constraintdef',
        'pg_get_viewdef': 'pg_get_viewdef',
        'pg_size_pretty': 'pg_size_pretty',
        'pg_typeof': 'pg_typeof',
        'printf': 'printf',
        'regexp_escape': 'regexp_escape',
        'regexp_extract': 'regexp_extract',
        'regexp_extract_all': 'regexp_extract_all',
        'regexp_replace': 'regexp_replace',
        'regexp_split_to_array': 'regexp_split_to_array',
        'repeat': 'repeat',
        'replace': 'replace',
        'reverse': 'reverse',
        'right': 'right',
        'right_grapheme': 'right_grapheme',
        'row_to_json': 'row_to_json',
        'rpad': 'rpad',
        'rtrim': 'rtrim',
        'session_user': 'session_user',
        'sha1': 'sha1',
        'sha256': 'sha256',
        'split': 'split',
        'split_part': 'split_part',
        'stats': 'stats',
        'str_split': 'str_split',
        'str_split_regex': 'str_split_regex',
        'strftime': 'strftime',
        'string_split': 'string_split',
        'string_split_regex': 'string_split_regex',
        'string_to_array': 'string_to_array',
        'strip_accents': 'strip_accents',
        'substr': 'substr',
        'substring': 'substring',
        'substring_grapheme': 'substring_grapheme',
        'to_base': 'to_base',
        'to_base64': 'to_base64',
        'to_binary': 'to_binary',
        'to_hex': 'to_hex',
        'to_json': 'to_json',
        'translate': 'translate',
        'trim': 'trim',
        'typeof': 'typeof',
        'ucase': 'ucase',
        'upper': 'upper',
        'url_decode': 'url_decode',
        'url_encode': 'url_encode',
        'user': 'user',
        'uuid': 'uuid',
        'uuidv4': 'uuidv4',
        'uuidv7': 'uuidv7',
        'variant_typeof': 'variant_typeof',
        'vector_type': 'vector_type',
        'version': 'version',
    }

    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {
        '->>': 'symbol_002d_003e_003e',
    }

class ScalarFunctionNamespace:
    """DuckDB scalar function categories."""
    __slots__ = ()
    Blob: ScalarBlobFunctions = ScalarBlobFunctions()  # noqa: N802
    Boolean: ScalarBooleanFunctions = ScalarBooleanFunctions()  # noqa: N802
    Generic: ScalarGenericFunctions = ScalarGenericFunctions()  # noqa: N802
    Numeric: ScalarNumericFunctions = ScalarNumericFunctions()  # noqa: N802
    Varchar: ScalarVarcharFunctions = ScalarVarcharFunctions()  # noqa: N802
    def __dir__(self) -> list[str]:
        return sorted(name for name in self.__class__.__dict__ if not name.startswith('_'))

class WindowBlobFunctions(_StaticFunctionNamespace):
    """DuckDB window functions returning binary results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'window'
    return_category: ClassVar[str] = 'blob'
    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {}
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class WindowBooleanFunctions(_StaticFunctionNamespace):
    """DuckDB window functions returning boolean results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'window'
    return_category: ClassVar[str] = 'boolean'
    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {}
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class WindowGenericFunctions(_StaticFunctionNamespace):
    """DuckDB window functions returning generic results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'window'
    return_category: ClassVar[str] = 'generic'
    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {}
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class WindowNumericFunctions(_StaticFunctionNamespace):
    """DuckDB window functions returning numeric results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'window'
    return_category: ClassVar[str] = 'numeric'
    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {}
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class WindowVarcharFunctions(_StaticFunctionNamespace):
    """DuckDB window functions returning string results."""
    __slots__ = ()
    function_type: ClassVar[str] = 'window'
    return_category: ClassVar[str] = 'varchar'
    _IDENTIFIER_FUNCTIONS: ClassVar[dict[str, str]] = {}
    _SYMBOLIC_FUNCTIONS: ClassVar[dict[str, str]] = {}

class WindowFunctionNamespace:
    """DuckDB window function categories."""
    __slots__ = ()
    Blob: WindowBlobFunctions = WindowBlobFunctions()  # noqa: N802
    Boolean: WindowBooleanFunctions = WindowBooleanFunctions()  # noqa: N802
    Generic: WindowGenericFunctions = WindowGenericFunctions()  # noqa: N802
    Numeric: WindowNumericFunctions = WindowNumericFunctions()  # noqa: N802
    Varchar: WindowVarcharFunctions = WindowVarcharFunctions()  # noqa: N802
    def __dir__(self) -> list[str]:
        return sorted(name for name in self.__class__.__dict__ if not name.startswith('_'))

class DuckDBFunctionNamespace:
    """Aggregate entry point for DuckDB typed function namespaces."""
    __slots__ = ()
    Scalar: ScalarFunctionNamespace = ScalarFunctionNamespace()
    Aggregate: AggregateFunctionNamespace = AggregateFunctionNamespace()
    Window: WindowFunctionNamespace = WindowFunctionNamespace()
    def __dir__(self) -> list[str]:  # pragma: no cover - interactive helper
        return ['Scalar', 'Aggregate', 'Window']

SCALAR_FUNCTIONS = ScalarFunctionNamespace()
AGGREGATE_FUNCTIONS = AggregateFunctionNamespace()
WINDOW_FUNCTIONS = WindowFunctionNamespace()

__all__ = [
    'DuckDBFunctionDefinition',
    'DuckDBFunctionNamespace',
    'DuckDBFunctionSignature',
    'SCALAR_FUNCTIONS',
    'AGGREGATE_FUNCTIONS',
    'WINDOW_FUNCTIONS',
]
