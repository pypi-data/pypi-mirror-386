from __future__ import annotations
import collections.abc
import typing
__all__: list[str] = ['Accelerator', 'AcceleratorConnection', 'AnyType', 'AppID', 'AppIDPath', 'ArrayType', 'BitVectorType', 'BitsType', 'BundlePort', 'BundleType', 'Callback', 'ChannelPort', 'ChannelType', 'Constant', 'Context', 'Debug', 'Direction', 'Error', 'From', 'Function', 'HWModule', 'HostMem', 'HostMemOptions', 'HostMemRegion', 'Info', 'Instance', 'IntegerType', 'LogLevel', 'Logger', 'MMIO', 'MMIORegion', 'MMIORegionDescriptor', 'Manifest', 'MessageDataFuture', 'ModuleInfo', 'ReadChannelPort', 'SIntType', 'Service', 'ServicePort', 'StructType', 'SysInfo', 'Telemetry', 'To', 'Type', 'UIntType', 'VoidType', 'Warning', 'WriteChannelPort']
class Accelerator(HWModule):
    pass
class AcceleratorConnection:
    def __init__(self, arg0: Context, arg1: str, arg2: str) -> None:
        ...
    def get_accelerator(self) -> Accelerator:
        ...
    def get_service_hostmem(self) -> HostMem:
        ...
    def get_service_mmio(self) -> MMIO:
        ...
    def sysinfo(self) -> SysInfo:
        ...
class AnyType(Type):
    def __init__(self, id: str) -> None:
        ...
class AppID:
    def __eq__(self, arg0: AppID) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __init__(self, name: str, idx: typing.SupportsInt | None = None) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def idx(self) -> typing.Any:
        ...
    @property
    def name(self) -> str:
        ...
class AppIDPath:
    def __repr__(self) -> str:
        ...
class ArrayType(Type):
    def __init__(self, id: str, element_type: Type, size: typing.SupportsInt) -> None:
        ...
    @property
    def element(self) -> Type:
        ...
    @property
    def size(self) -> int:
        ...
class BitVectorType(Type):
    def __init__(self, id: str, width: typing.SupportsInt) -> None:
        ...
    @property
    def width(self) -> int:
        ...
class BitsType(BitVectorType):
    def __init__(self, id: str, width: typing.SupportsInt) -> None:
        ...
class BundlePort:
    def getRead(self, arg0: str) -> ReadChannelPort:
        ...
    def getWrite(self, arg0: str) -> WriteChannelPort:
        ...
    @property
    def channels(self) -> dict[str, ChannelPort]:
        ...
    @property
    def id(self) -> AppID:
        ...
class BundleType(Type):
    def __init__(self, id: str, channels: collections.abc.Sequence[tuple[str, Direction, Type]]) -> None:
        ...
    @property
    def channels(self) -> list[tuple[str, Direction, Type]]:
        ...
class Callback(ServicePort):
    def connect(self, arg0: collections.abc.Callable[[typing.Any], typing.Any]) -> None:
        ...
class ChannelPort:
    def connect(self, buffer_size: typing.SupportsInt | None = None) -> None:
        ...
    def disconnect(self) -> None:
        ...
    @property
    def type(self) -> Type:
        ...
class ChannelType(Type):
    def __init__(self, id: str, inner: Type) -> None:
        ...
    @property
    def inner(self) -> Type:
        ...
class Constant:
    @property
    def type(self) -> typing.Any:
        ...
    @property
    def value(self) -> typing.Any:
        ...
class Context:
    def __init__(self) -> None:
        ...
    def connect(self, arg0: str, arg1: str) -> AcceleratorConnection:
        ...
    def set_stdio_logger(self, arg0: LogLevel) -> None:
        ...
class Direction:
    """
    Members:
    
      To
    
      From
    """
    From: typing.ClassVar[Direction]  # value = <Direction.From: 1>
    To: typing.ClassVar[Direction]  # value = <Direction.To: 0>
    __members__: typing.ClassVar[dict[str, Direction]]  # value = {'To': <Direction.To: 0>, 'From': <Direction.From: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Function(ServicePort):
    def call(self, arg0: bytearray) -> MessageDataFuture:
        ...
    def connect(self) -> None:
        ...
class HWModule:
    @property
    def children(self) -> dict[AppID, Instance]:
        ...
    @property
    def info(self) -> esiaccel.esiCppAccel.ModuleInfo | None:
        ...
    @property
    def ports(self) -> dict[AppID, BundlePort]:
        ...
    @property
    def services(self) -> list[Service]:
        ...
class HostMem(Service):
    def allocate(self, size: typing.SupportsInt, options: HostMemOptions = ...) -> HostMemRegion:
        ...
    def map_memory(self, ptr: typing.SupportsInt, size: typing.SupportsInt, options: HostMemOptions = ...) -> bool:
        ...
    def unmap_memory(self, ptr: typing.SupportsInt) -> None:
        ...
class HostMemOptions:
    use_large_pages: bool
    writeable: bool
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class HostMemRegion:
    @property
    def ptr(self) -> int:
        ...
    @property
    def size(self) -> int:
        ...
class Instance(HWModule):
    @property
    def id(self) -> AppID:
        ...
class IntegerType(BitVectorType):
    def __init__(self, id: str, width: typing.SupportsInt) -> None:
        ...
class LogLevel:
    """
    Members:
    
      Debug
    
      Info
    
      Warning
    
      Error
    """
    Debug: typing.ClassVar[LogLevel]  # value = <LogLevel.Debug: 1>
    Error: typing.ClassVar[LogLevel]  # value = <LogLevel.Error: 4>
    Info: typing.ClassVar[LogLevel]  # value = <LogLevel.Info: 2>
    Warning: typing.ClassVar[LogLevel]  # value = <LogLevel.Warning: 3>
    __members__: typing.ClassVar[dict[str, LogLevel]]  # value = {'Debug': <LogLevel.Debug: 1>, 'Info': <LogLevel.Info: 2>, 'Warning': <LogLevel.Warning: 3>, 'Error': <LogLevel.Error: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: typing.SupportsInt) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: typing.SupportsInt) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Logger:
    pass
class MMIO(Service):
    def read(self, arg0: typing.SupportsInt) -> int:
        ...
    def write(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def regions(self) -> dict[AppIDPath, MMIORegionDescriptor]:
        ...
class MMIORegion(ServicePort):
    def read(self, arg0: typing.SupportsInt) -> int:
        ...
    def write(self, arg0: typing.SupportsInt, arg1: typing.SupportsInt) -> None:
        ...
    @property
    def descriptor(self) -> MMIORegionDescriptor:
        ...
class MMIORegionDescriptor:
    @property
    def base(self) -> int:
        ...
    @property
    def size(self) -> int:
        ...
class Manifest:
    def __init__(self, arg0: Context, arg1: str) -> None:
        ...
    def build_accelerator(self, arg0: AcceleratorConnection) -> Accelerator:
        ...
    @property
    def api_version(self) -> int:
        ...
    @property
    def module_infos(self) -> list[ModuleInfo]:
        ...
    @property
    def type_table(self) -> list[typing.Any]:
        ...
class MessageDataFuture:
    def get(self) -> bytearray:
        ...
    def valid(self) -> bool:
        ...
    def wait(self) -> None:
        ...
class ModuleInfo:
    def __repr__(self) -> str:
        ...
    @property
    def commit_hash(self) -> str | None:
        ...
    @property
    def constants(self) -> dict[str, Constant]:
        ...
    @property
    def name(self) -> str | None:
        ...
    @property
    def repo(self) -> str | None:
        ...
    @property
    def summary(self) -> str | None:
        ...
    @property
    def version(self) -> str | None:
        ...
class ReadChannelPort(ChannelPort):
    def read(self) -> bytearray:
        """
        Read data from the channel. Blocking.
        """
    def read_async(self) -> MessageDataFuture:
        ...
class SIntType(IntegerType):
    def __init__(self, id: str, width: typing.SupportsInt) -> None:
        ...
class Service:
    pass
class ServicePort(BundlePort):
    pass
class StructType(Type):
    def __init__(self, id: str, fields: collections.abc.Sequence[tuple[str, Type]], reverse: bool = True) -> None:
        ...
    @property
    def fields(self) -> list[tuple[str, Type]]:
        ...
    @property
    def reverse(self) -> bool:
        ...
class SysInfo(Service):
    def esi_version(self) -> int:
        ...
    def json_manifest(self) -> str:
        ...
class Telemetry(ServicePort):
    def connect(self) -> None:
        ...
    def read(self) -> MessageDataFuture:
        ...
class Type:
    def __init__(self, id: str) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def id(self) -> str:
        ...
class UIntType(IntegerType):
    def __init__(self, id: str, width: typing.SupportsInt) -> None:
        ...
class VoidType(Type):
    def __init__(self, id: str) -> None:
        ...
class WriteChannelPort(ChannelPort):
    def tryWrite(self, arg0: bytearray) -> bool:
        ...
    def write(self, arg0: bytearray) -> None:
        ...
Debug: LogLevel  # value = <LogLevel.Debug: 1>
Error: LogLevel  # value = <LogLevel.Error: 4>
From: Direction  # value = <Direction.From: 1>
Info: LogLevel  # value = <LogLevel.Info: 2>
To: Direction  # value = <Direction.To: 0>
Warning: LogLevel  # value = <LogLevel.Warning: 3>
