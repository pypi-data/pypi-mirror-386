"""
The scte35_tags module holds all the different nodes
you may come across when parsing SCTE35 XML information.
"""

from functools import cached_property
from typing import Any, List, Optional

from lxml.etree import Element, QName

from ..parser.attribute_parsers import (
    get_bool_value,
    get_float_value,
    get_int_value,
)

LOOKUP_STR_FORMAT = './*[local-name(.) = "{target}"]'
KEYS_NOT_FOR_SETTING = ["element", "tag_map"]


class Tag:
    """Generic repr of scte35 tag object"""

    def __init__(self, element: Element) -> None:
        self.element: Element = element
        self.tag_map: dict = {}

    def __setattr__(self, key: str, value: Any) -> None:
        """overload default setattr to make changes to the lxml element when attributes are changed by user"""
        super().__setattr__(key, value)
        # attributes that are not generated by lxml parsing
        if key in KEYS_NOT_FOR_SETTING:
            return

        # not an attribute, but part of the element
        if key == "text":
            self.element.text = value
            return

        # most attributes have a camel case name in SCTE35
        element_attrib_name = self.to_camel_case(key)

        # and those that don't, are mapped in tag_map
        if self.tag_map and key in self.tag_map:
            element_attrib_name = self.tag_map.get(key, element_attrib_name)

        # the value is None, remove attribute
        if not value:
            self.element.attrib.pop(element_attrib_name, None)
            return

        # list value should turn to a comma separated string
        if isinstance(value, list):
            self.element.attrib[element_attrib_name] = ",".join(map(str, value))
            return

        self.element.attrib[element_attrib_name] = str(value)

    @classmethod
    def to_camel_case(cls, snake_case_string: str) -> str:
        """convert snake_case to lowerCamelCase"""
        lead, *follow = snake_case_string.split("_")
        return "".join([lead, *map(str.capitalize, follow)])

    def unparsed_attr(self, key: str) -> Optional[str]:
        """get unparsed attribute value"""
        return self.element.attrib.get(key)

    def get_attr(self, key: str) -> Optional[str]:
        """Get attribute value, checking both namespaced and non-namespaced versions"""
        # Try non-namespaced first
        value = self.element.attrib.get(key)
        if value is not None:
            return value

        # Try with namespace
        for attr_key in self.element.attrib:
            if isinstance(attr_key, str):
                local_name = attr_key.split("}")[-1] if "}" in attr_key else attr_key
            else:
                local_name = QName(attr_key).localname
            if local_name == key:
                return self.element.attrib[attr_key]
        return None

    def cast_single_child(self, node_name, class_name):
        nodes = self.element.xpath(LOOKUP_STR_FORMAT.format(target=node_name))
        return class_name(nodes[0]) if nodes else None


class SpliceTime(Tag):
    """SpliceTime tag representation"""

    @cached_property
    def pts_time(self) -> Optional[int]:
        return get_int_value(self.get_attr("ptsTime"))


class TimeSignal(Tag):
    """TimeSignal tag representation"""

    @cached_property
    def splice_time(self) -> Optional[SpliceTime]:
        return self.cast_single_child("SpliceTime", SpliceTime)


class SpliceInsert(Tag):
    """SpliceInsert tag representation"""

    @cached_property
    def splice_event_id(self) -> Optional[int]:
        return get_int_value(self.get_attr("spliceEventId"))

    @cached_property
    def splice_event_cancel_indicator(self) -> Optional[bool]:
        return get_bool_value(self.get_attr("spliceEventCancelIndicator"))

    @cached_property
    def out_of_network_indicator(self) -> Optional[bool]:
        return get_bool_value(self.get_attr("outOfNetworkIndicator"))

    @cached_property
    def splice_immediate_flag(self) -> Optional[bool]:
        return get_bool_value(self.get_attr("spliceImmediateFlag"))

    @cached_property
    def unique_program_id(self) -> Optional[int]:
        return get_int_value(self.get_attr("uniqueProgramId"))

    @cached_property
    def avail_num(self) -> Optional[int]:
        return get_int_value(self.get_attr("availNum"))

    @cached_property
    def avails_expected(self) -> Optional[int]:
        return get_int_value(self.get_attr("availsExpected"))

    @cached_property
    def program(self) -> Optional[TimeSignal]:
        return self.cast_single_child("Program", TimeSignal)

    @cached_property
    def break_duration(self) -> Optional[dict]:
        duration = self.element.xpath(LOOKUP_STR_FORMAT.format(target="BreakDuration"))
        if not duration:
            return None
        return {
            "auto_return": get_bool_value(duration[0].attrib.get("autoReturn")),
            "duration": get_int_value(duration[0].attrib.get("duration")),
        }


class SegmentationUpid(Tag):
    """SegmentationUpid tag representation"""

    @cached_property
    def segmentation_upid_type(self) -> Optional[int]:
        return get_int_value(self.get_attr("segmentationUpidType"))

    @cached_property
    def segmentation_upid_format(self) -> Optional[str]:
        return self.get_attr("segmentationUpidFormat")

    @cached_property
    def text(self) -> Optional[str]:
        return self.element.text


class SegmentationDescriptor(Tag):
    """SegmentationDescriptor tag representation"""

    @cached_property
    def segmentation_event_id(self) -> Optional[int]:
        return get_int_value(self.get_attr("segmentationEventId"))

    @cached_property
    def segmentation_event_cancel_indicator(self) -> Optional[bool]:
        return get_bool_value(self.get_attr("segmentationEventCancelIndicator"))

    @cached_property
    def segmentation_duration(self) -> Optional[int]:
        return get_int_value(self.get_attr("segmentationDuration"))

    @cached_property
    def segmentation_type_id(self) -> Optional[int]:
        return get_int_value(self.get_attr("segmentationTypeId"))

    @cached_property
    def segment_num(self) -> Optional[int]:
        return get_int_value(self.get_attr("segmentNum"))

    @cached_property
    def segments_expected(self) -> Optional[int]:
        return get_int_value(self.get_attr("segmentsExpected"))

    @cached_property
    def segmentation_upid(self) -> Optional[SegmentationUpid]:
        return self.cast_single_child("SegmentationUpid", SegmentationUpid)


class Ext(Tag):
    """Ext tag representation"""

    @cached_property
    def avail_type(self) -> Optional[int]:
        return get_int_value(self.get_attr("availType"))

    @cached_property
    def time_from_signal(self) -> Optional[str]:
        return self.get_attr("timeFromSignal")


class BreakDuration(Tag):
    """BreakDuration tag representation"""

    @cached_property
    def auto_return(self) -> Optional[bool]:
        return get_bool_value(self.get_attr("autoReturn"))

    @cached_property
    def duration(self) -> Optional[int]:
        return get_int_value(self.get_attr("duration"))


class AvailDescriptor(Tag):
    """AvailDescriptor tag representation"""

    @cached_property
    def provider_avail_id(self) -> Optional[int]:
        return get_int_value(self.get_attr("providerAvailId"))


class DTMFDescriptor(Tag):
    """DTMFDescriptor tag representation"""

    @cached_property
    def preroll(self) -> Optional[int]:
        return get_int_value(self.get_attr("preroll"))

    @cached_property
    def chars(self) -> Optional[str]:
        return self.get_attr("chars")


class TimeDescriptor(Tag):
    """TimeDescriptor tag representation"""

    @cached_property
    def tai_seconds(self) -> Optional[int]:
        return get_int_value(self.get_attr("taiSeconds"))

    @cached_property
    def tai_ns(self) -> Optional[int]:
        return get_int_value(self.get_attr("taiNs"))

    @cached_property
    def utc_offset(self) -> Optional[int]:
        return get_int_value(self.get_attr("utcOffset"))


class AudioChannel(Tag):
    """AudioChannel tag representation"""

    @cached_property
    def iso_code(self) -> Optional[str]:
        return self.get_attr("ISOCode")

    @cached_property
    def bit_stream_mode(self) -> Optional[int]:
        return get_int_value(self.get_attr("BitStreamMode"))

    @cached_property
    def num_channels(self) -> Optional[int]:
        return get_int_value(self.get_attr("NumChannels"))

    @cached_property
    def full_srvc_audio(self) -> Optional[bool]:
        return get_bool_value(self.get_attr("FullSrvcAudio"))

    @cached_property
    def component_tag(self) -> Optional[int]:
        return get_int_value(self.get_attr("componentTag"))


class AudioDescriptor(Tag):
    """AudioDescriptor tag representation"""

    @cached_property
    def audio_channels(self) -> List[AudioChannel]:
        return [
            AudioChannel(channel)
            for channel in self.element.xpath(
                LOOKUP_STR_FORMAT.format(target="AudioChannel")
            )
        ]


class PrivateDescriptor(Tag):
    """PrivateDescriptor tag representation"""

    @cached_property
    def descriptor_tag(self) -> Optional[int]:
        return get_int_value(self.get_attr("descriptorTag"))

    @cached_property
    def identifier(self) -> Optional[int]:
        return get_int_value(self.get_attr("identifier"))

    @cached_property
    def private_bytes(self) -> Optional[str]:
        return self.get_attr("PrivateBytes")


class PrivateCommand(Tag):
    """PrivateCommand tag representation"""

    @cached_property
    def identifier(self) -> Optional[int]:
        return get_int_value(self.get_attr("identifier"))

    @cached_property
    def private_bytes(self) -> Optional[str]:
        return self.get_attr("PrivateBytes")


class BandwidthReservation(Tag):
    """BandwidthReservation tag representation"""

    pass


class SpliceScheduleEvent(Tag):
    """SpliceScheduleEvent tag representation"""

    @cached_property
    def splice_event_id(self) -> Optional[int]:
        return get_int_value(self.get_attr("spliceEventId"))

    @cached_property
    def splice_event_cancel_indicator(self) -> Optional[bool]:
        return get_bool_value(self.get_attr("spliceEventCancelIndicator"))

    @cached_property
    def out_of_network_indicator(self) -> Optional[bool]:
        return get_bool_value(self.get_attr("outOfNetworkIndicator"))

    @cached_property
    def unique_program_id(self) -> Optional[int]:
        return get_int_value(self.get_attr("uniqueProgramId"))

    @cached_property
    def avail_num(self) -> Optional[int]:
        return get_int_value(self.get_attr("availNum"))

    @cached_property
    def avails_expected(self) -> Optional[int]:
        return get_int_value(self.get_attr("availsExpected"))

    @cached_property
    def program(self) -> Optional[TimeSignal]:
        return self.cast_single_child("Program", TimeSignal)

    @cached_property
    def break_duration(self) -> Optional[BreakDuration]:
        return self.cast_single_child("BreakDuration", BreakDuration)


class SpliceSchedule(Tag):
    """SpliceSchedule tag representation"""

    @cached_property
    def events(self) -> List[SpliceScheduleEvent]:
        return [
            SpliceScheduleEvent(event)
            for event in self.element.xpath(LOOKUP_STR_FORMAT.format(target="Event"))
        ]


class SpliceNull(Tag):
    """SpliceNull tag representation"""

    pass


class EncryptedPacket(Tag):
    """EncryptedPacket tag representation"""

    @cached_property
    def encryption_algorithm(self) -> Optional[int]:
        return get_int_value(self.get_attr("encryptionAlgorithm"))

    @cached_property
    def cw_index(self) -> Optional[int]:
        return get_int_value(self.get_attr("cwIndex"))

    @cached_property
    def ext(self) -> Optional[Ext]:
        return self.cast_single_child("Ext", Ext)


class SpliceInfoSection(Tag):
    """SpliceInfoSection tag representation"""

    @cached_property
    def protocol_version(self) -> Optional[int]:
        return get_int_value(self.get_attr("protocolVersion"))

    @cached_property
    def pts_adjustment(self) -> Optional[int]:
        return get_int_value(self.get_attr("ptsAdjustment"))

    @cached_property
    def tier(self) -> Optional[int]:
        return get_int_value(self.get_attr("tier"))

    @cached_property
    def splice_insert(self) -> Optional[SpliceInsert]:
        return self.cast_single_child("SpliceInsert", SpliceInsert)

    @cached_property
    def time_signal(self) -> Optional[TimeSignal]:
        return self.cast_single_child("TimeSignal", TimeSignal)

    @cached_property
    def splice_null(self) -> Optional[SpliceNull]:
        return self.cast_single_child("SpliceNull", SpliceNull)

    @cached_property
    def splice_schedule(self) -> Optional[SpliceSchedule]:
        return self.cast_single_child("SpliceSchedule", SpliceSchedule)

    @cached_property
    def bandwidth_reservation(self) -> Optional[BandwidthReservation]:
        return self.cast_single_child("BandwidthReservation", BandwidthReservation)

    @cached_property
    def private_command(self) -> Optional[PrivateCommand]:
        return self.cast_single_child("PrivateCommand", PrivateCommand)

    @cached_property
    def encrypted_packet(self) -> Optional[EncryptedPacket]:
        return self.cast_single_child("EncryptedPacket", EncryptedPacket)

    @cached_property
    def segmentation_descriptors(self) -> List[SegmentationDescriptor]:
        return [
            SegmentationDescriptor(desc)
            for desc in self.element.xpath(
                LOOKUP_STR_FORMAT.format(target="SegmentationDescriptor")
            )
        ]

    @cached_property
    def avail_descriptors(self) -> List[AvailDescriptor]:
        return [
            AvailDescriptor(desc)
            for desc in self.element.xpath(
                LOOKUP_STR_FORMAT.format(target="AvailDescriptor")
            )
        ]

    @cached_property
    def dtmf_descriptors(self) -> List[DTMFDescriptor]:
        return [
            DTMFDescriptor(desc)
            for desc in self.element.xpath(
                LOOKUP_STR_FORMAT.format(target="DTMFDescriptor")
            )
        ]

    @cached_property
    def time_descriptors(self) -> List[TimeDescriptor]:
        return [
            TimeDescriptor(desc)
            for desc in self.element.xpath(
                LOOKUP_STR_FORMAT.format(target="TimeDescriptor")
            )
        ]

    @cached_property
    def audio_descriptors(self) -> List[AudioDescriptor]:
        return [
            AudioDescriptor(desc)
            for desc in self.element.xpath(
                LOOKUP_STR_FORMAT.format(target="AudioDescriptor")
            )
        ]

    @cached_property
    def private_descriptors(self) -> List[PrivateDescriptor]:
        return [
            PrivateDescriptor(desc)
            for desc in self.element.xpath(
                LOOKUP_STR_FORMAT.format(target="PrivateDescriptor")
            )
        ]

    @cached_property
    def ext(self) -> Optional[Ext]:
        return self.cast_single_child("Ext", Ext)
