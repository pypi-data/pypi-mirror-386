{"task_id": "CUDA/30", "date": "2025-03-31" , "prompt": "Write CUDA functions to perform grid synchronization using cooperative groups:\n\n1. A kernel function called `sync_kernel` that uses cooperative groups to synchronize grid. \n   This kernel should invoke `pre_sync()` before the grid sync and `post_sync()` after the grid sync.\n   The beginning of the kernel should look like:\n   ```cuda\n   template <class PreSync, class PostSync>\n   __global__ void sync_kernel(PreSync pre_sync, PostSync post_sync) {\n      pre_sync();\n   ```\n   followed by the cooperative groups grid synchronization, followed by `post_sync()` invocation.\n2. A host function called `launch` that launches the `sync_kernel` using `cudaLaunchCooperativeKernel`.\n\nThe following headers are already defined and should not be included in the response:\n```cuda\n#include <cooperative_groups.h>\n```\n\nImplement the functions in the following order using the provided signatures:\n```cuda\ntemplate <class PreSync, class PostSync>\n__global__ void sync_kernel(PreSync pre_sync, PostSync post_sync);\n\ntemplate <class PreSync, class PostSync>\nvoid launch(int num_blocks, int block_size, PreSync pre_sync, PostSync post_sync);\n```\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <cooperative_groups.h>\n#include <cuda_runtime_api.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\ntemplate <class PreSync, class PostSync>\n__global__ void sync_kernel(PreSync pre_sync, PostSync post_sync);\n\ntemplate <class PreSync, class PostSync>\nvoid launch(int num_blocks, int block_size, PreSync pre_sync, PostSync post_sync);\n\n", "test": "int main() {\n\nint num_blocks = 2;\nint *d_data{};\ncudaMalloc(&d_data, 2 * sizeof(int));\ncudaMemset(d_data, 0, 2 * sizeof(int));\n\nauto pre_sync = [d_data]__device__() {\n  if (blockIdx.x == 0) {\n    if (threadIdx.x == 0) {\n      while (atomicAdd(&d_data[0], 0) == 0) {}\n    }\n    __syncthreads();\n    __threadfence();\n\n    if (threadIdx.x == 0) {\n      d_data[0] = 42;\n    }\n  } else if (blockIdx.x == 1) {\n    if (threadIdx.x == 0) {\n      atomicAdd(&d_data[0], 1);\n    }\n  }\n};\nauto post_sync = [d_data, num_blocks]__device__() {\n  if (blockIdx.x == 1) {\n    if (threadIdx.x == 0) {\n      if (d_data[0] != 42 || num_blocks != gridDim.x || 1 != blockDim.x) {\n        d_data[1] = 0;\n      } else { \n        d_data[1] = 4242;\n      }\n    }\n  }\n};\n\nauto dynamic_test = [&]() {\n  launch(num_blocks, 1, pre_sync, post_sync);\n  int result{};\n  cudaMemcpy(&result, d_data + 1, sizeof(int), cudaMemcpyDeviceToHost);\n\n  if (result != 4242) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\nauto static_test = []() {\n  const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n  if (path == nullptr) {\n    std::cerr << \"Environment variable not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::ifstream file(path);\n  if (!file.is_open()) {\n    std::cerr << \"File not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::string line;\n\n  // Skip until the beginning of the completion block\n  while (std::getline(file, line)) {\n    if (line.find(\"completion-begin\") != std::string::npos && \n        line.find(\"std::string::npos\") == std::string::npos) {\n      break;\n    }\n  }\n\n  // Search for the thrust::transform call\n  bool found = false;\n  while (std::getline(file, line)) {\n    if (line.find(\"cudaLaunchCooperativeKernel\") != std::string::npos) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\n// static_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/31", "date": "2025-03-31" , "prompt": "Write a function `void add(int num_items, const int *in, int *out)` that adds `num_items` elements on GPU using CUB library. \nThe resulting sum should be stored in `out`.  \nThe following headers are already defined and should not be included in the response:\n```cuda\n#include <cub/device/device_reduce.cuh>\n```\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <thrust/device_vector.h>\n#include <cub/device/device_reduce.cuh>\n\nvoid add(int num_items, const int* in, int *out);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n  const int num_items = 1 << 14;\n  thrust::device_vector<int> in(num_items, 1);\n  thrust::device_vector<int> out(1);\n\n  add(num_items, in.data().get(), out.data().get());\n\n  if (out[0] != num_items) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\nauto static_test = []() {\n  const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n  if (path == nullptr) {\n    std::cerr << \"Environment variable not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::ifstream file(path);\n  if (!file.is_open()) {\n    std::cerr << \"File not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::string line;\n\n  // Skip until the beginning of the completion block\n  while (std::getline(file, line)) {\n    if (line.find(\"completion-begin\") != std::string::npos && \n        line.find(\"std::string::npos\") == std::string::npos) {\n      break;\n    }\n  }\n\n  // Search for the thrust::transform call\n  bool found = false;\n  while (std::getline(file, line)) {\n    if (line.find(\"cub::DeviceReduce\") != std::string::npos) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/32", "date": "2025-03-31" , "prompt": "Write a function `void scan(int num_items, const int *in, int *out)` that computes exclusive prefix sum of `num_items` elements on GPU using CUB library. \nThe resulting should be stored in `out`.  \nThe following headers are already defined and should not be included in the response:\n```cuda\n#include <cub/device/device_scan.cuh>\n```\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <thrust/device_vector.h>\n#include <cub/device/device_scan.cuh>\n\nvoid scan(int num_items, const int* in, int *out);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n  thrust::device_vector<int> in{ 1, 4, 0 };\n  thrust::device_vector<int> out(in.size());\n\n  scan(in.size(), in.data().get(), out.data().get());\n\n  if (out[0] != 0 || out[1] != 1 || out[2] != 5) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\nauto static_test = []() {\n  const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n  if (path == nullptr) {\n    std::cerr << \"Environment variable not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::ifstream file(path);\n  if (!file.is_open()) {\n    std::cerr << \"File not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::string line;\n\n  // Skip until the beginning of the completion block\n  while (std::getline(file, line)) {\n    if (line.find(\"completion-begin\") != std::string::npos && \n        line.find(\"std::string::npos\") == std::string::npos) {\n      break;\n    }\n  }\n\n  // Search for the thrust::transform call\n  bool found = false;\n  while (std::getline(file, line)) {\n    if (line.find(\"cub::DeviceScan\") != std::string::npos) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/33", "date": "2025-03-31" , "prompt": "Write a function `void sort(int num_items, const int *in, int *out)` that sorts `num_items` elements on GPU using radix sort from CUB library. \nThe resulting should be stored in `out`.  \nThe following headers are already defined and should not be included in the response:\n```cuda\n#include <cub/device/device_radix_sort.cuh>\n```\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <thrust/device_vector.h>\n#include <cub/device/device_radix_sort.cuh>\n\nvoid sort(int num_items, const int* in, int *out);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n  thrust::device_vector<int> in{ 1, 4, 0, 3 };\n  thrust::device_vector<int> out(in.size());\n\n  sort(in.size(), in.data().get(), out.data().get());\n\n  if (out[0] != 0 || out[1] != 1 || out[2] != 3 || out[3] != 4) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\nauto static_test = []() {\n  const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n  if (path == nullptr) {\n    std::cerr << \"Environment variable not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::ifstream file(path);\n  if (!file.is_open()) {\n    std::cerr << \"File not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::string line;\n\n  // Skip until the beginning of the completion block\n  while (std::getline(file, line)) {\n    if (line.find(\"completion-begin\") != std::string::npos && \n        line.find(\"std::string::npos\") == std::string::npos) {\n      break;\n    }\n  }\n\n  // Search for the thrust::transform call\n  bool found = false;\n  while (std::getline(file, line)) {\n    if (line.find(\"cub::DeviceRadixSort\") != std::string::npos) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/34", "date": "2025-03-31" , "prompt": "Write a CUDA kernel where each thread uses cuda::atomic_ref from libcu++ to increment a value in a device memory by one. \nUse device scope for atomic increment. The kernel should have the following signature:\n```cuda\n__global__ void kernel(int *ptr);\n```\n\nThe following headers are already defined and should not be included in the response:\n```cuda\n#include <cuda/atomic>\n```\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda", "ld_flags": "", "declaration": "#include <cuda/atomic>\n#include <cuda_runtime_api.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\n__global__ void kernel(int *ptr);\n\n", "test": "int main() {\n\nauto dynamic_test = [&]() {\n  int *d_data{};\n  cudaMalloc(&d_data, sizeof(int));\n  cudaMemset(d_data, 0, sizeof(int));\n\n  const int threads = 64;\n  const int blocks = 42;\n\n  kernel<<<blocks, threads>>>(d_data);\n\n  int result;\n  cudaMemcpy(&result, d_data, sizeof(int), cudaMemcpyDeviceToHost);\n\n  if (result != blocks * threads) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\nauto static_test = []() {\n  const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n  if (path == nullptr) {\n    std::cerr << \"Environment variable not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::ifstream file(path);\n  if (!file.is_open()) {\n    std::cerr << \"File not found!\" << std::endl;\n    std::exit(1);\n  }\n\n  std::string line;\n\n  // Skip until the beginning of the completion block\n  while (std::getline(file, line)) {\n    if (line.find(\"completion-begin\") != std::string::npos && \n        line.find(\"std::string::npos\") == std::string::npos) {\n      break;\n    }\n  }\n\n  // Search for the thrust::transform call\n  bool found = false;\n  while (std::getline(file, line)) {\n    if (line.find(\"fetch_add\") != std::string::npos) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    std::cerr << \"Test failed!\" << std::endl;\n    std::exit(1);\n  }\n};\n\n// static_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/35", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> scan(const thrust::device_vector<int>& vec)` that\ncomputes exclusive prefix sum of the input vector on GPU using thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/execution_policy.h>\n#include <thrust/scan.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> scan(const thrust::device_vector<int> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    const thrust::device_vector<int> in {1, 4, 0};\n    thrust::device_vector<int> out = scan(in);\n\n    if (out[0] != 0 || out[1] != 1 || out[2] != 5)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::exclusive_scan call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::exclusive_scan\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/36", "date": "2025-03-31" , "prompt": "Write a function `float sum(const thrust::device_vector<float>& vec)` that adds all elements of a\nvector on GPU using thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/reduce.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nfloat sum(const thrust::device_vector<float> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<float> vec {1.0f, 2.0f, 3.0f};\n\n    if (sum(vec) != 6.0f)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::reduce call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::reduce\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/37", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> sort(const thrust::device_vector<int>& vec)` that sorts\nthe input vector on GPU using thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/execution_policy.h>\n#include <thrust/sort.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> sort(const thrust::device_vector<int> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    const thrust::device_vector<int> in {3, 1, 4, 0};\n    thrust::device_vector<int> out = sort(in);\n\n    if (out[0] != 0 || out[1] != 1 || out[2] != 3 || out[3] != 4)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::sort call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::sort\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/38", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<float> vadd(const thrust::device_vector<float>& x, const\nthrust::device_vector<float>& y)` that adds two vectors on GPU.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/transform.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<float> vadd(const thrust::device_vector<float> &x,\n                                  const thrust::device_vector<float> &y);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    float x_arr[3] = {1.0f, 2.0f, 3.0f};\n    float y_arr[3] = {3.0f, 2.0f, 1.0f};\n    thrust::device_vector<float> x(x_arr, x_arr + 3);\n    thrust::device_vector<float> y(y_arr, y_arr + 3);\n    thrust::device_vector<float> xy = vadd(x, y);\n\n    for (int i = 0; i < xy.size(); i++)\n    {\n        const float product  = xy[i];\n        const float expected = x[i] + y[i];\n\n        if (product != expected)\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::transform call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::transform\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/39", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int>::iterator find(thrust::device_vector<int>&\nvec, int target)` that finds the first occurrence of the target value in the input vector.\n\nDo not include any code outside the function. Wrap the completed function code, including the\nprovided signature, inside a ```cuda markdown code block.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/find.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int>::iterator find(thrust::device_vector<int> &vec, int target);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {42, 0, 4, 2, 4};\n\n    auto it    = find(x, 4);\n    auto index = thrust::distance(x.begin(), it);\n\n    if (index != 2)\n    {\n        std::cerr << \"Error: expected 2, got \" << index << std::endl;\n        std::exit(1);\n    }\n\n    it    = find(x, -1);\n    index = thrust::distance(x.begin(), it);\n\n    if (index != 5)\n    {\n        std::cerr << \"Error: expected 5 (last), got \" << index << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::find call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::find\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/40", "date": "2025-03-31" , "prompt": "Write a function `void inclusive_add(thrust::device_vector<int>& x)` that\ncomputes an inclusive prefix sum in all the values of the array. It should do it inplace\nand the resulting array should stay on the device.\nDo not include any code outside the function. Wrap the completed function\ncode, including the provided signature, inside a ```cuda markdown code block.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/scan.h>\n#include <thrust/transform.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid inclusive_add(thrust::device_vector<int> &x);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {1, 2, 3, 4, 5};\n    inclusive_add(x);\n\n    int expected_result[] = {1, 3, 6, 10, 15};\n    for (int i = 0; i < x.size(); i++)\n    {\n        if (x[i] != expected_result[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::transform call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::inclusive_scan\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\ndynamic_test();\nstatic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/41", "date": "2025-03-31" , "prompt": "Write a function `int partitionVector(thrust::device_vector<int>& vec)` that takes a device vector\nas input and reorders the vector elements. The first elements should be less than 10 followed by the\nitems who are greater. The operation should be inplace and the function should return the index of\nthe first element that does not satisfy the condition.\n\nDo not include any code outside the function. Wrap the completed function code, including the\nprovided signature, inside a ```cuda markdown code block.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/partition.h>\n#include <thrust/sort.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nint partitionVector(thrust::device_vector<int>& vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> vec {41, 1, 42, 2, 43, 3};\n    int middle = partitionVector(vec);\n\n    if (middle != 3)\n    {\n        std::cout << \"Test failed. Middle of the partition should be 3\" << std::endl;\n        std::exit(1);\n    }\n\n    // Verify elements are partitioned correctly:\n    // partition doesn't guarantee the order of elements\n    // sort each partition to simplify the test\n    thrust::sort(vec.begin(), vec.begin() + 3);\n    thrust::sort(vec.begin() + 3, vec.end());\n\n    thrust::device_vector<int> expected {1, 2, 3, 41, 42, 43};\n    if (vec != expected)\n    {\n        std::cout << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::partition call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::partition\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/42", "date": "2025-03-31" , "prompt": "Write a function `int partitionVector(thrust::device_vector<int>& vec)` that takes a device vector\nas input and reorders the vector elements. The function should preserve relative order of the input.\nThe first elements should be less than 10 followed by the elements who are greater. The operation\nshould be inplace and the function should return the index of the first element that does not\nsatisfy the condition.\n\nDo not include any code outside the function. Wrap the completed function code, including the\nprovided signature, inside a ```cuda markdown code block.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/partition.h>\n#include <thrust/sort.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nint partitionVector(thrust::device_vector<int>& vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> vec {51, 1, 42, 2, 33, 3};\n    int middle = partitionVector(vec);\n\n    if (middle != 3)\n    {\n        std::cout << \"Test failed. Middle of the partition should be 3\" << std::endl;\n        std::exit(1);\n    }\n\n    thrust::device_vector<int> expected {1, 2, 3, 51, 42, 33};\n    if (vec != expected)\n    {\n        std::cout << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::partition call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::stable_partition\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/43", "date": "2025-03-31" , "prompt": "Write a function `void copy(const thrust::device_vector<float>& src,\nthrust::device_vector<float>& dst)` that copies half the elements of a src\nvector in GPU to a dst vector in GPU.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/copy.h>\n#include <thrust/device_vector.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid copy(const thrust::device_vector<float> &src, thrust::device_vector<float> &dst);\n\n", "test": "int main() {\nauto dynamic_test = []() {\n    thrust::device_vector<float> x {0, 1, 2, 3, 4};\n    thrust::device_vector<float> y(x.size() / 2);\n    copy(x, y);\n\n    thrust::device_vector<float> expected {0, 1};\n\n    for (std::size_t i = 0; i < y.size(); i++)\n    {\n        if (y[i] != expected[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::copy call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::copy\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/44", "date": "2025-03-31" , "prompt": "Write a function `void fill_vector_increasingly(thrust::device_vector<int>& vec)` that fills a\nvector with sequentially increasing numbers starting from 0 to `.size() - 1` using thrust\nalgorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/execution_policy.h>\n#include <thrust/sequence.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid fill_vector_increasingly(thrust::device_vector<int> &vec);\n\n", "test": "int main() {\nauto dynamic_test = []() {\n    thrust::device_vector<int> x(5);\n    fill_vector_increasingly(x);\n\n    thrust::device_vector<int> expected {0, 1, 2, 3, 4};\n\n    for (std::size_t i = 0; i < x.size(); i++)\n    {\n        if (x[i] != expected[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::sequence call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::sequence\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/45", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> combine_ranges(thrust::device_vector<int> const& vec1,\nthrust::device_vector<int> const& vec2)` that combines two sorted vectors into a single sorted\nvector in the GPU using a thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/execution_policy.h>\n#include <thrust/merge.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> combine_ranges(thrust::device_vector<int> const &vec1,\n                                          thrust::device_vector<int> const &vec2);\n\n", "test": "int main() {\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {1, 3, 5, 7};\n    thrust::device_vector<int> y {0, 2, 4, 6, 8};\n\n    auto result_vec = combine_ranges(x, y);\n\n    thrust::device_vector<int> expected {0, 1, 2, 3, 4, 5, 6, 7, 8};\n\n    for (std::size_t i = 0; i < result_vec.size(); i++)\n    {\n        if (result_vec[i] != expected[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::merge call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::merge\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/46", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> redistribute_elements(thrust::device_vector<int> const&\nvec, thrust::device_vector<int> const& map)` that takes an input vector and a map vector (of equal\nsize) that holds indices. It returns a new vector where each element from source is redistributed\naccording to the index pointed by the corresponding element in the map vector using a thrust\nalgorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/scatter.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> redistribute_elements(thrust::device_vector<int> const &vec,\n                                                 thrust::device_vector<int> const &map);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {10, 30, 20, 40, 50};\n    thrust::device_vector<int> map {2, 4, 0, 1, 3};\n\n    thrust::device_vector<int> result = redistribute_elements(x, map);\n    thrust::device_vector<int> ref {20, 40, 10, 50, 30};\n\n    for (int i = 0; i < result.size(); i++)\n    {\n        if (result[i] != ref[i])\n        {\n            std::cerr << \"Error: error at index \" << i << \" got \" << result[i] << \" expected \"\n                      << ref[i] << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::scatter call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::scatter\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/47", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> remap_elements(thrust::device_vector<int> const& vec,\nthrust::device_vector<int> const& map)` that takes an input vector and a map vector and returns a\nnew vector (equal size to map.size()) where each element is being picked from the source according to the index\nindicated by map using a thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/gather.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> remap_elements(thrust::device_vector<int> const &vec,\n                                          thrust::device_vector<int> const &map);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {1, 3, 2, 10, 3};\n    thrust::device_vector<int> map {0, 4, 1, 1};\n\n    thrust::device_vector<int> result = remap_elements(x, map);\n    thrust::device_vector<int> ref {1, 3, 3, 3};\n\n    for (int i = 0; i < result.size(); i++)\n    {\n        if (result[i] != ref[i])\n        {\n            std::cerr << \"Error: error at index \" << i << \" got \" << result[i] << \" expected \"\n                      << ref[i] << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::gather call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::gather\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/48", "date": "2025-03-31" , "prompt": "Write a function `std::size_t find_partition_barrier(thrust::device_vector<int> const& vec)` that\ntakes an already partitioned device vector where its first partition is even numbers and its second\npartition is odd numbers as input and finds the index at which the partition takes place. Use a\nsingle thrust algorithm.\n\nDo not include any code outside the function. Wrap the completed function code, including the\nprovided signature, inside a ```cuda markdown code block.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/partition.h>\n#include <thrust/sort.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nstd::size_t find_partition_barrier(thrust::device_vector<int> const & vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> vec {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};\n    auto result = find_partition_barrier(vec);\n\n    if (result != 5)\n    {\n        std::cerr << \"Test failed. Partition point should be 5.\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::partition_point call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::partition_point\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/49", "date": "2025-03-31" , "prompt": "Write a function `void shift_by_5(thrust::device_vector<int>::iterator& it)` that takes a device\nvector iterator and shifts it ahead it by 5 elements using one thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/advance.h>\n#include <thrust/device_vector.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid shift_by_5(thrust::device_vector<int>::iterator &it);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> v1 {0, -1, -2, -3, -4, -5, -6};\n    thrust::device_vector<int>::iterator it = v1.begin();\n    shift_by_5(it);\n\n    auto dst = thrust::distance(v1.begin(), it);\n\n    if (dst != 5)\n    {\n        std::cerr << \"Error, expected 5 got \" << dst << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::advance call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::advance\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/50", "date": "2025-03-31" , "prompt": "Write a function `void flip_values(thrust::device_vector<int> &vec1, thrust::device_vector<int>\n&vec2)` that accepts two device vectors and exchanges their values with each other using a thrust\nalgorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/swap.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid flip_values(thrust::device_vector<int> &vec1, thrust::device_vector<int> &vec2);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {42, 0, 4, 2, 4};\n    thrust::device_vector<int> y {-1, -2, -3, -4, -5};\n\n    flip_values(x, y);\n\n    thrust::device_vector<int> x_ref {-1, -2, -3, -4, -5};\n    thrust::device_vector<int> y_ref {42, 0, 4, 2, 4};\n    if (x_ref != x || y_ref != y)\n    {\n        std::cerr << \"Error: flip_values failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::swap call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::swap\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/51", "date": "2025-03-31" , "prompt": "Write a function `\nthrust::device_vector<char> find_the_word(\n  thrust::device_vector<char> const& chunk1,\n  thrust::device_vector<int> const& keys1,\n  thrust::device_vector<char> const& chunk2,\n  thrust::device_vector<int> const& keys2)` that merges the two input chunk vectors that hold\ncharacters according to their corresponding key vectors in the GPU. You are required to use only\none thrust algorithm. The resulting device vector should hold all the merged characters from chunk1,\nchunk2 in order according to keys1, keys2 to form the final word.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/execution_policy.h>\n#include <thrust/host_vector.h>\n#include <thrust/merge.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<char> find_the_word(thrust::device_vector<char> const & chunk1,\n                                          thrust::device_vector<int> const & keys1,\n                                          thrust::device_vector<char> const & chunk2,\n                                          thrust::device_vector<int> const & keys2);\n\n", "test": "int main() {\nauto dynamic_test = []() {\n    thrust::device_vector<int> k1 {0, 3, 4, 6, 9, 10, 13};\n    thrust::device_vector<char> ch1 {'m', 't', 'i', 'h', 'a', 'd', 'g'};\n\n    thrust::device_vector<int> k2 {1, 2, 5, 7, 8, 11, 12};\n    thrust::device_vector<char> ch2 {'u', 'l', 't', 'r', 'e', 'i', 'n'};\n\n    auto word = find_the_word(ch1, k1, ch2, k2);\n\n    thrust::host_vector<char> h_word(word);\n    std::string word_string(h_word.begin(), h_word.end());\n    std::string ref = \"multithreading\";\n    if (word_string != ref)\n    {\n        std::cerr << \"Test failed, expected \" << ref << \", got \" << word_string << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::merge_by_key call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::merge_by_key\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/52", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<float> local_prefix_maxima(thrust::device_vector<float>\nconst &vec, thrust::device_vector<int> const &keys);` that given an input vector and a keys vector\ncalculates the prefix maximum for each group of input elements that correspond to the same keys\nusing one thrust algorithm. Returns a new vector with equal size to the input vector that holds\nprefix maximum values.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/host_vector.h>\n#include <thrust/scan.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<float> local_prefix_maxima(thrust::device_vector<float> const &vec,\n                                                 thrust::device_vector<int> const &keys);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<float> vec {1.2, 1.3, 1.0, 2.7, 2.8, 2.1, 2.9, 4.9, 5.1, 5.4, 5.3};\n    thrust::device_vector<int> keys {0, 0, 0, 1, 1, 1, 1, 2, 3, 3, 3};\n\n    auto res = local_prefix_maxima(vec, keys);\n    thrust::host_vector<float> res_host(res);\n\n    thrust::host_vector<float> expected {1.2, 1.3, 1.3, 2.7, 2.8, 2.8, 2.9, 4.9, 5.1, 5.4, 5.4};\n\n    for (size_t i = 0; i < res_host.size(); i++)\n    {\n        if (res_host[i] != expected[i])\n        {\n            std::cerr << \"Error, expected \" << expected[i] << \" but got \" << res_host[i]\n                      << \" at index \" << i << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::inclusive_scan_by_key call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::inclusive_scan_by_key\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/53", "date": "2025-03-31" , "prompt": "Write a function `void remove_consecutive_duplicates(thrust::device_vector<int> &vec)` that removes\nduplicate elements from the input vector on GPU using thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/execution_policy.h>\n#include <thrust/unique.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid remove_consecutive_duplicates(thrust::device_vector<int> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> in {3, 1, 1, 4, 1, 0, 0};\n    remove_consecutive_duplicates(in);\n\n    thrust::device_vector<int> expected {3, 1, 4, 1, 0};\n\n    for (std::size_t i = 0; i < in.size(); i++)\n    {\n        if (in[i] != expected[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::unique call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::unique\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/54", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int>\nlocal_prefix_exclusive_sum(thrust::device_vector<int> const &vec, thrust::device_vector<int>\nconst &keys);` that given an input vector and a keys vector calculates the exclusive prefix sum\nfor each group of input elements that correspond to the same keys. Use only one thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/host_vector.h>\n#include <thrust/scan.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> local_prefix_exclusive_sum(thrust::device_vector<int> const &vec,\n                                                      thrust::device_vector<int> const &keys);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> vec {1, 2, 3, 2, 2, 3, 3, 5, 3, 2};\n    thrust::device_vector<int> keys {0, 0, 0, 1, 1, 1, 1, 2, 3, 3, 3};\n\n    auto res = local_prefix_exclusive_sum(vec, keys);\n    thrust::host_vector<int> res_host(res);\n\n    thrust::host_vector<int> expected {0, 1, 3, 0, 2, 4, 7, 0, 0, 3};\n\n    for (size_t i = 0; i < res_host.size(); i++)\n    {\n        if (res_host[i] != expected[i])\n        {\n            std::cerr << \"Error, expected \" << expected[i] << \" but got \" << res_host[i]\n                      << \" at index \" << i << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::exclusive_scan_by_key call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::exclusive_scan_by_key\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/55", "date": "2025-03-31" , "prompt": "Write a function `int negate_and_add(const thrust::device_vector<int> &vec)` that negates all\nelements of the input vector and then adds them all together on GPU using one thrust algorithm.\nRetiurn the sum.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/transform_reduce.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nint negate_and_add(const thrust::device_vector<int> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> vec {1, -3, 2, -4, 5};\n    auto res = negate_and_add(vec);\n\n    if (res != -1)\n    {\n        std::cerr << \"Test failed, expected -1, got \" << res << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::transform_reduce call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::transform_reduce\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/56", "date": "2025-03-31" , "prompt": "Write a function `void replace_twos(thrust::device_vector<int>& vec)` that replaces the elements of\na vector with the value 2 with the value -2 using a Thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/replace.h>\n#include <cstddef>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid replace_twos(thrust::device_vector<int>& vec);\n\n", "test": "int main() {\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {2, 1, 2, 3, -2};\n    replace_twos(x);\n\n    thrust::device_vector<int> expected {-2, 1, -2, 3, -2};\n\n    for (std::size_t i = 0; i < x.size(); i++)\n    {\n        if (x[i] != expected[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::replace call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::replace\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/57", "date": "2025-03-31" , "prompt": "Write a function `void copy_evens(const thrust::device_vector<int>& src,\nthrust::device_vector<int>& dst)` that copies the even integers of a src\nvector in GPU to a dst vector in GPU using a Thrust algorithm.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/copy.h>\n#include <thrust/device_vector.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid copy_evens(const thrust::device_vector<int> &src, thrust::device_vector<int> &dst);\n\n", "test": "int main() {\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {0, 1, 2, 3, 4};\n    thrust::device_vector<int> y(x.size());\n    copy_evens(x, y);\n\n    thrust::device_vector<int> expected {0, 2, 4};\n\n    for (std::size_t i = 0; i < y.size(); i++)\n    {\n        if (y[i] != expected[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::copy_if call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::copy_if\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/58", "date": "2025-03-31" , "prompt": "Write a function `bool has_negatives(thrust::device_vector<int> const& vec)` that checks whether\nthere are any negatives in the input vector using a thrust algorithm. Do not use `thrust::all_of`.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/logical.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nbool has_negatives(thrust::device_vector<int> const &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {42, 0, 4, -2, 1};\n\n    auto has = has_negatives(x);\n\n    if (has != true)\n    {\n        std::cerr << \"Error: expected true, got \" << has << std::endl;\n        std::exit(1);\n    }\n\n    x   = {42, 0, 4, 2, 1};\n    has = has_negatives(x);\n\n    if (has != false)\n    {\n        std::cerr << \"Error: expected false, got \" << has << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::any_of call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::any_of\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/59", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> only_common(thrust::device_vector<int> const& vec1,\nthrust::device_vector<int> const& vec2)` that combines only the common elements of two input sorted\nvectors into a single sorted vector and returns it using one thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/set_operations.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> only_common(thrust::device_vector<int> const &vec1,\n                                       thrust::device_vector<int> const &vec2);\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> v1 {1, 2, 2, 2, 3, 10};\n    thrust::device_vector<int> v2 {-10, 0, 2, 2, 5, 10};\n\n    auto result = only_common(v1, v2);\n\n    thrust::device_vector<int> expected {2, 2, 10};\n\n    for (int i = 0; i < result.size(); i++)\n    {\n        if (result[i] != expected[i])\n        {\n            std::cerr << \"Error: error at index \" << i << \" got \" << result[i] << \" expected \"\n                      << expected[i] << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::set_intersection call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::set_intersection\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/60", "date": "2025-03-31" , "prompt": "Write a function `thrust::pair<float, float> find_extrema(const thrust::device_vector<float>\n&vec)` that finds and returns the maximum and the minimum values (as a pair) of the input vector\nusing a thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/extrema.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::pair<float, float> find_extrema(const thrust::device_vector<float> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<float> vec {1.0f, 3.0f, 2.0f, 1.5f};\n\n    auto [min, max] = find_extrema(vec);\n    if (min != 1.0f || max != 3.0f)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::minmax_element call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::minmax_element\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/61", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> combine(thrust::device_vector<int> const& vec1,\nthrust::device_vector<int> const& vec2)` that combines every element of two input sorted vectors\ninto a single sorted vector and returns it using one thrust algorithm. If an element in exists\nin both inputs it shouldn't be duplicated.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/set_operations.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> combine(thrust::device_vector<int> const &vec1,\n                                   thrust::device_vector<int> const &vec2);\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> v1 {1, 2, 2, 3, 10};\n    thrust::device_vector<int> v2 {-10, 0, 2, 3, 5};\n\n    auto result = combine(v1, v2);\n\n    thrust::device_vector<int> expected {-10, 0, 1, 2, 2, 3, 5, 10};\n\n    for (int i = 0; i < result.size(); i++)\n    {\n        if (result[i] != expected[i])\n        {\n            std::cerr << \"Error: error at index \" << i << \" got \" << result[i] << \" expected \"\n                      << expected[i] << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::set_union call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::set_union\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/62", "date": "2025-03-31" , "prompt": "Write a function `bool no_positives(thrust::device_vector<int> const& vec)` that checks whether\nno values in a vector are positive using the proper logical thrust algorithm. Don't use\nthrust::all_of, thrust::any_of, thrust::find/(_if) or thrust::count/(_if).\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/logical.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nbool no_positives(thrust::device_vector<int> const &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x = {-1, 2, 2, 5};\n    auto check                   = no_positives(x);\n\n    if (check != false)\n    {\n        std::cerr << \"Error: expected false, got \" << check << std::endl;\n        std::exit(1);\n    }\n\n    x     = {-1, -6, 0, -10};\n    check = no_positives(x);\n\n    if (check != true)\n    {\n        std::cerr << \"Error: expected true, got \" << check << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::none_of call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::none_of\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/63", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> reduce_chunks(thrust::device_vector<int>& vec,\nthrust::device_vector<int> const& keys)` that adds all elements of the input vector vec that have\nthe same corresponding key value in the keys vector on GPU using one thrust algorithm. It should\nreturn a vector with the reduced values.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/host_vector.h>\n#include <thrust/reduce.h>\n#include <thrust/unique.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> reduce_chunks(thrust::device_vector<int>& vec,\n                                         thrust::device_vector<int> const & keys);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> vec {4, 2, 3, 4, 5, 10, 2, 1, 6, 8};\n    thrust::device_vector<int> keys {0, 1, 1, 1, 2, 2, 3, 3, 3, 3};\n\n    thrust::device_vector<int> res = reduce_chunks(vec, keys);\n    thrust::host_vector<int> res_host(res);\n    thrust::host_vector<int> ref {4, 9, 15, 17};\n\n    for (int i = 0; i < res.size(); i++)\n    {\n        if (res_host[i] != ref[i])\n        {\n            std::cerr << \"Error, expected \" << ref[i] << \" got \" << res[i] << \"in position \" << i\n                      << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::reduce_by_key call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::reduce_by_key\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/64", "date": "2025-03-31" , "prompt": "Write a function `void delete_twos(thrust::device_vector<int>& vec)` that removes the elements of\na vector that are equal to 2 using a Thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/remove.h>\n#include <cstddef>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid delete_twos(thrust::device_vector<int>& vec);\n\n", "test": "int main() {\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {2, 1, 2, 3, -2};\n    delete_twos(x);\n\n    thrust::device_vector<int> expected {1, 3, -2};\n\n    for (std::size_t i = 0; i < x.size(); i++)\n    {\n        if (x[i] != expected[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::remove call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::remove\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/65", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int>::iterator\nfind_first_negative(thrust::device_vector<int>& vec)` that finds and returns an iterator to the\nfirst element of the input vector that is negative.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/find.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int>::iterator find_first_negative(thrust::device_vector<int> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {42, 0, 4, -2, 4};\n\n    auto it    = find_first_negative(x);\n    auto index = thrust::distance(x.begin(), it);\n\n    if (index != 3)\n    {\n        std::cerr << \"Error: expected 3, got \" << index << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::find call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::find_if\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/66", "date": "2025-03-31" , "prompt": "Write a function `void all_42s(thrust::device_vector<int>& vec)` that flls the input vector all with\n42s using a thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/fill.h>\n#include <cstddef>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid all_42s(thrust::device_vector<int>& vec);\n", "test": "int main() {\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {0, 1, 2, 3};\n    all_42s(x);\n\n    thrust::device_vector<int> expected {42, 42, 42, 42};\n\n    for (std::size_t i = 0; i < x.size(); i++)\n    {\n        if (x[i] != expected[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::fill call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::fill\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/67", "date": "2025-03-31" , "prompt": "Write a function `std::size_t find_divergence(thrust::device_vector<int>\nconst &vec1, thrust::device_vector<int> const &vec2)` that  detects the first index where the input\nvectors are not equal and returns the index using one thrust algorithm.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/host_vector.h>\n#include <thrust/mismatch.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nstd::size_t find_divergence(thrust::device_vector<int> const &vec1,\n                            thrust::device_vector<int> const &vec2);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {0, 1, 2, 3, 4, 5};\n    thrust::device_vector<int> y {0, 1, 2, 5, 4};\n\n    auto res = find_divergence(x, y);\n\n    std::size_t expected = 3;\n\n    if (res != expected)\n    {\n        std::cerr << \"Error: expected \" << expected << \", got \" << res << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::mismatch call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::mismatch\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/68", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> neighbors_difference(thrust::device_vector<int> const&\nvec)` that computes the difference between every input element with its previous element using one\nthrust algorithm. For the first element just copy it as is.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/adjacent_difference.h>\n#include <thrust/device_vector.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> neighbors_difference(thrust::device_vector<int> const &vec);\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> v1 {1, 2, 3, 4, 3, 2};\n\n    auto result = neighbors_difference(v1);\n\n    thrust::device_vector<int> expected {1, 1, 1, 1, -1, -1};\n\n    for (std::size_t i = 0; i < result.size(); i++)\n    {\n        if (result[i] != expected[i])\n        {\n            std::cerr << \"Error: error at index \" << i << \" got \" << result[i] << \" expected \"\n                      << expected[i] << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::adjacent_difference call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::adjacent_difference\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/69", "date": "2025-03-31" , "prompt": "Write a function `void square_indices(thrust::device_vector<int> &vec);` that fills the input vector\nwith the squares of the indices using one thrust algorithm.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/host_vector.h>\n#include <thrust/tabulate.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid square_indices(thrust::device_vector<int> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x(5);\n\n    square_indices(x);\n\n    thrust::host_vector<int> expected {0, 1, 4, 9, 16};\n    thrust::host_vector<int> h_x(x);\n\n    for (std::size_t i = 0; i < x.size(); i++)\n    {\n        if (h_x[i] != expected[i])\n        {\n            std::cerr << \"Error at index \" << i << \": expected \" << expected[i] << \", got \"\n                      << h_x[i] << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::tabulate call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::tabulate\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/70", "date": "2025-03-31" , "prompt": "Write a function `void stable_sort_pairs(const thrust::device_vector<thrust::pair<int, char>> &vec)`\nthat sorts the input vector on GPU in increasing order according to the first element of the pair by\nmaintaining the relative order of the elements using a single thrust algorithm.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/execution_policy.h>\n#include <thrust/host_vector.h>\n#include <thrust/pair.h>\n#include <thrust/sort.h>\n#include <thrust/tuple.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid stable_sort_pairs(const thrust::device_vector<thrust::pair<int, char>>& vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<thrust::pair<int, char>> in = {{4, 'a'}, {1, 'b'}, {0, 'c'}, {1, 'd'}};\n\n    stable_sort_pairs(in);\n\n    thrust::host_vector<thrust::pair<int, char>> ref(in);\n    if (ref[0] != thrust::make_pair(0, 'c') || ref[1] != thrust::make_pair(1, 'b') ||\n        ref[2] != thrust::make_pair(1, 'd') || ref[3] != thrust::make_pair(4, 'a'))\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::stable_sort call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::stable_sort\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/71", "date": "2025-03-31" , "prompt": "Write a function `bool is_divided(thrust::device_vector<int> const& vec1)` that accepts a device\nvector and checks whether it is divided properly such that all even numbers appear before all odd\nnumbers using a single thrust algorithm.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/partition.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nbool is_divided(thrust::device_vector<int> const &vec1);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {42, 0, 4, 2, 4, 1, 3};\n    if (is_divided(x) == false)\n    {\n        std::cerr << \"Error: is_divided failed, expected true!\" << std::endl;\n        std::exit(1);\n    }\n\n    x = {42, 0, 3, 2, 4, 1};\n    if (is_divided(x) == true)\n    {\n        std::cerr << \"Error: is_divided failed, expected false!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::is_partitioned call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::is_partitioned\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/72", "date": "2025-03-31" , "prompt": "Write a function `bool check_equality(thrust::device_vector<int>&\nvec1, thrust::device_vector<int>& vec2)` that checks whether two vectors are equal on device using a\nthrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/equal.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nbool check_equality(thrust::device_vector<int> &vec1, thrust::device_vector<int> &vec2);\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> vec1 {42, 0, 4, 2, 4};\n    thrust::device_vector<int> vec2 {42, 0, 4, 2, 4};\n\n    auto same = check_equality(vec1, vec2);\n\n    if (same != true)\n    {\n        std::cerr << \"Error: expected true, got false.\" << std::endl;\n        std::exit(1);\n    }\n\n    vec2 = {42, 0, 4, 2, 42};\n    same = check_equality(vec1, vec2);\n\n    if (same != false)\n    {\n        std::cerr << \"Error: expected false, got true.\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::equal call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::equal\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/73", "date": "2025-03-31" , "prompt": "Write a function `bool is_arranged_in_order(const thrust::device_vector<int>& vec)` that checks if\ndevice input vector elements are in order using a thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/execution_policy.h>\n#include <thrust/sort.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nbool is_arranged_in_order(const thrust::device_vector<int> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    const thrust::device_vector<int> in1 {3, 1, 4, 0};\n    bool check = is_arranged_in_order(in1);\n\n    if (check != false)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n\n    const thrust::device_vector<int> in2 = {1, 2, 3, 4};\n    check                                = is_arranged_in_order(in2);\n\n    if (check != true)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::is_sorted call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::is_sorted\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/74", "date": "2025-03-31" , "prompt": "Write a function `thrust::device_vector<int> vector_difference(thrust::device_vector<int> const&\nvec1, thrust::device_vector<int> const& vec2)` that removes all the elements of the sorted vector\nvec2 from the sorted vector vec1 using one thrust algorithm. Returns the difference vector as a\nresult.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/set_operations.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nthrust::device_vector<int> vector_difference(thrust::device_vector<int> const &vec1,\n                                             thrust::device_vector<int> const &vec2);\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> v1 {1, 2, 2, 2, 3, 10};\n    thrust::device_vector<int> v2 {-10, 0, 2, 2, 5, 10};\n\n    auto result = vector_difference(v1, v2);\n\n    thrust::device_vector<int> expected {1, 2, 3};\n\n    for (int i = 0; i < result.size(); i++)\n    {\n        if (result[i] != expected[i])\n        {\n            std::cerr << \"Error: error at index \" << i << \" got \" << result[i] << \" expected \"\n                      << expected[i] << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::set_difference call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::set_difference\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/75", "date": "2025-03-31" , "prompt": "Write a function `int how_many_threes(thrust::device_vector<int> const& vec)` that counts how many\noccurances of the number three are there in the input vector using a thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/count.h>\n#include <thrust/device_vector.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nint how_many_threes(thrust::device_vector<int> const &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {1, 3, 2, 10, 3};\n\n    int threes = how_many_threes(x);\n\n    if (threes != 2)\n    {\n        std::cerr << \"Error: expected 2, got \" << threes << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::count call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::count\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/76", "date": "2025-03-31" , "prompt": "Write a function `int how_many_negatives(thrust::device_vector<int> const& vec)` that counts how\nmany negative numbers are there in the input vector using a thrust algorithm.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/count.h>\n#include <thrust/device_vector.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nint how_many_negatives(thrust::device_vector<int> const &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {1, 3, -2, -10, 0};\n\n    int neatives = how_many_negatives(x);\n\n    if (neatives != 2)\n    {\n        std::cerr << \"Error: expected 2, got \" << neatives << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::count_if call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::count_if\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/77", "date": "2025-03-31" , "prompt": "Write a function `void copy_first_n(const thrust::device_vector<int>& src,\nthrust::device_vector<int>& dst, int n)` that copies the first n elements of a src vector in GPU to\na dst vector in GPU using a thrust algorithm that efficiently transfers a specific number of\nelements. The function should utilize an appropriate thrust method for copying a fixed number of\nelements.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/copy.h>\n#include <thrust/device_vector.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid copy_first_n(const thrust::device_vector<int> &src, thrust::device_vector<int> &dst, int n);\n\n", "test": "int main() {\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {0, 1, 2, 3, 4};\n    thrust::device_vector<int> y(2);\n    copy_first_n(x, y, 2);\n\n    thrust::device_vector<int> expected {0, 1};\n\n    for (std::size_t i = 0; i < y.size(); i++)\n    {\n        if (y[i] != expected[i])\n        {\n            std::cerr << \"Test failed!\" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::copy_n call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::copy_n\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/78", "date": "2025-03-31" , "prompt": "Write a function `bool all_positives(thrust::device_vector<int> const& vec)` that checks whether\nall values in a vector are positive using a Thrust algorithm.\n", "cc_flags": "-arch=sm_90a --extended-lambda -arch=sm_89 --extended-lambda -arch=sm_80 --extended-lambda -arch=sm_70 --extended-lambda -arch=sm_60 --extended-lambda", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/logical.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nbool all_positives(thrust::device_vector<int> const &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {1, 6, 2, 10};\n\n    auto check = all_positives(x);\n\n    if (check != true)\n    {\n        std::cerr << \"Error: expected true, got \" << check << std::endl;\n        std::exit(1);\n    }\n\n    x     = {-1, 2, 2, 5};\n    check = all_positives(x);\n\n    if (check != false)\n    {\n        std::cerr << \"Error: expected false, got \" << check << std::endl;\n        std::exit(1);\n    }\n\n    x     = {1, 2, 0, 5};\n    check = all_positives(x);\n\n    if (check != false)\n    {\n        std::cerr << \"Error: expected false, got \" << check << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::all_of call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::all_of\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/79", "date": "2025-03-31" , "prompt": "Write a function `void mix_and_scramble(thrust::device_vector<int>& vec)` that\ntakes an input vector and reorders the elements in a random way using one thrust algorithm.\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <thrust/device_vector.h>\n#include <thrust/shuffle.h>\n#include <thrust/sort.h>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n\nvoid mix_and_scramble(thrust::device_vector<int> &vec);\n\n", "test": "int main() {\n\nauto dynamic_test = []() {\n    thrust::device_vector<int> x {1, 2, 3, 4, 5};\n    thrust::device_vector<int> ref {1, 2, 3, 4, 5};\n\n    mix_and_scramble(x);\n\n    if (x == ref)\n    {\n        std::cerr << \"Error: result vector is the same before and after shuffle!\" << std::endl;\n        std::exit(1);\n    }\n\n    thrust::sort(x.begin(), x.end());\n\n    if (x != ref)\n    {\n        std::cerr << \"Error: elements are not the same as the original.\" << std::endl;\n        std::exit(1);\n    }\n};\n\nauto static_test = []() {\n    const char *path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n    if (path == nullptr)\n    {\n        std::cerr << \"Environment variable not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::ifstream file(path);\n    if (!file.is_open())\n    {\n        std::cerr << \"File not found!\" << std::endl;\n        std::exit(1);\n    }\n\n    std::string line;\n\n    // Skip until the beginning of the completion block\n    while (std::getline(file, line))\n    {\n        if (line.find(\"completion-begin\") != std::string::npos &&\n            line.find(\"std::string::npos\") == std::string::npos)\n        {\n            break;\n        }\n    }\n\n    // Search for the thrust::shuffle call\n    bool found = false;\n    while (std::getline(file, line))\n    {\n        if (line.find(\"thrust::shuffle\") != std::string::npos)\n        {\n            found = true;\n            break;\n        }\n\n        if (line.find(\"completion-end\") != std::string::npos)\n        {\n            break;\n        }\n    }\n\n    if (!found)\n    {\n        std::cerr << \"Test failed!\" << std::endl;\n        std::exit(1);\n    }\n};\n\nstatic_test();\ndynamic_test();\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}