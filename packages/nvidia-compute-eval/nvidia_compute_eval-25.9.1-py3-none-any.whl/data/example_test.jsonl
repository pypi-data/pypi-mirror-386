{"task_id": "CUDA/0", "prompt": "Implement a function called `launch` that launches a kernel function named `kernel` with the provided grid and block dimensions using triple chevrons. The x,y,z grid sizes and block sizes will be provided as parameters\nto the `launch` function. Assume that the `kernel` function is already defined. \n\nThe signature of the `kernel` function is\n```cuda\n__global__ void kernel(int *output, const int *input) \n```\n\nThe function signature is \n```cuda\nvoid launch(int gridSizeX, int blockSizeX, int gridSizeY = 1, int blockSizeY = 1, int gridSizeZ = 1, int blockSizeZ = 1)\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <cuda.h>\n#include \"cuda_runtime.h\"\n#include <iostream>\n\nusing namespace std;\n\n#define cudaCheckErrors(msg)                                                                 \\\n    do                                                                                       \\\n    {                                                                                        \\\n        cudaError_t __err = cudaGetLastError();                                              \\\n        if (__err != cudaSuccess)                                                            \\\n        {                                                                                    \\\n            fprintf(stderr, \"Fatal error: %s (%s at %s:%d)\", msg, cudaGetErrorString(__err), \\\n                    __FILE__, __LINE__);                                                     \\\n            fprintf(stderr, \"*** FAILED - ABORTING\");                                        \\\n            exit(1);                                                                         \\\n        }                                                                                    \\\n    }                                                                                        \\\n    while (0)\n\n\n__global__ void kernel(int *output, const int *input)\n{\n    int id     = threadIdx.x + blockIdx.x * blockDim.x;\n    output[id] = input[id];\n}\n", "test": "int main() {\nlaunch(4, 1024);\ncudaCheckErrors(\"kernel launch failed\");\nlaunch(4, 32, 4, 32);\ncudaCheckErrors(\"kernel launch failed\");\nlaunch(4, 16, 4, 16, 4, 4);\ncudaCheckErrors(\"kernel launch failed\");\n\n}\n", "example_test": "", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/1", "prompt": "Implement a function called `launch` that launches a kernel function named `kernel` with the provided grid and block dimensions using triple chevrons and also allocates dynamic shared memory. The x,y,z grid sizes and block sizes will be provided as parameters\nto the `launch` function. Assume that the `kernel` function is already defined. \n\nThe signature of the `kernel` function is\n```cuda\n__global__ void kernel(int *output, const int *input) \n```\n\nThe function signature is \n```cuda\nvoid launch(int gridSizeX, int blockSizeX, int gridSizeY = 1, int blockSizeY = 1, int gridSizeZ = 1, int blockSizeZ = 1)\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <cuda.h>\n#include \"cuda_runtime.h\"\n#include <iostream>\n\nusing namespace std;\n\n#define cudaCheckErrors(msg)                                                                 \\\n    do                                                                                       \\\n    {                                                                                        \\\n        cudaError_t __err = cudaGetLastError();                                              \\\n        if (__err != cudaSuccess)                                                            \\\n        {                                                                                    \\\n            fprintf(stderr, \"Fatal error: %s (%s at %s:%d)\", msg, cudaGetErrorString(__err), \\\n                    __FILE__, __LINE__);                                                     \\\n            fprintf(stderr, \"*** FAILED - ABORTING\");                                        \\\n            exit(1);                                                                         \\\n        }                                                                                    \\\n    }                                                                                        \\\n    while (0)\n\n\n__global__ void kernel(int *output, const int *input)\n{\n    int id     = threadIdx.x + blockIdx.x * blockDim.x;\n    output[id] = input[id];\n}\n\n", "test": "int main() {\nlaunch(4, 256);\ncudaCheckErrors(\"kernel launch failed\");\nlaunch(4, 16, 4, 16);\ncudaCheckErrors(\"kernel launch failed\");\nlaunch(4, 16, 4, 16, 4, 1);\ncudaCheckErrors(\"kernel launch failed\");\n\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/2", "prompt": "Implement a function called `launch` that launches a kernel function named `kernel` with the provided grid and block dimensions using triple chevrons, allocates dynamic shared memory and also uses cuda streams. The x,y,z grid sizes and block sizes will be provided as parameters\nto the `launch` function. Assume that the `kernel` function is already defined. \n\nThe signature of the `kernel` function is\n```cuda\n__global__ void kernel(int *output, const int *input) \n```\n\nThe function signature is \n```cuda\nvoid launch(int gridSizeX, int blockSizeX, int gridSizeY = 1, int blockSizeY = 1, int gridSizeZ = 1, int blockSizeZ = 1)\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <cuda.h>\n#include \"cuda_runtime.h\"\n#include <iostream>\n\nusing namespace std;\n\n#define cudaCheckErrors(msg)                                                                 \\\n    do                                                                                       \\\n    {                                                                                        \\\n        cudaError_t __err = cudaGetLastError();                                              \\\n        if (__err != cudaSuccess)                                                            \\\n        {                                                                                    \\\n            fprintf(stderr, \"Fatal error: %s (%s at %s:%d)\", msg, cudaGetErrorString(__err), \\\n                    __FILE__, __LINE__);                                                     \\\n            fprintf(stderr, \"*** FAILED - ABORTING\");                                        \\\n            exit(1);                                                                         \\\n        }                                                                                    \\\n    }                                                                                        \\\n    while (0)\n\n__global__ void kernel(int *output, const int *input)\n{\n}\n\n", "test": "int main() {\nlaunch(4, 256);\ncudaCheckErrors(\"kernel launch failed\");\nlaunch(4, 16, 4, 16);\ncudaCheckErrors(\"kernel launch failed\");\nlaunch(4, 16, 4, 16, 4, 1);\ncudaCheckErrors(\"kernel launch failed\");\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/3", "prompt": "Implement a function called `launch` that launches a kernel function named `kernel` without using triple chevrons. The x,y,z grid and dimensions will be provided as parameters\nto the `launch` function. Assume that the `kernel` function is already defined. \n\nThe signature of the `kernel` function is\n```cuda\n__global__ void kernel(int *output, const int *input) \n```\n\nThe function signature is \n```cuda\nvoid launch(int gridSizeX, int blockSizeX, int gridSizeY = 1, int blockSizeY = 1, int gridSizeZ = 1, int blockSizeZ = 1)\n", "cc_flags": "-arch=sm_90a -arch=sm_89 -arch=sm_80 -arch=sm_70 -arch=sm_60", "ld_flags": "", "declaration": "#include <cuda.h>\n#include \"cuda_runtime.h\"\n#include <fstream>\n#include <iostream>\n\nusing namespace std;\n\n#define cudaCheckErrors(msg)                                                                 \\\n    do                                                                                       \\\n    {                                                                                        \\\n        cudaError_t __err = cudaGetLastError();                                              \\\n        if (__err != cudaSuccess)                                                            \\\n        {                                                                                    \\\n            fprintf(stderr, \"Fatal error: %s (%s at %s:%d)\", msg, cudaGetErrorString(__err), \\\n                    __FILE__, __LINE__);                                                     \\\n            fprintf(stderr, \"*** FAILED - ABORTING\");                                        \\\n            exit(1);                                                                         \\\n        }                                                                                    \\\n    }                                                                                        \\\n    while (0)\n\n__global__ void kernel(int *output, const int *input)\n{\n    int id     = threadIdx.x + blockIdx.x * blockDim.x;\n    output[id] = input[id];\n}\n\nstd::string trim(const std::string& str) {\n    size_t first = str.find_first_not_of(' ');\n    if (std::string::npos == first) {\n        return str;\n    }\n    size_t last = str.find_last_not_of(' ');\n    return str.substr(first, last - first + 1);\n}\n", "test": "int main() {\n    auto static_test = [] () {\n        const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n        if (path == nullptr) {\n            std::cerr << \"Environment variable not found!\" << std::endl;\n            std::exit(1);\n        }\n\n        std::ifstream file(path);\n        if (!file.is_open()) {\n            std::cerr << \"File not found!\" << std::endl;\n            std::exit(1);\n        }\n\n        std::string line;\n\n        // Skip until the beginning of the completion block\n        while (std::getline(file, line)) {\n\n            if (line.find(\"completion-begin\") != std::string::npos && \n                line.find(\"std::string::npos\") == std::string::npos) {\n                break;\n            }\n        }\n\n        // Search for the CUDA kernel launch API call\n        bool found = false;\n        while (std::getline(file, line)) {\n\n            std::string trimmedLine = trim(line);\n\n            // If the line contains the completion-end marker, stop searching\n            if (trimmedLine.find(\"completion-end\") != std::string::npos) {\n                break;\n            }\n\n            // ignore commented lines\n            if (trimmedLine.find(\"//\") == 0) continue;\n            \n            if (trimmedLine.find(\"cudaLaunchKernelEx\") != std::string::npos) {\n                found = true;\n                break;\n            }\n\n        }\n\n        if (!found) {\n            std::cerr << \"Test failed because the generated code doesn't use CUDA kernel launch API!\" << std::endl;\n            std::exit(1);\n        }\n    };\n\n    auto dynamic_test = [] () {\n        int *output, *input;\n        launch(4, 256);\n        cudaCheckErrors(\"kernel launch failed\");\n        launch(4, 16, 4, 16);\n        cudaCheckErrors(\"kernel launch failed\");\n        launch(4, 16, 4, 16, 4, 1);\n        cudaCheckErrors(\"kernel launch failed\");\n    };\n\n    static_test();\n    dynamic_test();\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}
{"task_id": "CUDA/4", "prompt": "Implement a function called `launch` that launches a kernel function named `kernel` with thread block clusters and wihout using triple chevrons. The x,y,z grid and dimensions will be provided as parameters\nto the `launch` function. Assume that the `kernel` function is already defined. \n\nThe signature of the `kernel` function is\n```cuda\n__global__ void kernel(int *output, const int *input) \n```\n\nThe function signature is \n```cuda\nvoid launch(int gridSizeX, int blockSizeX, int gridSizeY = 1, int blockSizeY = 1, int gridSizeZ = 1, int blockSizeZ = 1)\n", "cc_flags": "-arch=sm_90a", "ld_flags": "", "declaration": "#include <cuda.h>\n#include \"cuda_runtime.h\"\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\n#define cudaCheckErrors(msg)                                                                 \\\n    do                                                                                      \\\n    {                                                                                        \\\n        cudaError_t __err = cudaGetLastError();                                              \\\n        if (__err == cudaErrorInvalidKernelImage || __err == cudaErrorNoKernelImageForDevice) \\\n        {                                                                                     \\\n            fprintf(stderr, \"Invalid GPU architecture: %s (%s at %s:%d)\", msg, cudaGetErrorString(__err), \\\n                    __FILE__, __LINE__);                                                     \\\n            fprintf(stderr, \"*** FAILED - ABORTING\");                                        \\\n            exit(200);                                                                       \\\n        }                                                                                       \\\n        else if (__err != cudaSuccess)                                                            \\\n        {                                                                                    \\\n            fprintf(stderr, \"Fatal error: %s (%s at %s:%d)\", msg, cudaGetErrorString(__err), \\\n                    __FILE__, __LINE__);                                                     \\\n            fprintf(stderr, \"*** FAILED - ABORTING\");                                        \\\n            exit(1);                                                                         \\\n        }                                                                                    \\\n    }                                                                                        \\\n    while (0)\n\n__global__ void kernel(int *output, const int *input)\n{\n\n}\n\nstd::string trim(const std::string& str) {\n    size_t first = str.find_first_not_of(' ');\n    if (std::string::npos == first) {\n        return str;\n    }\n    size_t last = str.find_last_not_of(' ');\n    return str.substr(first, last - first + 1);\n}\n", "test": "int main() {\nauto static_test = [] () {\n        const char* path = std::getenv(\"COMPUTE_EVAL_SRC_FILE\");\n        if (path == nullptr) {\n            std::cerr << \"Environment variable not found!\" << std::endl;\n            std::exit(1);\n        }\n\n        std::ifstream file(path);\n        if (!file.is_open()) {\n            std::cerr << \"File not found!\" << std::endl;\n            std::exit(1);\n        }\n\n        std::string line;\n\n        // Skip until the beginning of the completion block\n        while (std::getline(file, line)) {\n\n            if (line.find(\"completion-begin\") != std::string::npos && \n                line.find(\"std::string::npos\") == std::string::npos) {\n                break;\n            }\n        }\n\n        // Search for the CUDA kernel launch API call\n        bool foundKernelLaunch = false, foundClusterDim = false;\n        while (std::getline(file, line)) {\n\n            std::string trimmedLine = trim(line);\n\n            // If the line contains the completion-end marker, stop searching\n            if (trimmedLine.find(\"completion-end\") != std::string::npos) {\n                break;\n            }\n\n            // ignore commented lines\n            if (trimmedLine.find(\"//\") == 0) continue;\n            \n            if (trimmedLine.find(\"cudaLaunchKernelEx\") != std::string::npos) foundKernelLaunch = true;\n            if (trimmedLine.find(\"cudaLaunchAttributeClusterDimension\") != std::string::npos) foundClusterDim = true;\n\n            if (foundKernelLaunch && foundClusterDim) break;\n\n        }\n\n        if (!foundKernelLaunch) {\n            std::cerr << \"Test failed because the generated code doesn't use CUDA kernel launch API!\" << std::endl;\n            std::exit(1);\n        }\n\n        if (!foundClusterDim) {\n            std::cerr << \"Test failed because the generated code doesn't use cluster dimension attribute!\" << std::endl;\n            std::exit(1);\n        }\n    };\n\n    auto dynamic_test = [] () {\n        int *output, *input;\n        launch(4, 256);\n        cudaCheckErrors(\"kernel launch failed\");\n        launch(4, 16, 4, 16);\n        cudaCheckErrors(\"kernel launch failed\");\n        launch(4, 16, 4, 16, 4, 1);\n        cudaCheckErrors(\"kernel launch failed\");\n    };\n\n    static_test();\n    dynamic_test();\n}\n", "example_test": "@example_test\n", "cuda_toolkit": "12.0"}