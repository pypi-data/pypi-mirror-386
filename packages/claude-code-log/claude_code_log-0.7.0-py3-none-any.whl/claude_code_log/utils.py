#!/usr/bin/env python3
"""Utility functions for message filtering and processing."""

from typing import Union, List

from claude_code_log.cache import SessionCacheData
from .models import ContentItem, TextContent, TranscriptEntry


def is_system_message(text_content: str) -> bool:
    """Check if a message is a system message that should be filtered out."""
    system_message_patterns = [
        "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.",
        "[Request interrupted by user for tool use]",
        "<local-command-stdout>",
    ]

    return any(text_content.startswith(pattern) for pattern in system_message_patterns)


def is_command_message(text_content: str) -> bool:
    """Check if a message contains command information that should be displayed."""
    return "<command-name>" in text_content and "<command-message>" in text_content


def is_local_command_output(text_content: str) -> bool:
    """Check if a message contains local command output."""
    return "<local-command-stdout>" in text_content


def is_bash_input(text_content: str) -> bool:
    """Check if a message contains bash input command."""
    return "<bash-input>" in text_content and "</bash-input>" in text_content


def is_bash_output(text_content: str) -> bool:
    """Check if a message contains bash command output."""
    return "<bash-stdout>" in text_content or "<bash-stderr>" in text_content


def should_skip_message(text_content: str) -> bool:
    """
    Determine if a message should be skipped in transcript rendering.

    This is the centralized logic for filtering out unwanted messages.
    """
    is_system = is_system_message(text_content)
    is_command = is_command_message(text_content)
    is_output = is_local_command_output(text_content)

    # Skip system messages that are not command messages AND not local command output
    return is_system and not is_command and not is_output


def extract_init_command_description(text_content: str) -> str:
    """
    Extract a meaningful description from init command content.

    Returns a user-friendly description for init commands instead of raw XML.
    """
    if "<command-name>init" in text_content and "<command-contents>" in text_content:
        return "Claude Initializes Codebase Documentation Guide (/init command)"
    return text_content


def should_use_as_session_starter(text_content: str) -> bool:
    """
    Determine if a user message should be used as a session starter preview.

    This filters out system messages and most command messages, except for 'init' commands
    which are typically the start of a new session.
    """
    # Skip system messages
    if is_system_message(text_content):
        return False

    # Skip command messages except for 'init' commands
    if "<command-name>" in text_content:
        return "<command-name>init" in text_content

    return True


# Constants
FIRST_USER_MESSAGE_PREVIEW_LENGTH = 1000


def create_session_preview(text_content: str) -> str:
    """Create a truncated preview of first user message for session display.

    Args:
        text_content: The raw text content from the first user message

    Returns:
        A preview string, truncated to FIRST_USER_MESSAGE_PREVIEW_LENGTH with
        ellipsis if needed, and with init commands converted to friendly descriptions.
    """
    preview_content = extract_init_command_description(text_content)
    if len(preview_content) > FIRST_USER_MESSAGE_PREVIEW_LENGTH:
        return preview_content[:FIRST_USER_MESSAGE_PREVIEW_LENGTH] + "..."
    return preview_content


def extract_text_content_length(content: Union[str, List[ContentItem]]) -> int:
    """Get the length of text content for quick checks without full extraction."""
    if isinstance(content, str):
        return len(content.strip())

    # For list content, count only text items
    total_length = 0
    for item in content:
        # Only count TextContent items, skip tool/thinking/image items
        if isinstance(item, TextContent):
            total_length += len(item.text.strip())

    return total_length


def extract_working_directories(
    entries: List[TranscriptEntry] | List[SessionCacheData],
) -> List[str]:
    """Extract unique working directories from a list of entries.

    Ordered by timestamp (most recent first).

    Args:
        entries: List of entries to extract working directories from

    Returns:
        List of unique working directory paths found in the entries
    """
    working_directories: dict[str, str] = {}

    for entry in entries:
        cwd = getattr(entry, "cwd", None)
        if not cwd:
            continue

        # Get appropriate timestamp based on entry type
        if isinstance(entry, SessionCacheData):
            timestamp = entry.last_timestamp
        elif hasattr(entry, "timestamp"):
            timestamp = getattr(entry, "timestamp", "")
        else:
            timestamp = ""

        working_directories[cwd] = timestamp

    # Sort by timestamp (most recent first) and return just the paths
    sorted_dirs = sorted(working_directories.items(), key=lambda x: x[1], reverse=True)
    return [path for path, _ in sorted_dirs]
