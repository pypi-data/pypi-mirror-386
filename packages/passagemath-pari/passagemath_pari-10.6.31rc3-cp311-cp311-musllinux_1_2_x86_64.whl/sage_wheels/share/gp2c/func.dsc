!_
2
0
2
${1 code}
1
negbool
2
bool
parens
${1 code}
1
bool
2
negbool
parens
1
gnot
G
1
gen
#_
2
0
4
lg(${1 code})
1
vecsmall
1
lg
lg(${1 code})
1
vec
1
lg
lgpol(${1 code})
1
pol
1
small
glength(${1 code})
1
gen
1
small
1
glength
G
1
small
#_~
2
0
1
gtranslength(${1 code})
1
gen
1
small
1
gtranslength
G
1
small
%
1
1
pari_get_hist
D0,L,
1
gen
%#
1
1
pari_histtime
D0,L,
1
gen
+_
1
0
5
${1 code}
1
small
2
small
parens
${1 code}
1
int
3
int
parens
copy
${1 code}
1
real
3
real
parens
copy
${1 code}
1
mp
3
mp
parens
copy
${1 code}
1
gen
3
gen
parens
copy
-_
2
0
9
-${parens 1 code}
1
small
2
small
parens
negi(${1 code})
1
int
1
int
negr(${1 code})
1
real
1
real
mpneg(${1 code})
1
mp
1
mp
gneg(${1 code})
1
gen
1
gen
Fp_neg(${1 code}, p)
1
Fp
1
Fp
FpX_neg(${1 code}, p)
1
FpX
1
FpX
Fq_neg(${1 code}, T, p)
1
Fq
1
Fq
FqX_neg(${1 code}, T, p)
1
FqX
1
FqX
1
gneg
G
1
gen
Catalan
2
0
1
mpcatalan(${prec})
0
2
real
prec
1
mpcatalan
p
2
gen
prec
Col
2
0
1
gtocol(${1 code})
1
gen
1
vec
1
gtocol0
GD0,L,
1
gen
Colrev
2
0
1
gtocolrev(${1 code})
1
gen
1
vec
1
gtocolrev0
GD0,L,
1
gen
DEBUGLEVEL
2
0
1
DEBUGLEVEL
0
1
small
1
DEBUGLEVEL

1
void
Euler
2
0
1
mpeuler(${prec})
0
2
real
prec
1
mpeuler
p
2
gen
prec
I
2
0
0
1
gen_I

1
gen
List
2
0
2
mklist()
0
1
list
listinit(gtolist(${1 code}))
1
gen
1
list
1
gtolist
DG
1
gen
Map
2
0
2
mkmap()
0
1
list
listinit(gtomap(${1 code}))
1
gen
1
list
1
gtomap
DG
1
gen
Mat
2
0
2
cgetg(1, t_MAT)
0
1
vec
gtomat(${1 code})
1
gen
1
vec
1
gtomat
DG
1
gen
Mod
2
0
3
gmodulss(${1 code}, ${2 code})
2
small
small
1
gen
gmodulsg(${1 code}, ${2 code})
2
small
gen
1
gen
gmodulo(${1 code}, ${2 code})
2
gen
gen
1
gen
1
gmodulo
GG
1
gen
O
1
1
ggrando

1
gen
O(_^_)
2
0
5
ggrando(${1 code}, 1)
1
gen
1
gen
ggrando(gen_1, ${2 code})
2
1
small
1
gen
zeropadic(${1 code}, ${2 code})
2
int
small
1
gen
ggrando(${1 code}, ${2 code})
2
gen
small
1
gen
zeroser(${1 code}, ${2 code})
2
var
small
1
gen
1
ggrando
GD1,L,
1
gen
Pi
2
0
1
mppi(${prec})
0
2
real
prec
1
mppi
p
2
gen
prec
Pol
2
0
1
gtopoly(${1 code}, ${2 code})
2
gen
?var
1
pol
1
gtopoly
GDn
1
gen
Polrev
2
0
1
gtopolyrev(${1 code}, ${2 code})
2
gen
?var
1
pol
1
gtopolyrev
GDn
1
gen
Qfb
1
1
Qfb0
GDGDG
1
gen
Ser
1
1
Ser0
GDnDGDP
1
gen
Set
2
0
2
cgetg(1,t_VEC)
0
1
vec
gtoset(${1 code})
1
gen
1
vec
1
gtoset
DG
1
gen
Str
2
0
5
${1 :genstr cast}
1
gen
3
genstr
copy
parens
Str(mkvec2(${1 code}, ${2 code}))
2
gen
gen
1
genstr
Str(mkvec3(${1 code}, ${2 code}, ${3 code}))
3
gen
gen
gen
1
genstr
Str(mkvec4(${1 code}, ${2 code}, ${3 code}, ${4 code}))
4
gen
gen
gen
gen
1
genstr
Str(mkvecn(${nbarg}, ${2 code}))
2
gen
...
1
genstr
1
Str
s*
1
gen
Strchr
1
1
pari_strchr
G
1
gen
Strexpand
1
1
strexpand
s*
1
gen
Strprintf
1
1
strprintf
ss*
1
gen
Strtex
1
1
strtex
s*
1
gen
Vec
2
0
1
gtovec(${1 code})
1
gen
1
vec
1
gtovec0
GD0,L,
1
gen
Vecrev
2
0
1
gtovecrev(${1 code})
1
gen
1
vec
1
gtovecrev0
GD0,L,
1
gen
Vecsmall
2
0
2
gtovecsmall(${1 code})
2
gen
?0
1
vecsmall
gtovecsmall0(${1 code}, ${2 code})
2
gen
small
1
vecsmall
1
gtovecsmall0
GD0,L,
1
gen
[_.._]
2
0
2
vecrange(${1 code}, ${2 code})
2
gen
gen
1
vec
vecrangess(${1 code}, ${2 code})
2
small
small
1
vec
1
vecrange
GG
1
gen
[_|_<-_,_;_]
3
0
2
veccatapply(${3 cookie}, ${3 wrapper}, ${1 code})
3
gen

closure
1
gen
veccatselapply(${4 cookie}, ${4 wrapper}, ${3 cookie}, ${3 wrapper}, ${1 code})
4
gen

closure
closure
1
gen
1
vecexpr1
GVDEDE
2
gen
copy
2
4


_wrap_G
_wrap_bG
[_|_<-_,_]
3
0
3
vecapply(${3 cookie}, ${3 wrapper}, ${1 code})
3
gen

closure
1
gen
vecselect(${4 cookie}, ${4 wrapper}, ${1 code})
4
gen


closure
1
gen
vecselapply(${4 cookie}, ${4 wrapper}, ${3 cookie}, ${3 wrapper}, ${1 code})
4
gen

closure
closure
1
gen
1
vecexpr0
GVDEDE
1
gen
2
4


_wrap_G
_wrap_bG
_!
2
0
1
mpfact(${1 code})
1
small
1
int
1
mpfact
L
1
gen
_!=_
2
0
19
${parens 1 code} != ${parens 2 code}
2
small
small
2
bool
parens
${parens 1 code} != ${parens 2 code}
2
lg
lg
2
bool
parens
equalsi(${1 code}, ${2 code})
2
small
int
1
negbool
equalis(${1 code}, ${2 code})
2
int
small
1
negbool
equali1(${1 code})
2
int
1
1
negbool
equalim1(${1 code})
2
int
-1
1
negbool
equalii(${1 code}, ${2 code})
2
int
int
1
negbool
equalrr(${1 code}, ${2 code})
2
real
real
1
negbool
mpcmp(${1 code}, ${2 code}) != 0
2
mp
mp
2
bool
parens
${parens 1 code} != ${parens 2 code}
2
errtyp
errtyp
2
bool
parens
${parens 1 code} != ${parens 2 :errtyp cast}
2
errtyp
#str
2
bool
parens
${parens 1 :errtyp cast} != ${parens 2 code}
2
#str
errtyp
2
bool
parens
${parens 1 code} != ${parens 2 code}
2
typ
typ
2
bool
parens
${parens 1 code} != ${parens 2 :typ cast}
2
typ
#str
2
bool
parens
${parens 1 :typ cast} != ${parens 2 code}
2
#str
typ
2
bool
parens
strcmp(${1 code}, ${2 code})
2
str
str
1
bool
gequalsg(${1 code}, ${2 code})
2
small
gen
1
negbool
gequalgs(${1 code}, ${2 code})
2
gen
small
1
negbool
gequal(${1 code}, ${2 code})
2
gen
gen
1
negbool
1
gne
GG
1
gen
_#
2
0
1
mpprimorial(${1 code})
1
small
1
int
1
mpprimorial
L
1
gen
_%=_
2
0
6
${1 code} = smodss(${1 code}, ${2 code})
2
*small
small
2
small
parens
${1 code} = modis(${1 code}, ${2 code})
2
*int
small
2
int
parens
${1 code} = modii(${1 code}, ${2 code})
2
*int
int
2
int
parens
${1 code} = gmod(${1 code}, ${2 code})
2
*pol
gen
2
gen
parens
${1 code} = gmodgs(${1 code}, ${2 code})
2
*gen
small
2
gen
parens
${1 code} = gmod(${1 code}, ${2 code})
2
*gen
gen
2
gen
parens
1
gmode
&G
1
gen
_%_
2
0
9
smodss(${1 code}, ${2 code})
2
small
small
1
small
modsi(${1 code}, ${2 code})
2
small
int
1
int
smodis(${1 code}, ${2 code})
2
int
small
1
small
modii(${1 code}, ${2 code})
2
int
int
1
int
gmodgs(${1 code}, ${2 code})
2
gen
small
1
gen
gmodsg(${1 code}, ${2 code})
2
small
gen
1
gen
gmod(${1 code}, ${2 code})
2
gen
gen
1
gen
FpX_rem(${1 code}, ${2 code}, p)
2
FpX
FpX
1
FpX
FqX_rem(${1 code}, ${2 code}, T, p)
2
FqX
FqX
1
FqX
1
gmod
GG
1
gen
_&&_
2
0
1
${parens 1 code} && ${parens 2 code}
2
bool
bool
2
bool
parens
1
andpari
GE
1
gen
_'
1
1
deriv
GDn
1
gen
_'_
2
0
3
deriv(${1 code}, -1)
2
gen
1
1
gen
FpX_deriv(${1 code}, p)
2
FpX
1
1
FpX
FqX_deriv(${1 code}, T, p)
2
FqX
1
1
FqX
1
derivn
GLDn
1
gen
_(_)
1
0
4
closure_callgenall(${1 code}, 0)
1
gen
1
gen
closure_callgen1(${1 code}, ${2 code})
2
gen
gen
1
gen
closure_callgen2(${1 code}, ${2 code}, ${3 code})
3
gen
gen
gen
1
gen
closure_callgenall(${1 code}, ${nbarg 1 sub}, ${3 code})
3
gen
gen
...
1
gen
_*=_
2
0
12
${1 code} *= ${parens 2 code}
2
*small
small
2
small
parens
${1 code} = mulis(${1 code}, ${2 code})
2
*int
small
2
int
parens
${1 code} = mulii(${1 code}, ${2 code})
2
*int
int
2
int
parens
${1 code} = mulrs(${1 code}, ${2 code})
2
*real
small
2
real
parens
${1 code} = mulri(${1 code}, ${2 code})
2
*real
int
2
real
parens
${1 code} = mulrr(${1 code}, ${2 code})
2
*real
real
2
real
parens
${1 code} = mpmul(${1 code}, ${2 code})
2
*mp
mp
2
mp
parens
${1 code} = gmulgs(${1 code}, ${2 code})
2
*pol
small
2
gen
parens
${1 code} = gmul(${1 code}, ${2 code})
2
*pol
gen
2
gen
parens
${1 code} = gmul(${1 code}, ${2 code})
2
*vec
gen
2
gen
parens
${1 code} = gmulgs(${1 code}, ${2 code})
2
*gen
small
2
gen
parens
${1 code} = gmul(${1 code}, ${2 code})
2
*gen
gen
2
gen
parens
1
gmule
&G
1
gen
_*_
2
0
36
${parens 1 code}*${parens 2 code}
2
small
small
2
small
parens
mulis(${1 code}, ${2 code})
2
int
small
1
int
mulsi(${1 code}, ${2 code})
2
small
int
1
int
mulii(${1 code}, ${2 code})
2
int
int
1
int
(${2 code}, 0)/*for side effect*/
2
0
mp
1
small
mulsr(${1 code}, ${2 code})
2
#small
real
1
real
gmulsg(${1 code}, ${2 code})
2
small
real
1
mp
(${1 code}, 0)/*for side effect*/
2
mp
0
1
small
mulrs(${1 code}, ${2 code})
2
real
#small
1
real
gmulgs(${1 code}, ${2 code})
2
real
small
1
mp
mulrr(${1 code}, ${2 code})
2
real
real
1
real
gmul(${1 code}, ${2 code})
2
mp
mp
1
mp
gmulgs(${1 code}, ${2 code})
2
gen
small
1
gen
gmulsg(${1 code}, ${2 code})
2
small
gen
1
gen
perm_mul(${1 code}, ${2 code})
2
vecsmall
vecsmall
1
vecsmall
gmul(${1 code}, ${2 code})
2
gen
gen
1
gen
Fp_mulu(${2 code}, ${1 code}, p)
2
usmall
Fp
1
Fp
Fp_muls(${2 code}, ${1 code}, p)
2
small
Fp
1
Fp
Fp_mulu(${1 code}, ${2 code}, p)
2
Fp
usmall
1
Fp
Fp_muls(${1 code}, ${2 code}, p)
2
Fp
small
1
Fp
FpX_mulu(${2 code}, ${1 code}, p)
2
usmall
FpX
1
FpX
FpX_mulu(${1 code}, ${2 code}, p)
2
FpX
usmall
1
FpX
FpX_Fp_mul(${2 code}, ${1 code}, p)
2
Fp
FpX
1
FpX
FpX_Fp_mul(${1 code}, ${2 code}, p)
2
FpX
Fp
1
FpX
FpX_mul(${1 code}, ${2 code}, p)
2
FpX
FpX
1
FpX
Fq_mulu(${2 code}, ${1 code}, T, p)
2
usmall
Fq
1
Fq
Fq_mulu(${1 code}, ${2 code}, T, p)
2
Fq
usmall
1
Fq
Fq_Fp_mul(${1 code}, ${2 code}, T, p)
2
Fq
Fp
1
Fq
Fq_Fp_mul(${2 code}, ${1 code}, T, p)
2
Fp
Fq
1
Fq
FqX_mulu(${2 code}, ${1 code}, T, p)
2
usmall
FqX
1
FqX
FqX_mulu(${1 code}, ${2 code}, T, p)
2
FqX
usmall
1
FqX
FqX_Fp_mul(${1 code}, ${2 code}, T, p)
2
FqX
Fp
1
FqX
FqX_Fp_mul(${2 code}, ${1 code}, T, p)
2
Fp
FqX
1
FqX
FqX_Fq_mul(${2 code}, ${1 code}, T, p)
2
Fq
FqX
1
FqX
FqX_Fq_mul(${1 code}, ${2 code}, T, p)
2
FqX
Fq
1
FqX
FqX_mul(${1 code}, ${2 code}, T, p)
2
FqX
FqX
1
FqX
1
gmul
GG
1
gen
_++
2
0
8
++${1 code}
1
*bptr
1
bptr
++${1 code}
1
*small
1
small
++${1 code}
1
*lg
1
lg
${1 code} = addis(${1 code}, 1)
1
*int
2
int
parens
${1 code} = addrs(${1 code}, 1)
1
*real
2
real
parens
${1 code} = mpadd(${1 code}, gen_1)
1
*mp
2
mp
parens
${1 code} = gaddgs(${1 code}, 1)
1
*pol
2
pol
parens
${1 code} = gaddgs(${1 code}, 1)
1
*gen
2
gen
parens
1
gadd1e
&
1
gen
_+=_
2
0
13
${1 code} += ${parens 2 code}
2
*small
small
2
small
parens
${1 code} += ${parens 2 code}
2
*lg
small
2
lg
parens
${1 code} = addis(${1 code}, ${2 code})
2
*int
small
2
int
parens
${1 code} = addii(${1 code}, ${2 code})
2
*int
int
2
int
parens
${1 code} = addrs(${1 code}, ${2 code})
2
*real
small
2
real
parens
${1 code} = addir(${2 code}, ${1 code})
2
*real
int
2
real
parens
${1 code} = addrr(${1 code}, ${2 code})
2
*real
real
2
real
parens
${1 code} = mpadd(${1 code}, ${2 code})
2
*mp
mp
2
mp
parens
${1 code} = gaddgs(${1 code}, ${2 code})
2
*pol
small
2
gen
parens
${1 code} = gadd(${1 code}, ${2 code})
2
*pol
gen
2
gen
parens
${1 code} = gadd(${1 code}, ${2 code})
2
*vec
gen
2
gen
parens
${1 code} = gaddgs(${1 code}, ${2 code})
2
*gen
small
2
gen
parens
${1 code} = gadd(${1 code}, ${2 code})
2
*gen
gen
2
gen
parens
1
gadde
&G
1
gen
_+_
2
0
24
${parens 1 code}
2
lg
1
2
small
parens
${parens 1 code} + ${parens 2 code}
2
small
small
2
small
parens
${parens 1 code} + ${parens 2 code}
2
lg
small
2
lg
parens
${parens 1 code} + ${parens 2 code}
2
small
lg
2
lg
parens
addis(${1 code}, ${2 code})
2
int
small
1
int
addsi(${1 code}, ${2 code})
2
small
int
1
int
addii(${1 code}, ${2 code})
2
int
int
1
int
addrs(${1 code}, ${2 code})
2
real
small
1
real
addsr(${1 code}, ${2 code})
2
small
real
1
real
addrr(${1 code}, ${2 code})
2
real
real
1
real
mpadd(${1 code}, ${2 code})
2
mp
real
1
real
mpadd(${1 code}, ${2 code})
2
real
mp
1
real
mpadd(${1 code}, ${2 code})
2
mp
mp
1
mp
gaddgs(${1 code}, ${2 code})
2
gen
small
1
gen
gaddsg(${1 code}, ${2 code})
2
small
gen
1
gen
gadd(${1 code}, ${2 code})
2
gen
gen
1
gen
Fp_add(${1 code}, ${2 code}, p)
2
Fp
Fp
1
Fp
FpX_Fp_add(${1 code}, ${2 code}, p)
2
FpX
Fp
1
FpX
FpX_Fp_add(${2 code}, ${1 code}, p)
2
Fp
FpX
1
FpX
FpX_add(${1 code}, ${2 code}, p)
2
FpX
FpX
1
FpX
Fq_add(${1 code}, ${2 code}, T, p)
2
Fq
Fq
1
Fq
FqX_Fq_add(${1 code}, ${2 code}, T, p)
2
FqX
Fq
1
FqX
FqX_Fq_add(${2 code}, ${1 code}, T, p)
2
Fq
FqX
1
FqX
FqX_add(${1 code}, ${2 code}, T, p)
2
FqX
FqX
1
FqX
1
gadd
GG
1
gen
_--
2
0
8
--${1 code}
1
*bptr
1
bptr
--${1 code}
1
*small
1
small
--${1 code}
1
*lg
1
lg
${1 code} = subis(${1 code}, 1)
1
*int
2
int
parens
${1 code} = subrs(${1 code}, 1)
1
*real
2
real
parens
${1 code} = mpsub(${1 code}, gen_1)
1
*mp
2
mp
parens
${1 code} = gsubgs(${1 code}, 1)
1
*pol
2
pol
parens
${1 code} = gsubgs(${1 code}, 1)
1
*gen
2
gen
parens
1
gsub1e
&
1
gen
_-=_
2
0
13
${1 code} -= ${parens 2 code}
2
*small
small
2
small
parens
${1 code} -= ${parens 2 code}
2
*lg
small
2
lg
parens
${1 code} = subis(${1 code}, ${2 code})
2
*int
small
2
int
parens
${1 code} = subii(${1 code}, ${2 code})
2
*int
int
2
int
parens
${1 code} = subrs(${1 code}, ${2 code})
2
*real
small
2
real
parens
${1 code} = subri(${1 code}, ${2 code})
2
*real
int
2
real
parens
${1 code} = subrr(${1 code}, ${2 code})
2
*real
real
2
real
parens
${1 code} = mpsub(${1 code}, ${2 code})
2
*mp
mp
2
mp
parens
${1 code} = gsubgs(${1 code}, ${2 code})
2
*pol
small
2
gen
parens
${1 code} = gsub(${1 code}, ${2 code})
2
*pol
gen
2
gen
parens
${1 code} = gsub(${1 code}, ${2 code})
2
*vec
gen
2
gen
parens
${1 code} = gsubgs(${1 code}, ${2 code})
2
*gen
small
2
gen
parens
${1 code} = gsub(${1 code}, ${2 code})
2
*gen
gen
2
gen
parens
1
gsube
&G
1
gen
_-_
2
0
21
${parens 1 code} - ${parens 2 code}
2
small
small
2
small
parens
${parens 1 code} - ${parens 2 code}
2
lg
small
2
lg
parens
subis(${1 code}, ${2 code})
2
int
small
1
int
subsi(${1 code}, ${2 code})
2
small
int
1
int
subii(${1 code}, ${2 code})
2
int
int
1
int
subrs(${1 code}, ${2 code})
2
real
small
1
real
subsr(${1 code}, ${2 code})
2
small
real
1
real
subrr(${1 code}, ${2 code})
2
real
real
1
real
mpsub(${1 code}, ${2 code})
2
mp
real
1
real
mpsub(${1 code}, ${2 code})
2
real
mp
1
real
mpsub(${1 code}, ${2 code})
2
mp
mp
1
mp
gsubgs(${1 code}, ${2 code})
2
gen
small
1
gen
gsubsg(${1 code}, ${2 code})
2
small
gen
1
gen
gsub(${1 code}, ${2 code})
2
gen
gen
1
gen
Fp_sub(${1 code}, ${2 code}, p)
2
Fp
Fp
1
Fp
Fp_FpX_sub(${1 code}, ${2 code}, p)
2
Fp
FpX
1
FpX
FpX_Fp_sub(${1 code}, ${2 code}, p)
2
FpX
Fp
1
FpX
FpX_sub(${1 code}, ${2 code}, p)
2
FpX
FpX
1
FpX
Fq_sub(${1 code}, ${2 code}, T, p)
2
Fq
Fq
1
Fq
FqX_Fq_sub(${1 code}, ${2 code}, T, p)
2
FqX
Fq
1
FqX
FqX_sub(${1 code}, ${2 code}, T, p)
2
FqX
FqX
1
FqX
1
gsub
GG
1
gen
_.a1
2
0
1
ell_get_a1(${1 code})
1
ell
2
gen
copy
1
member_a1
G
2
gen
copy
_.a2
2
0
1
ell_get_a2(${1 code})
1
ell
2
gen
copy
1
member_a2
G
2
gen
copy
_.a3
2
0
1
ell_get_a3(${1 code})
1
ell
2
gen
copy
1
member_a3
G
2
gen
copy
_.a4
2
0
1
ell_get_a4(${1 code})
1
ell
2
gen
copy
1
member_a4
G
2
gen
copy
_.a6
2
0
1
ell_get_a6(${1 code})
1
ell
2
gen
copy
1
member_a6
G
2
gen
copy
_.area
1
1
member_area
G
2
gen
copy
_.b2
2
0
1
ell_get_b2(${1 code})
1
ell
2
gen
copy
1
member_b2
G
2
gen
copy
_.b4
2
0
1
ell_get_b4(${1 code})
1
ell
2
gen
copy
1
member_b4
G
2
gen
copy
_.b6
2
0
1
ell_get_b6(${1 code})
1
ell
2
gen
copy
1
member_b6
G
2
gen
copy
_.b8
2
0
1
ell_get_b8(${1 code})
1
ell
2
gen
copy
1
member_b8
G
2
gen
copy
_.bid
2
0
2
bnr_get_bid(${1 code})
1
bnr
2
gen
copy
member_bid(${1 code})
1
gen
2
gen
copy
1
member_bid
G
2
gen
copy
_.bnf
2
0
3
${1 code}
1
bnf
2
bnf
parens
${1 :bnf cast}
1
bnr
3
bnf
copy
parens
member_bnf(${1 code})
1
gen
2
bnf
copy
1
member_bnf
G
2
gen
copy
_.c4
2
0
1
ell_get_c4(${1 code})
1
ell
2
gen
copy
1
member_c4
G
2
gen
copy
_.c6
2
0
1
ell_get_c6(${1 code})
1
ell
2
gen
copy
1
member_c6
G
2
gen
copy
_.clgp
2
0
4
${1 :clgp cast}
1
bnf
3
clgp
copy
parens
${1 :clgp cast}
1
bnr
3
clgp
copy
parens
${1 code}
1
clgp
2
clgp
parens
member_clgp(${1 code})
1
gen
2
clgp
copy
1
member_clgp
G
2
gen
copy
_.codiff
1
1
member_codiff
G
2
gen
copy
_.cyc
2
0
4
bnr_get_cyc(${1 code})
1
bnr
2
vec
copy
bnf_get_cyc(${1 code})
1
bnf
2
vec
copy
gel(${1 code}, 2)
1
clgp
2
vec
copy
member_cyc(${1 code})
1
gen
2
vec
copy
1
member_cyc
G
2
gen
copy
_.diff
2
0
2
nf_get_diff(${1 code})
1
nf
2
gen
copy
member_diff(${1 code})
1
gen
2
gen
copy
1
member_diff
G
2
gen
copy
_.disc
2
0
3
nf_get_disc(${1 code})
1
nf
2
int
copy
ell_get_disc(${1 code})
1
ell
2
gen
copy
member_disc(${1 code})
1
gen
2
gen
copy
1
member_disc
G
2
gen
copy
_.e
2
0
1
pr_get_e(${1 code})
1
prid
1
small
1
member_e
G
2
gen
copy
_.eta
1
1
member_eta
G
2
gen
copy
_.f
2
0
1
pr_get_f(${1 code})
1
prid
1
small
1
member_f
G
2
gen
copy
_.fu
2
0
3
$"ray units not implemented"
1
bnr
1
void
bnf_get_fu(${1 code})
1
bnf
2
gen
copy
member_fu(${1 code})
1
gen
1
gen
1
member_fu
G
1
gen
_.gen
2
0
6
bnr_get_gen(${1 code})
1
bnr
2
vec
copy
bnf_get_gen(${1 code})
1
bnf
2
vec
copy
gal_get_gen(${1 code})
1
gal
2
vecvecsmall
copy
gel(${1 code}, 3)
1
clgp
2
vec
copy
pr_get_gen(${1 code})
1
prid
2
gen
copy
member_gen(${1 code})
1
gen
2
gen
copy
1
member_gen
G
2
gen
copy
_.group
2
0
2
gal_get_group(${1 code})
1
gal
2
vecvecsmall
copy
member_group(${1 code})
1
gen
2
vecvecsmall
copy
1
member_group
G
2
gen
copy
_.index
2
0
2
nf_get_index(${1 code})
1
nf
2
int
copy
member_index(${1 code})
1
gen
2
int
copy
1
member_index
G
2
gen
copy
_.j
2
0
1
ell_get_j(${1 code})
1
ell
2
gen
copy
1
member_j
G
2
gen
copy
_.mod
1
1
member_mod
G
2
gen
copy
_.nf
2
0
2
${1 code}
1
nf
2
nf
parens
member_nf(${1 code})
1
gen
2
nf
copy
1
member_nf
G
2
gen
copy
_.no
2
0
4
bnr_get_no(${1 code})
1
bnr
2
int
copy
bnf_get_no(${1 code})
1
bnf
2
int
copy
gel(${1 code}, 1)
1
clgp
2
int
copy
member_no(${1 code})
1
gen
2
int
copy
1
member_no
G
2
gen
copy
_.normfu
1
1
member_normfu
G
2
gen
copy
_.omega
1
1
member_omega
G
2
gen
copy
_.orders
2
0
1
gal_get_orders(${1 code})
1
gal
2
vecsmall
copy
1
member_orders
G
2
gen
copy
_.p
2
0
3
gal_get_p(${1 code})
1
gal
2
int
copy
pr_get_p(${1 code})
1
prid
2
int
copy
member_p(${1 code})
1
gen
2
int
copy
1
member_p
G
2
gen
copy
_.pol
2
0
3
gal_get_pol(${1 code})
1
gal
2
gen
copy
nf_get_pol(${1 code})
1
nf
2
gen
copy
member_pol(${1 code})
1
gen
2
gen
copy
1
member_pol
G
2
gen
copy
_.polabs
1
1
member_polabs
G
2
gen
copy
_.r1
2
0
2
nf_get_r1(${1 code})
1
nf
1
small
member_r1(${1 code})
1
gen
2
int
copy
1
member_r1
G
2
gen
copy
_.r2
2
0
2
nf_get_r2(${1 code})
1
nf
1
small
member_r2(${1 code})
1
gen
2
int
copy
1
member_r2
G
2
gen
copy
_.reg
2
0
3
$"ray regulator not implemented"
1
bnr
1
real
bnf_get_reg(${1 code})
1
bnf
2
real
copy
member_reg(${1 code})
1
gen
2
real
copy
1
member_reg
G
2
gen
copy
_.roots
2
0
3
gal_get_roots(${1 code})
1
gal
2
vec
copy
nf_get_roots(${1 code})
1
nf
2
vec
copy
member_roots(${1 code})
1
gen
2
vec
copy
1
member_roots
G
2
gen
copy
_.sign
2
0
2
gel(${1 code}, 2)
1
nf
2
vec
copy
member_sign(${1 code})
1
gen
2
vec
copy
1
member_sign
G
2
gen
copy
_.t2
2
0
1
member_t2(${1 code})
1
gen
1
vec
1
member_t2
G
1
gen
_.tate
1
1
member_tate
G
2
gen
copy
_.tu
2
0
1
member_tu(${1 code})
1
gen
2
gen
copy
1
member_tu
G
1
gen
_.zk
2
0
2
nf_get_zk(${1 code})
1
nf
2
vec
copy
member_zk(${1 code})
1
gen
2
vec
copy
1
member_zk
G
2
gen
copy
_.zkst
2
0
1
bnr_get_bid(${1 code})
1
bnr
2
gen
copy
1
member_zkst
G
2
gen
copy
_/=_
2
0
10
$"cannot divide small: use \= instead."
2
*small
gen
1
void
$"cannot divide int: use \= instead."
2
*int
gen
1
void
${1 code} = divrr(${1 code}, ${2 code})
2
*real
real
2
real
parens
${1 code} = divrs(${1 code}, ${2 code})
2
*real
small
2
real
parens
${1 code} = mpdiv(${1 code}, ${2 code})
2
*real
mp
2
real
parens
${1 code} = mpdiv(${1 code}, ${2 code})
2
*mp
real
2
mp
parens
${1 code} = gdiv(${1 code}, ${2 code})
2
*pol
gen
2
gen
parens
${1 code} = gdiv(${1 code}, ${2 code})
2
*vec
gen
2
gen
parens
${1 code} = gdivgs(${1 code}, ${2 code})
2
*gen
small
2
gen
parens
${1 code} = gdiv(${1 code}, ${2 code})
2
*gen
gen
2
gen
parens
1
gdive
&G
1
gen
_/_
2
0
16
(${2 code}, 0)/*for side effect*/
2
0
mp
1
small
invr(${2 code})
2
1
real
1
real
divsr(${1 code}, ${2 code})
2
#small
real
1
real
divsr(${1 code}, ${2 code})
2
small
real
1
mp
divrs(${1 code}, ${2 code})
2
real
small
1
real
divrr(${1 code}, ${2 code})
2
real
real
1
real
mpdiv(${1 code}, ${2 code})
2
real
mp
1
real
mpdiv(${1 code}, ${2 code})
2
mp
real
1
mp
ginv(${2 code})
2
1
gen
1
gen
gdivgs(${1 code}, ${2 code})
2
gen
small
1
gen
gdivsg(${1 code}, ${2 code})
2
small
gen
1
gen
gdiv(${1 code}, ${2 code})
2
gen
gen
1
gen
Fp_halve(${1 code}, p)
2
Fp
2
1
Fp
Fp_div(${1 code}, ${2 code}, p)
2
Fp
Fp
1
Fp
Fq_halve(${1 code}, T, p)
2
Fq
2
1
Fq
Fq_div(${1 code}, ${2 code}, T, p)
2
Fq
Fq
1
Fq
1
gdiv
GG
1
gen
_<<=_
2
0
4
${1 code} <<= ${parens 2 code}
2
*small
small
2
small
parens
${1 code} = shifti(${1 code}, ${2 code})
2
*int
small
2
int
parens
${1 code} = mpshift(${1 code}, ${2 code})
2
*mp
small
2
mp
parens
${1 code} = gshift(${1 code}, ${2 code})
2
*gen
small
2
mp
parens
1
gshiftle
&L
1
gen
_<<_
2
0
3
shifti(${1 code}, ${2 code})
2
int
small
1
int
mpshift(${1 code}, ${2 code})
2
mp
small
1
mp
gshift(${1 code}, ${2 code})
2
gen
small
1
mp
1
gshift
GL
1
gen
_<=_
2
0
12
${parens 1 code} <= ${parens 2 code}
2
small
small
2
bool
parens
${parens 1 code} < ${parens 2 code}
2
small
lg
2
bool
parens
${parens 1 code} <= ${parens 2 code}
2
lg
lg
2
bool
parens
cmpsi(${1 code}, ${2 code}) <= 0
2
small
int
2
bool
parens
cmpis(${1 code}, ${2 code}) < 0
2
int
lg
2
bool
parens
cmpis(${1 code}, ${2 code}) <= 0
2
int
small
2
bool
parens
cmpii(${1 code}, ${2 code}) <= 0
2
int
int
2
bool
parens
mpcmp(${1 code}, ${2 code}) <= 0
2
mp
mp
2
bool
parens
strcmp(${1 code}, ${2 code}) <= 0
2
str
str
2
bool
parens
gcmpsg(${1 code}, ${2 code}) <= 0
2
small
gen
2
bool
parens
gcmpgs(${1 code}, ${2 code}) <= 0
2
gen
small
2
bool
parens
gcmp(${1 code}, ${2 code}) <= 0
2
gen
gen
2
bool
parens
1
gle
GG
1
gen
_<_
2
0
11
${parens 1 code} < ${parens 2 code}
2
small
small
2
bool
parens
${parens 1 code} < ${parens 2 code}
2
lg
lg
2
bool
parens
${parens 1 code} <= ${parens 2 code}
2
lg
small
2
bool
parens
cmpsi(${1 code}, ${2 code}) < 0
2
small
int
2
bool
parens
cmpis(${1 code}, ${2 code}) < 0
2
int
small
2
bool
parens
cmpii(${1 code}, ${2 code}) < 0
2
int
int
2
bool
parens
mpcmp(${1 code}, ${2 code}) < 0
2
mp
mp
2
bool
parens
strcmp(${1 code}, ${2 code}) < 0
2
str
str
2
bool
parens
gcmpsg(${1 code}, ${2 code}) < 0
2
small
gen
2
bool
parens
gcmpgs(${1 code}, ${2 code}) < 0
2
gen
small
2
bool
parens
gcmp(${1 code}, ${2 code}) < 0
2
gen
gen
2
bool
parens
1
glt
GG
1
gen
_===_
1
1
gidentical
GG
1
small_int
_==_
2
0
23
${parens 1 code} == ${parens 2 code}
2
small
small
2
bool
parens
${parens 1 code} == ${parens 2 code}
2
lg
lg
2
bool
parens
equalsi(${1 code}, ${2 code})
2
small
int
1
bool
!signe(${1 code})
2
mp
0
1
bool
equali1(${1 code})
2
int
1
1
bool
equalim1(${1 code})
2
int
-1
1
bool
equalis(${1 code}, ${2 code})
2
int
small
1
bool
equalii(${1 code}, ${2 code})
2
int
int
1
bool
gequal0(${1 code})
2
gen
0
1
bool
gequal1(${1 code})
2
gen
1
1
bool
gequalm1(${1 code})
2
gen
-1
1
bool
equalrr(${1 code}, ${2 code})
2
real
real
1
bool
mpcmp(${1 code}, ${2 code}) == 0
2
mp
mp
2
bool
parens
${parens 1 code} == ${parens 2 code}
2
errtyp
errtyp
2
bool
parens
${parens 1 code} == ${parens 2 :errtyp cast}
2
errtyp
#str
2
bool
parens
${parens 1 :errtyp cast} == ${parens 2 code}
2
#str
errtyp
2
bool
parens
${parens 1 code} == ${parens 2 code}
2
typ
typ
2
bool
parens
${parens 1 code} == ${parens 2 :typ cast}
2
typ
#str
2
bool
parens
${parens 1 :typ cast} == ${parens 2 code}
2
#str
typ
2
bool
parens
strcmp(${1 code}, ${2 code})
2
str
str
1
negbool
gequalsg(${1 code}, ${2 code})
2
small
gen
1
bool
gequalgs(${1 code}, ${2 code})
2
gen
small
1
bool
gequal(${1 code}, ${2 code})
2
gen
gen
1
bool
1
geq
GG
1
gen
_>=_
2
0
11
${parens 1 code} >= ${parens 2 code}
2
small
small
2
bool
parens
${parens 1 code} >= ${parens 2 code}
2
lg
lg
2
bool
parens
${parens 1 code} > ${parens 2 code}
2
lg
small
2
bool
parens
cmpsi(${1 code}, ${2 code}) >= 0
2
small
int
2
bool
parens
cmpis(${1 code}, ${2 code}) >= 0
2
int
small
2
bool
parens
cmpii(${1 code}, ${2 code}) >= 0
2
int
int
2
bool
parens
mpcmp(${1 code}, ${2 code}) >= 0
2
mp
mp
2
bool
parens
strcmp(${1 code}, ${2 code}) >= 0
2
str
str
2
bool
parens
gcmpsg(${1 code}, ${2 code}) >= 0
2
small
gen
2
bool
parens
gcmpgs(${1 code}, ${2 code}) >= 0
2
gen
small
2
bool
parens
gcmp(${1 code}, ${2 code}) >= 0
2
gen
gen
2
bool
parens
1
gge
GG
1
gen
_>>=_
2
0
4
${1 code} >>= ${parens 2 code}
2
*small
small
2
small
parens
${1 code} = shifti(${1 code}, -${parens 2 code})
2
*int
small
2
int
parens
${1 code} = mpshift(${1 code}, -${parens 2 code})
2
*mp
small
2
mp
parens
${1 code} = gshift(${1 code}, -${parens 2 code})
2
*gen
small
2
mp
parens
1
gshiftre
&L
1
gen
_>>_
2
0
4
${parens 1 code}>>${parens 2 code}
2
small
small
2
small
parens
shifti(${1 code}, -${parens 2 code})
2
int
small
1
int
mpshift(${1 code}, -${parens 2 code})
2
mp
small
1
mp
gshift(${1 code}, -${parens 2 code})
2
gen
small
1
mp
1
gshift_right
GL
1
gen
_>_
2
0
11
${parens 1 code} > ${parens 2 code}
2
small
small
2
bool
parens
${parens 1 code} > ${parens 2 code}
2
lg
lg
2
bool
parens
${parens 1 code} >= ${parens 2 code}
2
small
lg
2
bool
parens
cmpsi(${1 code}, ${2 code}) > 0
2
small
int
2
bool
parens
cmpis(${1 code}, ${2 code}) > 0
2
int
small
2
bool
parens
cmpii(${1 code}, ${2 code}) > 0
2
int
int
2
bool
parens
mpcmp(${1 code}, ${2 code}) > 0
2
mp
mp
2
bool
parens
strcmp(${1 code}, ${2 code}) > 0
2
str
str
2
bool
parens
gcmpsg(${1 code}, ${2 code}) > 0
2
small
gen
2
bool
parens
gcmpgs(${1 code}, ${2 code}) > 0
2
gen
small
2
bool
parens
gcmp(${1 code}, ${2 code}) > 0
2
gen
gen
2
bool
parens
1
ggt
GG
1
gen
_F2xq_log_Coppersmith_worker
1
1
F2xq_log_Coppersmith_worker
GLGG
1
gen
_Flxq_log_Coppersmith_worker
1
1
Flxq_log_Coppersmith_worker
GLGG
1
gen
_FpM_ratlift_worker
1
1
FpM_ratlift_worker
GGG
1
gen
_Fp_log_sieve_worker
1
1
Fp_log_sieve_worker
LLGGGGGG
1
gen
_QM_charpoly_ZX_worker
1
1
QM_charpoly_ZX_worker
GGG
1
gen
_QXQ_div_worker
1
1
QXQ_div_worker
GGGG
1
gen
_QXQ_inv_worker
1
1
QXQ_inv_worker
GGG
1
gen
_RgM_ZM_mul_worker
1
1
RgM_ZM_mul_worker
GG
1
gen
_ZM_det_worker
1
1
ZM_det_worker
GG
1
gen
_ZM_gauss_worker
1
1
ZM_gauss_worker
GGG
1
gen
_ZM_inv_worker
1
1
ZM_inv_worker
GG
1
gen
_ZM_ker_worker
1
1
ZM_ker_worker
GG
1
gen
_ZM_mul_worker
1
1
ZM_mul_worker
GGG
1
gen
_ZM_sqr_worker
1
1
ZM_sqr_worker
GG
1
gen
_ZXQX_composedsum_worker
1
1
ZXQX_composedsum_worker
GGGG
1
gen
_ZXQX_resultant_worker
1
1
ZXQX_resultant_worker
GGGGG
1
gen
_ZXQ_minpoly_worker
1
1
ZXQ_minpoly_worker
GGGL
1
gen
_ZX_ZXY_resultant_worker
1
1
ZX_ZXY_resultant_worker
GGGGG
1
gen
_ZX_composedsum_worker
1
1
ZX_composedsum_worker
GGG
1
gen
_ZX_gcd_worker
1
1
ZX_gcd_worker
GGGG
1
gen
_ZX_resultant_worker
1
1
ZX_resultant_worker
GGGG
1
gen
_ZabM_inv_worker
1
1
ZabM_inv_worker
GGG
1
gen
_[_,]
1
0
3
$"Scalar has no rows"
2
mp
small
1
gen
rowcopy(${1 code}, ${2 code})
2
vec
small
1
vec
rowcopy(${1 code}, ${2 code})
2
gen
small
1
vec
_[_,_]
1
0
10
$"Scalar has no components"
2
mp
small
1
gen
$"Scalar has no components"
3
mp
small
small
1
gen
${parens 1 code}[${2 code}]
2
vecsmall
small
1
small
$"Vecsmall are single-dimensional"
3
vecsmall
small
small
1
gen
gel(list_data(${1 code}), ${2 code})
2
list
small
2
gen
copy
gel(${1 code}, ${2 code})
2
vecvecsmall
small
1
vecsmall
gel(${1 code}, ${2 code})
2
vec
small
2
gen
copy
gcoeff(${1 code}, ${2 code}, ${3 code})
3
vec
small
small
2
gen
copy
gel(${1 code}, ${2 code})
2
gen
small
2
gen
copy
gcoeff(${1 code}, ${2 code}, ${3 code})
3
gen
small
small
2
gen
copy
_[_.._,_.._]
1
1
matslice0
GD0,L,D0,L,D0,L,D0,L,
1
gen
_[_.._]
1
1
vecslice0
GD0,L,L
1
gen
_\/=_
2
0
3
${1 code} = gdivround(${1 code}, ${2 code})
2
*int
int
2
int
parens
${1 code} = gdivround(${1 code}, ${2 code})
2
*pol
gen
2
gen
parens
${1 code} = gdivround(${1 code}, ${2 code})
2
*gen
gen
2
gen
parens
1
gdivrounde
&G
1
gen
_\/_
2
0
2
gdivround(${1 code}, ${2 code})
2
int
int
1
int
gdivround(${1 code}, ${2 code})
2
gen
gen
1
gen
1
gdivround
GG
1
gen
_\=_
2
0
4
${1 code} /= ${parens 2 code}
2
*small
small
2
small
parens
${1 code} = gdivent(${1 code}, ${2 code})
2
*int
int
2
int
parens
${1 code} = gdivent(${1 code}, ${2 code})
2
*pol
gen
2
gen
parens
${1 code} = gdivent(${1 code}, ${2 code})
2
*gen
gen
2
gen
parens
1
gdivente
&G
1
gen
_\_
2
0
7
${parens 1 code}/${parens 2 code}
2
small
small
2
small
parens
truedivis(${1 code}, ${2 code})
2
int
small
1
int
gdiventsg(${1 code}, ${2 code})
2
small
int
1
int
truedivii(${1 code}, ${2 code})
2
int
int
1
int
gdiventgs(${1 code}, ${2 code})
2
gen
small
1
gen
gdiventsg(${1 code}, ${2 code})
2
small
gen
1
gen
gdivent(${1 code}, ${2 code})
2
gen
gen
1
gen
1
gdivent
GG
1
gen
_^_
2
0
32
sqru(${1 code})
2
usmall
2
1
int
sqrs(${1 code})
2
small
2
1
int
sqri(${1 code})
2
int
2
1
int
powiu(${1 code}, 3)
2
int
3
1
int
powiu(${1 code}, 4)
2
int
4
1
int
powiu(${1 code}, 5)
2
int
5
1
int
invr(${1 code})
2
real
-1
1
real
ginv(${1 code})
2
mp
-1
1
mp
ginv(${1 code})
2
gen
-1
1
gen
sqrr(${1 code})
2
real
2
1
real
mpsqr(${1 code})
2
mp
2
1
mp
gsqr(${1 code})
2
gen
2
1
gen
powis(${1 code}, ${2 code})
2
int
small
1
gen
gpowgs(${1 code}, ${2 code})
2
real
small
1
real
gpowgs(${1 code}, ${2 code})
2
gen
small
1
gen
powgi(${1 code}, ${2 code})
2
real
int
1
real
powgi(${1 code}, ${2 code})
2
gen
int
1
gen
gpow(${1 code}, ${2 code}, ${prec})
2
gen
gen
2
gen
prec
Fp_sqr(${1 code}, p)
2
Fp
2
1
Fp
Fp_powu(${1 code}, ${2 code}, p)
2
Fp
usmall
1
Fp
Fp_pows(${1 code}, ${2 code}, p)
2
Fp
small
1
Fp
Fp_pow(${1 code}, ${2 code}, p)
2
Fp
int
1
Fp
FpX_sqr(${1 code}, p)
2
FpX
2
1
FpX
FpX_powu(${1 code}, ${2 code}, p)
2
FpX
usmall
1
FpX
Fq_sqr(${1 code}, T, p)
2
Fq
2
1
Fq
Fq_powu(${1 code}, ${2 code}, T, p)
2
Fq
usmall
1
Fq
Fq_pow(${1 code}, ${2 code}, T, p)
2
Fq
int
1
Fq
Fq_sqr(${1 code}, T, p)
2
Fq
2
1
Fq
Fq_powu(${1 code}, ${2 code}, T, p)
2
Fq
usmall
1
Fq
Fq_pow(${1 code}, ${2 code}, T, p)
2
Fq
int
1
Fq
FqX_sqr(${1 code}, T, p)
2
FqX
2
1
FqX
FqX_powu(${1 code}, ${2 code}, T, p)
2
FqX
usmall
1
FqX
1
gpow
GGp
2
gen
prec
_^s
1
1
gpowgs
GL
1
gen
__
1
0
4
gconcat(${1 code}, ${2 code})
2
genstr
genstr
1
genstr
gconcat(${1 code}, ${2 code})
2
genstr
gen
1
genstr
gconcat(${1 code}, ${2 code})
2
gen
genstr
1
genstr
gconcat(${1 :genstr cast}, ${2 code})
2
gen
gen
1
genstr
_aprcl_step4_worker
1
1
aprcl_step4_worker
UGGG
1
gen
_aprcl_step6_worker
1
1
aprcl_step6_worker
GLGGG
1
gen
_avma
1
0
1
avma
0
1
pari_sp
_badtype
1
0
14
typ(${1 code}) != t_INT
1
int
2
bool
parens
typ(${1 code}) != t_REAL
1
real
2
bool
parens
is_intreal_t(typ(${1 code}))
1
mp
1
negbool
is_matvec_t(typ(${1 code}))
1
vec
1
negbool
typ(${1 code}) != t_VECSMALL
1
vecsmall
2
bool
parens
typ(${1 code}) != t_POL
1
pol
2
bool
parens
typ(${1 code}) != t_LIST
1
list
2
bool
parens
${1 code} = checknf(${1 code})
1
*nf
2
void
parens
${1 code} = checkbnf(${1 code})
1
*bnf
2
void
parens
checkbnr(${1 code})
1
bnr
1
void
checkprid(${1 code})
1
prid
1
void
checkabgrp(${1 code})
1
clgp
1
void
checkell(${1 code})
1
ell
1
void
${1 code} = checkgal(${1 code})
1
*gal
2
void
parens
_cast
1
0
116
0
1
void
1
bool
${1 value not}
1
#negbool
1
bool
!${parens 1 code}
1
negbool
1
bool

1
small_int
1
bool

1
usmall
1
bool

1
small
1
bool
${parens 1 code}!=1
1
lg
2
bool
parens
*${parens 1 code}
1
bptr
1
bool
!gequal0(${1 code})
1
gen
1
bool
signe(${1 code})
1
real
1
bool
signe(${1 code})
1
int
1
bool
signe(${1 code})
1
mp
1
bool
signe(${1 code})
1
pol
1
bool
1
1
void
1
negbool
${1 value not}
1
#bool
1
negbool
!${parens 1 code}
1
bool
1
negbool
${parens 1 code}==1
1
lg
2
negbool
parens
!*${parens 1 code}
1
bptr
1
negbool
gequal0(${1 code})
1
gen
1
negbool
!signe(${1 code})
1
int
1
negbool
!signe(${1 code})
1
real
1
negbool
!signe(${1 code})
1
mp
1
negbool
!signe(${1 code})
1
pol
1
negbool

1
bool
1
small_int

1
typ
1
small_int

1
small
1
small_int

1
bool
1
usmall

1
typ
1
usmall

1
small
1
usmall

1
bool
1
small

1
typ
1
small

1
small_int
1
small

1
usmall
1
small
*${parens 1 code}
1
bptr
1
small
itos(${1 code})
1
int
1
small
itou(${1 code})
1
int
1
usmall
${1 value 1 sub}
1
#lg
2
small
parens
${parens 1 code}-1
1
lg
2
small
parens
gtos(${1 code})
1
gen
1
small
gtou(${1 code})
1
gen
1
usmall
gen_0
1
void
1
int
gen_m2
1
-2
1
int
gen_m1
1
-1
1
int
gen_0
1
0
1
int
gen_1
1
1
1
int
gen_2
1
2
1
int
stoi(${1 code})
1
bool
1
int
stoi(${1 code})
1
small
1
int
utoi(${1 code})
1
usmall
1
int

1
mp
1
int

1
gen
1
int

1
mp
1
real

1
gen
1
real

1
int
1
mp

1
real
1
mp

1
gen
1
mp
${1 1 value add}
1
#bool
2
lg
parens
${parens 1 code}+1
1
bool
2
lg
parens
${1 1 value add}
1
#small
2
lg
parens
${parens 1 code}+1
1
small
2
lg
parens

1
gen
1
error

1
gen
1
closure

1
gen
1
vecsmall

1
nf
1
vec

1
bnf
1
vec

1
bnr
1
vec

1
ell
1
vec

1
clgp
1
vec

1
prid
1
vec

1
gal
1
vec

1
vecvecsmall
1
vec

1
gen
1
vec

1
vec
1
vecvecsmall

1
gen
1
list
varn(${1 code})
1
pol
1
var
gvar(${1 code})
1
gen
1
var
pol_x(${1 code})
1
var
1
pol

1
gen
1
pol

1
int
1
gen

1
mp
1
gen

1
vecsmall
1
gen

1
vec
1
gen

1
vecvecsmall
1
gen

1
list
1
gen

1
pol
1
gen

1
genstr
1
gen

1
error
1
gen

1
closure
1
gen

1
Fp
1
gen

1
FpX
1
gen

1
Fq
1
gen

1
FqX
1
gen

1
gen
1
Fp

1
gen
1
FpX

1
gen
1
Fq

1
gen
1
FqX
GENtoGENstr(${1 code})
1
gen
1
genstr
strtoGENstr(${1 code})
1
str
1
genstr
GENtostr_unquoted(${1 code})
1
gen
1
str
GSTR(${1 code})
1
genstr
1
str
type_name(${1 code})
1
typ
1
str
numerr_name(${1 code})
1
errtyp
1
str
${1 str_format}
1
#str
1
typ
${1 str_format}
1
#str
1
errtyp
bnf_get_nf(${1 code})
1
bnf
1
nf

1
gen
1
nf
bnr_get_bnf(${1 code})
1
bnr
1
bnf

1
gen
1
bnf

1
gen
1
bnr
bnf_get_clgp(${1 code})
1
bnf
1
clgp
bnr_get_clgp(${1 code})
1
bnr
1
clgp

1
gen
1
clgp

1
gen
1
ell

1
gen
1
gal

1
gen
1
prid

1
Fp
1
Fq
_cgetg
1
0
2
cgetg(${1 code}, ${2 str_raw})
2
lg
#str
1
gen
${1 code} = cgetg(${2 code}, ${3 str_raw})
3
gen
lg
#str
1
gen
_chinese_unit_worker
1
1
chinese_unit_worker
GGGGGG
1
gen
_const_expr
1
0
1
readseq(${1 code})
1
str
1
gen
_const_quote
1
0
3
0
1
"x"
1
var
1
1
"y"
1
var
fetch_user_var(${1 code})
1
str
1
var
_const_real
1
0
1
strtor(${1 code}, ${prec})
1
str
2
real
prec
_const_smallreal
1
0
4
real_0(${prec})
1
0
2
real
prec
real_1(${prec})
1
1
2
real
prec
real_m1(${prec})
1
-1
2
real
prec
stor(${1 code}, ${prec})
1
small
2
real
prec
_decl_base
1
0
20
void
1
C!void
0
long
1
C!long
0
ulong
1
C!ulong
0
int
1
C!int
0
GEN
1
C!GEN
0
char
1
C!char*
0
byteptr
1
C!byteptr
0
pari_sp
1
C!pari_sp
0
GEN
1
C!func_GG
0
forprime_t
1
C!forprime_t
0
forcomposite_t
1
C!forcomposite_t
0
forpart_t
1
C!forpart_t
0
forperm_t
1
C!forperm_t
0
forvec_t
1
C!forvec_t
0
forsubset_t
1
C!forsubset_t
0
parfor_t
1
C!parfor_t
0
parforstep_t
1
C!parforstep_t
0
parforeach_t
1
C!parforeach_t
0
parforprime_t
1
C!parforprime_t
0
parforvec_t
1
C!parforvec_t
0
_decl_ext
1
0
2
*${1 code}
1
C!char*
0
(*${1 code})(GEN, GEN)
1
C!func_GG
0
_default_check
1
0
2
!${parens 1 code}
1
C!GEN
1
bool
${parens 1 code} == -1
1
var
1
bool
_default_marker
1
0
4
NULL
1
C!GEN
0
-1
1
var
0
0
1
small
0
""
1
str
0
_derivfun
1
1
derivfun0
GGGD1,L,p
2
gen
prec
_diffptr
1
0
1
diffptr
0
1
bptr
_dirartin_worker
1
1
dirartin_worker
GUGGGG
1
gen
_direllnf_worker
1
1
direllnf_worker
GUG
1
gen
_direllsympow_worker
1
1
direllsympow_worker
GUGU
1
gen
_dirgenus2_worker
1
1
dirgenus2_worker
GLG
1
gen
_dirhgm_worker
1
1
dirhgm_worker
GUGG
1
gen
_ecpp_ispsp_worker
1
1
ecpp_ispsp_worker
G
1
gen
_ecpp_sqrt_worker
1
1
ecpp_sqrt_worker
GGG
1
gen
_ecpp_step2_worker
1
1
ecpp_step2_worker
GGGL
1
gen
_eisker_worker
1
1
eisker_worker
GGGGG
1
gen
_ellQ_factorback_worker
1
1
ellQ_factorback_worker
GGGGU
1
gen
_err_primes
1
0
1
pari_err(e_MAXPRIME)
0
1
void
_err_type
1
0
1
pari_err_TYPE(${1 code},${2 code})
2
str
gen
1
void
_eval_mnemonic
1
1
eval_mnemonic
Gs
1
small
_factor_Aurifeuille
1
1
factor_Aurifeuille
GL
1
gen
_factor_Aurifeuille_prime
1
1
factor_Aurifeuille_prime
GL
1
gen
_forcomposite_init
1
0
2
forcomposite_init(&${1 code}, ${2 code}, NULL)
2
forcomposite
int
1
void
forcomposite_init(&${1 code}, ${2 code}, ${3 code})
3
forcomposite
int
?int
1
void
_forcomposite_next
1
0
1
forcomposite_next(&${1 code})
1
forcomposite
1
int
_formatcode
1
0
6
${1 code}
1
#small
1
void
%ld
1
small
1
small
%d
1
small_int
1
small_int
${1 str_format}
1
#str
1
void
%s
1
str
1
str
%Ps
1
gen
1
gen
_forpart_init
1
0
1
forpart_init(&${1 code}, ${2 code}, ${3 code}, ${4 code})
4
forpart
small
?gen
?gen
1
void
_forpart_next
1
0
1
forpart_next(&${1 code})
1
forpart
1
vecsmall
_forperm_init
1
0
1
forperm_init(&${1 code}, ${2 code})
2
forperm
gen
1
void
_forperm_next
1
0
1
forperm_next(&${1 code})
1
forperm
1
vecsmall
_forprime_init
1
0
1
forprime_init(&${1 code}, ${2 code}, ${3 code});
3
forprime
int
?int
1
void
_forprime_next
1
0
1
NEXT_PRIME_VIADIFF(${1 code}, ${2 code})
2
*small
*bptr
1
void
_forprime_next_
1
0
1
forprime_next(&${1 code})
1
forprime
1
int
_forprimestep_init
1
0
1
forprimestep_init(&${1 code},${2 code},${3 code},${4 code});
4
forprime
int
?int
int
1
void
_forsubset_init
1
0
2
forallsubset_init(&${1 code}, ${2 code})
2
forsubset
small
1
void
forsubset_init(&${1 code}, ${2 code})
2
forsubset
gen
1
void
_forsubset_next
1
0
1
forsubset_next(&${1 code})
1
forsubset
1
vecsmall
_forvec_init
1
0
1
forvec_init(&${1 code}, ${2 code}, ${3 code})
3
forvec
gen
?small
1
void
_forvec_next
1
0
1
forvec_next(&${1 code})
1
forvec
1
vec
_gc_needed
1
0
1
gc_needed(${1 code}, 1)
1
pari_sp
1
bool
_gerepileall
1
0
2
${2 code} = gerepilecopy(${1 code}, ${2 code})
2
pari_sp
gen
2
void
parens
gerepileall(${1 code}, ${nbarg 1 sub}, ${stdref 3 code})
3
pari_sp
gen
...
1
void
_gerepileupto
1
0
5
gerepileuptoint(${1 code}, ${2 code})
2
pari_sp
int
1
int
gerepileuptoleaf(${1 code}, ${2 code})
2
pari_sp
mp
1
mp
gerepileuptoleaf(${1 code}, ${2 code})
2
pari_sp
vecsmall
1
vecsmall
gerepileupto(${1 code}, ${2 code})
2
pari_sp
vec
1
vec
gerepileupto(${1 code}, ${2 code})
2
pari_sp
gen
1
gen
_iferr_CATCH
1
0
2
pari_CATCH(CATCH_ALL)
1
0
0
pari_CATCH2(__iferr_old${1 code}, CATCH_ALL)
1
small
0
_iferr_CATCH_reset
1
0
2
pari_CATCH_reset()
1
0
1
void
pari_CATCH2_reset(__iferr_old${1 code})
1
small
1
void
_iferr_ENDCATCH
1
0
2
pari_ENDCATCH
1
0
0
pari_ENDCATCH2(__iferr_old${1 code})
1
small
0
_iferr_error
1
0
1
pari_err_last()
0
1
error
_iferr_rethrow
1
0
1
pari_err(0, ${1 code})
1
error
1
void
_inv
1
1
ginv
G
1
gen
_lerch_worker
1
1
lerch_worker
GG
1
gen
_lfuninit_theta2_worker
1
1
lfuninit_theta2_worker
LGGGGGG
1
gen
_lfuninit_worker
1
1
lfuninit_worker
LGGGGGGGG
1
gen
_low_stack_lim
1
0
1
low_stack(${1 code}, stack_lim(${2 code}, 1))
2
pari_sp
pari_sp
1
bool
_maxprime
1
0
1
maxprime()
0
1
small
_multi_if
1
1
ifpari_multi
GE*
1
gen
_ndec2nbits
1
0
1
ndec2nbits(${1 code})
1
small
1
small
_ndec2prec
1
0
1
ndec2prec(${1 code})
1
small
1
small
_nflist_A462_worker
1
1
nflist_A462_worker
GGGGG
1
gen
_nflist_A46S46P_worker
1
1
nflist_A46S46P_worker
GGGG
1
gen
_nflist_A4S4_worker
1
1
nflist_A4S4_worker
GGGG
1
gen
_nflist_C32C4_worker
1
1
nflist_C32C4_worker
GGGG
1
gen
_nflist_C32D4_worker
1
1
nflist_C32D4_worker
GGGG
1
gen
_nflist_C3C3_worker
1
1
nflist_C3C3_worker
GGGG
1
gen
_nflist_C3_worker
1
1
nflist_C3_worker
GG
1
gen
_nflist_C4vec_worker
1
1
nflist_C4vec_worker
GGGG
1
gen
_nflist_C5_worker
1
1
nflist_C5_worker
GG
1
gen
_nflist_C6_worker
1
1
nflist_C6_worker
GGGGG
1
gen
_nflist_C9_worker
1
1
nflist_C9_worker
GGG
1
gen
_nflist_CL_worker
1
1
nflist_CL_worker
GGG
1
gen
_nflist_D4_worker
1
1
nflist_D4_worker
GGGG
1
gen
_nflist_D612_worker
1
1
nflist_D612_worker
GGGG
1
gen
_nflist_D9_worker
1
1
nflist_D9_worker
GGG
1
gen
_nflist_DL_worker
1
1
nflist_DL_worker
GGGGGG
1
gen
_nflist_Mgen_worker
1
1
nflist_Mgen_worker
GGGG
1
gen
_nflist_S32_worker
1
1
nflist_S32_worker
GGGGG
1
gen
_nflist_S36_worker
1
1
nflist_S36_worker
GGG
1
gen
_nflist_S3C3_worker
1
1
nflist_S3C3_worker
GGG
1
gen
_nflist_S3I_worker
1
1
nflist_S3I_worker
GG
1
gen
_nflist_S3R_worker
1
1
nflist_S3R_worker
GG
1
gen
_nflist_S462_worker
1
1
nflist_S462_worker
GGGGG
1
gen
_nflist_S46M_worker
1
1
nflist_S46M_worker
GGGG
1
gen
_nflist_V4_worker
1
1
nflist_V4_worker
GGGG
1
gen
_norange
1
0
1
LONG_MAX
0
1
small
_nxMV_polint_worker
1
1
nxMV_polint_center_tree_worker
GGGGG
1
gen
_parapply_slice_worker
1
1
parapply_slice_worker
GG
1
gen
_pareval_worker
1
1
pareval_worker
G
1
gen
_parfor_init
1
0
1
parfor_init(&${1 code}, ${2 code}, ${3 code}, ${4 code})
4
parfor
gen
gen
gen
1
void
_parfor_next
1
0
1
parfor_next(&${1 code})
1
parfor
1
gen
_parfor_stop
1
0
1
parfor_stop(&${1 code})
1
parfor
1
void
_parfor_worker
1
1
parfor_worker
GG
1
gen
_parforeach_init
1
0
1
parforeach_init(&${1 code}, ${2 code}, ${3 code})
3
parforeach
gen
gen
1
void
_parforeach_next
1
0
1
parforeach_next(&${1 code})
1
parforeach
1
gen
_parforeach_stop
1
0
1
parforeach_stop(&${1 code})
1
parforeach
1
void
_parforprime_init
1
0
1
parforprime_init(&${1 code}, ${2 code}, ${3 code}, ${4 code})
4
parforprime
gen
?gen
gen
1
void
_parforprime_next
1
0
1
parforprime_next(&${1 code})
1
parforprime
1
gen
_parforprime_stop
1
0
1
parforprime_stop(&${1 code})
1
parforprime
1
void
_parforprimestep_init
1
0
1
parforprimestep_init(&${1 code}, ${2 code}, ${3 code}, ${4 code}, ${5 code})
5
parforprime
gen
?gen
gen
gen
1
void
_parforstep_init
1
0
1
parforstep_init(&${1 code}, ${2 code}, ${3 code}, ${4 code}, ${5 code})
5
parforstep
gen
?gen
gen
gen
1
void
_parforstep_next
1
0
1
parforstep_next(&${1 code})
1
parforstep
1
gen
_parforstep_stop
1
0
1
parforstep_stop(&${1 code})
1
parforstep
1
void
_parforvec_init
1
0
1
parforvec_init(&${1 code}, ${2 code}, ${3 code}, ${4 code})
4
parforvec
vec
closure
?small
1
void
_parforvec_next
1
0
1
parforvec_next(&${1 code})
1
parforvec
1
gen
_parforvec_stop
1
0
1
parforvec_stop(&${1 code})
1
parforvec
1
void
_parsqf_worker
1
1
parsqf_worker
GGG
1
gen
_parsum_slice_worker
1
1
parsum_slice_worker
GGGG
1
gen
_parsumprimefun_worker
1
1
parsumprimefun_worker
GGGGGG
1
gen
_partmap_reverse_frac_worker
1
1
partmap_reverse_frac_worker
GGGGGL
1
gen
_parvector_worker
1
1
parvector_worker
GG
1
gen
_polclass_worker
1
1
polclass_worker
GGG
1
gen
_polint_worker
1
1
nmV_polint_center_tree_worker
GGGGG
1
gen
_polmodular_worker
1
1
polmodular_worker
GUGGGGLGGGG
1
gen
_primecertisvalid_ecpp_worker
1
1
primecertisvalid_ecpp_worker
G
1
gen
_proto_code
1
0
5
n
1
var
0
L
1
C!long
0
U
1
C!ulong
0
G
1
C!GEN
0
s
1
C!char*
0
_proto_max_args
1
0
1

1
20
0
_proto_ret
1
0
5
v
1
C!void
0
i
1
C!int
0
l
1
C!long
0
u
1
C!ulong
0

1
C!GEN
0
_ramanujantau_worker
1
1
ramanujantau_worker
GGGG
1
gen
_safecoeff
1
0
4
*safeel(${1 code}, ${2 code})
2
vecsmall
small
1
small
*safelistel(${1 code}, ${2 code})
2
list
small
2
gen
copy
*safegel(${1 code}, ${2 code})
2
gen
small
2
gen
copy
*safegcoeff(${1 code}, ${2 code}, ${3 code})
3
gen
small
small
2
gen
copy
_serh_worker
1
1
serh_worker
GGGGG
1
gen
_stack_lim
1
0
1
stack_lim(${1 code}, ${2 code})
2
pari_sp
small
1
pari_sp
_strtoclosure
1
0
2
strtofunction(${1 code})
1
str
1
closure
strtoclosure(${1 code}, ${nbarg 1 sub}, ${3 code})
3
str
gen
...
1
closure
_taugen_n_worker
1
1
taugen_n_worker
GGG
1
gen
_tovec
1
0
7
cgetg(1, t_VEC)
0
1
vec
mkvec(${1 code})
1
gen
1
vec
mkvec2(${1 code}, ${2 code})
2
gen
gen
1
vec
mkvec3(${1 code}, ${2 code}, ${3 code})
3
gen
gen
gen
1
vec
mkvec4(${1 code}, ${2 code}, ${3 code}, ${4 code})
4
gen
gen
gen
gen
1
vec
mkvec5(${1 code}, ${2 code}, ${3 code}, ${4 code}, ${5 code})
5
gen
gen
gen
gen
gen
1
vec
mkvecn(${nbarg}, ${2 code})
2
gen
...
1
vec
_tovecprec
1
0
6
mkvecs(${prec})
0
2
vec
prec
mkvec2(${1 code}, stoi(${prec}))
1
gen
2
vec
prec
mkvec3(${1 code}, ${2 code}, stoi(${prec}))
2
gen
gen
2
vec
prec
mkvec4(${1 code}, ${2 code}, ${3 code}, stoi(${prec}))
3
gen
gen
gen
2
vec
prec
mkvec5(${1 code}, ${2 code}, ${3 code}, ${4 code}, stoi(${prec}))
4
gen
gen
gen
gen
2
vec
prec
mkvecn(${nbarg 1 add}, ${2 code}, stoi(${prec}))
2
gen
...
2
vec
prec
_type_preorder
1
0
22

7
empty
void
bool
small
int
mp
gen
0

3
empty
real
mp
0

3
empty
bptr
small
0

4
empty
bool
lg
small
0

4
empty
bool
small_int
small
0

4
empty
bool
usmall
small
0

4
empty
void
negbool
bool
0

5
empty
typ
str
genstr
gen
0

3
empty
errtyp
str
0

3
empty
vecsmall
gen
0

4
empty
vecvecsmall
vec
gen
0

3
empty
list
gen
0

3
empty
closure
gen
0

3
empty
error
gen
0

5
empty
bnr
bnf
nf
vec
0

5
empty
bnr
bnf
clgp
vec
0

3
empty
ell
vec
0

3
empty
prid
vec
0

3
empty
gal
vec
0

4
empty
var
pol
gen
0

4
empty
Fp
Fq
gen
0

4
empty
FpX
FqX
gen
0
_typedef
1
0
49
void
1
empty
0
void
1
void
0
long
1
negbool
0
long
1
bool
0
int
1
small_int
0
ulong
1
usmall
0
long
1
small
0
GEN
1
int
0
GEN
1
real
0
GEN
1
mp
0
long
1
lg
0
GEN
1
vecsmall
0
GEN
1
vec
0
GEN
1
vecvecsmall
0
GEN
1
list
0
long
1
var
0
GEN
1
pol
0
GEN
1
gen
0
GEN
1
closure
0
GEN
1
error
0
GEN
1
genstr
0
char*
1
str
0
byteptr
1
bptr
0
forcomposite_t
1
forcomposite
0
forpart_t
1
forpart
0
forperm_t
1
forperm
0
forprime_t
1
forprime
0
forsubset_t
1
forsubset
0
forvec_t
1
forvec
0
parfor_t
1
parfor
0
parforstep_t
1
parforstep
0
parforeach_t
1
parforeach
0
parforprime_t
1
parforprime
0
parforvec_t
1
parforvec
0
func_GG
1
func_GG
0
pari_sp
1
pari_sp
0
long
1
typ
0
long
1
errtyp
0
GEN
1
nf
0
GEN
1
bnf
0
GEN
1
bnr
0
GEN
1
ell
0
GEN
1
clgp
0
GEN
1
prid
0
GEN
1
gal
0
GEN
1
Fp
0
GEN
1
FpX
0
GEN
1
Fq
0
GEN
1
FqX
0
_u_forprime_init
1
0
2
u_forprime_init(&${1 code}, ${2 code}, LONG_MAX);
3
forprime
small

1
void
u_forprime_init(&${1 code}, ${2 code}, ${3 code});
3
forprime
small
small
1
void
_u_forprime_next
1
0
1
u_forprime_next(&${1 code})
1
forprime
1
small
_void_if
1
1
ifpari_void
GDIDI
1
void
_wrap_G
2
0
1
${1 code}
1
gen
1
gen
1
gp_call
G
1
gen
_wrap_GG
2
0
1
${1 code}
1
gen
1
gen
1
gp_call2
GG
1
gen
_wrap_Gp
2
0
1
${1 code}
1
gen
1
gen
1
gp_callprec
Gp
2
gen
prec
_wrap_bG
2
0
1
${1 code}
1
bool
1
bool
1
gp_callbool
G
1
small
_wrap_vG
2
0
1
0
1
void
1
small
1
gp_callvoid
G
1
small
_||_
2
0
1
${parens 1 code} || ${parens 2 code}
2
bool
bool
2
bool
parens
1
orpari
GE
1
gen
_~
2
0
2
gtrans(${1 code})
1
vec
1
vec
gtrans(${1 code})
1
gen
1
gen
1
gtrans
G
1
gen
abs
2
0
5
labs(${1 code})
1
small
1
small
mpabs(${1 code})
1
int
1
int
mpabs(${1 code})
1
real
1
real
mpabs(${1 code})
1
mp
1
mp
gabs(${1 code}, ${prec})
1
gen
2
gen
prec
1
gabs
Gp
2
gen
prec
acos
1
1
gacos
Gp
2
gen
prec
acosh
1
1
gacosh
Gp
2
gen
prec
addhelp
1
1
addhelp
rs
1
void
addprimes
1
1
addprimes
DG
1
gen
agm
1
1
agm
GGp
2
gen
prec
airy
1
1
airy
Gp
2
gen
prec
alarm
1
1
gp_alarm
D0,L,DE
1
gen
algadd
1
1
algadd
DGGG
1
gen
algalgtobasis
1
1
algalgtobasis
GG
1
gen
algaut
1
1
algaut
G
2
gen
copy
algb
1
1
algb
G
2
gen
copy
algbasis
1
1
algbasis
G
2
gen
copy
algbasistoalg
1
1
algbasistoalg
GG
1
gen
algcenter
1
1
algcenter
G
2
gen
copy
algcentralproj
1
1
alg_centralproj
GGD0,L,
1
gen
algchar
1
1
algchar
G
2
gen
copy
algcharpoly
1
1
algcharpoly
DGGDnD0,L,
1
gen
algdegree
1
1
algdegree
G
1
small
algdep
1
1
algdep0
GLD0,L,
1
gen
algdim
1
1
algdim
GD0,L,
1
small
algdisc
1
1
algdisc
G
1
gen
algdivl
1
1
algdivl
DGGG
1
gen
algdivr
1
1
algdivr
DGGG
1
gen
alggroup
1
1
alggroup
GDG
1
gen
alggroupcenter
1
1
alggroupcenter
GDGD&
1
gen
alghasse
1
1
alghasse
GDG
1
gen
alghassef
1
1
alghassef
G
2
gen
copy
alghassei
1
1
alghassei
G
2
gen
copy
algindex
1
1
algindex
GDG
1
small
alginit
1
1
alginit
GGDnD3,L,
1
gen
alginv
1
1
alginv
DGG
1
gen
alginvbasis
1
1
alginvbasis
G
2
gen
copy
algisassociative
1
1
algisassociative
GD0,G,
1
small_int
algiscommutative
1
1
algiscommutative
G
1
small_int
algisdivision
1
1
algisdivision
GDG
1
small_int
algisdivl
1
1
algisdivl
DGGGD&
1
small_int
algisinv
1
1
algisinv
DGGD&
1
small_int
algisramified
1
1
algisramified
GDG
1
small_int
algissemisimple
1
1
algissemisimple
G
1
small_int
algissimple
1
1
algissimple
GD0,L,
1
small_int
algissplit
1
1
algissplit
GDG
1
small_int
alglatadd
1
1
alglatadd
GGGD&
1
gen
alglatcontains
1
1
alglatcontains
GGGD&
1
small_int
alglatelement
1
1
alglatelement
GGG
1
gen
alglathnf
1
1
alglathnf
GGD0,G,
1
gen
alglatindex
1
1
alglatindex
GGG
1
gen
alglatinter
1
1
alglatinter
GGGD&
1
gen
alglatlefttransporter
1
1
alglatlefttransporter
GGG
1
gen
alglatmul
1
1
alglatmul
GGG
1
gen
alglatrighttransporter
1
1
alglatrighttransporter
GGG
1
gen
alglatsubset
1
1
alglatsubset
GGGD&
1
small_int
algmakeintegral
1
1
algmakeintegral
GD0,L,
1
gen
algmul
1
1
algmul
DGGG
1
gen
algmultable
1
1
algmultable
G
2
gen
copy
algneg
1
1
algneg
DGG
1
gen
algnorm
1
1
algnorm
DGGD0,L,
1
gen
algpoleval
1
1
algpoleval
DGGG
1
gen
algpow
1
1
algpow
DGGG
1
gen
algprimesubalg
1
1
algprimesubalg
G
1
gen
algquotient
1
1
alg_quotient
GGD0,L,
1
gen
algradical
1
1
algradical
G
1
gen
algramifiedplaces
1
1
algramifiedplaces
G
1
gen
algrandom
1
1
algrandom
DGG
1
gen
algrelmultable
1
1
algrelmultable
G
2
gen
copy
algsimpledec
1
1
algsimpledec
GD0,L,
1
gen
algsplit
1
1
algsplit
GDn
1
gen
algsplittingdata
1
1
algsplittingdata
G
2
gen
copy
algsplittingfield
1
1
algsplittingfield
G
2
gen
copy
algsqr
1
1
algsqr
DGG
1
gen
algsub
1
1
algsub
DGGG
1
gen
algsubalg
1
1
algsubalg
GG
1
gen
algtableinit
1
1
algtableinit
GDG
1
gen
algtensor
1
1
algtensor
GGD3,L,
1
gen
algtomatrix
1
1
algtomatrix
DGGD0,L,
1
gen
algtrace
1
1
algtrace
DGGD0,L,
1
gen
algtype
1
1
algtype
G
1
small
alias
1
1
alias0
rr
1
void
allocatemem
1
1
gp_allocatemem
DG
1
void
apply
3
0
1
genapply(${1 cookie}, ${1 wrapper}, ${2 code})
2
closure
gen
1
gen
1
apply0
GG
1
gen
2
1
_wrap_G
arg
1
1
garg
Gp
2
gen
prec
arity
1
1
arity0
G
1
gen
asin
1
1
gasin
Gp
2
gen
prec
asinh
1
1
gasinh
Gp
2
gen
prec
asympnum
1
1
asympnum0
GDGp
2
gen
prec
asympnumraw
1
1
asympnumraw0
GLDGp
2
gen
prec
atan
1
1
gatan
Gp
2
gen
prec
atanh
1
1
gatanh
Gp
2
gen
prec
bernfrac
1
1
bernfrac
L
1
gen
bernpol
1
1
bernpol_eval
LDG
1
gen
bernreal
1
1
bernreal
Lp
2
gen
prec
bernvec
1
1
bernvec
L
1
gen
besselh1
1
1
hbessel1
GGp
2
gen
prec
besselh2
1
1
hbessel2
GGp
2
gen
prec
besseli
1
1
ibessel
GGp
2
gen
prec
besselj
1
1
jbessel
GGp
2
gen
prec
besseljh
1
1
jbesselh
GGp
2
gen
prec
besseljzero
1
1
besseljzero
GD1,L,b
2
gen
prec
besselk
1
1
kbessel
GGp
2
gen
prec
besseln
1
1
ybessel
GGp
2
gen
prec
bessely
1
1
ybessel
GGp
2
gen
prec
besselyzero
1
1
besselyzero
GD1,L,b
2
gen
prec
bestappr
1
1
bestappr
GDG
1
gen
bestapprPade
1
1
bestapprPade0
GD-1,L,D-1,L,
1
gen
bestapprnf
1
1
bestapprnf
GGDGp
2
gen
prec
bezout
1
1
gcdext0
GG
1
gen
bezoutres
1
1
polresultantext0
GGDn
1
gen
bigomega
1
1
bigomega
G
1
small
binary
1
1
binaire
G
1
gen
binomial
1
1
binomial0
GDG
1
gen
bitand
2
0
2
${parens 1 code}&${parens 2 code}
2
small
small
2
small
parens
gbitand(${1 code}, ${2 code})
2
gen
gen
1
int
1
gbitand
GG
1
gen
bitneg
1
1
gbitneg
GD-1,L,
1
gen
bitnegimply
2
0
2
${parens 1 code}&~${parens 2 code}
2
small
small
2
small
parens
gbitnegimply(${1 code}, ${2 code})
2
gen
gen
1
int
1
gbitnegimply
GG
1
gen
bitor
2
0
2
${parens 1 code}|${parens 2 code}
2
small
small
2
small
parens
gbitor(${1 code}, ${2 code})
2
gen
gen
1
int
1
gbitor
GG
1
gen
bitprecision
1
1
bitprecision00
GDG
1
gen
bittest
2
0
3
(${parens 1 code}>>${parens 2 code})&1
2
small
small
2
bool
parens
bittest(${1 code}, ${2 code})
2
int
small
1
bool
gbittest(${1 code}, ${2 code})
2
gen
small
1
gen
1
gbittest
GL
1
gen
bitxor
2
0
2
${parens 1 code}^${parens 2 code}
2
small
small
2
small
parens
gbitxor(${1 code}, ${2 code})
2
gen
gen
1
int
1
gbitxor
GG
1
gen
bnfcertify
1
1
bnfcertify0
GD0,L,
1
small
bnfdecodemodule
1
1
decodemodule
GG
1
gen
bnfinit
2
0
4
Buchall(${1 code}, 0, ${prec})
1
gen
2
bnf
prec
Buchall(${1 code}, 0, ${prec})
2
gen
0
2
bnf
prec
Buchall(${1 code}, nf_FORCE, ${prec})
2
gen
1
2
bnf
prec
bnfinit0(${1 code}, ${2 code}, ${3 code}, ${prec})
3
gen
?small
?gen
2
bnf
prec
1
bnfinit0
GD0,L,DGp
2
gen
prec
bnfisintnorm
1
1
bnfisintnorm0
GGD0,L,
1
gen
bnfisnorm
1
1
bnfisnorm
GGD1,L,
1
gen
bnfisprincipal
1
1
bnfisprincipal0
GGD1,L,
1
gen
bnfissunit
1
1
bnfissunit
GGG
1
gen
bnfisunit
1
1
bnfisunit0
GGDG
1
gen
bnflog
1
1
bnflog
GG
1
gen
bnflogdegree
1
1
bnflogdegree
GGG
1
gen
bnflogef
1
1
bnflogef
GG
1
gen
bnfnarrow
1
1
bnfnarrow
G
1
gen
bnfsignunit
1
1
signunits
G
1
gen
bnfsunit
1
1
bnfsunit
GGp
2
gen
prec
bnfunits
1
1
bnfunits
GDG
1
gen
bnrL1
1
1
bnrL1
GDGD0,L,p
2
gen
prec
bnrchar
1
1
bnrchar
GGDG
1
gen
bnrclassfield
1
1
bnrclassfield
GDGD0,L,p
2
gen
prec
bnrclassno
1
1
bnrclassno0
GDGDG
1
gen
bnrclassnolist
1
1
bnrclassnolist
GG
1
gen
bnrcompositum
1
1
bnrcompositum
GG
1
gen
bnrconductor
1
1
bnrconductor0
GDGDGD0,L,
1
gen
bnrconductorofchar
1
1
bnrconductorofchar
GG
1
gen
bnrdisc
1
1
bnrdisc0
GDGDGD0,L,
1
gen
bnrdisclist
1
1
bnrdisclist0
GGDG
1
gen
bnrgaloisapply
1
1
bnrgaloisapply
GGG
1
gen
bnrgaloismatrix
1
1
bnrgaloismatrix
GG
1
gen
bnrinit
2
0
1
bnrinit0(${1 code}, ${2 code}, ${3 code})
3
gen
gen
?small
1
bnr
1
bnrinitmod
GGD0,L,DG
1
gen
bnrisconductor
1
1
bnrisconductor0
GDGDG
1
small
bnrisgalois
1
1
bnrisgalois
GGG
1
small
bnrisprincipal
1
1
bnrisprincipal
GGD1,L,
1
gen
bnrmap
1
1
bnrmap
GG
1
gen
bnrrootnumber
1
1
bnrrootnumber
GGD0,L,p
2
gen
prec
bnrstark
1
1
bnrstark
GDGp
2
gen
prec
bnrstarkunit
1
1
bnrstarkunit
GDG
1
gen
break
1
1
break0
D1,L,
1
gen
breakpoint
1
1
pari_breakpoint

1
void
call
1
1
call0
GG
1
gen
ceil
2
0
5
${1 code}
1
small
2
small
parens
${1 code}
1
int
3
int
copy
parens
ceilr(${1 code})
1
real
1
int
mpceil(${1 code})
1
mp
1
int
gceil(${1 code})
1
gen
1
gen
1
gceil
G
1
gen
centerlift
2
0
6
centerlift(${1 code})
1
pol
1
pol
centerlift(${1 code})
1
vec
1
vec
centerlift(${1 code})
1
gen
1
gen
centerlift0(${1 code}, ${2 code})
2
pol
var
1
pol
centerlift0(${1 code}, ${2 code})
2
vec
var
1
vec
centerlift0(${1 code}, ${2 code})
2
gen
var
1
gen
1
centerlift0
GDn
1
gen
characteristic
1
1
characteristic
G
2
gen
copy
charconj
1
1
charconj0
GG
1
gen
chardiv
1
1
chardiv0
GGG
1
gen
chareval
1
1
chareval
GGGDG
1
gen
chargalois
1
1
chargalois
GDG
1
gen
charker
1
1
charker0
GG
1
gen
charmul
1
1
charmul0
GGG
1
gen
charorder
1
1
charorder0
GG
1
gen
charpoly
1
1
charpoly0
GDnD5,L,
1
gen
charpow
1
1
charpow0
GGG
1
gen
chinese
2
0
2
chinese1(${1 code})
1
gen
1
gen
chinese(${1 code}, ${2 code})
2
gen
gen
1
gen
1
chinese
GDG
1
gen
clone
1
0
11
${1 code}
1
small
2
small
parens
gclone(${1 code})
1
int
1
int
gclone(${1 code})
1
real
1
real
gclone(${1 code})
1
mp
1
mp
gclone(${1 code})
1
vecsmall
1
vecsmall
gclone(${1 code})
1
vec
1
vec
gclone(${1 code})
1
pol
1
pol
gclone(${1 code})
1
list
1
list
gclone(${1 code})
1
closure
1
closure
gclone(${1 code})
1
genstr
1
genstr
gclone(${1 code})
1
gen
1
gen
cmp
1
1
cmp_universal
GG
1
small_int
component
2
0
2
err_get_compo(${1 code}, ${2 code})
2
error
small
1
gen
compo(${1 code},${2 code})
2
gen
small
1
gen
1
compo
GL
1
gen
concat
2
0
12
gconcat(${1 code}, ${2 code})
2
vecvecsmall
vecvecsmall
1
vecvecsmall
gconcat1(${1 code})
1
vecvecsmall
1
vecsmall
gconcat(${1 code}, ${2 code})
2
mp
mp
1
vec
gconcat(${1 code}, ${2 code})
2
vec
mp
1
vec
gconcat(${1 code}, ${2 code})
2
mp
vec
1
vec
gconcat(${1 code}, ${2 code})
2
vec
vec
1
vec
gconcat(${1 code}, ${2 code})
2
list
list
1
list
gconcat(${1 code}, ${2 code})
2
genstr
gen
1
genstr
gconcat(${1 code}, ${2 code})
2
gen
genstr
1
genstr
gconcat1(${1 code})
1
gen
1
gen
gconcat1(${1 code})
2
gen

1
gen
gconcat(${1 code}, ${2 code})
2
gen
gen
1
gen
1
gconcat
GDG
1
gen
conj
1
1
gconj
G
1
gen
conjvec
1
1
conjvec
Gp
2
gen
prec
content
1
1
content0
GDG
1
gen
contfrac
1
1
contfrac0
GDGD0,L,
1
gen
contfraceval
1
1
contfraceval
GGD-1,L,
1
gen
contfracinit
1
1
contfracinit
GD-1,L,
1
gen
contfracpnqn
1
1
contfracpnqn
GD-1,L,
1
gen
copy
1
0
9
${1 code}
1
small
2
small
parens
icopy(${1 code})
1
int
1
int
gcopy(${1 code})
1
real
1
real
gcopy(${1 code})
1
mp
1
mp
gcopy(${1 code})
1
vecsmall
1
vecsmall
gcopy(${1 code})
1
vec
1
vec
gcopy(${1 code})
1
pol
1
pol
listinit(${1 code})
1
list
1
list
gcopy(${1 code})
1
gen
1
gen
core
1
1
core0
GD0,L,
1
gen
coredisc
1
1
coredisc0
GD0,L,
1
gen
cos
2
0
3
mpcos(${1 code})
1
real
1
real
gcos(${1 code}, ${prec})
1
mp
2
real
prec
gcos(${1 code}, ${prec})
1
gen
2
gen
prec
1
gcos
Gp
2
gen
prec
cosh
2
0
2
gcosh(${1 code}, ${prec})
1
mp
2
real
prec
gcosh(${1 code}, ${prec})
1
gen
2
gen
prec
1
gcosh
Gp
2
gen
prec
cotan
2
0
2
gcotan(${1 code}, ${prec})
1
mp
2
real
prec
gcotan(${1 code}, ${prec})
1
gen
2
gen
prec
1
gcotan
Gp
2
gen
prec
cotanh
2
0
2
gcotanh(${1 code}, ${prec})
1
mp
2
real
prec
gcotanh(${1 code}, ${prec})
1
gen
2
gen
prec
1
gcotanh
Gp
2
gen
prec
dbg_down
1
1
dbg_down
D1,L,
1
void
dbg_err
1
1
dbg_err

1
gen
dbg_up
1
1
dbg_up
D1,L,
1
void
dbg_x
1
1
dbgGEN
GD-1,L,
1
void
default
2
0
16
getrealprecision()
1
"realprecision"
2
small
prec
setrealprecision(${2 code}, &${prec})
2
"realprecision"
small
2
small
prec
precdl
1
"seriesprecision"
1
small
precdl = ${2 code}
2
"seriesprecision"
small
2
small
parens
DEBUGLEVEL
1
"debug"
1
small
DEBUGLEVEL = ${2 code}
2
"debug"
small
2
small
parens
DEBUGMEM
1
"debugmem"
1
small
DEBUGMEM = ${2 code}
2
"debugmem"
small
2
small
parens
DEBUGFILES
1
"debugfiles"
1
small
DEBUGFILES = ${2 code}
2
"debugfiles"
small
2
small
parens
factor_add_primes
1
"factor_add_primes"
1
small
factor_add_primes = ${2 code}
2
"factor_add_primes"
small
1
small
factor_proven
1
"factor_proven"
1
small
factor_proven = ${2 code}
2
"factor_proven"
small
1
small
new_galois_format
1
"new_galois_format"
1
small
new_galois_format = ${2 code}
2
"new_galois_format"
small
1
small
1
default0
DrDs
1
gen
denominator
1
1
denominator
GDG
1
gen
deriv
1
1
deriv
GDn
1
gen
derivn
1
1
derivn
GLDn
1
gen
derivnum
3
0
2
derivnum(${2 cookie}, ${2 wrapper}, ${1 code}, ${prec})
2
gen
gen
2
gen
prec
derivfunk(${2 cookie}, ${2 wrapper}, ${1 code}, ${3 code}, ${prec})
3
gen
gen
gen
2
gen
prec
1
derivnum0
V=GEDGp
2
gen
prec
2
2

_wrap_Gp
diffop
2
0
2
diffop(${1 code}, ${2 code}, ${3 code})
4
gen
gen
gen
?1
1
gen
diffop0(${1 code}, ${2 code}, ${3 code}, ${4 code})
4
gen
gen
gen
small
1
gen
1
diffop0
GGGD1,L,
1
gen
digits
1
1
digits
GDG
1
gen
dilog
1
1
dilog
Gp
2
gen
prec
dirdiv
1
1
dirdiv
GG
1
gen
direuler
3
0
1
direuler(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${4 code})
4
gen
gen
closure
?gen
1
gen
1
direuler0
V=GGEDG
1
gen
2
3


_wrap_G
dirmul
1
1
dirmul
GG
1
gen
dirpowers
1
1
dirpowers
LGp
2
gen
prec
dirpowerssum
1
1
dirpowerssum0
GGDGD0,L,p
2
gen
prec
dirzetak
1
1
dirzetak
GG
1
gen
divisors
2
0
2
divisors(${1 code})
2
gen
?0
1
vec
divisors_factored(${1 code})
2
gen
1
1
vec
1
divisors0
GD0,L,
1
gen
divisorslenstra
1
1
divisorslenstra
GGG
1
gen
divrem
1
1
divrem
GGDn
1
gen
eint1
1
1
veceint1
GDGp
2
gen
prec
ell2cover
1
1
ell2cover
Gp
2
gen
prec
ellE
1
1
ellE
Gp
2
gen
prec
ellK
1
1
ellK
Gp
2
gen
prec
ellL1
1
1
ellL1
GD0,L,b
2
gen
prec
elladd
1
1
elladd
GGG
1
gen
ellak
1
1
akell
GG
1
gen
ellan
1
1
ellan
GL
1
gen
ellanalyticrank
1
1
ellanalyticrank
GDGb
2
gen
prec
ellap
1
1
ellap
GDG
1
gen
ellbil
1
1
bilhell
GGGp
2
gen
prec
ellbsd
1
1
ellbsd
Gp
2
gen
prec
ellcard
1
1
ellcard
GDG
1
gen
ellchangecurve
2
0
1
ellchangecurve(${1 code}, ${2 code})
2
gen
gen
1
ell
1
ellchangecurve
GG
1
gen
ellchangepoint
1
1
ellchangepoint
GG
1
gen
ellchangepointinv
1
1
ellchangepointinv
GG
1
gen
ellconvertname
1
1
ellconvertname
G
1
gen
elldivpol
1
1
elldivpol
GLDn
1
gen
elleisnum
1
1
elleisnum
GLD0,L,p
2
gen
prec
elleta
1
1
elleta
Gp
2
gen
prec
ellformaldifferential
1
1
ellformaldifferential
GDPDn
1
gen
ellformalexp
1
1
ellformalexp
GDPDn
1
gen
ellformallog
1
1
ellformallog
GDPDn
1
gen
ellformalpoint
1
1
ellformalpoint
GDPDn
1
gen
ellformalw
1
1
ellformalw
GDPDn
1
gen
ellfromeqn
1
1
ellfromeqn
G
1
gen
ellfromj
1
1
ellfromj
G
1
gen
ellgenerators
1
1
ellgenerators
G
1
gen
ellglobalred
2
0
1
ellglobalred(${1 code})
1
gen
1
gen
1
ellglobalred
G
1
gen
ellgroup
1
1
ellgroup0
GDGD0,L,
1
gen
ellheegner
1
1
ellheegner
G
1
gen
ellheight
1
1
ellheight0
GDGDGp
2
gen
prec
ellheightmatrix
1
1
ellheightmatrix
GGp
2
gen
prec
ellidentify
1
1
ellidentify
G
1
gen
ellinit
2
0
1
ellinit(${1 code}, ${2 code}, ${prec})
3
gen
gen
small
2
ell
prec
1
ellinit
GDGp
2
gen
prec
ellintegralmodel
1
1
ellintegralmodel
GD&
1
gen
elliscm
1
1
elliscm
G
1
small
ellisdivisible
1
1
ellisdivisible
GGGD&
1
small
ellisisom
1
1
ellisisom
GG
1
gen
ellisogeny
1
1
ellisogeny
GGD0,L,DnDn
1
gen
ellisogenyapply
1
1
ellisogenyapply
GG
1
gen
ellisomat
1
1
ellisomat
GD0,L,D0,L,
1
gen
ellisoncurve
1
1
ellisoncurve
GG
1
gen
ellisotree
1
1
ellisotree
G
1
gen
ellissupersingular
1
1
ellissupersingular
GDG
1
small_int
ellj
1
1
jell
Gp
2
gen
prec
elllocalred
1
1
elllocalred
GDG
1
gen
elllog
1
1
elllog
GGGDG
1
gen
elllseries
1
1
elllseries
GGDGp
2
gen
prec
ellmaninconstant
1
1
ellmaninconstant
G
1
gen
ellminimaldisc
1
1
ellminimaldisc
G
1
gen
ellminimalmodel
1
1
ellminimalmodel
GD&
1
gen
ellminimaltwist
1
1
ellminimaltwist0
GD0,L,
1
gen
ellmoddegree
1
1
ellmoddegree
G
1
gen
ellmodulareqn
1
1
ellmodulareqn
LDnDn
1
gen
ellmul
1
1
ellmul
GGG
1
gen
ellneg
1
1
ellneg
GG
1
gen
ellnonsingularmultiple
1
1
ellnonsingularmultiple
GG
1
gen
ellorder
1
1
ellorder
GGDG
1
gen
ellordinate
1
1
ellordinate
GGp
2
gen
prec
ellpadicL
1
1
ellpadicL
GGLDGD0,L,DG
1
gen
ellpadicbsd
1
1
ellpadicbsd
GGLDG
1
gen
ellpadicfrobenius
1
1
ellpadicfrobenius
GUL
1
gen
ellpadicheight
1
1
ellpadicheight0
GGLGDG
1
gen
ellpadicheightmatrix
1
1
ellpadicheightmatrix
GGLG
1
gen
ellpadiclambdamu
1
1
ellpadiclambdamu
GLD1,L,D0,L,
1
gen
ellpadiclog
1
1
ellpadiclog
GGLG
1
gen
ellpadicregulator
1
1
ellpadicregulator
GGLG
1
gen
ellpadics2
1
1
ellpadics2
GGL
1
gen
ellperiods
1
1
ellperiods
GD0,L,p
2
gen
prec
ellpointtoz
1
1
zell
GGp
2
gen
prec
ellpow
1
1
ellmul
GGG
1
gen
ellrank
1
1
ellrank
GD0,L,DGp
2
gen
prec
ellrankinit
1
1
ellrankinit
Gp
2
gen
prec
ellratpoints
1
1
ellratpoints
GGD0,L,
1
gen
ellrootno
1
1
ellrootno
GDG
1
small
ellsaturation
1
1
ellsaturation
GGLp
2
gen
prec
ellsea
1
1
ellsea
GD0,L,
1
gen
ellsearch
1
1
ellsearch
G
1
gen
ellsigma
1
1
ellsigma
GDGD0,L,p
2
gen
prec
ellsub
1
1
ellsub
GGG
1
gen
ellsupersingularj
1
1
ellsupersingularj
G
1
gen
elltamagawa
1
1
elltamagawa
G
1
gen
elltaniyama
1
1
elltaniyama
GDP
1
gen
elltatepairing
1
1
elltatepairing
GGGG
1
gen
elltors
1
1
elltors
G
1
gen
elltrace
1
1
elltrace
GG
1
gen
elltwist
1
1
elltwist
GDG
1
gen
ellweilcurve
1
1
ellweilcurve
GD&
1
gen
ellweilpairing
1
1
ellweilpairing
GGGG
1
gen
ellwp
1
1
ellwp0
GDGD0,L,p
2
gen
prec
ellxn
1
1
ellxn
GLDn
1
gen
ellzeta
1
1
ellzeta
GDGp
2
gen
prec
ellztopoint
1
1
pointell
GGp
2
gen
prec
erfc
1
1
gerfc
Gp
2
gen
prec
errname
2
0
1
err_get_num(${1 code})
1
gen
1
errtyp
1
errname
G
1
gen
error
2
0
2
pari_err(0, ${1 code})
1
error
1
void
pari_err(e_MISC, "${2 format_string}"${2 format_args})
2
?gen
...
1
void
1
error0
s*
1
void
eta
1
1
eta0
GD0,L,p
2
gen
prec
eulerfrac
1
1
eulerfrac
L
1
gen
eulerianpol
1
1
eulerianpol
LDn
1
gen
eulerphi
2
0
1
eulerphi(${1 code})
1
gen
1
int
1
eulerphi
G
1
gen
eulerpol
1
1
eulerpol
LDn
1
gen
eulerreal
1
1
eulerreal
Lp
2
gen
prec
eulervec
1
1
eulervec
L
1
gen
eval
2
0
1
geval(${1 code})
1
gen
1
gen
1
geval_gp
GC
1
gen
exp
2
0
3
mpexp(${1 code})
1
real
1
real
gexp(${1 code}, ${prec})
1
mp
2
real
prec
gexp(${1 code}, ${prec})
1
gen
2
gen
prec
1
gexp
Gp
2
gen
prec
expm1
2
0
1
mpexpm1(${1 code})
1
real
1
real
1
gexpm1
Gp
2
gen
prec
exponent
1
1
gpexponent
G
1
gen
export
0
exportall
1
1
exportall

1
void
extern
1
1
gpextern
s
1
gen
externstr
1
1
externstr
s
1
gen
factor
2
0
6
Z_factor(${1 code})
1
int
1
vec
Z_factor(${1 code})
2
int

1
vec
Z_factor_limit(${1 code}, ${2 code})
2
int
small
1
vec
factor(${1 code})
1
gen
1
vec
factor(${1 code})
2
gen

1
vec
factor0(${1 code}, ${2 code})
2
gen
gen
1
vec
1
factor0
GDG
1
gen
factorback
2
0
3
factorback(${1 code})
1
gen
1
gen
factorback(${1 code})
2
gen

1
gen
factorback2(${1 code}, ${2 code})
2
gen
gen
1
gen
1
factorback2
GDG
1
gen
factorcantor
1
1
factmod
GG
1
gen
factorff
1
1
factorff
GDGDG
1
gen
factorial
1
1
mpfactr
Lp
2
gen
prec
factorint
1
1
factorint
GD0,L,
1
gen
factormod
1
1
factormod0
GDGD0,L,
1
gen
factormodDDF
1
1
factormodDDF
GDG
1
gen
factormodSQF
1
1
factormodSQF
GDG
1
gen
factormodcyclo
1
1
factormodcyclo
LGD0,L,Dn
1
gen
factornf
1
1
polfnf
GG
1
gen
factorpadic
1
1
factorpadic
GGL
1
gen
ffcompomap
1
1
ffcompomap
GG
1
gen
ffembed
1
1
ffembed
GG
1
gen
ffextend
1
1
ffextend
GGDn
1
gen
fffrobenius
1
1
fffrobenius
GD1,L,
1
gen
ffgen
1
1
ffgen
GDn
1
gen
ffinit
2
0
1
ffinit(${1 code}, ${2 code}, ${3 code})
3
int
small
?var
1
pol
1
ffinit
GLDn
1
gen
ffinvmap
1
1
ffinvmap
G
1
gen
fflog
1
1
fflog
GGDG
1
gen
ffmap
1
1
ffmap
GG
1
gen
ffmaprel
1
1
ffmaprel
GG
1
gen
ffnbirred
2
0
3
ffnbirred(${1 code}, ${2 code})
3
int
small
?0
1
int
ffsumnbirred(${1 code}, ${2 code})
3
int
small
1
1
int
ffnbirred0(${1 code}, ${2 code}, ${3 code})
3
int
small
?small
1
int
1
ffnbirred0
GLD0,L,
1
gen
fforder
1
1
fforder
GDG
1
gen
ffprimroot
1
1
ffprimroot
GD&
1
gen
fft
1
1
FFT
GG
1
gen
fftinv
1
1
FFTinv
GG
1
gen
fibonacci
1
1
fibo
L
1
gen
fileclose
1
1
gp_fileclose
L
1
void
fileextern
1
1
gp_fileextern
s
1
small
fileflush
1
1
gp_fileflush0
DG
1
void
fileopen
1
1
gp_fileopen
sD"r",s,
1
small
fileread
1
1
gp_fileread
L
1
gen
filereadstr
1
1
gp_filereadstr
L
1
gen
filewrite
1
1
gp_filewrite
Ls
1
void
filewrite1
1
1
gp_filewrite1
Ls
1
void
floor
2
0
5
${1 code}
1
small
2
small
parens
${1 code}
1
int
3
int
copy
parens
floorr(${1 code})
1
real
1
int
mpfloor(${1 code})
1
mp
1
int
gfloor(${1 code})
1
gen
1
gen
1
gfloor
G
1
gen
fold
3
0
1
genfold(${1 cookie}, ${1 wrapper}, ${2 code})
2
closure
gen
1
gen
1
fold0
GG
1
gen
2
1
_wrap_GG
for
1
1
forpari
V=GGI
1
void
forcomposite
2
1
forcomposite
V=GDGI
1
void
3
1
3
forcomposite
_forcomposite_init
_forcomposite_next
3
gen
gen
?gen
0
fordiv
1
1
fordiv
GVI
1
void
fordivfactored
1
1
fordivfactored
GVI
1
void
foreach
1
1
foreachpari
GVI
1
void
forell
3
0
1
forell(${4 cookie}, ${4 wrapper}, ${2 code}, ${3 code}, ${5 code})
5

small
small
closure
?small
1
void
1
forell0
VLLID0,L,
1
void
2
5



_wrap_vG

forfactored
1
1
forfactored
V=GGI
1
void
forpart
4
0
1
forpart(${2 cookie}, ${2 wrapper}, ${1 code}, ${3 code}, ${4 code})
4
small
closure
?gen
?gen
1
void
1
forpart0
V=GIDGDG
1
void
2
4

_wrap_vG


3
1
3
forpart
_forpart_init
_forpart_next
4
gen
small
?gen
?gen
0
forperm
3
1
forperm0
GVI
1
void
2
4

_wrap_vG


3
1
3
forperm
_forperm_init
_forperm_next
2
gen
gen
0
forprime
2
1
forprime
V=GDGI
1
void
3
5
3
forprime
_u_forprime_init
_u_forprime_next
3
*notype
small
small
0
3
forprime
_forprime_init
_forprime_next_
4
*notype
gen
gen
gen
0
3
forprime
_u_forprime_init
_u_forprime_next
3
*small
gen
?gen
0
3
forprime
_forprime_init
_forprime_next_
3
*int
gen
?gen
0
3
forprime
_forprime_init
_forprime_next_
3
gen
gen
?gen
0
forprimestep
2
1
forprimestep
V=GDGGI
1
void
3
5
3
forprime
_forprimestep_init
_u_forprime_next
4
*notype
small
small
gen
0
3
forprime
_forprimestep_init
_forprime_next_
4
*notype
gen
gen
gen
0
3
forprime
_forprimestep_init
_u_forprime_next
4
*small
gen
?gen
gen
0
3
forprime
_forprimestep_init
_forprime_next_
4
*int
gen
?gen
gen
0
3
forprime
_forprimestep_init
_forprime_next_
4
gen
gen
?gen
gen
0
forqfvec
3
0
1
forqfvec1(${4 cookie}, ${4 wrapper}, ${2 code}, ${3 code})
4

gen
?gen
closure
1
void
1
forqfvec0
VGDGI
1
void
2
4



_wrap_vG
forsquarefree
1
1
forsquarefree
V=GGI
1
void
forstep
1
1
forstep
V=GGGI
1
void
forsubgroup
3
0
1
forsubgroup(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code})
3
gen
?gen
closure
1
void
1
forsubgroup0
V=GDGI
1
void
2
3


_wrap_vG
forsubset
3
1
forsubset0
GVI
1
void
2
4

_wrap_vG


3
1
3
forsubset
_forsubset_init
_forsubset_next
2
gen
gen
0
forvec
2
1
forvec
V=GID0,L,
1
void
3
1
3
forvec
_forvec_init
_forvec_next
3
gen
gen
?small
0
frac
1
1
gfrac
G
1
gen
fromdigits
1
1
fromdigits
GDG
1
gen
galoischardet
1
1
galoischardet
GGD1,L,
1
gen
galoischarpoly
1
1
galoischarpoly
GGD1,L,
1
gen
galoischartable
1
1
galoischartable
G
1
gen
galoisconjclasses
1
1
galoisconjclasses
G
1
gen
galoisexport
1
1
galoisexport
GD0,L,
1
gen
galoisfixedfield
2
0
1
galoisfixedfield(${1 code}, ${2 code}, ${3 code}, ${4 code})
4
gen
gen
?small
?var
1
vec
1
galoisfixedfield
GGD0,L,Dn
1
gen
galoisgetgroup
2
0
3
galoisnbpol(${1 code})
1
small
1
int
galoisnbpol(${1 code})
2
small

1
int
galoisgetgroup(${1 code}, ${2 code})
2
small
small
1
vec
1
galoisgetgroup
LD0,L,
1
gen
galoisgetname
1
1
galoisgetname
LL
1
gen
galoisgetpol
2
0
4
galoisnbpol(${1 code})
1
small
1
int
galoisnbpol(${1 code})
2
small

1
int
galoisnbpol(${1 code})
3
small


1
int
galoisgetpol(${1 code}, ${2 code} ,${3 code})
3
small
small
small
1
vec
1
galoisgetpol
LD0,L,D1,L,
1
gen
galoisidentify
1
1
galoisidentify
G
1
gen
galoisinit
2
0
1
galoisinit(${1 code}, ${2 code})
2
gen
?int
1
gal
1
galoisinit
GDG
1
gen
galoisisabelian
1
1
galoisisabelian
GD0,L,
1
gen
galoisisnormal
1
1
galoisisnormal
GG
1
small
galoispermtopol
1
1
galoispermtopol
GG
1
gen
galoissplittinginit
1
1
galoissplittinginit
GDG
1
gen
galoissubcyclo
1
1
galoissubcyclo
GDGD0,L,Dn
1
gen
galoissubfields
1
1
galoissubfields
GD0,L,Dn
1
gen
galoissubgroups
1
1
galoissubgroups
G
1
gen
gamma
1
1
ggamma
Gp
2
gen
prec
gammah
1
1
ggammah
Gp
2
gen
prec
gammamellininv
1
1
gammamellininv
GGD0,L,b
2
gen
prec
gammamellininvasymp
1
1
gammamellininvasymp
GDPD0,L,
1
gen
gammamellininvinit
1
1
gammamellininvinit
GD0,L,b
2
gen
prec
gcd
2
0
4
cgcd(${1 code}, ${2 code})
2
small
small
1
small
gcdii(${1 code}, ${2 code})
2
int
int
1
int
content(${1 code})
1
gen
1
gen
ggcd(${1 code}, ${2 code})
2
gen
gen
1
gen
1
ggcd0
GDG
1
gen
gcdext
1
1
gcdext0
GG
1
gen
gcharalgebraic
1
1
gcharalgebraic
GDG
1
gen
gcharconductor
1
1
gchar_conductor
GG
1
gen
gcharduallog
1
1
gcharduallog
GG
1
gen
gchareval
1
1
gchareval
GGGD1,L,
1
gen
gcharidentify
1
1
gchar_identify
GGGp
2
gen
prec
gcharinit
1
1
gcharinit
GGp
2
gen
prec
gcharisalgebraic
1
1
gcharisalgebraic
GGD&
1
small_int
gcharlocal
1
1
gcharlocal
GGGpD&
2
gen
prec
gcharlog
1
1
gcharlog
GGp
2
gen
prec
gcharnewprec
1
1
gcharnewprec
Gp
2
gen
prec
genus2igusa
1
1
genus2igusa
GD0,L,
1
gen
genus2red
1
1
genus2red
GDG
1
gen
getabstime
1
1
getabstime

1
small
getcache
1
1
getcache

1
gen
getenv
1
1
gp_getenv
s
1
gen
getheap
1
1
getheap

1
gen
getlocalbitprec
1
1
getlocalbitprec
b
2
small
prec
getlocalprec
1
1
getlocalprec
p
2
small
prec
getrand
1
1
getrand

1
gen
getstack
1
1
getstack

1
small
gettime
1
1
gettime

1
small
getwalltime
1
1
getwalltime

1
gen
global
0
halfgcd
1
1
ghalfgcd
GG
1
gen
hammingweight
1
1
hammingweight
G
1
small
harmonic
1
1
harmonic0
UDG
1
gen
hgmalpha
1
1
hgmalpha
G
1
gen
hgmbydegree
1
1
hgmbydegree
L
1
gen
hgmcoef
1
1
hgmcoef
GGG
1
gen
hgmcoefs
1
1
hgmcoefs
GGL
1
gen
hgmcyclo
1
1
hgmcyclo
G
1
gen
hgmeulerfactor
1
1
hgmeulerfactor
GGLD&
1
gen
hgmgamma
1
1
hgmgamma
G
1
gen
hgminit
1
1
hgminit
GDG
1
gen
hgmissymmetrical
1
1
hgmissymmetrical
G
1
small
hgmparams
1
1
hgmparams
G
1
gen
hgmtwist
1
1
hgmtwist
G
1
gen
hilbert
1
1
hilbert
GGDG
1
small
hyperellchangecurve
1
1
hyperellchangecurve
GG
1
gen
hyperellcharpoly
1
1
hyperellcharpoly
G
1
gen
hyperelldisc
1
1
hyperelldisc
G
1
gen
hyperellisoncurve
1
1
hyperellisoncurve
GG
1
small_int
hyperellminimaldisc
1
1
hyperellminimaldisc
GDG
1
gen
hyperellminimalmodel
1
1
hyperellminimalmodel
GD&DG
1
gen
hyperellordinate
1
1
hyperellordinate
GG
1
gen
hyperellpadicfrobenius
1
1
hyperellpadicfrobenius0
GGL
1
gen
hyperellratpoints
1
1
hyperellratpoints
GGD0,L,
1
gen
hyperellred
1
1
hyperellred
GD&
1
gen
hypergeom
1
1
hypergeom
DGDGGp
2
gen
prec
hyperu
1
1
hyperu
GGGp
2
gen
prec
idealadd
1
1
idealadd
GGG
1
gen
idealaddtoone
1
1
idealaddtoone0
GGDG
1
gen
idealappr
1
1
idealappr0
GGD0,L,
1
gen
idealchinese
1
1
idealchinese
GGDG
1
gen
idealcoprime
1
1
idealcoprime
GGG
1
gen
idealdiv
2
0
4
idealdiv(${1 code}, ${2 code}, ${3 code})
4
gen
gen
gen
?0
1
gen
idealdivexact(${1 code}, ${2 code}, ${3 code})
4
gen
gen
gen
1
1
gen
$"invalid flag in idealdiv"
4
gen
gen
gen
#small
1
gen
idealdiv0(${1 code}, ${2 code}, ${3 code}, ${4 code})
4
gen
gen
gen
small
1
gen
1
idealdiv0
GGGD0,L,
1
gen
idealdown
1
1
idealdown
GG
1
gen
idealfactor
1
1
gpidealfactor
GGDG
1
gen
idealfactorback
1
1
idealfactorback
GGDGD0,L,
1
gen
idealfrobenius
1
1
idealfrobenius
GGG
1
gen
idealhnf
1
1
idealhnf0
GGDG
1
gen
idealintersect
1
1
idealintersect
GGG
1
gen
idealinv
2
0
1
idealinv(${1 code}, ${2 code})
2
gen
gen
1
gen
1
idealinv
GG
1
gen
idealismaximal
1
1
idealismaximal
GG
1
gen
idealispower
1
1
idealispower
GGLD&
1
small
ideallist
1
1
gideallist
GGD4,L,
1
gen
ideallistarch
1
1
ideallistarch
GGG
1
gen
ideallog
1
1
ideallog
DGGG
1
gen
idealmin
1
1
idealmin
GGDG
1
gen
idealmul
2
0
4
idealmul(${1 code}, ${2 code}, ${3 code})
4
gen
gen
gen
?0
1
gen
idealmulred(${1 code}, ${2 code}, ${3 code})
4
gen
gen
gen
1
1
gen
$"invalid flag in idealmul"
4
gen
gen
gen
#small
1
gen
idealmul0(${1 code}, ${2 code}, ${3 code}, ${4 code})
4
gen
gen
gen
small
1
gen
1
idealmul0
GGGD0,L,
1
gen
idealnorm
1
1
idealnorm
GG
1
gen
idealnumden
1
1
idealnumden
GG
1
gen
idealpow
1
1
idealpow0
GGGD0,L,
1
gen
idealprimedec
2
0
2
idealprimedec(${1 code}, ${2 code})
2
gen
gen
1
vec
idealprimedec_limit_f(${1 code}, ${2 code}, ${3 code})
3
gen
gen
?small
1
vec
1
idealprimedec_limit_f
GGD0,L,
1
gen
idealprincipalunits
1
1
idealprincipalunits
GGL
1
gen
idealramgroups
1
1
idealramgroups
GGG
1
gen
idealred
1
1
idealred0
GGDG
1
gen
idealredmodpower
1
1
idealredmodpower
GGUD0,U,
1
gen
idealstar
1
1
idealstarmod
DGGD1,L,DG
1
gen
idealtwoelt
1
1
idealtwoelt0
GGDG
1
gen
idealval
1
1
gpidealval
GGG
1
gen
if
1
1
ifpari
GDEDE
1
gen
iferr
1
1
iferrpari
EVEDE
1
gen
imag
1
1
gimag
G
1
gen
incgam
1
1
incgam0
GGDGp
2
gen
prec
incgamc
1
1
incgamc
GGp
2
gen
prec
inline
0
input
1
1
gp_input

1
gen
install
1
1
gpinstall
rrD"",r,D"",s,
1
void
intcirc
3
0
1
intcirc(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${4 code}, ${prec})
4
gen
gen
gen
?gen
2
gen
prec
1
intcirc0
V=GGEDGp
2
gen
prec
2
3


_wrap_G
intformal
1
1
integ
GDn
1
gen
intfuncinit
3
0
1
intfuncinit(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${4 code}, ${prec})
4
gen
gen
gen
?small
2
gen
prec
1
intfuncinit0
V=GGED0,L,p
2
gen
prec
2
3


_wrap_G
intnum
3
0
1
intnum(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${4 code}, ${prec})
4
gen
gen
gen
?gen
2
gen
prec
1
intnum0
V=GGEDGp
2
gen
prec
2
3


_wrap_G
intnumgauss
3
0
1
intnumgauss(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${4 code}, ${prec})
4
gen
gen
gen
?gen
2
gen
prec
1
intnumgauss0
V=GGEDGp
2
gen
prec
2
3


_wrap_G
intnumgaussinit
1
1
intnumgaussinit
D0,L,p
2
gen
prec
intnuminit
1
1
intnuminit
GGD0,L,p
2
gen
prec
intnumosc
1
1
intnumosc0
V=GEGD0,L,DGp
2
gen
prec
intnumromb
3
0
1
intnumromb(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${4 code}, ${bitprec})
4
gen
gen
gen
?small
2
gen
prec
1
intnumromb0
V=GGED0,L,b
2
gen
prec
2
3


_wrap_G
isfundamental
2
0
2
Z_isfundamental(${1 code})
1
int
1
bool
isfundamental(${1 code})
1
gen
1
bool
1
isfundamental
G
1
small
ispolygonal
1
1
ispolygonal
GGD&
1
small
ispower
2
0
2
Z_isanypower(${1 code}, NULL)
1
int
1
small
Z_isanypower(${1 code}, &${2 code})
2
int
&int
1
small
1
ispower
GDGD&
1
small
ispowerful
1
1
ispowerful
G
1
small
isprime
2
0
2
isprime(${1 code})
2
int
?0
1
bool
gisprime(${1 code}, ${2 code})
2
gen
?small
1
gen
1
gisprime
GD0,L,
1
gen
isprimepower
1
1
isprimepower
GD&
1
small
ispseudoprime
2
0
4
BPSW_psp(${1 code})
2
int
?0
1
bool
millerrabin(${1 code},${2 code})
2
int
#small
1
bool
ispseudoprime(${1 code}, ${2 code})
2
int
small
1
bool
gispseudoprime(${1 code}, ${2 code})
2
gen
?small
1
gen
1
gispseudoprime
GD0,L,
1
gen
ispseudoprimepower
1
1
ispseudoprimepower
GD&
1
small
issquare
2
0
4
Z_issquare(${1 code})
1
int
1
bool
issquare(${1 code})
1
gen
1
bool
Z_issquareall(${1 code}, &${2 code})
2
int
&int
1
bool
issquareall(${1 code}, &${2 code})
2
gen
&gen
1
bool
1
issquareall
GD&
1
small
issquarefree
2
0
1
issquarefree(${1 code})
1
gen
1
bool
1
issquarefree
G
1
small
istotient
1
1
istotient
GD&
1
small
kill
1
1
kill0
r
1
void
kronecker
2
0
4
kross(${1 code}, ${2 code})
2
small
small
1
small
krois(${1 code}, ${2 code})
2
int
small
1
small
krosi(${1 code}, ${2 code})
2
small
int
1
small
kronecker(${1 code}, ${2 code})
2
gen
gen
1
small
1
kronecker
GG
1
small
lambertw
1
1
glambertW
GD0,L,p
2
gen
prec
laurentseries
1
1
laurentseries0
GDPDnp
2
gen
prec
lcm
2
0
3
lcmii(${1 code}, ${2 code})
2
int
int
1
int
glcm0(${1 code}, NULL)
1
gen
1
gen
glcm(${1 code}, ${2 code})
2
gen
gen
1
gen
1
glcm0
GDG
1
gen
length
2
0
4
lg(${1 code})
1
vecsmall
1
lg
lg(${1 code})
1
vec
1
lg
lgpol(${1 code})
1
pol
1
small
glength(${1 code})
1
gen
1
small
1
glength
G
1
small
lerchphi
1
1
lerchphi
GGGp
2
gen
prec
lerchzeta
1
1
lerchzeta
GGGp
2
gen
prec
lex
1
1
lexcmp
GG
1
small_int
lfun
2
0
3
lfun(${1 code}, ${2 code}, ${bitprec})
2
gen
gen
2
gen
prec
lfun(${1 code}, ${2 code}, ${bitprec})
3
gen
gen
?0
2
gen
prec
lfun0(${1 code}, ${2 code}, ${3 code}, ${bitprec})
3
gen
gen
small
2
gen
prec
1
lfun0
GGD0,L,b
2
gen
prec
lfunan
1
1
lfunan
GLp
2
gen
prec
lfunartin
1
1
lfunartin
GGGLb
2
gen
prec
lfuncheckfeq
1
1
lfuncheckfeq
GDGb
2
small
prec
lfunconductor
1
1
lfunconductor
GDGD0,L,b
2
gen
prec
lfuncost
1
1
lfuncost0
GDGD0,L,b
2
gen
prec
lfuncreate
1
1
lfuncreate
G
1
gen
lfundiv
1
1
lfundiv
GGb
2
gen
prec
lfundual
1
1
lfundual
Gb
2
gen
prec
lfunetaquo
1
1
lfunetaquo
G
1
gen
lfuneuler
1
1
lfuneuler
GGp
2
gen
prec
lfungenus2
1
1
lfungenus2
G
1
gen
lfunhardy
1
1
lfunhardy
GGb
2
gen
prec
lfunhgm
1
1
lfunhgm
GGDGb
2
gen
prec
lfuninit
1
1
lfuninit0
GGD0,L,b
2
gen
prec
lfunlambda
1
1
lfunlambda0
GGD0,L,b
2
gen
prec
lfunmf
1
1
lfunmf
GDGb
2
gen
prec
lfunmfspec
1
1
lfunmfspec
Gb
2
gen
prec
lfunmul
1
1
lfunmul
GGb
2
gen
prec
lfunorderzero
1
1
lfunorderzero
GD-1,L,b
2
small
prec
lfunparams
1
1
lfunparams
Gp
2
gen
prec
lfunqf
1
1
lfunqf
Gp
2
gen
prec
lfunrootres
1
1
lfunrootres
Gb
2
gen
prec
lfunshift
1
1
lfunshift
GGD0,L,b
2
gen
prec
lfunsympow
1
1
lfunsympow
GU
1
gen
lfuntheta
1
1
lfuntheta
GGD0,L,b
2
gen
prec
lfunthetacost
1
1
lfunthetacost0
GDGD0,L,b
2
small
prec
lfunthetainit
1
1
lfunthetainit
GDGD0,L,b
2
gen
prec
lfuntwist
1
1
lfuntwist
GGb
2
gen
prec
lfunzeros
1
1
lfunzeros
GGD8,L,b
2
gen
prec
lift
2
0
6
lift(${1 code})
1
pol
1
pol
lift(${1 code})
1
vec
1
vec
lift(${1 code})
1
gen
1
gen
lift0(${1 code}, ${2 code})
2
pol
var
1
pol
lift0(${1 code}, ${2 code})
2
vec
var
1
vec
lift0(${1 code}, ${2 code})
2
gen
var
1
gen
1
lift0
GDn
1
gen
liftall
2
0
3
liftall(${1 code})
1
pol
1
pol
liftall(${1 code})
1
vec
1
vec
liftall(${1 code})
1
gen
1
gen
1
liftall
G
1
gen
liftint
2
0
3
liftint(${1 code})
1
pol
1
pol
liftint(${1 code})
1
vec
1
vec
liftint(${1 code})
1
gen
1
gen
1
liftint
G
1
gen
liftpol
2
0
3
liftpol(${1 code})
1
pol
1
pol
liftpol(${1 code})
1
vec
1
vec
liftpol(${1 code})
1
gen
1
gen
1
liftpol
G
1
gen
limitnum
1
1
limitnum0
GDGp
2
gen
prec
lindep
1
1
lindep0
GD0,L,
1
gen
listcreate
2
0
1
mklist()
1
?gen
1
list
1
listcreate_gp
D0,L,
1
gen
listinsert
2
0
1
listinsert(${1 code}, ${2 code}, ${3 code})
3
list
gen
small
1
gen
1
listinsert0
WGL
2
gen
copy
listkill
1
1
listkill
W
1
void
listpop
2
0
1
listpop(${1 code}, ${2 code})
2
list
small
1
void
1
listpop0
WD0,L,
1
void
listput
2
0
1
listput(${1 code}, ${2 code}, ${3 code})
3
list
gen
small
1
gen
1
listput0
WGD0,L,
2
gen
copy
listsort
1
1
listsort
WD0,L,
1
void
lngamma
1
1
glngamma
Gp
2
gen
prec
local
0
localbitprec
1
1
localbitprec
G
1
void
localprec
1
1
localprec
G
1
void
log
2
0
1
glog(${1 code}, ${prec})
1
gen
2
gen
prec
1
glog
Gp
2
gen
prec
log1p
1
1
glog1p
Gp
2
gen
prec
logint
2
0
3
expi(${1 code})
2
int
2
1
small
logint0(${1 code}, ${2 code}, NULL)
2
gen
gen
1
small
logint0(${1 code}, ${2 code}, &${3 code})
3
gen
gen
&int
1
small
1
logint0
GGD&
1
small
mapapply
1
1
mapapply
WGGDG
1
gen
mapdelete
1
1
mapdelete
WG
1
void
mapget
1
1
mapget
GG
1
gen
mapisdefined
1
1
mapisdefined
GGD&
1
small_int
mapput
1
1
mapput
WGG
1
void
matadjoint
1
1
matadjoint0
GD0,L,
1
gen
matalgtobasis
1
1
matalgtobasis
GG
1
gen
matbasistoalg
1
1
matbasistoalg
GG
1
gen
matcompanion
1
1
matcompanion
G
1
gen
matconcat
1
1
matconcat
G
1
gen
matdet
2
0
4
det(${1 code})
2
gen
?0
1
gen
det2(${1 code})
2
gen
1
1
gen
$"incorrect flag in matdet"
2
gen
#small
1
gen
det0(${1 code}, ${2 code})
2
gen
small
1
gen
1
det0
GD0,L,
1
gen
matdetint
1
1
detint
G
1
gen
matdetmod
1
1
matdetmod
GG
1
gen
matdiagonal
1
1
diagonal
G
1
gen
mateigen
1
1
mateigen
GD0,L,p
2
gen
prec
matfrobenius
1
1
matfrobenius
GD0,L,Dn
1
gen
mathess
1
1
hess
G
1
gen
mathilbert
1
1
mathilbert
L
1
gen
mathnf
1
1
mathnf0
GD0,L,
1
gen
mathnfmod
1
1
hnfmod
GG
1
gen
mathnfmodid
1
1
hnfmodid
GG
1
gen
mathouseholder
1
1
mathouseholder
GG
1
gen
matid
2
0
1
matid(${1 code})
1
small
1
vec
1
matid
L
1
gen
matimage
2
0
4
image(${1 code})
2
gen
?0
1
vec
image2(${1 code})
2
gen
1
1
vec
$"incorrect flag in matimage"
2
gen
#small
0
matimage0(${1 code}, ${2 code})
2
gen
small
1
vec
1
matimage0
GD0,L,
1
gen
matimagecompl
2
0
1
imagecompl(${1 code})
1
gen
1
vecsmall
1
imagecompl
G
1
gen
matimagemod
1
1
matimagemod
GGD&
1
gen
matindexrank
2
0
1
indexrank(${1 code})
1
gen
1
vecvecsmall
1
indexrank
G
1
gen
matintersect
1
1
intersect
GG
1
gen
matinverseimage
1
1
inverseimage
GG
1
gen
matinvmod
1
1
matinvmod
GG
1
gen
matisdiagonal
1
1
isdiagonal
G
1
small_int
matker
2
0
4
ker(${1 code})
2
gen
?0
1
vec
ZM_ker(${1 code})
2
gen
1
1
vec
$"incorrect flag in matker"
2
gen
#small
0
matker0(${1 code}, ${2 code})
2
gen
small
1
vec
1
matker0
GD0,L,
1
gen
matkerint
1
1
matkerint0
GD0,L,
1
gen
matkermod
1
1
matkermod
GGD&
1
gen
matmuldiagonal
1
1
matmuldiagonal
GG
1
gen
matmultodiagonal
1
1
matmultodiagonal
GG
1
gen
matpascal
1
1
matqpascal
LDG
1
gen
matpermanent
1
1
matpermanent
G
1
gen
matqr
1
1
matqr
GD0,L,p
2
gen
prec
matrank
1
1
rank
G
1
small
matreduce
1
1
matreduce
G
1
gen
matrix
1
1
matrice
GDGDVDVDE
1
gen
matrixqz
1
1
matrixqz0
GDG
1
gen
matsize
1
1
matsize
G
1
gen
matsnf
1
1
matsnf0
GD0,L,
1
gen
matsolve
1
1
gauss
GG
1
gen
matsolvemod
1
1
matsolvemod
GGGD0,L,
1
gen
matsupplement
1
1
suppl
G
1
gen
mattranspose
1
1
gtrans
G
1
gen
max
2
0
10
maxss(${1 code}, ${2 code})
2
small
small
1
small
gmaxsg(${1 code}, ${2 code})
2
small
int
1
int
gmaxgs(${1 code}, ${2 code})
2
int
small
1
int
gmax(${1 code}, ${2 code})
2
int
int
1
int
gmaxsg(${1 code}, ${2 code})
2
small
mp
1
mp
gmaxgs(${1 code}, ${2 code})
2
mp
small
1
mp
gmax(${1 code}, ${2 code})
2
mp
mp
1
mp
gmaxsg(${1 code}, ${2 code})
2
small
gen
1
gen
gmaxgs(${1 code}, ${2 code})
2
gen
small
1
gen
gmax(${1 code}, ${2 code})
2
gen
gen
1
gen
1
gmax
GG
1
gen
mfDelta
1
1
mfDelta

1
gen
mfEH
1
1
mfEH
G
1
gen
mfEk
1
1
mfEk
L
1
gen
mfTheta
1
1
mfTheta
DG
1
gen
mfatkin
1
1
mfatkin
GG
1
gen
mfatkineigenvalues
1
1
mfatkineigenvalues
GLp
2
gen
prec
mfatkininit
1
1
mfatkininit
GLp
2
gen
prec
mfbasis
1
1
mfbasis
GD4,L,
1
gen
mfbd
1
1
mfbd
GL
1
gen
mfbracket
1
1
mfbracket
GGD0,L,
1
gen
mfcoef
1
1
mfcoef
GL
1
gen
mfcoefs
1
1
mfcoefs
GLD1,L,
1
gen
mfconductor
1
1
mfconductor
GG
1
small
mfcosets
1
1
mfcosets
G
1
gen
mfcuspisregular
1
1
mfcuspisregular
GG
1
small
mfcusps
1
1
mfcusps
G
1
gen
mfcuspval
1
1
mfcuspval
GGGb
2
gen
prec
mfcuspwidth
1
1
mfcuspwidth
GG
1
small
mfderiv
1
1
mfderiv
GD1,L,
1
gen
mfderivE2
1
1
mfderivE2
GD1,L,
1
gen
mfdescribe
1
1
mfdescribe
GD&
1
gen
mfdim
1
1
mfdim
GD4,L,
1
gen
mfdiv
1
1
mfdiv
GG
1
gen
mfeigenbasis
1
1
mfeigenbasis
G
1
gen
mfeigensearch
1
1
mfeigensearch
GDG
1
gen
mfeisenstein
1
1
mfeisenstein
LDGDG
1
gen
mfembed
1
1
mfembed0
GDGp
2
gen
prec
mfeval
1
1
mfeval
GGGb
2
gen
prec
mffields
1
1
mffields
G
1
gen
mffromell
1
1
mffromell
G
1
gen
mffrometaquo
1
1
mffrometaquo
GD0,L,
1
gen
mffromlfun
1
1
mffromlfun
Gp
2
gen
prec
mffromqf
1
1
mffromqf
GDG
1
gen
mfgaloisprojrep
1
1
mfgaloisprojrep
GGp
2
gen
prec
mfgaloistype
1
1
mfgaloistype
GDG
1
gen
mfhecke
1
1
mfhecke
GGL
1
gen
mfheckemat
1
1
mfheckemat
GG
1
gen
mfinit
1
1
mfinit
GD4,L,
1
gen
mfisCM
1
1
mfisCM
G
1
gen
mfisequal
1
1
mfisequal
GGD0,L,
1
small
mfisetaquo
1
1
mfisetaquo
GD0,L,
1
gen
mfkohnenbasis
1
1
mfkohnenbasis
G
1
gen
mfkohnenbijection
1
1
mfkohnenbijection
G
1
gen
mfkohneneigenbasis
1
1
mfkohneneigenbasis
GG
1
gen
mflinear
1
1
mflinear
GG
1
gen
mfmanin
1
1
mfmanin
Gb
2
gen
prec
mfmul
1
1
mfmul
GG
1
gen
mfnumcusps
1
1
mfnumcusps
G
1
gen
mfparams
1
1
mfparams
G
1
gen
mfperiodpol
1
1
mfperiodpol
GGD0,L,b
2
gen
prec
mfperiodpolbasis
1
1
mfperiodpolbasis
LD0,L,
1
gen
mfpetersson
1
1
mfpetersson
GDG
1
gen
mfpow
1
1
mfpow
GL
1
gen
mfsearch
1
1
mfsearch
GGD4,L,
1
gen
mfshift
1
1
mfshift
GL
1
gen
mfshimura
1
1
mfshimura
GGD1,L,
1
gen
mfslashexpansion
1
1
mfslashexpansion
GGGLLD&p
2
gen
prec
mfspace
1
1
mfspace
GDG
1
small
mfsplit
1
1
mfsplit
GD0,L,D0,L,
1
gen
mfsturm
1
1
mfsturm
G
1
small
mfsymbol
1
1
mfsymbol
GDGb
2
gen
prec
mfsymboleval
1
1
mfsymboleval
GGDGb
2
gen
prec
mftaylor
1
1
mftaylor
GLD0,L,p
2
gen
prec
mftobasis
1
1
mftobasis
GGD0,L,
1
gen
mftocoset
1
1
mftocoset
UGG
1
gen
mftonew
1
1
mftonew
GG
1
gen
mftraceform
1
1
mftraceform
GD0,L,
1
gen
mftwist
1
1
mftwist
GG
1
gen
min
2
0
10
minss(${1 code}, ${2 code})
2
small
small
1
small
gminsg(${1 code}, ${2 code})
2
small
int
1
int
gmings(${1 code}, ${2 code})
2
int
small
1
int
gmin(${1 code}, ${2 code})
2
int
int
1
int
gminsg(${1 code}, ${2 code})
2
small
mp
1
mp
gmings(${1 code}, ${2 code})
2
mp
small
1
mp
gmin(${1 code}, ${2 code})
2
mp
mp
1
mp
gminsg(${1 code}, ${2 code})
2
small
gen
1
gen
gmings(${1 code}, ${2 code})
2
gen
small
1
gen
gmin(${1 code}, ${2 code})
2
gen
gen
1
gen
1
gmin
GG
1
gen
minpoly
1
1
minpoly
GDn
1
gen
modreverse
1
1
modreverse
G
1
gen
moebius
1
1
moebius
G
1
small
msatkinlehner
1
1
msatkinlehner
GLDG
1
gen
mscosets
1
1
mscosets0
GG
1
gen
mscuspidal
1
1
mscuspidal
GD0,L,
1
gen
msdim
1
1
msdim
G
1
small
mseisenstein
1
1
mseisenstein
G
1
gen
mseval
1
1
mseval
GGDG
1
gen
msfarey
1
1
msfarey0
GGD&
1
gen
msfromcusp
1
1
msfromcusp
GG
1
gen
msfromell
1
1
msfromell
GD0,L,
1
gen
msfromhecke
1
1
msfromhecke
GGDG
1
gen
msgetlevel
1
1
msgetlevel
G
1
small
msgetsign
1
1
msgetsign
G
1
small
msgetweight
1
1
msgetweight
G
1
small
mshecke
1
1
mshecke
GLDG
1
gen
msinit
1
1
msinit
GGD0,L,
1
gen
msissymbol
1
1
msissymbol
GG
1
gen
mslattice
1
1
mslattice
GDG
1
gen
msnew
1
1
msnew
G
1
gen
msomseval
1
1
msomseval
GGG
1
gen
mspadicL
1
1
mspadicL
GDGD0,L,
1
gen
mspadicinit
1
1
mspadicinit
GLLD-1,L,
1
gen
mspadicmoments
1
1
mspadicmoments
GGD1,L,
1
gen
mspadicseries
1
1
mspadicseries
GD0,L,
1
gen
mspathgens
1
1
mspathgens
G
1
gen
mspathlog
1
1
mspathlog
GG
1
gen
mspetersson
1
1
mspetersson
GDGDG
1
gen
mspolygon
1
1
mspolygon
GD0,L,
1
gen
msqexpansion
1
1
msqexpansion
GGDP
1
gen
mssplit
1
1
mssplit
GDGD0,L,
1
gen
msstar
1
1
msstar
GDG
1
gen
mstooms
1
1
mstooms
GG
1
gen
my
0
newtonpoly
1
1
newtonpoly
GG
1
gen
next
1
1
next0
D1,L,
1
gen
nextprime
2
0
1
nextprime(${1 code})
1
gen
1
int
1
nextprime
G
1
gen
nfalgtobasis
1
1
algtobasis
GG
1
gen
nfbasis
1
1
nfbasis
GD&
1
gen
nfbasistoalg
1
1
basistoalg
GG
1
gen
nfcertify
1
1
nfcertify
G
1
gen
nfcompositum
1
1
nfcompositum
GGGD0,L,
1
gen
nfdetint
1
1
nfdetint
GG
1
gen
nfdisc
1
1
nfdisc
G
1
gen
nfdiscfactors
1
1
nfdiscfactors
G
1
gen
nfeltadd
1
1
nfadd
GGG
1
gen
nfeltdiv
1
1
nfdiv
GGG
1
gen
nfeltdiveuc
1
1
nfdiveuc
GGG
1
gen
nfeltdivmodpr
1
1
nfdivmodpr
GGGG
1
gen
nfeltdivrem
1
1
nfdivrem
GGG
1
gen
nfeltembed
1
1
nfeltembed
GGDGp
2
gen
prec
nfeltispower
1
1
nfispower
GGLD&
1
small
nfeltissquare
1
1
nfissquare
GGD&
1
small
nfeltmod
1
1
nfmod
GGG
1
gen
nfeltmul
1
1
nfmul
GGG
1
gen
nfeltmulmodpr
1
1
nfmulmodpr
GGGG
1
gen
nfeltnorm
1
1
nfnorm
GG
1
gen
nfeltpow
1
1
nfpow
GGG
1
gen
nfeltpowmodpr
1
1
nfpowmodpr
GGGG
1
gen
nfeltreduce
1
1
nfreduce
GGG
1
gen
nfeltreducemodpr
1
1
nfreducemodpr
GGG
1
gen
nfeltsign
1
1
nfeltsign
GGDG
1
gen
nfelttrace
1
1
nftrace
GG
1
gen
nfeltval
1
1
gpnfvalrem
GGGD&
1
gen
nffactor
1
1
nffactor
GG
1
gen
nffactorback
1
1
nffactorback
GGDG
1
gen
nffactormod
1
1
nffactormod
GGG
1
gen
nfgaloisapply
1
1
galoisapply
GGG
1
gen
nfgaloisconj
1
1
galoisconj0
GD0,L,DGp
2
gen
prec
nfgrunwaldwang
1
1
nfgrunwaldwang
GGGGDn
1
gen
nfhilbert
1
1
nfhilbert0
GGGDG
1
small
nfhnf
1
1
nfhnf0
GGD0,L,
1
gen
nfhnfmod
1
1
nfhnfmod
GGG
1
gen
nfinit
2
0
7
nfinit0(${1 code}, 0, ${prec})
2
gen
?0
2
nf
prec
nfinit0(${1 code}, nf_ORIG, ${prec})
2
gen
1
2
nf
prec
nfinit0(${1 code}, nf_RED, ${prec})
2
gen
2
2
nf
prec
nfinit0(${1 code}, nf_ORIG|nf_RED, ${prec})
2
gen
3
2
gen
prec
nfinit0(${1 code}, nf_NOLLL, ${prec})
2
gen
4
2
gen
prec
$"incorrect flag in nfinit"
2
gen
#small
1
void
nfinit0(${1 code}, ${2 code}, ${prec})
2
gen
small
2
gen
prec
1
nfinit0
GD0,L,p
2
gen
prec
nfisideal
1
1
isideal
GG
1
small
nfisincl
2
0
2
nfisincl(${1 code}, ${2 code})
3
gen
gen
?0
1
gen
nfisincl0(${1 code}, ${2 code}, ${3 code})
3
gen
gen
small
1
gen
1
nfisincl0
GGD0,L,
1
gen
nfisisom
1
1
nfisisom
GG
1
gen
nfislocalpower
1
1
nfislocalpower
GGGG
1
small
nfkermodpr
1
1
nfkermodpr
GGG
1
gen
nflist
1
1
nflist
GDGD-1,L,DG
1
gen
nfmodpr
1
1
nfmodpr
GGG
1
gen
nfmodprinit
1
1
nfmodprinit0
GGDn
1
gen
nfmodprlift
1
1
nfmodprlift
GGG
1
gen
nfnewprec
1
1
nfnewprec
Gp
2
gen
prec
nfpolsturm
1
1
nfpolsturm
GGDG
1
gen
nfresolvent
1
1
nfresolvent
GD0,L,
1
gen
nfroots
1
1
nfroots
DGG
1
gen
nfrootsof1
1
1
nfrootsof1
G
1
gen
nfsnf
1
1
nfsnf0
GGD0,L,
1
gen
nfsolvemodpr
1
1
nfsolvemodpr
GGGG
1
gen
nfsplitting
1
1
nfsplitting0
GDGD0,L,
1
gen
nfsubfields
1
1
nfsubfields0
GD0,L,D0,L,
1
gen
nfsubfieldscm
1
1
nfsubfieldscm
GD0,L,
1
gen
nfsubfieldsmax
1
1
nfsubfieldsmax
GD0,L,
1
gen
nfweilheight
1
1
nfweilheight
GGp
2
gen
prec
norm
1
1
gnorm
G
1
gen
norml2
1
1
gnorml2
G
1
gen
normlp
2
0
3
gsupnorm(${1 code}, ${prec})
1
gen
2
gen
prec
gsupnorm(${1 code}, ${prec})
2
gen

2
gen
prec
gnorml1(${1 code}, ${prec})
2
gen
1
2
gen
prec
1
gnormlp
GDGp
2
gen
prec
numbpart
1
1
numbpart
G
1
gen
numdiv
2
0
1
numdiv(${1 code})
1
gen
1
int
1
numdiv
G
1
gen
numerator
1
1
numerator
GDG
1
gen
numtoperm
2
0
2
Z_to_perm(${1 code}, ${2 code})
2
small
int
1
vecsmall
numtoperm(${1 code}, ${2 code})
2
small
gen
1
vecsmall
1
numtoperm
LG
1
gen
omega
1
1
omega
G
1
small
oo
1
1
mkoo

1
gen
padicappr
1
1
padicappr
GG
1
gen
padicfields
1
1
padicfields0
GGD0,L,
1
gen
padicprec
1
1
gppadicprec
GG
1
gen
parapply
1
1
parapply
GG
1
gen
pareval
1
1
pareval
G
1
gen
parfor
2
1
parfor0
V=GDGJDVDI
1
void
3
1
4
parfor
_parfor_init
_parfor_next
_parfor_stop
5
gen
gen
?gen
closure
?notype
0
parforeach
2
1
parforeach0
GVJDVDI
1
void
3
1
4
parforeach
_parforeach_init
_parforeach_next
_parforeach_stop
4
gen
gen
closure
?notype
0
parforprime
2
1
parforprime0
V=GDGJDVDI
1
void
3
1
4
parforprime
_parforprime_init
_parforprime_next
_parforprime_stop
5
gen
gen
?gen
closure
?notype
0
parforprimestep
2
1
parforprimestep0
V=GDGGJDVDI
1
void
3
1
4
parforprime
_parforprimestep_init
_parforprime_next
_parforprime_stop
6
gen
gen
gen
?gen
closure
?notype
0
parforstep
2
1
parforstep0
V=GDGGJDVDI
1
void
3
1
4
parforstep
_parforstep_init
_parforstep_next
_parforstep_stop
6
gen
?gen
gen
?gen
closure
?notype
0
parforvec
2
1
parforvec0
V=GJDVDID0,L,
1
void
3
1
4
parforvec
_parforvec_init
_parforvec_next
_parforvec_stop
5
vec
vec
closure
?notype
?small
0
parploth
2
0
1
parploth(${1 code}, ${2 code}, ${3 code}, ${4 code}, ${5 code}, ${prec})
5
gen
gen
closure
?small
?small
2
vec
prec
1
parploth
V=GGJD0,M,D0,L,p
2
gen
prec
parplothexport
2
0
1
parplothexport(${1 code}, ${2 code}, ${3 code}, ${4 code}, ${5 code}, ${6 code}, ${prec})
6
gen
gen
gen
closure
?small
?small
2
gen
prec
1
parplothexport
GV=GGJD0,M,D0,L,p
2
gen
prec
parselect
1
1
parselect
GGD0,L,
1
gen
parsum
2
0
1
parsum(${1 code}, ${2 code}, ${3 code})
3
gen
gen
closure
1
gen
1
parsum
V=GGJ
1
gen
partitions
2
0
1
partitions(${1 code}, ${2 code}, ${3 code})
3
small
?gen
?gen
1
vecvecsmall
1
partitions
LDGDG
1
gen
parvector
2
0
1
parvector(${1 code}, ${3 code})
3
small

closure
1
vec
1
parvector
LVJ
1
gen
permcycles
1
1
permcycles
G
1
gen
permorder
1
1
permorder
G
1
gen
permsign
1
1
permsign
G
1
small
permtonum
1
1
permtonum
G
1
gen
plot
3
0
1
pariplot(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${4 code}, ${5 code}, ${prec})
5
gen
gen
gen
?gen
?gen
2
void
prec
1
pariplot0
V=GGEDGDGp
2
void
prec
2
3


_wrap_G
plotarc
1
1
plotarc
LGGD0,L,
1
void
plotbox
1
1
plotbox
LGGD0,L,
1
void
plotclip
1
1
plotclip
L
1
void
plotcolor
1
1
plotcolor
LG
1
gen
plotcopy
1
1
plotcopy
LLGGD0,L,
1
void
plotcursor
1
1
plotcursor
L
1
gen
plotdraw
1
1
plotdraw
GD0,L,
1
void
plotexport
1
1
plotexport
GGD0,L,
1
gen
ploth
3
0
1
ploth(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${4 code}, ${5 code}, ${prec})
5
gen
gen
gen
?small
?small
2
gen
prec
1
ploth0
V=GGED0,M,D0,L,p
2
gen
prec
2
3


_wrap_G
plothexport
3
0
1
plothexport(${1 code}, ${4 cookie}, ${4 wrapper}, ${2 code}, ${3 code}, ${5 code}, ${6 code}, ${prec})
6
gen
gen
gen
gen
?small
?small
2
gen
prec
1
plothexport0
GV=GGED0,M,D0,L,p
2
gen
prec
2
4



_wrap_G
plothraw
1
1
plothraw
GGD0,L,
1
gen
plothrawexport
1
1
plothrawexport
GGGD0,L,
1
gen
plothsizes
1
1
plothsizes
D0,L,
1
gen
plotinit
1
1
plotinit
LDGDGD0,L,
1
void
plotkill
1
1
plotkill
L
1
void
plotlines
1
1
plotlines
LGGD0,L,
1
void
plotlinetype
1
1
plotlinetype
LL
1
void
plotmove
1
1
plotmove
LGG
1
void
plotpoints
1
1
plotpoints
LGG
1
void
plotpointsize
1
1
plotpointsize
LG
1
void
plotpointtype
1
1
plotpointtype
LL
1
void
plotrbox
1
1
plotrbox
LGGD0,L,
1
void
plotrecth
3
0
1
plotrecth(${4 cookie}, ${4 wrapper}, ${1 code}, ${2 code}, ${3 code}, ${5 code}, ${6 code}, ${prec})
6
small
gen
gen
gen
?small
?small
2
gen
prec
1
plotrecth0
LV=GGED0,M,D0,L,p
2
gen
prec
2
4



_wrap_G
plotrecthraw
1
1
plotrecthraw
LGD0,L,
1
gen
plotrline
1
1
plotrline
LGG
1
void
plotrmove
1
1
plotrmove
LGG
1
void
plotrpoint
1
1
plotrpoint
LGG
1
void
plotscale
1
1
plotscale
LGGGG
1
void
plotstring
1
1
plotstring
LsD0,L,
1
void
polchebyshev
2
0
3
polchebyshev1(${1 code},${3 code})
3
small
?1
?var
1
gen
polchebyshev2(${1 code},${3 code})
3
small
2
?var
1
gen
polchebyshev(${1 code},${2 code},${3 code})
3
small
small
?var
1
gen
1
polchebyshev_eval
LD1,L,DG
1
gen
polclass
1
1
polclass
GD0,L,Dn
1
gen
polcoef
2
0
5
constant_coeff(${1 code})
2
pol
0
2
gen
copy
constant_coeff(${1 code})
3
pol
0

2
gen
copy
RgX_coeff(${1 code}, ${2 code})
2
pol
small
2
gen
copy
RgX_coeff(${1 code}, ${2 code})
3
pol
small

2
gen
copy
polcoeff0(${1 code}, ${2 code}, ${3 code})
3
gen
small
?var
1
gen
1
polcoef
GLDn
1
gen
polcoeff
2
0
5
constant_coeff(${1 code})
2
pol
0
2
gen
copy
constant_coeff(${1 code})
3
pol
0

2
gen
copy
RgX_coeff(${1 code}, ${2 code})
2
pol
small
2
gen
copy
RgX_coeff(${1 code}, ${2 code})
3
pol
small

2
gen
copy
polcoef(${1 code}, ${2 code}, ${3 code})
3
gen
small
?var
1
gen
1
polcoef
GLDn
1
gen
polcompositum
1
1
polcompositum0
GGD0,L,
1
gen
polcyclo
2
0
2
polcyclo(${1 code},${2 code})
2
small
?var
1
gen
polcyclo_eval(${1 code},${2 code})
2
small
gen
1
gen
1
polcyclo_eval
LDG
1
gen
polcyclofactors
1
1
polcyclofactors
G
1
gen
poldegree
1
1
gppoldegree
GDn
1
gen
poldisc
2
0
2
poldisc0(${1 code}, -1)
1
gen
1
gen
poldisc0(${1 code}, ${2 code})
2
gen
var
1
gen
1
poldisc0
GDn
1
gen
poldiscfactors
1
1
poldiscfactors
GD0,L,
1
gen
poldiscreduced
1
1
reduceddiscsmith
G
1
gen
polfromroots
1
1
polfromroots
GDn
1
gen
polgalois
1
1
polgalois
Gp
2
gen
prec
polgraeffe
1
1
polgraeffe
G
1
gen
polhensellift
1
1
polhensellift
GGGL
1
gen
polhermite
2
0
2
polhermite(${1 code},${2 code})
2
small
?var
1
gen
polhermite_eval(${1 code},${2 code})
2
small
gen
1
gen
1
polhermite_eval0
LDGD0,L,
1
gen
polinterpolate
1
1
polint
GDGDGD&
1
gen
polisclass
1
1
polisclass
G
1
small
poliscyclo
1
1
poliscyclo
G
1
small
poliscycloprod
1
1
poliscycloprod
G
1
small
polisirreducible
1
1
polisirreducible
G
1
small
pollaguerre
1
1
pollaguerre_eval0
LDGDGD0,L,
1
gen
pollead
2
0
3
leading_coeff(${1 code})
1
pol
2
gen
copy
pollead(${1 code}, -1)
1
gen
1
gen
pollead(${1 code}, ${2 code})
2
gen
var
1
gen
1
pollead
GDn
1
gen
pollegendre
2
0
2
pollegendre(${1 code},${2 code})
2
small
?var
1
gen
pollegendre_eval(${1 code},${2 code})
2
small
gen
1
gen
1
pollegendre_eval0
LDGD0,L,
1
gen
polmodular
1
1
polmodular
LD0,L,DGDnD0,L,
1
gen
polrecip
1
1
polrecip
G
1
gen
polred
1
1
polred0
GD0,L,DG
1
gen
polredabs
1
1
polredabs0
GD0,L,
1
gen
polredbest
1
1
polredbest
GD0,L,
1
gen
polredord
1
1
polredord
G
1
gen
polresultant
1
1
polresultant0
GGDnD0,L,
1
gen
polresultantext
1
1
polresultantext0
GGDn
1
gen
polroots
2
0
1
roots(${1 code}, ${prec})
1
gen
2
vec
prec
1
roots
Gp
2
gen
prec
polrootsbound
1
1
polrootsbound
GDG
1
gen
polrootsff
1
1
polrootsff
GDGDG
1
gen
polrootsmod
1
1
polrootsmod
GDG
1
gen
polrootspadic
1
1
polrootspadic
GGL
1
gen
polrootsreal
2
0
1
realroots(${1 code}, ${2 code}, ${prec})
2
gen
?gen
2
vec
prec
1
realroots
GDGp
2
gen
prec
polsturm
1
1
sturmpart
GDGDG
1
small
polsubcyclo
1
1
polsubcyclo
LLDn
1
gen
polsubcyclofast
1
1
polsubcyclofast
GLD0,L,D0,L,
1
gen
polsylvestermatrix
1
1
sylvestermatrix
GG
1
gen
polsym
1
1
polsym
GL
1
gen
poltchebi
1
1
polchebyshev1
LDn
1
gen
polteichmuller
1
1
polteichmuller
GUL
1
gen
poltomonic
1
1
poltomonic
GD&
1
gen
poltschirnhaus
1
1
tschirnhaus
G
1
gen
polylog
1
1
polylog0
LGD0,L,p
2
gen
prec
polylogmult
1
1
polylogmult_interpolate
GDGDGp
2
gen
prec
polzagier
1
1
polzag
LL
1
gen
powers
2
0
1
gpowers(${1 code}, ${2 code})
2
gen
small
1
vec
1
gpowers0
GLDG
1
gen
precision
1
1
precision00
GDG
1
gen
precprime
2
0
1
precprime(${1 code})
1
gen
1
int
1
precprime
G
1
gen
prime
1
1
prime
L
1
gen
primecert
1
1
primecert0
GD0,L,D0,L,
1
gen
primecertexport
1
1
primecertexport
GD0,L,
1
gen
primecertisvalid
1
1
primecertisvalid
G
1
small
primepi
2
0
1
primepi(${1 code})
1
gen
1
int
1
primepi
G
1
gen
primes
1
1
primes0
G
1
gen
print
2
0
1
pari_printf("${2 format_string}\n"${2 format_args})
2
?gen
...
1
void
1
print
s*
1
void
print1
2
0
1
pari_printf("${2 format_string}"${2 format_args})
2
?gen
...
1
void
1
print1
s*
1
void
printf
1
1
printf0
ss*
1
void
printp
2
0
1
pari_printf("${2 format_string}\n"${2 format_args})
2
?gen
...
1
void
1
printp
s*
1
void
printsep
1
1
printsep
ss*
1
void
printsep1
1
1
printsep1
ss*
1
void
printtex
1
1
printtex
s*
1
void
prod
1
1
produit
V=GGEDG
1
gen
prodeuler
1
1
prodeuler0
V=GGEp
2
gen
prec
prodeulerrat
1
1
prodeulerrat
GDGD2,L,p
2
gen
prec
prodinf
3
0
2
prodinf(${2 cookie}, ${2 wrapper}, ${1 code}, ${prec})
3
gen
gen
?0
2
gen
prec
prodinf(${2 cookie}, ${2 wrapper}, ${1 code}, ${prec})
3
gen
gen
1
2
gen
prec
1
prodinf0
V=GED0,L,p
2
gen
prec
2
2

_wrap_G
prodnumrat
1
1
prodnumrat
GLp
2
gen
prec
psdraw
1
1
psdraw
GD0,L,
1
void
psi
1
1
gpsi_der
GD0,L,p
2
gen
prec
psploth
3
0
1
psploth(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${4 code}, ${5 code}, ${prec})
5
gen
gen
gen
?small
?small
2
gen
prec
1
psploth0
V=GGED0,M,D0,L,p
2
gen
prec
2
3


_wrap_G
psplothraw
1
1
psplothraw
GGD0,L,
1
gen
qfauto
1
1
qfauto0
GDG
1
gen
qfautoexport
1
1
qfautoexport
GD0,L,
1
gen
qfbclassno
1
1
qfbclassno0
GD0,L,
1
gen
qfbcomp
1
1
qfbcomp
GG
1
gen
qfbcompraw
1
1
qfbcompraw
GG
1
gen
qfbcornacchia
1
1
qfbcornacchia
GG
1
gen
qfbhclassno
1
1
hclassno
G
1
gen
qfbil
1
1
qfbil
GGDG
1
gen
qfbnucomp
1
1
nucomp
GGG
1
gen
qfbnupow
1
1
nupow
GGDG
1
gen
qfbpow
1
1
qfbpow
GG
1
gen
qfbpowraw
1
1
qfbpowraw
GL
1
gen
qfbprimeform
1
1
primeform
GG
1
gen
qfbred
1
1
qfbred0
GD0,L,DGDG
1
gen
qfbredsl2
1
1
qfbredsl2
GDG
1
gen
qfbsolve
1
1
qfbsolve
GGD0,L,
1
gen
qfcholesky
1
1
qfcholesky
Gp
2
gen
prec
qfcvp
1
1
qfcvp0
GGDGDGD0,L,
1
gen
qfeval
1
1
qfeval0
DGGDG
1
gen
qfgaussred
1
1
qfgaussred0
GD0,L,
1
gen
qfisom
1
1
qfisom0
GGDGDG
1
gen
qfisominit
1
1
qfisominit0
GDGDG
1
gen
qfjacobi
1
1
jacobi
Gp
2
gen
prec
qflll
2
0
7
lll(${1 code})
2
vec
?0
1
vec
lllintpartial(${1 code})
2
vec
2
1
vec
lllkerim(${1 code})
2
vec
4
1
vec
lllkerimgen(${1 code})
2
vec
5
1
vec
lllgen(${1 code})
2
vec
8
1
vec
$"Bad flag in qflll"
2
vec
#small
1
vec
qflll0(${1 code}, ${2 code})
2
vec
small
1
vec
1
qflll0
GD0,L,
1
gen
qflllgram
1
1
qflllgram0
GD0,L,
1
gen
qfminim
1
1
qfminim0
GDGDGD0,L,p
2
gen
prec
qfminimize
1
1
qfminimize
G
1
gen
qfnorm
1
1
qfnorm
GDG
1
gen
qforbits
1
1
qforbits
GG
1
gen
qfparam
1
1
qfparam
GGD0,L,
1
gen
qfperfection
1
1
qfperfection
G
1
gen
qfrep
1
1
qfrep0
GGD0,L,
1
gen
qfsign
1
1
qfsign
G
1
gen
qfsolve
1
1
qfsolve
G
1
gen
quadclassunit
1
1
quadclassunit0
GD0,L,DGp
2
gen
prec
quaddisc
1
1
quaddisc
G
1
gen
quadgen
1
1
quadgen0
GDn
1
gen
quadhilbert
1
1
quadhilbert
Gp
2
gen
prec
quadpoly
1
1
quadpoly0
GDn
1
gen
quadray
1
1
quadray
GGp
2
gen
prec
quadregulator
1
1
quadregulator
Gp
2
gen
prec
quadunit
1
1
quadunit0
GDn
1
gen
quadunitindex
1
1
quadunitindex
GG
1
gen
quadunitnorm
1
1
quadunitnorm
G
1
small
quit
1
1
gp_quit
D0,L,
1
void
ramanujantau
1
1
ramanujantau
GD12,L,
1
gen
random
2
0
3
genrand(${1 code})
1
?int
1
int
genrand(${1 code})
1
real
1
real
genrand(${1 code})
1
gen
1
gen
1
genrand
DG
1
gen
randomprime
1
1
randomprime0
DGDG
1
gen
read
2
0
1
gp_read_file(${1 code})
1
str
1
gen
1
gp_read_file
D"",s,
1
gen
readstr
1
1
readstr
D"",s,
1
gen
readvec
2
0
1
gp_readvec_file(${1 code})
1
str
1
gen
1
gp_readvec_file
D"",s,
1
gen
real
1
1
greal
G
1
gen
removeprimes
1
1
removeprimes
DG
1
gen
return
1
1
return0
DG
1
gen
rnfalgtobasis
1
1
rnfalgtobasis
GG
1
gen
rnfbasis
1
1
rnfbasis
GG
1
gen
rnfbasistoalg
1
1
rnfbasistoalg
GG
1
gen
rnfcharpoly
1
1
rnfcharpoly
GGGDn
1
gen
rnfconductor
1
1
rnfconductor0
GGD0,L,
1
gen
rnfdedekind
1
1
rnfdedekind
GGDGD0,L,
1
gen
rnfdet
1
1
rnfdet
GG
1
gen
rnfdisc
1
1
rnfdiscf
GG
1
gen
rnfeltabstorel
1
1
rnfeltabstorel
GG
1
gen
rnfeltdown
1
1
rnfeltdown0
GGD0,L,
1
gen
rnfeltnorm
1
1
rnfeltnorm
GG
1
gen
rnfeltreltoabs
1
1
rnfeltreltoabs
GG
1
gen
rnfelttrace
1
1
rnfelttrace
GG
1
gen
rnfeltup
1
1
rnfeltup0
GGD0,L,
1
gen
rnfequation
1
1
rnfequation0
GGD0,L,
1
gen
rnfhnfbasis
1
1
rnfhnfbasis
GG
1
gen
rnfidealabstorel
1
1
rnfidealabstorel
GG
1
gen
rnfidealdown
1
1
rnfidealdown
GG
1
gen
rnfidealfactor
1
1
rnfidealfactor
GG
1
gen
rnfidealhnf
1
1
rnfidealhnf
GG
1
gen
rnfidealmul
1
1
rnfidealmul
GGG
1
gen
rnfidealnormabs
1
1
rnfidealnormabs
GG
1
gen
rnfidealnormrel
1
1
rnfidealnormrel
GG
1
gen
rnfidealprimedec
1
1
rnfidealprimedec
GG
1
gen
rnfidealreltoabs
1
1
rnfidealreltoabs0
GGD0,L,
1
gen
rnfidealtwoelt
1
1
rnfidealtwoelement
GG
1
gen
rnfidealup
1
1
rnfidealup0
GGD0,L,
1
gen
rnfinit
1
1
rnfinit0
GGD0,L,
1
gen
rnfisabelian
1
1
rnfisabelian
GG
1
small
rnfisfree
1
1
rnfisfree
GG
1
small
rnfislocalcyclo
1
1
rnfislocalcyclo
G
1
small
rnfisnorm
1
1
rnfisnorm
GGD0,L,
1
gen
rnfisnorminit
1
1
rnfisnorminit
GGD2,L,
1
gen
rnfkummer
1
1
rnfkummer
GDGp
2
gen
prec
rnflllgram
1
1
rnflllgram
GGGp
2
gen
prec
rnfnormgroup
1
1
rnfnormgroup
GG
1
gen
rnfpolred
1
1
rnfpolred
GGp
2
gen
prec
rnfpolredabs
1
1
rnfpolredabs
GGD0,L,
1
gen
rnfpolredbest
1
1
rnfpolredbest
GGD0,L,
1
gen
rnfpseudobasis
1
1
rnfpseudobasis
GG
1
gen
rnfsteinitz
1
1
rnfsteinitz
GG
1
gen
rootsof1
1
1
grootsof1
Lp
2
gen
prec
round
2
0
9
${1 code}
1
small
2
small
parens
${1 code}
1
int
3
int
copy
parens
roundr(${1 code})
1
real
1
int
mpround(${1 code})
1
mp
1
int
grndtoi(${1 code}, &${2 code})
2
mp
&small
1
int
round0(${1 code}, &${2 code})
2
mp
&int
1
int
ground(${1 code})
1
gen
1
gen
grndtoi(${1 code}, &${2 code})
2
gen
&small
1
gen
round0(${1 code}, &${2 code})
2
gen
&int
1
gen
1
round0
GD&
1
gen
select
3
0
3
genselect(${1 cookie}, ${1 wrapper}, ${2 code})
2
gen
gen
1
gen
genselect(${1 cookie}, ${1 wrapper}, ${2 code})
3
gen
gen
0
1
gen
genindexselect(${1 cookie}, ${1 wrapper}, ${2 code})
3
gen
gen
1
1
vecsmall
1
select0
GGD0,L,
1
gen
2
1
_wrap_bG
self
1
1
pari_self

2
gen
copy
seralgdep
1
1
seralgdep
GLL
1
gen
serchop
1
1
serchop
GD0,L,
1
gen
serconvol
1
1
convol
GG
1
gen
serdiffdep
1
1
serdiffdep
GLL
1
gen
serlaplace
1
1
laplace
G
1
gen
serprec
1
1
gpserprec
Gn
1
gen
serreverse
1
1
serreverse
G
1
gen
setbinop
1
1
setbinop
GGDG
1
gen
setdebug
1
1
setdebug
DsD-1,L,
1
gen
setdelta
2
0
1
setdelta(${1 code}, ${2 code})
2
vec
vec
1
vec
1
setdelta
GG
1
gen
setintersect
2
0
1
setintersect(${1 code}, ${2 code})
2
vec
vec
1
vec
1
setintersect
GG
1
gen
setisset
1
1
setisset
G
1
small
setminus
2
0
1
setminus(${1 code}, ${2 code})
2
vec
vec
1
vec
1
setminus
GG
1
gen
setrand
1
1
setrand
G
1
void
setsearch
1
1
setsearch
GGD0,L,
1
small
setunion
2
0
1
setunion(${1 code}, ${2 code})
2
vec
vec
1
vec
1
setunion
GG
1
gen
shift
1
1
gshift
GL
1
gen
shiftmul
1
1
gmul2n
GL
1
gen
sigma
2
0
2
sumdiv(${1 code})
2
gen
?1
1
int
numdiv(${1 code})
2
gen
0
1
int
1
sumdivk
GD1,L,
1
gen
sign
2
0
2
signe(${1 code})
1
mp
1
small
gsigne(${1 code})
1
gen
1
small
1
gsigne
G
1
small_int
simplify
1
1
simplify
G
1
gen
sin
2
0
3
mpsin(${1 code})
1
real
1
real
gsin(${1 code}, ${prec})
1
mp
2
real
prec
gsin(${1 code}, ${prec})
1
gen
2
gen
prec
1
gsin
Gp
2
gen
prec
sinc
2
0
2
gsinc(${1 code}, ${prec})
1
mp
2
real
prec
gsinc(${1 code}, ${prec})
1
gen
2
gen
prec
1
gsinc
Gp
2
gen
prec
sinh
2
0
2
gsinh(${1 code}, ${prec})
1
mp
2
real
prec
gsinh(${1 code}, ${prec})
1
gen
2
gen
prec
1
gsinh
Gp
2
gen
prec
sizebyte
1
1
gsizebyte
G
1
small
sizedigit
1
1
sizedigit
G
1
small
snfrank
1
1
snfrank
GDG
1
small
solve
3
0
1
zbrent(${3 cookie}, ${3 wrapper}, ${1 code}, ${2 code}, ${prec})
3
gen
gen
gen
2
gen
prec
1
zbrent0
V=GGEp
2
gen
prec
2
3


_wrap_G
solvestep
3
0
1
solvestep(${4 cookie}, ${4 wrapper}, ${1 code}, ${2 code}, ${3 code}, ${5 code}, ${prec})
5
gen
gen
gen
gen
?small
2
gen
prec
1
solvestep0
V=GGGED0,L,p
2
gen
prec
2
4



_wrap_G
sqr
2
0
5
sqru(${1 code})
1
usmall
1
int
sqrs(${1 code})
1
small
1
int
sqri(${1 code})
1
int
1
int
gsqr(${1 code})
1
mp
1
mp
gsqr(${1 code})
1
gen
1
gen
1
gsqr
G
1
gen
sqrt
2
0
2
sqrtr(${1 code})
1
real
1
gen
gsqrt(${1 code}, ${prec})
1
gen
2
gen
prec
1
gsqrt
Gp
2
gen
prec
sqrtint
2
0
1
sqrtint(${1 code})
1
gen
1
int
1
sqrtint0
GD&
1
gen
sqrtn
1
1
gsqrtn
GGD&p
2
gen
prec
sqrtnint
2
0
1
sqrtnint(${1 code}, ${2 code})
2
gen
small
1
int
1
sqrtnint
GL
1
gen
stirling
1
1
stirling
LLD1,L,
1
gen
strchr
1
1
pari_strchr
G
1
gen
strexpand
1
1
strexpand
s*
1
gen
strjoin
1
1
strjoin
GDG
1
gen
strprintf
1
1
strprintf
ss*
1
gen
strsplit
1
1
strsplit
GDG
1
gen
strtex
1
1
strtex
s*
1
gen
strtime
1
1
strtime
L
1
gen
subcyclohminus
1
1
subcyclohminus
GDG
1
gen
subcycloiwasawa
1
1
subcycloiwasawa
GGD0,L,
1
gen
subcyclopclgp
1
1
subcyclopclgp
GGD0,L,
1
gen
subgrouplist
1
1
subgrouplist0
GDGD0,L,
1
gen
subst
1
1
gsubst
GnG
1
gen
substpol
1
1
gsubstpol
GGG
1
gen
substvec
1
1
gsubstvec
GGG
1
gen
sum
1
1
somme
V=GGEDG
1
gen
sumalt
3
0
2
sumalt(${2 cookie}, ${2 wrapper}, ${1 code}, ${prec})
3
gen
gen
?0
2
gen
prec
sumalt2(${2 cookie}, ${2 wrapper}, ${1 code}, ${prec})
3
gen
gen
1
2
gen
prec
1
sumalt0
V=GED0,L,p
2
gen
prec
2
2

_wrap_G
sumdedekind
1
1
sumdedekind
GG
1
gen
sumdigits
1
1
sumdigits0
GDG
1
gen
sumdiv
1
1
sumdivexpr
GVE
1
gen
sumdivmult
3
0
1
sumdivmultexpr(${3 cookie}, ${3 wrapper}, ${1 code})
3
gen

gen
1
gen
1
sumdivmultexpr0
GVE
1
gen
2
3


_wrap_G
sumeulerrat
1
1
sumeulerrat
GDGD2,L,p
2
gen
prec
sumformal
1
1
sumformal
GDn
1
gen
suminf
3
0
1
suminf(${2 cookie}, ${2 wrapper}, ${1 code}, ${prec})
2
gen
gen
2
gen
prec
1
suminf0
V=GEb
2
gen
prec
2
2

_wrap_G
sumnum
3
0
1
sumnum(${2 cookie}, ${2 wrapper}, ${1 code}, ${3 code}, ${prec})
3
gen
gen
?gen
2
gen
prec
1
sumnum0
V=GEDGp
2
gen
prec
2
2

_wrap_G
sumnumap
3
0
1
sumnumap(${2 cookie}, ${2 wrapper}, ${1 code}, ${3 code}, ${prec})
3
gen
gen
?gen
2
gen
prec
1
sumnumap0
V=GEDGp
2
gen
prec
2
2

_wrap_G
sumnumapinit
1
1
sumnumapinit
DGp
2
gen
prec
sumnuminit
1
1
sumnuminit
DGp
2
gen
prec
sumnumlagrange
3
0
1
sumnumlagrange(${2 cookie}, ${2 wrapper}, ${1 code}, ${3 code}, ${prec})
3
gen
gen
?gen
2
gen
prec
1
sumnumlagrange0
V=GEDGp
2
gen
prec
2
2

_wrap_Gp
sumnumlagrangeinit
1
1
sumnumlagrangeinit
DGDGp
2
gen
prec
sumnummonien
3
0
1
sumnummonien(${2 cookie}, ${2 wrapper}, ${1 code}, ${3 code}, ${prec})
3
gen
gen
?gen
2
gen
prec
1
sumnummonien0
V=GEDGp
2
gen
prec
2
2

_wrap_G
sumnummonieninit
1
1
sumnummonieninit
DGDGDGp
2
gen
prec
sumnumrat
1
1
sumnumrat
GGp
2
gen
prec
sumnumsidi
3
0
1
sumnumsidi(${2 cookie}, ${2 wrapper}, ${1 code}, ${3 code}, ${prec})
3
gen
gen
?long
2
gen
prec
1
sumnumsidi0
V=GED1,L,p
2
gen
prec
2
2

_wrap_Gb
sumpos
3
0
2
sumpos(${2 cookie}, ${2 wrapper}, ${1 code}, ${prec})
3
gen
gen
?0
2
gen
prec
sumpos2(${2 cookie}, ${2 wrapper}, ${1 code}, ${prec})
3
gen
gen
1
2
gen
prec
1
sumpos0
V=GED0,L,p
2
gen
prec
2
2

_wrap_G
system
1
1
gpsystem
s
1
small
tan
2
0
2
gtan(${1 code}, ${prec})
1
mp
2
real
prec
gtan(${1 code}, ${prec})
1
gen
2
gen
prec
1
gtan
Gp
2
gen
prec
tanh
2
0
2
gtanh(${1 code}, ${prec})
1
mp
2
real
prec
gtanh(${1 code}, ${prec})
1
gen
2
gen
prec
1
gtanh
Gp
2
gen
prec
taylor
1
1
tayl
GnDP
1
gen
teichmuller
1
1
teichmuller
GDG
1
gen
theta
1
1
theta
GGp
2
gen
prec
thetanullk
1
1
thetanullk
GLp
2
gen
prec
thue
1
1
thue
GGDG
1
gen
thueinit
1
1
thueinit
GD0,L,p
2
gen
prec
trace
1
1
gtrace
G
1
gen
trap
3
0
1
trap0(${1 code}, ${2 code}, ${3 code})
3
?str
?closure
?closure
1
gen
1
trap0
DrDEDE
1
gen
2
3

_
_
truncate
2
0
9
${1 code}
1
small
2
small
parens
${1 code}
1
int
3
int
copy
parens
truncr(${1 code})
1
real
1
int
mptrunc(${1 code})
1
mp
1
int
gcvtoi(${1 code}, &${2 code})
2
mp
&small
1
int
trunc0(${1 code}, &${2 code})
2
mp
&int
1
int
gtrunc(${1 code})
1
gen
1
gen
gcvtoi(${1 code}, &${2 code})
2
gen
&small
1
gen
trunc0(${1 code}, &${2 code})
2
gen
&int
1
gen
1
trunc0
GD&
1
gen
type
2
0
1
typ(${1 code})
1
gen
1
typ
1
type0
G
1
gen
unclone
1
0
2
(void)0 /*unclone*/
1
small
1
void
gunclone(${1 code})
1
gen
1
void
unexport
0
unexportall
1
1
unexportall

1
void
uninline
0
until
1
1
untilpari
EI
1
void
valuation
1
1
gpvaluation
GDG
1
gen
varhigher
1
1
varhigher
sDn
1
gen
variable
2
0
2
${1 :var cast}
1
pol
3
var
parens
copy
gpolvar(${1 code})
1
gen
1
gen
1
gpolvar
DG
1
gen
variables
1
1
variables_vec
DG
1
gen
varlower
1
1
varlower
sDn
1
gen
vecextract
2
0
1
extract0(${1 code}, ${2 code}, ${3 code})
3
vec
gen
?gen
1
vec
1
extract0
GGDG
1
gen
vecmax
2
0
2
vecmax(${1 code})
1
gen
1
gen
vecmax0(${1 code}, &${2 code})
2
gen
&gen
1
gen
1
vecmax0
GD&
1
gen
vecmin
2
0
2
vecmin(${1 code})
1
gen
1
gen
vecmin0(${1 code}, &${2 code})
2
gen
&gen
1
gen
1
vecmin0
GD&
1
gen
vecprod
1
1
vecprod
G
1
gen
vecsearch
1
1
vecsearch
GGDG
1
small
vecsort
2
0
16
vecsort0(${1 code}, ${2 code}, ${3 code})
3
vecsmall
?gen
?small
1
vecsmall
sort(${1 code})
3
vecvecsmall

?0
1
vecvecsmall
sort(${1 code})
3
vec

?0
1
vec
indexsort(${1 code})
3
vec

1
1
vecsmall
lexsort(${1 code})
3
vec

2
1
vec
vecsort0(${1 code}, ${2 code}, 0)
2
vec
gen
1
vec
vecsort0(${1 code}, ${2 code}, 1)
3
vec
?gen
1
1
vecsmall
vecsort0(${1 code}, ${2 code}, 3)
3
vec
?gen
3
1
vecsmall
vecsort0(${1 code}, ${2 code}, 5)
3
vec
?gen
5
1
vecsmall
vecsort0(${1 code}, ${2 code}, 7)
3
vec
?gen
7
1
vecsmall
vecsort0(${1 code}, ${2 code}, 9)
3
vec
?gen
9
1
vecsmall
vecsort0(${1 code}, ${2 code}, 11)
3
vec
?gen
11
1
vecsmall
vecsort0(${1 code}, ${2 code}, 13)
3
vec
?gen
13
1
vecsmall
vecsort0(${1 code}, ${2 code}, 15)
3
vec
?gen
15
1
vecsmall
vecsort0(${1 code}, ${2 code}, ${3 code})
3
vec
?gen
#small
1
vec
vecsort0(${1 code}, ${2 code}, ${3 code})
3
vec
?gen
small
1
gen
1
vecsort0
GDGD0,L,
1
gen
vecsum
1
1
vecsum
G
1
gen
vector
1
1
vecteur
GDVDE
1
gen
vectorsmall
1
1
vecteursmall
GDVDE
1
gen
vectorv
1
1
vvecteur
GDVDE
1
gen
version
1
1
pari_version

1
gen
warning
2
0
1
pari_warn(warnuser, mkvecn(${nbarg}, ${2 code}))
2
gen
...
1
void
1
warning0
s*
1
void
weber
1
1
weber0
GD0,L,p
2
gen
prec
whatnow
2
0
1
whatnow(${1 code}, 0)
1
str
1
void
1
whatnow0
r
1
void
while
1
1
whilepari
EI
1
void
write
1
1
write0
ss*
1
void
write1
1
1
write1
ss*
1
void
writebin
1
1
gpwritebin
sDG
1
void
writetex
1
1
writetex
ss*
1
void
zeta
1
1
gzeta
Gp
2
gen
prec
zetahurwitz
1
1
zetahurwitz
GGD0,L,b
2
gen
prec
zetamult
1
1
zetamult_interpolate
GDGp
2
gen
prec
zetamultall
1
1
zetamultall
LD0,L,p
2
gen
prec
zetamultconvert
1
1
zetamultconvert
GD1,L,
1
gen
zetamultdual
1
1
zetamultdual
G
1
gen
znchar
1
1
znchar
G
1
gen
zncharconductor
1
1
zncharconductor
GG
1
gen
znchardecompose
1
1
znchardecompose
GGG
1
gen
znchargauss
1
1
znchargauss
GGDGb
2
gen
prec
zncharinduce
1
1
zncharinduce
GGG
1
gen
zncharisodd
1
1
zncharisodd
GG
1
small
znchartokronecker
1
1
znchartokronecker
GGD0,L,
1
gen
znchartoprimitive
1
1
znchartoprimitive
GG
1
gen
znconreychar
1
1
znconreychar
GG
1
gen
znconreyconductor
1
1
znconreyconductor
GGD&
1
gen
znconreyexp
1
1
znconreyexp
GG
1
gen
znconreylog
1
1
znconreylog
GG
1
gen
zncoppersmith
1
1
zncoppersmith
GGGDG
1
gen
znlog
1
1
znlog0
GGDG
1
gen
znorder
2
0
1
znorder(${1 code}, ${2 code})
2
gen
?int
1
int
1
znorder
GDG
1
gen
znprimroot
1
1
znprimroot
G
1
gen
znstar
1
1
znstar0
GD0,L,
1
gen
znsubgroupgenerators
1
1
znsubgroupgenerators
GD0,L,
1
gen
