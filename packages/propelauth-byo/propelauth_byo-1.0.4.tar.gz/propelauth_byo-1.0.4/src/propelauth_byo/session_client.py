# Generated by PropelAuth

import json
from typing import Callable, List, Optional, Dict, Any
from .result import Result, Ok, Err, ok, err, is_ok
from .types import RequestFunc

from .generated.create_session_command import CreateSessionCommand
from .generated.create_session_response import CreateSessionResponse
from .generated.create_session_error import (
    CreateSessionError,
    CreateSessionErrorSessionLimitExceeded,
    CreateSessionErrorSessionLimitExceededDetails,
    CreateSessionErrorIpAddressError,
    CreateSessionErrorTagParseError,
    CreateSessionErrorInvalidDeviceRegistration,
    CreateSessionErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.ip_matching_error import IpMatchingError
from .generated.invalid_tag_error import InvalidTagError
from .generated.validate_session_command import ValidateSessionCommand
from .generated.validate_session_response import ValidateSessionResponse
from .generated.validate_session_error import (
    ValidateSessionError,
    ValidateSessionErrorInvalidSessionToken,
    ValidateSessionErrorIpAddressError,
    ValidateSessionErrorNewDeviceChallengeRequired,
    ValidateSessionErrorNewDeviceChallengeRequiredDetails,
    ValidateSessionErrorDeviceVerificationRequired,
    ValidateSessionErrorDeviceVerificationFailed,
    ValidateSessionErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.invalid_session_token_error import InvalidSessionTokenError
from .generated.ip_matching_error import IpMatchingError
from .generated.validate_and_refresh_session_command import ValidateAndRefreshSessionCommand
from .generated.validate_and_refresh_session_response import ValidateAndRefreshSessionResponse
from .generated.validate_and_refresh_session_error import (
    ValidateAndRefreshSessionError,
    ValidateAndRefreshSessionErrorInvalidSessionToken,
    ValidateAndRefreshSessionErrorIpAddressError,
    ValidateAndRefreshSessionErrorNewDeviceChallengeRequired,
    ValidateAndRefreshSessionErrorNewDeviceChallengeRequiredDetails,
    ValidateAndRefreshSessionErrorDeviceVerificationRequired,
    ValidateAndRefreshSessionErrorDeviceVerificationFailed,
    ValidateAndRefreshSessionErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.invalid_session_token_error import InvalidSessionTokenError
from .generated.ip_matching_error import IpMatchingError
from .generated.fetch_all_sessions_for_user_command import FetchAllSessionsForUserCommand
from .generated.fetch_all_sessions_for_user_response import FetchAllSessionsForUserResponse
from .generated.fetch_all_sessions_for_user_error import (
    FetchAllSessionsForUserError,
)
from .generated.session_info import SessionInfo
from .generated.fetch_all_sessions_command import FetchAllSessionsCommand
from .generated.fetch_all_sessions_response import FetchAllSessionsResponse
from .generated.fetch_all_sessions_error import (
    FetchAllSessionsError,
)
from .generated.fetch_session_by_id_command import FetchSessionByIdCommand
from .generated.session_info import SessionInfo
from .generated.fetch_session_by_id_error import (
    FetchSessionByIdError,
    FetchSessionByIdErrorSessionNotFound,
    FetchSessionByIdErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.device_info import DeviceInfo
from .generated.update_session_command import UpdateSessionCommand
from .generated.update_session_response import UpdateSessionResponse
from .generated.update_session_error import (
    UpdateSessionError,
    UpdateSessionErrorSessionNotFound,
    UpdateSessionErrorConflictingMetadataOptions,
    UpdateSessionErrorInvalidTagFormat,
    UpdateSessionErrorCannotModifyOnCreateOnlyTags,
    UpdateSessionErrorCannotModifyOnCreateOnlyTagsDetails,
    UpdateSessionErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.invalid_tag_error import InvalidTagError
from .generated.update_sessions_command import UpdateSessionsCommand
from .generated.update_sessions_response import UpdateSessionsResponse
from .generated.update_sessions_error import (
    UpdateSessionsError,
    UpdateSessionsErrorConflictingMetadataOptions,
    UpdateSessionsErrorInvalidTagFormat,
    UpdateSessionsErrorCannotModifyOnCreateOnlyTags,
    UpdateSessionsErrorCannotModifyOnCreateOnlyTagsDetails,
    UpdateSessionsErrorUpdatingTooManySessionsAtOnce,
    UpdateSessionsErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.invalid_tag_error import InvalidTagError
from .generated.invalidate_session_by_id_command import InvalidateSessionByIdCommand
from .generated.invalidate_session_by_id_response import InvalidateSessionByIdResponse
from .generated.invalidate_session_by_id_error import (
    InvalidateSessionByIdError,
    InvalidateSessionByIdErrorSessionNotFound,
    InvalidateSessionByIdErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.invalidate_session_by_token_command import InvalidateSessionByTokenCommand
from .generated.invalidate_session_by_token_response import InvalidateSessionByTokenResponse
from .generated.invalidate_session_by_token_error import (
    InvalidateSessionByTokenError,
)
from .generated.invalidate_all_sessions_for_user_command import InvalidateAllSessionsForUserCommand
from .generated.invalidate_all_sessions_for_user_response import InvalidateAllSessionsForUserResponse
from .generated.invalidate_all_sessions_for_user_error import (
    InvalidateAllSessionsForUserError,
)
from .generated.invalidate_all_sessions_for_user_except_one_command import InvalidateAllSessionsForUserExceptOneCommand
from .generated.invalidate_all_sessions_for_user_except_one_response import InvalidateAllSessionsForUserExceptOneResponse
from .generated.invalidate_all_sessions_for_user_except_one_error import (
    InvalidateAllSessionsForUserExceptOneError,
)
from .generated.create_stateless_token_command import CreateStatelessTokenCommand
from .generated.create_stateless_token_response import CreateStatelessTokenResponse
from .generated.create_stateless_token_error import (
    CreateStatelessTokenError,
    CreateStatelessTokenErrorTokenCreationFailed,
    CreateStatelessTokenErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.get_jwks_command import GetJwksCommand
from .generated.get_jwks_response import GetJwksResponse
from .generated.get_jwks_error import (
    GetJwksError,
)
from .generated.jwk_key import JwkKey
from .generated.rotate_stateless_token_key_command import RotateStatelessTokenKeyCommand
from .generated.rotate_stateless_token_key_response import RotateStatelessTokenKeyResponse
from .generated.rotate_stateless_token_key_error import (
    RotateStatelessTokenKeyError,
    RotateStatelessTokenKeyErrorRotationFailed,
    RotateStatelessTokenKeyErrorInvalidParameters,
    RotateStatelessTokenKeyErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.serde_json.json_value import JsonValue
from .generated.device_registration import DeviceRegistration
from .generated.device_verification import DeviceVerification
from .generated.sessions_filter import SessionsFilter
from .device_client import DeviceClient

class SessionClient:
    
    def __init__(self, request_func: RequestFunc):
        self._request = request_func
        
        self.device = DeviceClient(self._request)
    
    async def create(
        self,
        user_id: str,
        tags: Optional[List[str]] = None,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None,
        metadata: Optional[JsonValue] = None,
        device_registration: Optional[DeviceRegistration] = None
    ) -> Result[CreateSessionResponse, CreateSessionError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if tags is not None:
            data["tags"] = tags
        if user_agent is not None:
            data["userAgent"] = user_agent
        if ip_address is not None:
            data["ipAddress"] = ip_address
        if metadata is not None:
            data["metadata"] = metadata
        if device_registration is not None:
            data["deviceRegistration"] = device_registration._to_request()
        response = await self._request(
            command="CreateSession",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(CreateSessionResponse(
                session_id=data["sessionId"],
                session_token=data["sessionToken"],
                expires_at=data["expiresAt"],
                new_device_detected=data.get("newDeviceDetected")
            ))

        else:
            error_data = response.error
            if error_data["type"] == "SessionLimitExceeded":
                return err(CreateSessionErrorSessionLimitExceeded(
                    details=CreateSessionErrorSessionLimitExceededDetails(
                        current_count=error_data["details"]["currentCount"],
                        max_allowed=error_data["details"]["maxAllowed"]
                    )
                ))
            elif error_data["type"] == "IpAddressError":
                return err(CreateSessionErrorIpAddressError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "TagParseError":
                return err(CreateSessionErrorTagParseError(
                    details=InvalidTagError(
                        invalid_tag_format=error_data["details"]["InvalidTagFormat"]
                    )
                ))
            elif error_data["type"] == "InvalidDeviceRegistration":
                return err(CreateSessionErrorInvalidDeviceRegistration())
            elif error_data["type"] == "UnexpectedError":
                return err(CreateSessionErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def validate(
        self,
        session_token: Optional[str] = None,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None,
        required_tags: Optional[List[str]] = None,
        device_verification: Optional[DeviceVerification] = None,
        ignore_device_for_verification: Optional[bool] = None
    ) -> Result[ValidateSessionResponse, ValidateSessionError]:
        data: Dict[str, Any] = {}
        if session_token is not None:
            data["sessionToken"] = session_token
        if user_agent is not None:
            data["userAgent"] = user_agent
        if ip_address is not None:
            data["ipAddress"] = ip_address
        if required_tags is not None:
            data["requiredTags"] = required_tags
        if device_verification is not None:
            data["deviceVerification"] = device_verification._to_request()
        if ignore_device_for_verification is not None:
            data["ignoreDeviceForVerification"] = ignore_device_for_verification
        response = await self._request(
            command="ValidateSession",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(ValidateSessionResponse(
                session_id=data["sessionId"],
                user_id=data["userId"],
                created_at=data["createdAt"],
                expires_at=data["expiresAt"],
                tags=data.get("tags"),
                metadata=data.get("metadata"),
                has_device_registered=data["hasDeviceRegistered"]
            ))

        else:
            error_data = response.error
            if error_data["type"] == "InvalidSessionToken":
                return err(ValidateSessionErrorInvalidSessionToken(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "IpAddressError":
                return err(ValidateSessionErrorIpAddressError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "NewDeviceChallengeRequired":
                return err(ValidateSessionErrorNewDeviceChallengeRequired(
                    details=ValidateSessionErrorNewDeviceChallengeRequiredDetails(
                        device_challenge=error_data["details"]["deviceChallenge"],
                        expires_at=error_data["details"]["expiresAt"]
                    )
                ))
            elif error_data["type"] == "DeviceVerificationRequired":
                return err(ValidateSessionErrorDeviceVerificationRequired())
            elif error_data["type"] == "DeviceVerificationFailed":
                return err(ValidateSessionErrorDeviceVerificationFailed())
            elif error_data["type"] == "UnexpectedError":
                return err(ValidateSessionErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def validate_and_refresh(
        self,
        session_token: Optional[str] = None,
        user_agent: Optional[str] = None,
        ip_address: Optional[str] = None,
        required_tags: Optional[List[str]] = None,
        device_verification: Optional[DeviceVerification] = None,
        ignore_device_for_verification: Optional[bool] = None
    ) -> Result[ValidateAndRefreshSessionResponse, ValidateAndRefreshSessionError]:
        data: Dict[str, Any] = {}
        if session_token is not None:
            data["sessionToken"] = session_token
        if user_agent is not None:
            data["userAgent"] = user_agent
        if ip_address is not None:
            data["ipAddress"] = ip_address
        if required_tags is not None:
            data["requiredTags"] = required_tags
        if device_verification is not None:
            data["deviceVerification"] = device_verification._to_request()
        if ignore_device_for_verification is not None:
            data["ignoreDeviceForVerification"] = ignore_device_for_verification
        response = await self._request(
            command="ValidateAndRefreshSession",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(ValidateAndRefreshSessionResponse(
                session_id=data["sessionId"],
                user_id=data["userId"],
                created_at=data["createdAt"],
                expires_at=data["expiresAt"],
                tags=data.get("tags"),
                metadata=data.get("metadata"),
                has_device_registered=data["hasDeviceRegistered"],
                new_session_token=data.get("newSessionToken")
            ))

        else:
            error_data = response.error
            if error_data["type"] == "InvalidSessionToken":
                return err(ValidateAndRefreshSessionErrorInvalidSessionToken(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "IpAddressError":
                return err(ValidateAndRefreshSessionErrorIpAddressError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "NewDeviceChallengeRequired":
                return err(ValidateAndRefreshSessionErrorNewDeviceChallengeRequired(
                    details=ValidateAndRefreshSessionErrorNewDeviceChallengeRequiredDetails(
                        device_challenge=error_data["details"]["deviceChallenge"],
                        expires_at=error_data["details"]["expiresAt"]
                    )
                ))
            elif error_data["type"] == "DeviceVerificationRequired":
                return err(ValidateAndRefreshSessionErrorDeviceVerificationRequired())
            elif error_data["type"] == "DeviceVerificationFailed":
                return err(ValidateAndRefreshSessionErrorDeviceVerificationFailed())
            elif error_data["type"] == "UnexpectedError":
                return err(ValidateAndRefreshSessionErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def fetch_all_for_user(
        self,
        user_id: str,
        session_tags: Optional[List[str]] = None
    ) -> Result[FetchAllSessionsForUserResponse, FetchAllSessionsForUserError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if session_tags is not None:
            data["sessionTags"] = session_tags
        response = await self._request(
            command="FetchAllSessionsForUser",
            data=data
        )
        if is_ok(response):
            data = response.data
            sessions: List[SessionInfo] = []
            for sessions_data in data["sessions"]:  # type: Dict[str, Any]
                sessions.append(SessionInfo(
                    session_id=sessions_data["sessionId"],
                    created_at=sessions_data["createdAt"],
                    expires_at=sessions_data["expiresAt"],
                    last_activity_at=sessions_data["lastActivityAt"],
                    device=sessions_data["device"],
                    ip_address=sessions_data.get("ipAddress"),
                    session_tags=sessions_data.get("sessionTags"),
                    metadata=sessions_data.get("metadata")
                ))

            return ok(FetchAllSessionsForUserResponse(
                sessions=sessions
            ))

        else:
            error_data = response.error
            return err(FetchAllSessionsForUserError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def fetch_all(
        self,
        user_id: Optional[str] = None,
        session_tags: Optional[List[str]] = None,
        page: Optional[int] = None
    ) -> Result[FetchAllSessionsResponse, FetchAllSessionsError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if session_tags is not None:
            data["sessionTags"] = session_tags
        if page is not None:
            data["page"] = page
        response = await self._request(
            command="FetchAllSessions",
            data=data
        )
        if is_ok(response):
            data = response.data
            items: List[SessionInfo] = []
            for items_data in data["items"]:  # type: Dict[str, Any]
                items.append(SessionInfo(
                    session_id=items_data["sessionId"],
                    created_at=items_data["createdAt"],
                    expires_at=items_data["expiresAt"],
                    last_activity_at=items_data["lastActivityAt"],
                    device=items_data["device"],
                    ip_address=items_data.get("ipAddress"),
                    session_tags=items_data.get("sessionTags"),
                    metadata=items_data.get("metadata")
                ))

            return ok(FetchAllSessionsResponse(
                page=data["page"],
                page_size=data["pageSize"],
                total_count=data["totalCount"],
                has_more_results=data["hasMoreResults"],
                items=items
            ))

        else:
            error_data = response.error
            return err(FetchAllSessionsError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def fetch_by_id(
        self,
        session_id: str
    ) -> Result[SessionInfo, FetchSessionByIdError]:
        data: Dict[str, Any] = {}
        if session_id is not None:
            data["sessionId"] = session_id
        response = await self._request(
            command="FetchSessionById",
            data=data
        )
        if is_ok(response):
            data = response.data
            # Convert complex fields from camelCase to snake_case
            device_data: Dict[str, Any] = data["device"]
            # Handle object field: device
            device = DeviceInfo(
                display_name=device_data["displayName"],
                device_type=device_data["deviceType"],
                browser=device_data.get("browser"),
                browser_version=device_data.get("browserVersion"),
                os=device_data.get("os"),
                os_version=device_data.get("osVersion")
            )

            return ok(SessionInfo(
                session_id=data["sessionId"],
                created_at=data["createdAt"],
                expires_at=data["expiresAt"],
                last_activity_at=data["lastActivityAt"],
                ip_address=data.get("ipAddress"),
                session_tags=data.get("sessionTags"),
                metadata=data.get("metadata"),
                device=device
            ))

        else:
            error_data = response.error
            if error_data["type"] == "SessionNotFound":
                return err(FetchSessionByIdErrorSessionNotFound())
            elif error_data["type"] == "UnexpectedError":
                return err(FetchSessionByIdErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def update(
        self,
        session_id: str,
        tags_to_remove: Optional[List[str]] = None,
        tags_to_add: Optional[List[str]] = None,
        new_metadata: Optional[JsonValue] = None,
        patch_metadata: Optional[JsonValue] = None
    ) -> Result[UpdateSessionResponse, UpdateSessionError]:
        data: Dict[str, Any] = {}
        if session_id is not None:
            data["sessionId"] = session_id
        if tags_to_remove is not None:
            data["tagsToRemove"] = tags_to_remove
        if tags_to_add is not None:
            data["tagsToAdd"] = tags_to_add
        if new_metadata is not None:
            data["newMetadata"] = new_metadata
        if patch_metadata is not None:
            data["patchMetadata"] = patch_metadata
        response = await self._request(
            command="UpdateSession",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(UpdateSessionResponse())
            
        else:
            error_data = response.error
            if error_data["type"] == "SessionNotFound":
                return err(UpdateSessionErrorSessionNotFound())
            elif error_data["type"] == "ConflictingMetadataOptions":
                return err(UpdateSessionErrorConflictingMetadataOptions())
            elif error_data["type"] == "InvalidTagFormat":
                return err(UpdateSessionErrorInvalidTagFormat(
                    details=InvalidTagError(
                        invalid_tag_format=error_data["details"]["InvalidTagFormat"]
                    )
                ))
            elif error_data["type"] == "CannotModifyOnCreateOnlyTags":
                return err(UpdateSessionErrorCannotModifyOnCreateOnlyTags(
                    details=UpdateSessionErrorCannotModifyOnCreateOnlyTagsDetails(
                        tag_names=error_data["details"]["tagNames"]
                    )
                ))
            elif error_data["type"] == "UnexpectedError":
                return err(UpdateSessionErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def update_many(
        self,
        filter: SessionsFilter,
        tags_to_remove: Optional[List[str]] = None,
        tags_to_add: Optional[List[str]] = None,
        new_metadata: Optional[JsonValue] = None,
        patch_metadata: Optional[JsonValue] = None
    ) -> Result[UpdateSessionsResponse, UpdateSessionsError]:
        data: Dict[str, Any] = {}
        if filter is not None:
            data["filter"] = filter._to_request()
        if tags_to_remove is not None:
            data["tagsToRemove"] = tags_to_remove
        if tags_to_add is not None:
            data["tagsToAdd"] = tags_to_add
        if new_metadata is not None:
            data["newMetadata"] = new_metadata
        if patch_metadata is not None:
            data["patchMetadata"] = patch_metadata
        response = await self._request(
            command="UpdateSessions",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(UpdateSessionsResponse(
                updated_count=data["updatedCount"]
            ))

        else:
            error_data = response.error
            if error_data["type"] == "ConflictingMetadataOptions":
                return err(UpdateSessionsErrorConflictingMetadataOptions())
            elif error_data["type"] == "InvalidTagFormat":
                return err(UpdateSessionsErrorInvalidTagFormat(
                    details=InvalidTagError(
                        invalid_tag_format=error_data["details"]["InvalidTagFormat"]
                    )
                ))
            elif error_data["type"] == "CannotModifyOnCreateOnlyTags":
                return err(UpdateSessionsErrorCannotModifyOnCreateOnlyTags(
                    details=UpdateSessionsErrorCannotModifyOnCreateOnlyTagsDetails(
                        tag_names=error_data["details"]["tagNames"]
                    )
                ))
            elif error_data["type"] == "UpdatingTooManySessionsAtOnce":
                return err(UpdateSessionsErrorUpdatingTooManySessionsAtOnce())
            elif error_data["type"] == "UnexpectedError":
                return err(UpdateSessionsErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def invalidate_by_id(
        self,
        session_id: str,
        user_id: Optional[str] = None
    ) -> Result[InvalidateSessionByIdResponse, InvalidateSessionByIdError]:
        data: Dict[str, Any] = {}
        if session_id is not None:
            data["sessionId"] = session_id
        if user_id is not None:
            data["userId"] = user_id
        response = await self._request(
            command="InvalidateSessionById",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(InvalidateSessionByIdResponse())
            
        else:
            error_data = response.error
            if error_data["type"] == "SessionNotFound":
                return err(InvalidateSessionByIdErrorSessionNotFound())
            elif error_data["type"] == "UnexpectedError":
                return err(InvalidateSessionByIdErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def invalidate_by_token(
        self,
        session_token: Optional[str] = None
    ) -> Result[InvalidateSessionByTokenResponse, InvalidateSessionByTokenError]:
        data: Dict[str, Any] = {}
        if session_token is not None:
            data["sessionToken"] = session_token
        response = await self._request(
            command="InvalidateSessionByToken",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(InvalidateSessionByTokenResponse())
            
        else:
            error_data = response.error
            return err(InvalidateSessionByTokenError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def invalidate_all_for_user(
        self,
        user_id: str,
        session_tags: Optional[List[str]] = None
    ) -> Result[InvalidateAllSessionsForUserResponse, InvalidateAllSessionsForUserError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if session_tags is not None:
            data["sessionTags"] = session_tags
        response = await self._request(
            command="InvalidateAllSessionsForUser",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(InvalidateAllSessionsForUserResponse(
                sessions_invalidated=data["sessionsInvalidated"]
            ))

        else:
            error_data = response.error
            return err(InvalidateAllSessionsForUserError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def invalidate_all_for_user_except_one(
        self,
        user_id: str,
        session_token_to_keep: str,
        session_tags: Optional[List[str]] = None
    ) -> Result[InvalidateAllSessionsForUserExceptOneResponse, InvalidateAllSessionsForUserExceptOneError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if session_token_to_keep is not None:
            data["sessionTokenToKeep"] = session_token_to_keep
        if session_tags is not None:
            data["sessionTags"] = session_tags
        response = await self._request(
            command="InvalidateAllSessionsForUserExceptOne",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(InvalidateAllSessionsForUserExceptOneResponse(
                sessions_invalidated=data["sessionsInvalidated"]
            ))

        else:
            error_data = response.error
            return err(InvalidateAllSessionsForUserExceptOneError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def create_stateless_token(
        self,
        user_id: str,
        session_id: Optional[str] = None,
        custom_claims: Optional[JsonValue] = None,
        issuer: Optional[str] = None,
        audience: Optional[str] = None,
        not_before_unixtime: Optional[int] = None,
        lifetime_secs: Optional[int] = None
    ) -> Result[CreateStatelessTokenResponse, CreateStatelessTokenError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if session_id is not None:
            data["sessionId"] = session_id
        if custom_claims is not None:
            data["customClaims"] = custom_claims
        if issuer is not None:
            data["issuer"] = issuer
        if audience is not None:
            data["audience"] = audience
        if not_before_unixtime is not None:
            data["notBeforeUnixtime"] = not_before_unixtime
        if lifetime_secs is not None:
            data["lifetimeSecs"] = lifetime_secs
        response = await self._request(
            command="CreateStatelessToken",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(CreateStatelessTokenResponse(
                stateless_token=data["statelessToken"],
                expires_at=data["expiresAt"]
            ))

        else:
            error_data = response.error
            if error_data["type"] == "TokenCreationFailed":
                return err(CreateStatelessTokenErrorTokenCreationFailed(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "UnexpectedError":
                return err(CreateStatelessTokenErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def get_jwks(
        self
    ) -> Result[GetJwksResponse, GetJwksError]:
        data: Dict[str, Any] = {}
        response = await self._request(
            command="GetJwks",
            data=data
        )
        if is_ok(response):
            data = response.data
            keys: List[JwkKey] = []
            for keys_data in data["keys"]:  # type: Dict[str, Any]
                keys.append(JwkKey(
                    kty=keys_data["kty"],
                    kid=keys_data["kid"],
                    use=keys_data["use"],
                    alg=keys_data["alg"],
                    n=keys_data["n"],
                    e=keys_data["e"]
                ))

            return ok(GetJwksResponse(
                keys=keys
            ))

        else:
            error_data = response.error
            return err(GetJwksError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def rotate_stateless_token_key(
        self,
        secs_before_new_key_becomes_default: int,
        secs_before_existing_keys_are_deactivated: int
    ) -> Result[RotateStatelessTokenKeyResponse, RotateStatelessTokenKeyError]:
        data: Dict[str, Any] = {}
        if secs_before_new_key_becomes_default is not None:
            data["secsBeforeNewKeyBecomesDefault"] = secs_before_new_key_becomes_default
        if secs_before_existing_keys_are_deactivated is not None:
            data["secsBeforeExistingKeysAreDeactivated"] = secs_before_existing_keys_are_deactivated
        response = await self._request(
            command="RotateStatelessTokenKey",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(RotateStatelessTokenKeyResponse(
                new_key_id=data["newKeyId"],
                new_key_becomes_default_at=data["newKeyBecomesDefaultAt"],
                existing_keys_expire_at=data["existingKeysExpireAt"]
            ))

        else:
            error_data = response.error
            if error_data["type"] == "RotationFailed":
                return err(RotateStatelessTokenKeyErrorRotationFailed(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "InvalidParameters":
                return err(RotateStatelessTokenKeyErrorInvalidParameters(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "UnexpectedError":
                return err(RotateStatelessTokenKeyErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
