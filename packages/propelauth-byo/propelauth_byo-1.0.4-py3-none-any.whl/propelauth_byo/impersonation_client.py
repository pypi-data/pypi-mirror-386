# Generated by PropelAuth

import json
from typing import Callable, List, Optional, Dict, Any
from .result import Result, Ok, Err, ok, err, is_ok
from .types import RequestFunc

from .generated.create_impersonation_session_command import CreateImpersonationSessionCommand
from .generated.create_impersonation_session_response import CreateImpersonationSessionResponse
from .generated.create_impersonation_session_error import (
    CreateImpersonationSessionError,
    CreateImpersonationSessionErrorImpersonationDisabled,
    CreateImpersonationSessionErrorUnauthorizedEmployee,
    CreateImpersonationSessionErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.validate_impersonation_session_command import ValidateImpersonationSessionCommand
from .generated.validate_impersonation_session_response import ValidateImpersonationSessionResponse
from .generated.validate_impersonation_session_error import (
    ValidateImpersonationSessionError,
    ValidateImpersonationSessionErrorImpersonationNotEnabled,
    ValidateImpersonationSessionErrorInvalidImpersonationToken,
    ValidateImpersonationSessionErrorSessionNotFound,
    ValidateImpersonationSessionErrorIpAddressMismatch,
    ValidateImpersonationSessionErrorUserAgentMismatch,
    ValidateImpersonationSessionErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.invalid_impersonation_token_error import InvalidImpersonationTokenError
from .generated.fetch_impersonation_session_by_id_command import FetchImpersonationSessionByIdCommand
from .generated.impersonation_session_info import ImpersonationSessionInfo
from .generated.fetch_impersonation_session_by_id_error import (
    FetchImpersonationSessionByIdError,
    FetchImpersonationSessionByIdErrorSessionNotFound,
    FetchImpersonationSessionByIdErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.fetch_all_impersonation_sessions_for_employee_command import FetchAllImpersonationSessionsForEmployeeCommand
from .generated.fetch_all_impersonation_sessions_for_employee_response import FetchAllImpersonationSessionsForEmployeeResponse
from .generated.fetch_all_impersonation_sessions_for_employee_error import (
    FetchAllImpersonationSessionsForEmployeeError,
)
from .generated.fetch_all_impersonation_sessions_for_user_command import FetchAllImpersonationSessionsForUserCommand
from .generated.fetch_all_impersonation_sessions_for_user_response import FetchAllImpersonationSessionsForUserResponse
from .generated.fetch_all_impersonation_sessions_for_user_error import (
    FetchAllImpersonationSessionsForUserError,
)
from .generated.fetch_all_active_impersonation_sessions_command import FetchAllActiveImpersonationSessionsCommand
from .generated.fetch_all_active_impersonation_sessions_response import FetchAllActiveImpersonationSessionsResponse
from .generated.fetch_all_active_impersonation_sessions_error import (
    FetchAllActiveImpersonationSessionsError,
    FetchAllActiveImpersonationSessionsErrorInvalidPagingToken,
    FetchAllActiveImpersonationSessionsErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.invalidate_impersonation_session_by_id_command import InvalidateImpersonationSessionByIdCommand
from .generated.invalidate_impersonation_session_by_id_response import InvalidateImpersonationSessionByIdResponse
from .generated.invalidate_impersonation_session_by_id_error import (
    InvalidateImpersonationSessionByIdError,
    InvalidateImpersonationSessionByIdErrorSessionNotFound,
    InvalidateImpersonationSessionByIdErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.invalidate_impersonation_session_by_token_command import InvalidateImpersonationSessionByTokenCommand
from .generated.invalidate_impersonation_session_by_token_response import InvalidateImpersonationSessionByTokenResponse
from .generated.invalidate_impersonation_session_by_token_error import (
    InvalidateImpersonationSessionByTokenError,
    InvalidateImpersonationSessionByTokenErrorSessionNotFound,
    InvalidateImpersonationSessionByTokenErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.invalidate_all_impersonation_sessions_for_employee_command import InvalidateAllImpersonationSessionsForEmployeeCommand
from .generated.invalidate_all_impersonation_sessions_for_employee_response import InvalidateAllImpersonationSessionsForEmployeeResponse
from .generated.invalidate_all_impersonation_sessions_for_employee_error import (
    InvalidateAllImpersonationSessionsForEmployeeError,
)
from .generated.invalidate_all_impersonation_sessions_for_user_command import InvalidateAllImpersonationSessionsForUserCommand
from .generated.invalidate_all_impersonation_sessions_for_user_response import InvalidateAllImpersonationSessionsForUserResponse
from .generated.invalidate_all_impersonation_sessions_for_user_error import (
    InvalidateAllImpersonationSessionsForUserError,
)
from .generated.serde_json.json_value import JsonValue

class ImpersonationClient:
    
    def __init__(self, request_func: RequestFunc):
        self._request = request_func
    
    async def create(
        self,
        employee_email: str,
        target_user_id: str,
        user_agent: str,
        ip_address: str,
        metadata: Optional[JsonValue] = None
    ) -> Result[CreateImpersonationSessionResponse, CreateImpersonationSessionError]:
        data: Dict[str, Any] = {}
        if employee_email is not None:
            data["employeeEmail"] = employee_email
        if target_user_id is not None:
            data["targetUserId"] = target_user_id
        if user_agent is not None:
            data["userAgent"] = user_agent
        if ip_address is not None:
            data["ipAddress"] = ip_address
        if metadata is not None:
            data["metadata"] = metadata
        response = await self._request(
            command="CreateImpersonationSession",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(CreateImpersonationSessionResponse(
                session_id=data["sessionId"],
                impersonation_session_token=data["impersonationSessionToken"],
                expires_at=data["expiresAt"]
            ))

        else:
            error_data = response.error
            if error_data["type"] == "ImpersonationDisabled":
                return err(CreateImpersonationSessionErrorImpersonationDisabled())
            elif error_data["type"] == "UnauthorizedEmployee":
                return err(CreateImpersonationSessionErrorUnauthorizedEmployee(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "UnexpectedError":
                return err(CreateImpersonationSessionErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def validate(
        self,
        impersonation_token: str,
        user_agent: str,
        ip_address: str
    ) -> Result[ValidateImpersonationSessionResponse, ValidateImpersonationSessionError]:
        data: Dict[str, Any] = {}
        if impersonation_token is not None:
            data["impersonationToken"] = impersonation_token
        if user_agent is not None:
            data["userAgent"] = user_agent
        if ip_address is not None:
            data["ipAddress"] = ip_address
        response = await self._request(
            command="ValidateImpersonationSession",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(ValidateImpersonationSessionResponse(
                impersonation_session_id=data["impersonationSessionId"],
                employee_email=data["employeeEmail"],
                target_user_id=data["targetUserId"],
                created_at=data["createdAt"],
                expires_at=data["expiresAt"],
                metadata=data.get("metadata")
            ))

        else:
            error_data = response.error
            if error_data["type"] == "ImpersonationNotEnabled":
                return err(ValidateImpersonationSessionErrorImpersonationNotEnabled())
            elif error_data["type"] == "InvalidImpersonationToken":
                return err(ValidateImpersonationSessionErrorInvalidImpersonationToken(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            elif error_data["type"] == "SessionNotFound":
                return err(ValidateImpersonationSessionErrorSessionNotFound())
            elif error_data["type"] == "IpAddressMismatch":
                return err(ValidateImpersonationSessionErrorIpAddressMismatch())
            elif error_data["type"] == "UserAgentMismatch":
                return err(ValidateImpersonationSessionErrorUserAgentMismatch())
            elif error_data["type"] == "UnexpectedError":
                return err(ValidateImpersonationSessionErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def fetch_by_id(
        self,
        impersonation_session_id: str
    ) -> Result[ImpersonationSessionInfo, FetchImpersonationSessionByIdError]:
        data: Dict[str, Any] = {}
        if impersonation_session_id is not None:
            data["impersonationSessionId"] = impersonation_session_id
        response = await self._request(
            command="FetchImpersonationSessionById",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(ImpersonationSessionInfo(
                impersonation_session_id=data["impersonationSessionId"],
                employee_email=data["employeeEmail"],
                target_user_id=data["targetUserId"],
                metadata=data.get("metadata"),
                created_at=data["createdAt"],
                expires_at=data["expiresAt"]
            ))

        else:
            error_data = response.error
            if error_data["type"] == "SessionNotFound":
                return err(FetchImpersonationSessionByIdErrorSessionNotFound())
            elif error_data["type"] == "UnexpectedError":
                return err(FetchImpersonationSessionByIdErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def fetch_all_for_employee(
        self,
        employee_email: str
    ) -> Result[FetchAllImpersonationSessionsForEmployeeResponse, FetchAllImpersonationSessionsForEmployeeError]:
        data: Dict[str, Any] = {}
        if employee_email is not None:
            data["employeeEmail"] = employee_email
        response = await self._request(
            command="FetchAllImpersonationSessionsForEmployee",
            data=data
        )
        if is_ok(response):
            data = response.data
            sessions: List[ImpersonationSessionInfo] = []
            for sessions_data in data["sessions"]:  # type: Dict[str, Any]
                sessions.append(ImpersonationSessionInfo(
                    impersonation_session_id=sessions_data["impersonationSessionId"],
                    employee_email=sessions_data["employeeEmail"],
                    target_user_id=sessions_data["targetUserId"],
                    metadata=sessions_data.get("metadata"),
                    created_at=sessions_data["createdAt"],
                    expires_at=sessions_data["expiresAt"]
                ))

            return ok(FetchAllImpersonationSessionsForEmployeeResponse(
                sessions=sessions
            ))

        else:
            error_data = response.error
            return err(FetchAllImpersonationSessionsForEmployeeError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def fetch_all_for_user(
        self,
        user_id: str
    ) -> Result[FetchAllImpersonationSessionsForUserResponse, FetchAllImpersonationSessionsForUserError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        response = await self._request(
            command="FetchAllImpersonationSessionsForUser",
            data=data
        )
        if is_ok(response):
            data = response.data
            sessions: List[ImpersonationSessionInfo] = []
            for sessions_data in data["sessions"]:  # type: Dict[str, Any]
                sessions.append(ImpersonationSessionInfo(
                    impersonation_session_id=sessions_data["impersonationSessionId"],
                    employee_email=sessions_data["employeeEmail"],
                    target_user_id=sessions_data["targetUserId"],
                    metadata=sessions_data.get("metadata"),
                    created_at=sessions_data["createdAt"],
                    expires_at=sessions_data["expiresAt"]
                ))

            return ok(FetchAllImpersonationSessionsForUserResponse(
                sessions=sessions
            ))

        else:
            error_data = response.error
            return err(FetchAllImpersonationSessionsForUserError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def fetch_all_active(
        self,
        paging_token: Optional[str] = None,
        employee_email: Optional[str] = None,
        target_user_id: Optional[str] = None
    ) -> Result[FetchAllActiveImpersonationSessionsResponse, FetchAllActiveImpersonationSessionsError]:
        data: Dict[str, Any] = {}
        if paging_token is not None:
            data["pagingToken"] = paging_token
        if employee_email is not None:
            data["employeeEmail"] = employee_email
        if target_user_id is not None:
            data["targetUserId"] = target_user_id
        response = await self._request(
            command="FetchAllActiveImpersonationSessions",
            data=data
        )
        if is_ok(response):
            data = response.data
            sessions: List[ImpersonationSessionInfo] = []
            for sessions_data in data["sessions"]:  # type: Dict[str, Any]
                sessions.append(ImpersonationSessionInfo(
                    impersonation_session_id=sessions_data["impersonationSessionId"],
                    employee_email=sessions_data["employeeEmail"],
                    target_user_id=sessions_data["targetUserId"],
                    metadata=sessions_data.get("metadata"),
                    created_at=sessions_data["createdAt"],
                    expires_at=sessions_data["expiresAt"]
                ))

            return ok(FetchAllActiveImpersonationSessionsResponse(
                next_paging_token=data.get("nextPagingToken"),
                has_more_results=data["hasMoreResults"],
                sessions=sessions
            ))

        else:
            error_data = response.error
            if error_data["type"] == "InvalidPagingToken":
                return err(FetchAllActiveImpersonationSessionsErrorInvalidPagingToken())
            elif error_data["type"] == "UnexpectedError":
                return err(FetchAllActiveImpersonationSessionsErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def invalidate_by_id(
        self,
        impersonation_session_id: str
    ) -> Result[InvalidateImpersonationSessionByIdResponse, InvalidateImpersonationSessionByIdError]:
        data: Dict[str, Any] = {}
        if impersonation_session_id is not None:
            data["impersonationSessionId"] = impersonation_session_id
        response = await self._request(
            command="InvalidateImpersonationSessionById",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(InvalidateImpersonationSessionByIdResponse())
            
        else:
            error_data = response.error
            if error_data["type"] == "SessionNotFound":
                return err(InvalidateImpersonationSessionByIdErrorSessionNotFound())
            elif error_data["type"] == "UnexpectedError":
                return err(InvalidateImpersonationSessionByIdErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def invalidate_by_token(
        self,
        impersonation_session_token: str
    ) -> Result[InvalidateImpersonationSessionByTokenResponse, InvalidateImpersonationSessionByTokenError]:
        data: Dict[str, Any] = {}
        if impersonation_session_token is not None:
            data["impersonationSessionToken"] = impersonation_session_token
        response = await self._request(
            command="InvalidateImpersonationSessionByToken",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(InvalidateImpersonationSessionByTokenResponse())
            
        else:
            error_data = response.error
            if error_data["type"] == "SessionNotFound":
                return err(InvalidateImpersonationSessionByTokenErrorSessionNotFound())
            elif error_data["type"] == "UnexpectedError":
                return err(InvalidateImpersonationSessionByTokenErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def invalidate_all_for_employee(
        self,
        employee_email: str
    ) -> Result[InvalidateAllImpersonationSessionsForEmployeeResponse, InvalidateAllImpersonationSessionsForEmployeeError]:
        data: Dict[str, Any] = {}
        if employee_email is not None:
            data["employeeEmail"] = employee_email
        response = await self._request(
            command="InvalidateAllImpersonationSessionsForEmployee",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(InvalidateAllImpersonationSessionsForEmployeeResponse(
                sessions_invalidated=data["sessionsInvalidated"]
            ))

        else:
            error_data = response.error
            return err(InvalidateAllImpersonationSessionsForEmployeeError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def invalidate_all_for_user(
        self,
        user_id: str
    ) -> Result[InvalidateAllImpersonationSessionsForUserResponse, InvalidateAllImpersonationSessionsForUserError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        response = await self._request(
            command="InvalidateAllImpersonationSessionsForUser",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(InvalidateAllImpersonationSessionsForUserResponse(
                sessions_invalidated=data["sessionsInvalidated"]
            ))

        else:
            error_data = response.error
            return err(InvalidateAllImpersonationSessionsForUserError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
