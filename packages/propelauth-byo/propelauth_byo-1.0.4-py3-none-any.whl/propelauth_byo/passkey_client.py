# Generated by PropelAuth

import json
from typing import Callable, List, Optional, Dict, Any
from .result import Result, Ok, Err, ok, err, is_ok
from .types import RequestFunc

from .generated.start_passkey_registration_command import StartPasskeyRegistrationCommand
from .generated.start_passkey_registration_response import StartPasskeyRegistrationResponse
from .generated.start_passkey_registration_error import (
    StartPasskeyRegistrationError,
    StartPasskeyRegistrationErrorCannotParseAdditionalAllowedOrigin,
    StartPasskeyRegistrationErrorTooManyPasskeys,
    StartPasskeyRegistrationErrorTooManyPasskeysDetails,
    StartPasskeyRegistrationErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.finish_passkey_registration_command import FinishPasskeyRegistrationCommand
from .generated.finish_passkey_registration_response import FinishPasskeyRegistrationResponse
from .generated.finish_passkey_registration_error import (
    FinishPasskeyRegistrationError,
    FinishPasskeyRegistrationErrorCannotParseAdditionalAllowedOrigin,
    FinishPasskeyRegistrationErrorNoRegistrationChallengeFound,
    FinishPasskeyRegistrationErrorOriginNotAllowed,
    FinishPasskeyRegistrationErrorOriginNotAllowedDetails,
    FinishPasskeyRegistrationErrorPasskeyForUserAlreadyExists,
    FinishPasskeyRegistrationErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.start_passkey_authentication_command import StartPasskeyAuthenticationCommand
from .generated.start_passkey_authentication_response import StartPasskeyAuthenticationResponse
from .generated.start_passkey_authentication_error import (
    StartPasskeyAuthenticationError,
    StartPasskeyAuthenticationErrorCannotParseAdditionalAllowedOrigin,
    StartPasskeyAuthenticationErrorNoPasskeysRegisteredForUser,
    StartPasskeyAuthenticationErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.finish_passkey_authentication_command import FinishPasskeyAuthenticationCommand
from .generated.finish_passkey_authentication_response import FinishPasskeyAuthenticationResponse
from .generated.finish_passkey_authentication_error import (
    FinishPasskeyAuthenticationError,
    FinishPasskeyAuthenticationErrorCannotParseAdditionalAllowedOrigin,
    FinishPasskeyAuthenticationErrorNoAuthenticationChallengeFound,
    FinishPasskeyAuthenticationErrorOriginNotAllowed,
    FinishPasskeyAuthenticationErrorOriginNotAllowedDetails,
    FinishPasskeyAuthenticationErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.fetch_all_passkeys_for_user_command import FetchAllPasskeysForUserCommand
from .generated.fetch_all_passkeys_for_user_response import FetchAllPasskeysForUserResponse
from .generated.fetch_all_passkeys_for_user_error import (
    FetchAllPasskeysForUserError,
)
from .generated.passkey_info import PasskeyInfo
from .generated.deregister_passkey_command import DeregisterPasskeyCommand
from .generated.deregister_passkey_response import DeregisterPasskeyResponse
from .generated.deregister_passkey_error import (
    DeregisterPasskeyError,
    DeregisterPasskeyErrorPasskeyNotFound,
    DeregisterPasskeyErrorUnexpectedError,
    UnexpectedErrorDetails
)
from .generated.deregister_all_passkeys_for_user_command import DeregisterAllPasskeysForUserCommand
from .generated.deregister_all_passkeys_for_user_response import DeregisterAllPasskeysForUserResponse
from .generated.deregister_all_passkeys_for_user_error import (
    DeregisterAllPasskeysForUserError,
)
from .generated.serde_json.json_value import JsonValue

class PasskeyClient:
    
    def __init__(self, request_func: RequestFunc):
        self._request = request_func
    
    async def start_registration(
        self,
        user_id: str,
        email_or_username: str,
        user_display_name: Optional[str] = None,
        passkey_display_name: Optional[str] = None,
        additional_allowed_origin: Optional[str] = None
    ) -> Result[StartPasskeyRegistrationResponse, StartPasskeyRegistrationError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if email_or_username is not None:
            data["emailOrUsername"] = email_or_username
        if user_display_name is not None:
            data["userDisplayName"] = user_display_name
        if passkey_display_name is not None:
            data["passkeyDisplayName"] = passkey_display_name
        if additional_allowed_origin is not None:
            data["additionalAllowedOrigin"] = additional_allowed_origin
        response = await self._request(
            command="StartPasskeyRegistration",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(StartPasskeyRegistrationResponse(
                registration_options=data["registrationOptions"]
            ))

        else:
            error_data = response.error
            if error_data["type"] == "CannotParseAdditionalAllowedOrigin":
                return err(StartPasskeyRegistrationErrorCannotParseAdditionalAllowedOrigin())
            elif error_data["type"] == "TooManyPasskeys":
                return err(StartPasskeyRegistrationErrorTooManyPasskeys(
                    details=StartPasskeyRegistrationErrorTooManyPasskeysDetails(
                        max_passkeys=error_data["details"]["maxPasskeys"],
                        current_count=error_data["details"]["currentCount"]
                    )
                ))
            elif error_data["type"] == "UnexpectedError":
                return err(StartPasskeyRegistrationErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def finish_registration(
        self,
        user_id: str,
        public_key: JsonValue,
        additional_allowed_origin: Optional[str] = None
    ) -> Result[FinishPasskeyRegistrationResponse, FinishPasskeyRegistrationError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if public_key is not None:
            data["publicKey"] = public_key
        if additional_allowed_origin is not None:
            data["additionalAllowedOrigin"] = additional_allowed_origin
        response = await self._request(
            command="FinishPasskeyRegistration",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(FinishPasskeyRegistrationResponse())
            
        else:
            error_data = response.error
            if error_data["type"] == "CannotParseAdditionalAllowedOrigin":
                return err(FinishPasskeyRegistrationErrorCannotParseAdditionalAllowedOrigin())
            elif error_data["type"] == "NoRegistrationChallengeFound":
                return err(FinishPasskeyRegistrationErrorNoRegistrationChallengeFound())
            elif error_data["type"] == "OriginNotAllowed":
                return err(FinishPasskeyRegistrationErrorOriginNotAllowed(
                    details=FinishPasskeyRegistrationErrorOriginNotAllowedDetails(
                        message=error_data["details"]["message"]
                    )
                ))
            elif error_data["type"] == "PasskeyForUserAlreadyExists":
                return err(FinishPasskeyRegistrationErrorPasskeyForUserAlreadyExists())
            elif error_data["type"] == "UnexpectedError":
                return err(FinishPasskeyRegistrationErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def start_authentication(
        self,
        user_id: str,
        additional_allowed_origin: Optional[str] = None
    ) -> Result[StartPasskeyAuthenticationResponse, StartPasskeyAuthenticationError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if additional_allowed_origin is not None:
            data["additionalAllowedOrigin"] = additional_allowed_origin
        response = await self._request(
            command="StartPasskeyAuthentication",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(StartPasskeyAuthenticationResponse(
                authentication_options=data["authenticationOptions"]
            ))

        else:
            error_data = response.error
            if error_data["type"] == "CannotParseAdditionalAllowedOrigin":
                return err(StartPasskeyAuthenticationErrorCannotParseAdditionalAllowedOrigin())
            elif error_data["type"] == "NoPasskeysRegisteredForUser":
                return err(StartPasskeyAuthenticationErrorNoPasskeysRegisteredForUser())
            elif error_data["type"] == "UnexpectedError":
                return err(StartPasskeyAuthenticationErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def finish_authentication(
        self,
        user_id: str,
        public_key: JsonValue,
        additional_allowed_origin: Optional[str] = None
    ) -> Result[FinishPasskeyAuthenticationResponse, FinishPasskeyAuthenticationError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if public_key is not None:
            data["publicKey"] = public_key
        if additional_allowed_origin is not None:
            data["additionalAllowedOrigin"] = additional_allowed_origin
        response = await self._request(
            command="FinishPasskeyAuthentication",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(FinishPasskeyAuthenticationResponse())
            
        else:
            error_data = response.error
            if error_data["type"] == "CannotParseAdditionalAllowedOrigin":
                return err(FinishPasskeyAuthenticationErrorCannotParseAdditionalAllowedOrigin())
            elif error_data["type"] == "NoAuthenticationChallengeFound":
                return err(FinishPasskeyAuthenticationErrorNoAuthenticationChallengeFound())
            elif error_data["type"] == "OriginNotAllowed":
                return err(FinishPasskeyAuthenticationErrorOriginNotAllowed(
                    details=FinishPasskeyAuthenticationErrorOriginNotAllowedDetails(
                        message=error_data["details"]["message"]
                    )
                ))
            elif error_data["type"] == "UnexpectedError":
                return err(FinishPasskeyAuthenticationErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def fetch_all_passkeys_for_user(
        self,
        user_id: str
    ) -> Result[FetchAllPasskeysForUserResponse, FetchAllPasskeysForUserError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        response = await self._request(
            command="FetchAllPasskeysForUser",
            data=data
        )
        if is_ok(response):
            data = response.data
            passkeys: List[PasskeyInfo] = []
            for passkeys_data in data["passkeys"]:  # type: Dict[str, Any]
                passkeys.append(PasskeyInfo(
                    display_name=passkeys_data.get("displayName"),
                    credential_id=passkeys_data["credentialId"]
                ))

            return ok(FetchAllPasskeysForUserResponse(
                passkeys=passkeys
            ))

        else:
            error_data = response.error
            return err(FetchAllPasskeysForUserError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
    async def deregister_passkey(
        self,
        user_id: str,
        credential_id: str
    ) -> Result[DeregisterPasskeyResponse, DeregisterPasskeyError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        if credential_id is not None:
            data["credentialId"] = credential_id
        response = await self._request(
            command="DeregisterPasskey",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(DeregisterPasskeyResponse())
            
        else:
            error_data = response.error
            if error_data["type"] == "PasskeyNotFound":
                return err(DeregisterPasskeyErrorPasskeyNotFound())
            elif error_data["type"] == "UnexpectedError":
                return err(DeregisterPasskeyErrorUnexpectedError(
                    details=str(error_data["details"]) if isinstance(error_data["details"], (str, int, float, bool)) else json.dumps(error_data["details"])
                ))
            else:
                raise ValueError(f"Unknown error type: {error_data.get('type', 'missing type field')}")
    
    async def deregister_all_passkeys_for_user(
        self,
        user_id: str
    ) -> Result[DeregisterAllPasskeysForUserResponse, DeregisterAllPasskeysForUserError]:
        data: Dict[str, Any] = {}
        if user_id is not None:
            data["userId"] = user_id
        response = await self._request(
            command="DeregisterAllPasskeysForUser",
            data=data
        )
        if is_ok(response):
            data = response.data

            return ok(DeregisterAllPasskeysForUserResponse())
            
        else:
            error_data = response.error
            return err(DeregisterAllPasskeysForUserError(
                type=error_data.get("type"),
                details=error_data.get("details")
            ))
    
