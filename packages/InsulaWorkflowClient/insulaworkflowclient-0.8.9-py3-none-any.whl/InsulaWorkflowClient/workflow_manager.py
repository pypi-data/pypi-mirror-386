import yamlimport uuidfrom abc import ABC, abstractmethodfrom threading import Lockfrom .s3 import S3Clientfrom snakenest import Snakefrom .WorkflowDataManager import WorkflowDatafrom .placeholders import Placeholderclass WorkflowManager(ABC):    @abstractmethod    def parse(self, workflow_definition: str, external_params: dict = None) -> WorkflowData:        pass@Snake(having={'${insulaclient.workflow_manager.snake:native}': 'cwl'})class CwlWorkflowManager(WorkflowManager):    def __init__(self):        super().__init__()    def parse(self, workflow: dict, external_params: dict = None) -> WorkflowData:        raise Exception('CWL Not implemented yet')@Snake(having={'${insulaclient.workflow_manager.snake:native}': 'native'})class NativeWorkflowManager(WorkflowManager):    def __init__(self):        super().__init__()        self.__lock: Lock = Lock()        self.__counter_workflow = 0    def parse(self, workflow_definition: str, external_params: dict = None) -> WorkflowData:        workflow = yaml.safe_load(workflow_definition)        with self.__lock:            self.__counter_workflow += 2            wd = WorkflowData(f'{str(uuid.uuid4())}-{self.__counter_workflow}')            wd.name = workflow.get('name', 'UnName')            wd.version = workflow.get('version', None)            wd.type = workflow.get('type', None)            wd.parameters = NativeWorkflowManager.__init_parameters(workflow, external_params)            wd.requirements['connections'] = NativeWorkflowManager.__init_connection_requirements(workflow, wd)            wd.requirements['jobs'] = NativeWorkflowManager.__init_jobs_requirements(workflow)            for job in wd.requirements['jobs']:                job['id'] = Placeholder(str(job['id']), wd).get_result()            wd.config = NativeWorkflowManager.__init_config(workflow)            wd.templates = NativeWorkflowManager.__load_templates(workflow)            wd.steps = NativeWorkflowManager.__init_steps(workflow)            NativeWorkflowManager.__update_steps_with_templates(wd.steps, wd.templates)            return wd    @staticmethod    def __init_steps(workflow: dict) -> list:        return workflow.get('steps', []).copy()    @staticmethod    def __load_templates(workflow: dict) -> dict:        templates = {}        if 'templates' in workflow:            for template in workflow['templates']:                if 'name' in template:                    templates[template['name']] = template        return templates    @staticmethod    def __init_parameters(workflow: dict, external_params: dict) -> dict:        res = workflow.get('parameters')        if res:            if external_params is not None and isinstance(external_params, dict):                for key, value in external_params.items():                    res[key] = value            return res.copy()        return {}    @staticmethod    def __init_config(workflow: dict) -> dict:        if 'configuration' not in workflow:            return {'continue_on_error': False, 'max_parallel_jobs': 3, 'delete_workflow_log': False}        return {'continue_on_error': workflow['configuration'].get('continue_on_error', False),                'max_parallel_jobs': int(workflow['configuration'].get('max_parallel_jobs', 3)),                'delete_workflow_log': workflow['configuration'].get('delete_workflow_log', False)}    @staticmethod    def __init_jobs_requirements(workflow: dict) -> list:        if 'requirements' in workflow and 'jobs' in workflow['requirements']:            return workflow['requirements']['jobs']        return []    @staticmethod    def __init_connection_requirements(workflow, workflow_data: WorkflowData) -> dict:        connection_requirements = {}        if 'requirements' in workflow and 'connections' in workflow['requirements']:            for conn in workflow['requirements']['connections']:                if 'type' not in conn or 'name' not in conn:                    raise Exception('The connection must have a type and name.')                connection = {                    'name': conn['name'],                    'type': conn['type'],                    'connection': None                }                if conn['type'] == 's3':                    access_key = Placeholder(conn['params']['access_key'], workflow_data).get_result()                    secret_key = Placeholder(conn['params']['secret_key'], workflow_data).get_result()                    endpoint = Placeholder(conn['params']['endpoint'], workflow_data).get_result()                    bucket = Placeholder(conn['params']['bucket'], workflow_data).get_result()                    connection['connection'] = S3Client(access_key=access_key, secret_key=secret_key, endpoint=endpoint,                                                        bucket=bucket)                    connection_requirements[conn['name']] = connection                else:                    raise Exception(f"Connection type {conn['type']} not supported.")        return connection_requirements    @staticmethod    def __update_existing_param(template_param: list, step_param: list):        for template in template_param:            template_name = template['name']            find_param = False            for step in step_param:                step_name = step['name']                if template_name == step_name:                    find_param = True                    break            if not find_param:                step_param.append(template)    @staticmethod    def __update_steps_with_templates(stepss: list, templates: dict):        to_jump = ['name']        for steps in stepss:            for step in steps:                if 'template' in step:                    template_name = step['template']                    if template_name in templates:                        for key, value in templates[template_name].items():                            if key not in to_jump:                                if key not in step:                                    step[key] = value                                else:                                    if key == 'params':                                        NativeWorkflowManager.__update_existing_param(value, step[key])                    else:                        raise Exception(f'Template {template_name} not found')