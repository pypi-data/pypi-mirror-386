import re
from typing import Optional, Any, Dict, List

from click import Abort
from imagination import container

from dnastack.cli.core.command_spec import ArgumentSpec
from dnastack.cli.helpers.client_factory import ConfigurationBasedClientFactory
from dnastack.client.collections.client import CollectionServiceClient
from dnastack.client.collections.model import Collection
from dnastack.client.data_connect import DataConnectClient
from dnastack.common.logger import get_logger
from dnastack.configuration.manager import ConfigurationManager
from dnastack.context.models import Context

_logger = get_logger('cli/collections')

COLLECTION_ID_ARG = ArgumentSpec(
    name='collection',
    arg_names=['--collection', '-c'],
    help='The ID or slug name of the target collection.',
    required=True
)


def _get_context(context_name: Optional[str] = None) -> Context:
    config_manager: ConfigurationManager = container.get(ConfigurationManager)
    config = config_manager.load()
    config_context = config.contexts.get(context_name or config.current_context)

    assert config_context is not None, (
        f'The given context ({context_name} is not available.'
        if context_name
        else 'The default context is not initialized.'
    )

    return config_context


def _get_collection_service_client(context: Optional[str] = None, id: Optional[str] = None) -> CollectionServiceClient:
    factory: ConfigurationBasedClientFactory = container.get(ConfigurationBasedClientFactory)
    return factory.get(CollectionServiceClient, context_name=context, endpoint_id=id)


def _switch_to_data_connect(context: Context,
                            collection_service_client: CollectionServiceClient,
                            collection_id_or_slug_name: Optional[str],
                            no_auth: bool = False) -> DataConnectClient:
    default_no_auth_properties = {'authentication': None, 'fallback_authentications': None}

    try:
        proposed_data_connect_endpoint = collection_service_client.data_connect_endpoint(collection_id_or_slug_name,
                                                                                         no_auth=no_auth)

        # Look up for any similar registered service endpoint.
        for endpoint in context.endpoints:
            if proposed_data_connect_endpoint.type == endpoint.type:
                proposed_data_connect_endpoint_url = proposed_data_connect_endpoint.url
                if not proposed_data_connect_endpoint_url.endswith('/'):
                    proposed_data_connect_endpoint_url += '/'

                reference_data_connect_endpoint_url = endpoint.url
                if not reference_data_connect_endpoint_url.endswith('/'):
                    reference_data_connect_endpoint_url += '/'

                if proposed_data_connect_endpoint_url == reference_data_connect_endpoint_url:
                    return DataConnectClient.make(
                        endpoint.copy(update=default_no_auth_properties)
                        if no_auth
                        else endpoint
                    )
            else:
                pass

        _logger.debug(
            f'Unable to find a registered {proposed_data_connect_endpoint.type} endpoint at {proposed_data_connect_endpoint.url}.'
        )

        # Fallback to the endpoint generated by the collection service client.
        return DataConnectClient.make(
            proposed_data_connect_endpoint.copy(update=default_no_auth_properties)
            if no_auth
            else proposed_data_connect_endpoint
        )
    except AssertionError:
        _abort_with_collection_list(collection_service_client, collection_id_or_slug_name, no_auth=no_auth)


def _abort_with_collection_list(collection_service_client: CollectionServiceClient,
                                collection_id_or_slug_name: Optional[str],
                                no_auth: bool = False):
    available_identifiers = "\n - ".join(sorted([
        available_collection.slugName
        for available_collection in collection_service_client.list_collections(no_auth=no_auth)
    ]))

    error_message = f'The collection ID or slug name is not given via --collection or -c option or it is invalid. ' \
                    f'(Given: {collection_id_or_slug_name})'

    if available_identifiers:
        raise Abort(f'{error_message}\n\nHere is the list of available collection IDs:\n\n'
                    f' - {available_identifiers}\n')
    else:
        raise Abort(f'{error_message}\n\nHowever, you do not seem to have access to any collection at '
                    f'{collection_service_client.url} or there are no collections available at the moment.\n')





def _transform_to_public_collection(collection: Collection) -> Dict[str, Any]:
    return {
        field_name: value
        for field_name, value in (collection.model_dump() if isinstance(collection, Collection) else collection).items()
        if field_name not in ['itemsQuery', 'accessTypeLabels']
    }


def _simplify_collection(collection: Collection):
    return {
        'id': collection.slugName,
        'name': collection.name,
        'description': _clean_up_collection_collection_description(collection.description),
        'itemCounts': collection.itemCounts,
        'itemsChangedAt': collection.itemsChangedAt,
        'tags': [
            tag.label
            for tag in collection.tags
        ]
    }


def _clean_up_collection_collection_description(description: str) -> str:
    if not description:
        return ''

    description = description.replace('&nbsp;', '')
    description = re.sub(r'</p>', '\n\n</p>', description, re.IGNORECASE)
    description = re.sub(r'<br/?>', '\n<br/>', description, re.IGNORECASE)
    while re.match(r'<[^>]+>', description):
        description = re.sub(r'<[^>]+>', '', description)
    description = re.sub(r'\n{2,}', '\n', description)

    return description.strip()


def _filter_collection_fields(collection: Dict[str, Any], selected_fields: Optional[List[str]] = None):
    if not selected_fields:
        return collection
    else:
        return {
            k: v
            for k, v in collection.items()
            if k in selected_fields
        }
