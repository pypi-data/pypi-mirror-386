# coding: utf-8

"""
    HRA-API

    This API provides programmatic access to data registered to the Human Reference Atlas (HRA). See the [HuBMAP HRA Portal](https://humanatlas.io/) for details. 

    The version of the OpenAPI document: 0.16.1
    Contact: help@hubmapconsortium.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr, field_validator
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated
from hra_api_client.models.aggregate_count import AggregateCount
from hra_api_client.models.database_status import DatabaseStatus
from hra_api_client.models.flat_spatial_placement import FlatSpatialPlacement
from hra_api_client.models.get_spatial_placement_request import GetSpatialPlacementRequest
from hra_api_client.models.mesh3d_cell_population_request import Mesh3dCellPopulationRequest
from hra_api_client.models.min_max import MinMax
from hra_api_client.models.ontology_tree import OntologyTree
from hra_api_client.models.session_token import SessionToken
from hra_api_client.models.session_token_request import SessionTokenRequest
from hra_api_client.models.sparql_query_request import SparqlQueryRequest
from hra_api_client.models.spatial_entity import SpatialEntity
from hra_api_client.models.spatial_scene_node import SpatialSceneNode
from hra_api_client.models.spatial_search import SpatialSearch
from hra_api_client.models.tissue_block import TissueBlock

from hra_api_client.api_client import ApiClient, RequestSerialized
from hra_api_client.api_response import ApiResponse
from hra_api_client.rest import RESTResponseType


class V1Api:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def aggregate_results(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AggregateCount]:
        """Get aggregate results / statistics


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._aggregate_results_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AggregateCount]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def aggregate_results_with_http_info(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AggregateCount]]:
        """Get aggregate results / statistics


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._aggregate_results_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AggregateCount]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def aggregate_results_without_preload_content(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get aggregate results / statistics


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._aggregate_results_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AggregateCount]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _aggregate_results_serialize(
        self,
        age,
        age_range,
        bmi,
        bmi_range,
        cache,
        ontology_terms,
        cell_type_terms,
        biomarker_terms,
        consortiums,
        providers,
        sex,
        spatial,
        technologies,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ontology-terms': 'multi',
            'cell-type-terms': 'multi',
            'biomarker-terms': 'multi',
            'consortiums': 'multi',
            'providers': 'multi',
            'spatial': 'multi',
            'technologies': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if age is not None:
            
            _query_params.append(('age', age))
            
        if age_range is not None:
            
            _query_params.append(('age-range', age_range))
            
        if bmi is not None:
            
            _query_params.append(('bmi', bmi))
            
        if bmi_range is not None:
            
            _query_params.append(('bmi-range', bmi_range))
            
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if ontology_terms is not None:
            
            _query_params.append(('ontology-terms', ontology_terms))
            
        if cell_type_terms is not None:
            
            _query_params.append(('cell-type-terms', cell_type_terms))
            
        if biomarker_terms is not None:
            
            _query_params.append(('biomarker-terms', biomarker_terms))
            
        if consortiums is not None:
            
            _query_params.append(('consortiums', consortiums))
            
        if providers is not None:
            
            _query_params.append(('providers', providers))
            
        if sex is not None:
            
            _query_params.append(('sex', sex))
            
        if spatial is not None:
            
            _query_params.append(('spatial', spatial))
            
        if technologies is not None:
            
            _query_params.append(('technologies', technologies))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/aggregate-results',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def anatomical_systems_tree_model(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OntologyTree:
        """Get anatomical systems partonomy tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anatomical_systems_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def anatomical_systems_tree_model_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OntologyTree]:
        """Get anatomical systems partonomy tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anatomical_systems_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def anatomical_systems_tree_model_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get anatomical systems partonomy tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._anatomical_systems_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _anatomical_systems_tree_model_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/anatomical-systems-tree-model',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def asctb_omap_sheet_config(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Get OMAP sheet config data for the ASCT+B Reporter


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asctb_omap_sheet_config_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def asctb_omap_sheet_config_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Get OMAP sheet config data for the ASCT+B Reporter


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asctb_omap_sheet_config_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def asctb_omap_sheet_config_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get OMAP sheet config data for the ASCT+B Reporter


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asctb_omap_sheet_config_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _asctb_omap_sheet_config_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/asctb-omap-sheet-config',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def asctb_sheet_config(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Get sheet config data for the ASCT+B Reporter


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asctb_sheet_config_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def asctb_sheet_config_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Get sheet config data for the ASCT+B Reporter


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asctb_sheet_config_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def asctb_sheet_config_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get sheet config data for the ASCT+B Reporter


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asctb_sheet_config_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _asctb_sheet_config_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/asctb-sheet-config',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def biomarker_term_occurences(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Dict[str, int]:
        """Get number of biomarker type term occurrences for a search


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._biomarker_term_occurences_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def biomarker_term_occurences_with_http_info(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Dict[str, int]]:
        """Get number of biomarker type term occurrences for a search


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._biomarker_term_occurences_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def biomarker_term_occurences_without_preload_content(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get number of biomarker type term occurrences for a search


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._biomarker_term_occurences_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _biomarker_term_occurences_serialize(
        self,
        age,
        age_range,
        bmi,
        bmi_range,
        cache,
        ontology_terms,
        cell_type_terms,
        biomarker_terms,
        consortiums,
        providers,
        sex,
        spatial,
        technologies,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ontology-terms': 'multi',
            'cell-type-terms': 'multi',
            'biomarker-terms': 'multi',
            'consortiums': 'multi',
            'providers': 'multi',
            'spatial': 'multi',
            'technologies': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if age is not None:
            
            _query_params.append(('age', age))
            
        if age_range is not None:
            
            _query_params.append(('age-range', age_range))
            
        if bmi is not None:
            
            _query_params.append(('bmi', bmi))
            
        if bmi_range is not None:
            
            _query_params.append(('bmi-range', bmi_range))
            
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if ontology_terms is not None:
            
            _query_params.append(('ontology-terms', ontology_terms))
            
        if cell_type_terms is not None:
            
            _query_params.append(('cell-type-terms', cell_type_terms))
            
        if biomarker_terms is not None:
            
            _query_params.append(('biomarker-terms', biomarker_terms))
            
        if consortiums is not None:
            
            _query_params.append(('consortiums', consortiums))
            
        if providers is not None:
            
            _query_params.append(('providers', providers))
            
        if sex is not None:
            
            _query_params.append(('sex', sex))
            
        if spatial is not None:
            
            _query_params.append(('spatial', spatial))
            
        if technologies is not None:
            
            _query_params.append(('technologies', technologies))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/biomarker-term-occurences',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def biomarker_tree_model(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OntologyTree:
        """Get biomarker tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._biomarker_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def biomarker_tree_model_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OntologyTree]:
        """Get biomarker tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._biomarker_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def biomarker_tree_model_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get biomarker tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._biomarker_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _biomarker_tree_model_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/biomarker-tree-model',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cell_type_term_occurences(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Dict[str, int]:
        """Get number of cell type term occurrences for a search


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cell_type_term_occurences_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cell_type_term_occurences_with_http_info(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Dict[str, int]]:
        """Get number of cell type term occurrences for a search


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cell_type_term_occurences_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cell_type_term_occurences_without_preload_content(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get number of cell type term occurrences for a search


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cell_type_term_occurences_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cell_type_term_occurences_serialize(
        self,
        age,
        age_range,
        bmi,
        bmi_range,
        cache,
        ontology_terms,
        cell_type_terms,
        biomarker_terms,
        consortiums,
        providers,
        sex,
        spatial,
        technologies,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ontology-terms': 'multi',
            'cell-type-terms': 'multi',
            'biomarker-terms': 'multi',
            'consortiums': 'multi',
            'providers': 'multi',
            'spatial': 'multi',
            'technologies': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if age is not None:
            
            _query_params.append(('age', age))
            
        if age_range is not None:
            
            _query_params.append(('age-range', age_range))
            
        if bmi is not None:
            
            _query_params.append(('bmi', bmi))
            
        if bmi_range is not None:
            
            _query_params.append(('bmi-range', bmi_range))
            
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if ontology_terms is not None:
            
            _query_params.append(('ontology-terms', ontology_terms))
            
        if cell_type_terms is not None:
            
            _query_params.append(('cell-type-terms', cell_type_terms))
            
        if biomarker_terms is not None:
            
            _query_params.append(('biomarker-terms', biomarker_terms))
            
        if consortiums is not None:
            
            _query_params.append(('consortiums', consortiums))
            
        if providers is not None:
            
            _query_params.append(('providers', providers))
            
        if sex is not None:
            
            _query_params.append(('sex', sex))
            
        if spatial is not None:
            
            _query_params.append(('spatial', spatial))
            
        if technologies is not None:
            
            _query_params.append(('technologies', technologies))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/cell-type-term-occurences',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cell_type_tree_model(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OntologyTree:
        """Get cell type tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cell_type_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cell_type_tree_model_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OntologyTree]:
        """Get cell type tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cell_type_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cell_type_tree_model_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get cell type tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cell_type_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cell_type_tree_model_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/cell-type-tree-model',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def collisions(
        self,
        spatial_entity: Annotated[SpatialEntity, Field(description="Request format for routes using posted extraction sites ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Given an extraction site, get mesh-based collisions with the reference organ.


        :param spatial_entity: Request format for routes using posted extraction sites  (required)
        :type spatial_entity: SpatialEntity
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._collisions_serialize(
            spatial_entity=spatial_entity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def collisions_with_http_info(
        self,
        spatial_entity: Annotated[SpatialEntity, Field(description="Request format for routes using posted extraction sites ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Given an extraction site, get mesh-based collisions with the reference organ.


        :param spatial_entity: Request format for routes using posted extraction sites  (required)
        :type spatial_entity: SpatialEntity
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._collisions_serialize(
            spatial_entity=spatial_entity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def collisions_without_preload_content(
        self,
        spatial_entity: Annotated[SpatialEntity, Field(description="Request format for routes using posted extraction sites ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Given an extraction site, get mesh-based collisions with the reference organ.


        :param spatial_entity: Request format for routes using posted extraction sites  (required)
        :type spatial_entity: SpatialEntity
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._collisions_serialize(
            spatial_entity=spatial_entity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _collisions_serialize(
        self,
        spatial_entity,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if spatial_entity is not None:
            _body_params = spatial_entity


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/collisions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def consortium_names(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[str]:
        """Get consortium names (for filtering)


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._consortium_names_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def consortium_names_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[str]]:
        """Get consortium names (for filtering)


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._consortium_names_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def consortium_names_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get consortium names (for filtering)


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._consortium_names_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _consortium_names_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/consortium-names',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def corridor(
        self,
        spatial_entity: Annotated[SpatialEntity, Field(description="Request format for routes using posted extraction sites ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Given an extraction site, generate a corridor with the reference organ.


        :param spatial_entity: Request format for routes using posted extraction sites  (required)
        :type spatial_entity: SpatialEntity
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._corridor_serialize(
            spatial_entity=spatial_entity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def corridor_with_http_info(
        self,
        spatial_entity: Annotated[SpatialEntity, Field(description="Request format for routes using posted extraction sites ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Given an extraction site, generate a corridor with the reference organ.


        :param spatial_entity: Request format for routes using posted extraction sites  (required)
        :type spatial_entity: SpatialEntity
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._corridor_serialize(
            spatial_entity=spatial_entity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def corridor_without_preload_content(
        self,
        spatial_entity: Annotated[SpatialEntity, Field(description="Request format for routes using posted extraction sites ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Given an extraction site, generate a corridor with the reference organ.


        :param spatial_entity: Request format for routes using posted extraction sites  (required)
        :type spatial_entity: SpatialEntity
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._corridor_serialize(
            spatial_entity=spatial_entity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _corridor_serialize(
        self,
        spatial_entity,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if spatial_entity is not None:
            _body_params = spatial_entity


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'model/gltf-binary', 
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/corridor',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def db_status(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DatabaseStatus:
        """Get current status of database


        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._db_status_serialize(
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DatabaseStatus",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def db_status_with_http_info(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DatabaseStatus]:
        """Get current status of database


        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._db_status_serialize(
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DatabaseStatus",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def db_status_without_preload_content(
        self,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get current status of database


        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._db_status_serialize(
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DatabaseStatus",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _db_status_serialize(
        self,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/db-status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ds_graph(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Get dataset graph

        Get potentially filtered experimental data in dataset graph format (previously referred to as rui_locations.jsonld format)

        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ds_graph_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ds_graph_with_http_info(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Get dataset graph

        Get potentially filtered experimental data in dataset graph format (previously referred to as rui_locations.jsonld format)

        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ds_graph_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ds_graph_without_preload_content(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get dataset graph

        Get potentially filtered experimental data in dataset graph format (previously referred to as rui_locations.jsonld format)

        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ds_graph_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ds_graph_serialize(
        self,
        age,
        age_range,
        bmi,
        bmi_range,
        cache,
        ontology_terms,
        cell_type_terms,
        biomarker_terms,
        consortiums,
        providers,
        sex,
        spatial,
        technologies,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ontology-terms': 'multi',
            'cell-type-terms': 'multi',
            'biomarker-terms': 'multi',
            'consortiums': 'multi',
            'providers': 'multi',
            'spatial': 'multi',
            'technologies': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if age is not None:
            
            _query_params.append(('age', age))
            
        if age_range is not None:
            
            _query_params.append(('age-range', age_range))
            
        if bmi is not None:
            
            _query_params.append(('bmi', bmi))
            
        if bmi_range is not None:
            
            _query_params.append(('bmi-range', bmi_range))
            
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if ontology_terms is not None:
            
            _query_params.append(('ontology-terms', ontology_terms))
            
        if cell_type_terms is not None:
            
            _query_params.append(('cell-type-terms', cell_type_terms))
            
        if biomarker_terms is not None:
            
            _query_params.append(('biomarker-terms', biomarker_terms))
            
        if consortiums is not None:
            
            _query_params.append(('consortiums', consortiums))
            
        if providers is not None:
            
            _query_params.append(('providers', providers))
            
        if sex is not None:
            
            _query_params.append(('sex', sex))
            
        if spatial is not None:
            
            _query_params.append(('spatial', spatial))
            
        if technologies is not None:
            
            _query_params.append(('technologies', technologies))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/ds-graph',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def extraction_site(
        self,
        iri: Annotated[StrictStr, Field(description="extraction site iri to search for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Lookup Extraction Site


        :param iri: extraction site iri to search for (required)
        :type iri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._extraction_site_serialize(
            iri=iri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def extraction_site_with_http_info(
        self,
        iri: Annotated[StrictStr, Field(description="extraction site iri to search for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Lookup Extraction Site


        :param iri: extraction site iri to search for (required)
        :type iri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._extraction_site_serialize(
            iri=iri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def extraction_site_without_preload_content(
        self,
        iri: Annotated[StrictStr, Field(description="extraction site iri to search for")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Lookup Extraction Site


        :param iri: extraction site iri to search for (required)
        :type iri: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._extraction_site_serialize(
            iri=iri,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _extraction_site_serialize(
        self,
        iri,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if iri is not None:
            
            _query_params.append(('iri', iri))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/extraction-site',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ftu_illustrations(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Get 2D FTU Illustration data


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ftu_illustrations_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ftu_illustrations_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Get 2D FTU Illustration data


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ftu_illustrations_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ftu_illustrations_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get 2D FTU Illustration data


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ftu_illustrations_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ftu_illustrations_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/ftu-illustrations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_spatial_placement(
        self,
        get_spatial_placement_request: Annotated[GetSpatialPlacementRequest, Field(description="Request format for requesting a spatial placement for a given spatial entity IRI and RUI location")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FlatSpatialPlacement:
        """Given a SpatialEntity already placed relative to a reference SpatialEntity, retrieve a new direct SpatialPlacement to the given SpatialEntity IRI


        :param get_spatial_placement_request: Request format for requesting a spatial placement for a given spatial entity IRI and RUI location (required)
        :type get_spatial_placement_request: GetSpatialPlacementRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spatial_placement_serialize(
            get_spatial_placement_request=get_spatial_placement_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlatSpatialPlacement",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_spatial_placement_with_http_info(
        self,
        get_spatial_placement_request: Annotated[GetSpatialPlacementRequest, Field(description="Request format for requesting a spatial placement for a given spatial entity IRI and RUI location")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FlatSpatialPlacement]:
        """Given a SpatialEntity already placed relative to a reference SpatialEntity, retrieve a new direct SpatialPlacement to the given SpatialEntity IRI


        :param get_spatial_placement_request: Request format for requesting a spatial placement for a given spatial entity IRI and RUI location (required)
        :type get_spatial_placement_request: GetSpatialPlacementRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spatial_placement_serialize(
            get_spatial_placement_request=get_spatial_placement_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlatSpatialPlacement",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_spatial_placement_without_preload_content(
        self,
        get_spatial_placement_request: Annotated[GetSpatialPlacementRequest, Field(description="Request format for requesting a spatial placement for a given spatial entity IRI and RUI location")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Given a SpatialEntity already placed relative to a reference SpatialEntity, retrieve a new direct SpatialPlacement to the given SpatialEntity IRI


        :param get_spatial_placement_request: Request format for requesting a spatial placement for a given spatial entity IRI and RUI location (required)
        :type get_spatial_placement_request: GetSpatialPlacementRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_spatial_placement_serialize(
            get_spatial_placement_request=get_spatial_placement_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FlatSpatialPlacement",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_spatial_placement_serialize(
        self,
        get_spatial_placement_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if get_spatial_placement_request is not None:
            _body_params = get_spatial_placement_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/get-spatial-placement',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def gtex_rui_locations(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Get all GTEx rui locations (if enabled)

        This option is only enabled if GTEX_ROUTES=true in the environment

        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gtex_rui_locations_serialize(
            cache=cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def gtex_rui_locations_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Get all GTEx rui locations (if enabled)

        This option is only enabled if GTEX_ROUTES=true in the environment

        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gtex_rui_locations_serialize(
            cache=cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def gtex_rui_locations_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all GTEx rui locations (if enabled)

        This option is only enabled if GTEX_ROUTES=true in the environment

        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gtex_rui_locations_serialize(
            cache=cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _gtex_rui_locations_serialize(
        self,
        cache,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/gtex/rui_locations.jsonld',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def hubmap_rui_locations(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Get all hubmap rui locations (if enabled)

        This option is only enabled if XCONSORTIA_ROUTES=true in the environment

        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hubmap_rui_locations_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def hubmap_rui_locations_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Get all hubmap rui locations (if enabled)

        This option is only enabled if XCONSORTIA_ROUTES=true in the environment

        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hubmap_rui_locations_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def hubmap_rui_locations_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all hubmap rui locations (if enabled)

        This option is only enabled if XCONSORTIA_ROUTES=true in the environment

        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hubmap_rui_locations_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _hubmap_rui_locations_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/hubmap/rui_locations.jsonld',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def mesh3d_cell_population(
        self,
        mesh3d_cell_population_request: Annotated[Mesh3dCellPopulationRequest, Field(description="Request format for requesting a mesh-based 3d cell population. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Given a reference organ, 3d scene node, and cell population,  generate cells in that distribution to fit in that 3d scene node.


        :param mesh3d_cell_population_request: Request format for requesting a mesh-based 3d cell population.  (required)
        :type mesh3d_cell_population_request: Mesh3dCellPopulationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mesh3d_cell_population_serialize(
            mesh3d_cell_population_request=mesh3d_cell_population_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def mesh3d_cell_population_with_http_info(
        self,
        mesh3d_cell_population_request: Annotated[Mesh3dCellPopulationRequest, Field(description="Request format for requesting a mesh-based 3d cell population. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Given a reference organ, 3d scene node, and cell population,  generate cells in that distribution to fit in that 3d scene node.


        :param mesh3d_cell_population_request: Request format for requesting a mesh-based 3d cell population.  (required)
        :type mesh3d_cell_population_request: Mesh3dCellPopulationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mesh3d_cell_population_serialize(
            mesh3d_cell_population_request=mesh3d_cell_population_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def mesh3d_cell_population_without_preload_content(
        self,
        mesh3d_cell_population_request: Annotated[Mesh3dCellPopulationRequest, Field(description="Request format for requesting a mesh-based 3d cell population. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Given a reference organ, 3d scene node, and cell population,  generate cells in that distribution to fit in that 3d scene node.


        :param mesh3d_cell_population_request: Request format for requesting a mesh-based 3d cell population.  (required)
        :type mesh3d_cell_population_request: Mesh3dCellPopulationRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._mesh3d_cell_population_serialize(
            mesh3d_cell_population_request=mesh3d_cell_population_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
            '404': "ErrorMessage",
            '500': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _mesh3d_cell_population_serialize(
        self,
        mesh3d_cell_population_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if mesh3d_cell_population_request is not None:
            _body_params = mesh3d_cell_population_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/csv', 
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/mesh-3d-cell-population',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ontology_term_occurences(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Dict[str, int]:
        """Get number of ontology term occurrences for a search


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ontology_term_occurences_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ontology_term_occurences_with_http_info(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Dict[str, int]]:
        """Get number of ontology term occurrences for a search


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ontology_term_occurences_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ontology_term_occurences_without_preload_content(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get number of ontology term occurrences for a search


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ontology_term_occurences_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, int]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ontology_term_occurences_serialize(
        self,
        age,
        age_range,
        bmi,
        bmi_range,
        cache,
        ontology_terms,
        cell_type_terms,
        biomarker_terms,
        consortiums,
        providers,
        sex,
        spatial,
        technologies,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ontology-terms': 'multi',
            'cell-type-terms': 'multi',
            'biomarker-terms': 'multi',
            'consortiums': 'multi',
            'providers': 'multi',
            'spatial': 'multi',
            'technologies': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if age is not None:
            
            _query_params.append(('age', age))
            
        if age_range is not None:
            
            _query_params.append(('age-range', age_range))
            
        if bmi is not None:
            
            _query_params.append(('bmi', bmi))
            
        if bmi_range is not None:
            
            _query_params.append(('bmi-range', bmi_range))
            
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if ontology_terms is not None:
            
            _query_params.append(('ontology-terms', ontology_terms))
            
        if cell_type_terms is not None:
            
            _query_params.append(('cell-type-terms', cell_type_terms))
            
        if biomarker_terms is not None:
            
            _query_params.append(('biomarker-terms', biomarker_terms))
            
        if consortiums is not None:
            
            _query_params.append(('consortiums', consortiums))
            
        if providers is not None:
            
            _query_params.append(('providers', providers))
            
        if sex is not None:
            
            _query_params.append(('sex', sex))
            
        if spatial is not None:
            
            _query_params.append(('spatial', spatial))
            
        if technologies is not None:
            
            _query_params.append(('technologies', technologies))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/ontology-term-occurences',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ontology_tree_model(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OntologyTree:
        """Get ontology term tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ontology_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ontology_tree_model_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OntologyTree]:
        """Get ontology term tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ontology_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ontology_tree_model_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get ontology term tree nodes


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ontology_tree_model_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OntologyTree",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ontology_tree_model_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/ontology-tree-model',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def provider_names(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[str]:
        """Get tissue provider names (for filtering)


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._provider_names_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def provider_names_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[str]]:
        """Get tissue provider names (for filtering)


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._provider_names_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def provider_names_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get tissue provider names (for filtering)


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._provider_names_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _provider_names_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/provider-names',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reference_organ_scene(
        self,
        organ_iri: Annotated[StrictStr, Field(description="Filter result by organ.")],
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SpatialSceneNode]:
        """Get all nodes to form the 3D scene for an organ


        :param organ_iri: Filter result by organ. (required)
        :type organ_iri: str
        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reference_organ_scene_serialize(
            organ_iri=organ_iri,
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpatialSceneNode]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reference_organ_scene_with_http_info(
        self,
        organ_iri: Annotated[StrictStr, Field(description="Filter result by organ.")],
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SpatialSceneNode]]:
        """Get all nodes to form the 3D scene for an organ


        :param organ_iri: Filter result by organ. (required)
        :type organ_iri: str
        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reference_organ_scene_serialize(
            organ_iri=organ_iri,
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpatialSceneNode]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reference_organ_scene_without_preload_content(
        self,
        organ_iri: Annotated[StrictStr, Field(description="Filter result by organ.")],
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all nodes to form the 3D scene for an organ


        :param organ_iri: Filter result by organ. (required)
        :type organ_iri: str
        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reference_organ_scene_serialize(
            organ_iri=organ_iri,
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpatialSceneNode]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reference_organ_scene_serialize(
        self,
        organ_iri,
        age,
        age_range,
        bmi,
        bmi_range,
        cache,
        ontology_terms,
        cell_type_terms,
        biomarker_terms,
        consortiums,
        providers,
        sex,
        spatial,
        technologies,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ontology-terms': 'multi',
            'cell-type-terms': 'multi',
            'biomarker-terms': 'multi',
            'consortiums': 'multi',
            'providers': 'multi',
            'spatial': 'multi',
            'technologies': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if age is not None:
            
            _query_params.append(('age', age))
            
        if age_range is not None:
            
            _query_params.append(('age-range', age_range))
            
        if bmi is not None:
            
            _query_params.append(('bmi', bmi))
            
        if bmi_range is not None:
            
            _query_params.append(('bmi-range', bmi_range))
            
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if ontology_terms is not None:
            
            _query_params.append(('ontology-terms', ontology_terms))
            
        if cell_type_terms is not None:
            
            _query_params.append(('cell-type-terms', cell_type_terms))
            
        if biomarker_terms is not None:
            
            _query_params.append(('biomarker-terms', biomarker_terms))
            
        if organ_iri is not None:
            
            _query_params.append(('organ-iri', organ_iri))
            
        if consortiums is not None:
            
            _query_params.append(('consortiums', consortiums))
            
        if providers is not None:
            
            _query_params.append(('providers', providers))
            
        if sex is not None:
            
            _query_params.append(('sex', sex))
            
        if spatial is not None:
            
            _query_params.append(('spatial', spatial))
            
        if technologies is not None:
            
            _query_params.append(('technologies', technologies))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/reference-organ-scene',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def reference_organs(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SpatialEntity]:
        """Get all reference organs


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reference_organs_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpatialEntity]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def reference_organs_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SpatialEntity]]:
        """Get all reference organs


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reference_organs_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpatialEntity]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def reference_organs_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all reference organs


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._reference_organs_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpatialEntity]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _reference_organs_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/reference-organs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def rui_reference_data(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[object]:
        """Get reference data for the RUI tool


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rui_reference_data_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def rui_reference_data_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[object]]:
        """Get reference data for the RUI tool


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rui_reference_data_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def rui_reference_data_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get reference data for the RUI tool


        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._rui_reference_data_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[object]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _rui_reference_data_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/rui-reference-data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def scene(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SpatialSceneNode]:
        """Get all nodes to form the 3D scene of reference body, organs, and tissues


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._scene_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpatialSceneNode]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def scene_with_http_info(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SpatialSceneNode]]:
        """Get all nodes to form the 3D scene of reference body, organs, and tissues


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._scene_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpatialSceneNode]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def scene_without_preload_content(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all nodes to form the 3D scene of reference body, organs, and tissues


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._scene_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SpatialSceneNode]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _scene_serialize(
        self,
        age,
        age_range,
        bmi,
        bmi_range,
        cache,
        ontology_terms,
        cell_type_terms,
        biomarker_terms,
        consortiums,
        providers,
        sex,
        spatial,
        technologies,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ontology-terms': 'multi',
            'cell-type-terms': 'multi',
            'biomarker-terms': 'multi',
            'consortiums': 'multi',
            'providers': 'multi',
            'spatial': 'multi',
            'technologies': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if age is not None:
            
            _query_params.append(('age', age))
            
        if age_range is not None:
            
            _query_params.append(('age-range', age_range))
            
        if bmi is not None:
            
            _query_params.append(('bmi', bmi))
            
        if bmi_range is not None:
            
            _query_params.append(('bmi-range', bmi_range))
            
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if ontology_terms is not None:
            
            _query_params.append(('ontology-terms', ontology_terms))
            
        if cell_type_terms is not None:
            
            _query_params.append(('cell-type-terms', cell_type_terms))
            
        if biomarker_terms is not None:
            
            _query_params.append(('biomarker-terms', biomarker_terms))
            
        if consortiums is not None:
            
            _query_params.append(('consortiums', consortiums))
            
        if providers is not None:
            
            _query_params.append(('providers', providers))
            
        if sex is not None:
            
            _query_params.append(('sex', sex))
            
        if spatial is not None:
            
            _query_params.append(('spatial', spatial))
            
        if technologies is not None:
            
            _query_params.append(('technologies', technologies))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/scene',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def sennet_rui_locations(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Get all sennet rui locations (if enabled)

        This option is only enabled if XCONSORTIA_ROUTES=true in the environment

        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sennet_rui_locations_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def sennet_rui_locations_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Get all sennet rui locations (if enabled)

        This option is only enabled if XCONSORTIA_ROUTES=true in the environment

        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sennet_rui_locations_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def sennet_rui_locations_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all sennet rui locations (if enabled)

        This option is only enabled if XCONSORTIA_ROUTES=true in the environment

        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sennet_rui_locations_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _sennet_rui_locations_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/sennet/rui_locations.jsonld',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def session_token(
        self,
        session_token_request: Annotated[SessionTokenRequest, Field(description="Request format for requesting a session token ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SessionToken:
        """Get a session token


        :param session_token_request: Request format for requesting a session token  (required)
        :type session_token_request: SessionTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._session_token_serialize(
            session_token_request=session_token_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SessionToken",
            '404': "ErrorMessage",
            '405': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def session_token_with_http_info(
        self,
        session_token_request: Annotated[SessionTokenRequest, Field(description="Request format for requesting a session token ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SessionToken]:
        """Get a session token


        :param session_token_request: Request format for requesting a session token  (required)
        :type session_token_request: SessionTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._session_token_serialize(
            session_token_request=session_token_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SessionToken",
            '404': "ErrorMessage",
            '405': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def session_token_without_preload_content(
        self,
        session_token_request: Annotated[SessionTokenRequest, Field(description="Request format for requesting a session token ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a session token


        :param session_token_request: Request format for requesting a session token  (required)
        :type session_token_request: SessionTokenRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._session_token_serialize(
            session_token_request=session_token_request,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SessionToken",
            '404': "ErrorMessage",
            '405': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _session_token_serialize(
        self,
        session_token_request,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if session_token_request is not None:
            _body_params = session_token_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/session-token',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def sparql(
        self,
        query: Annotated[StrictStr, Field(description="SPARQL query to use")],
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Run a SPARQL query


        :param query: SPARQL query to use (required)
        :type query: str
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param format: Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sparql_serialize(
            query=query,
            token=token,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def sparql_with_http_info(
        self,
        query: Annotated[StrictStr, Field(description="SPARQL query to use")],
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Run a SPARQL query


        :param query: SPARQL query to use (required)
        :type query: str
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param format: Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sparql_serialize(
            query=query,
            token=token,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def sparql_without_preload_content(
        self,
        query: Annotated[StrictStr, Field(description="SPARQL query to use")],
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Run a SPARQL query


        :param query: SPARQL query to use (required)
        :type query: str
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param format: Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sparql_serialize(
            query=query,
            token=token,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _sparql_serialize(
        self,
        query,
        token,
        format,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if query is not None:
            
            _query_params.append(('query', query))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        if format is not None:
            
            _query_params.append(('format', format))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/csv'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/sparql',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def sparql_post(
        self,
        sparql_query_request: Annotated[SparqlQueryRequest, Field(description="Request format for a SPARQL query")],
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Run a SPARQL query (POST)


        :param sparql_query_request: Request format for a SPARQL query (required)
        :type sparql_query_request: SparqlQueryRequest
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param format: Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sparql_post_serialize(
            sparql_query_request=sparql_query_request,
            token=token,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def sparql_post_with_http_info(
        self,
        sparql_query_request: Annotated[SparqlQueryRequest, Field(description="Request format for a SPARQL query")],
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Run a SPARQL query (POST)


        :param sparql_query_request: Request format for a SPARQL query (required)
        :type sparql_query_request: SparqlQueryRequest
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param format: Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sparql_post_serialize(
            sparql_query_request=sparql_query_request,
            token=token,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def sparql_post_without_preload_content(
        self,
        sparql_query_request: Annotated[SparqlQueryRequest, Field(description="Request format for a SPARQL query")],
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        format: Annotated[Optional[StrictStr], Field(description="Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Run a SPARQL query (POST)


        :param sparql_query_request: Request format for a SPARQL query (required)
        :type sparql_query_request: SparqlQueryRequest
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param format: Override SPARQL response format (Note that not all formats are supported for all SPARQL query types)
        :type format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._sparql_post_serialize(
            sparql_query_request=sparql_query_request,
            token=token,
            format=format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _sparql_post_serialize(
        self,
        sparql_query_request,
        token,
        format,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        if format is not None:
            
            _query_params.append(('format', format))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if sparql_query_request is not None:
            _body_params = sparql_query_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    'text/csv'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json', 
                        'application/x-www-form-urlencoded'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/v1/sparql',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def technology_names(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[str]:
        """Get technology names (for filtering)


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._technology_names_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def technology_names_with_http_info(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[str]]:
        """Get technology names (for filtering)


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._technology_names_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def technology_names_without_preload_content(
        self,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get technology names (for filtering)


        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._technology_names_serialize(
            cache=cache,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[str]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _technology_names_serialize(
        self,
        cache,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/technology-names',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def tissue_blocks(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[TissueBlock]:
        """Get Tissue Block Results


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tissue_blocks_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[TissueBlock]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def tissue_blocks_with_http_info(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[TissueBlock]]:
        """Get Tissue Block Results


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tissue_blocks_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[TissueBlock]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def tissue_blocks_without_preload_content(
        self,
        age: Annotated[Optional[MinMax], Field(description="Filter result by age.")] = None,
        age_range: Annotated[Optional[StrictStr], Field(description="Filter result by age.")] = None,
        bmi: Annotated[Optional[MinMax], Field(description="Filter result by bmi.")] = None,
        bmi_range: Annotated[Optional[StrictStr], Field(description="Filter result by bmi.")] = None,
        cache: Annotated[Optional[StrictBool], Field(description="Hint to cache (or not) the response of this request")] = None,
        ontology_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        cell_type_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        biomarker_terms: Annotated[Optional[List[StrictStr]], Field(description="Filter result by ontology terms.")] = None,
        consortiums: Annotated[Optional[List[StrictStr]], Field(description="Filter result by consortiums.")] = None,
        providers: Annotated[Optional[List[StrictStr]], Field(description="Filter result by providers.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Filter result by sex.")] = None,
        spatial: Annotated[Optional[List[SpatialSearch]], Field(description="Filter result by spatial searches.")] = None,
        technologies: Annotated[Optional[List[StrictStr]], Field(description="Filter result by technologies.")] = None,
        token: Annotated[Optional[StrictStr], Field(description="Authentication token to use for authenticated searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Tissue Block Results


        :param age: Filter result by age.
        :type age: MinMax
        :param age_range: Filter result by age.
        :type age_range: str
        :param bmi: Filter result by bmi.
        :type bmi: MinMax
        :param bmi_range: Filter result by bmi.
        :type bmi_range: str
        :param cache: Hint to cache (or not) the response of this request
        :type cache: bool
        :param ontology_terms: Filter result by ontology terms.
        :type ontology_terms: List[str]
        :param cell_type_terms: Filter result by ontology terms.
        :type cell_type_terms: List[str]
        :param biomarker_terms: Filter result by ontology terms.
        :type biomarker_terms: List[str]
        :param consortiums: Filter result by consortiums.
        :type consortiums: List[str]
        :param providers: Filter result by providers.
        :type providers: List[str]
        :param sex: Filter result by sex.
        :type sex: str
        :param spatial: Filter result by spatial searches.
        :type spatial: List[SpatialSearch]
        :param technologies: Filter result by technologies.
        :type technologies: List[str]
        :param token: Authentication token to use for authenticated searches
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tissue_blocks_serialize(
            age=age,
            age_range=age_range,
            bmi=bmi,
            bmi_range=bmi_range,
            cache=cache,
            ontology_terms=ontology_terms,
            cell_type_terms=cell_type_terms,
            biomarker_terms=biomarker_terms,
            consortiums=consortiums,
            providers=providers,
            sex=sex,
            spatial=spatial,
            technologies=technologies,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[TissueBlock]",
            '404': "ErrorMessage",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tissue_blocks_serialize(
        self,
        age,
        age_range,
        bmi,
        bmi_range,
        cache,
        ontology_terms,
        cell_type_terms,
        biomarker_terms,
        consortiums,
        providers,
        sex,
        spatial,
        technologies,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ontology-terms': 'multi',
            'cell-type-terms': 'multi',
            'biomarker-terms': 'multi',
            'consortiums': 'multi',
            'providers': 'multi',
            'spatial': 'multi',
            'technologies': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if age is not None:
            
            _query_params.append(('age', age))
            
        if age_range is not None:
            
            _query_params.append(('age-range', age_range))
            
        if bmi is not None:
            
            _query_params.append(('bmi', bmi))
            
        if bmi_range is not None:
            
            _query_params.append(('bmi-range', bmi_range))
            
        if cache is not None:
            
            _query_params.append(('cache', cache))
            
        if ontology_terms is not None:
            
            _query_params.append(('ontology-terms', ontology_terms))
            
        if cell_type_terms is not None:
            
            _query_params.append(('cell-type-terms', cell_type_terms))
            
        if biomarker_terms is not None:
            
            _query_params.append(('biomarker-terms', biomarker_terms))
            
        if consortiums is not None:
            
            _query_params.append(('consortiums', consortiums))
            
        if providers is not None:
            
            _query_params.append(('providers', providers))
            
        if sex is not None:
            
            _query_params.append(('sex', sex))
            
        if spatial is not None:
            
            _query_params.append(('spatial', spatial))
            
        if technologies is not None:
            
            _query_params.append(('technologies', technologies))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/tissue-blocks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


