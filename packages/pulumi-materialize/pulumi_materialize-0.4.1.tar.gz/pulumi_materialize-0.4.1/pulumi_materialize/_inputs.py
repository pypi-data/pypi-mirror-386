# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'ClusterSchedulingArgs',
    'ClusterSchedulingArgsDict',
    'ClusterSchedulingOnRefreshArgs',
    'ClusterSchedulingOnRefreshArgsDict',
    'ClusterWaitUntilReadyArgs',
    'ClusterWaitUntilReadyArgsDict',
    'ConnectionAwsAccessKeyIdArgs',
    'ConnectionAwsAccessKeyIdArgsDict',
    'ConnectionAwsAccessKeyIdSecretArgs',
    'ConnectionAwsAccessKeyIdSecretArgsDict',
    'ConnectionAwsSecretAccessKeyArgs',
    'ConnectionAwsSecretAccessKeyArgsDict',
    'ConnectionAwsSessionTokenArgs',
    'ConnectionAwsSessionTokenArgsDict',
    'ConnectionAwsSessionTokenSecretArgs',
    'ConnectionAwsSessionTokenSecretArgsDict',
    'ConnectionConfluentSchemaRegistryAwsPrivatelinkArgs',
    'ConnectionConfluentSchemaRegistryAwsPrivatelinkArgsDict',
    'ConnectionConfluentSchemaRegistryPasswordArgs',
    'ConnectionConfluentSchemaRegistryPasswordArgsDict',
    'ConnectionConfluentSchemaRegistrySshTunnelArgs',
    'ConnectionConfluentSchemaRegistrySshTunnelArgsDict',
    'ConnectionConfluentSchemaRegistrySslCertificateArgs',
    'ConnectionConfluentSchemaRegistrySslCertificateArgsDict',
    'ConnectionConfluentSchemaRegistrySslCertificateAuthorityArgs',
    'ConnectionConfluentSchemaRegistrySslCertificateAuthorityArgsDict',
    'ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgs',
    'ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgsDict',
    'ConnectionConfluentSchemaRegistrySslCertificateSecretArgs',
    'ConnectionConfluentSchemaRegistrySslCertificateSecretArgsDict',
    'ConnectionConfluentSchemaRegistrySslKeyArgs',
    'ConnectionConfluentSchemaRegistrySslKeyArgsDict',
    'ConnectionConfluentSchemaRegistryUsernameArgs',
    'ConnectionConfluentSchemaRegistryUsernameArgsDict',
    'ConnectionConfluentSchemaRegistryUsernameSecretArgs',
    'ConnectionConfluentSchemaRegistryUsernameSecretArgsDict',
    'ConnectionKafkaAwsConnectionArgs',
    'ConnectionKafkaAwsConnectionArgsDict',
    'ConnectionKafkaAwsPrivatelinkArgs',
    'ConnectionKafkaAwsPrivatelinkArgsDict',
    'ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgs',
    'ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgsDict',
    'ConnectionKafkaKafkaBrokerArgs',
    'ConnectionKafkaKafkaBrokerArgsDict',
    'ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgs',
    'ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgsDict',
    'ConnectionKafkaKafkaBrokerSshTunnelArgs',
    'ConnectionKafkaKafkaBrokerSshTunnelArgsDict',
    'ConnectionKafkaSaslPasswordArgs',
    'ConnectionKafkaSaslPasswordArgsDict',
    'ConnectionKafkaSaslUsernameArgs',
    'ConnectionKafkaSaslUsernameArgsDict',
    'ConnectionKafkaSaslUsernameSecretArgs',
    'ConnectionKafkaSaslUsernameSecretArgsDict',
    'ConnectionKafkaSshTunnelArgs',
    'ConnectionKafkaSshTunnelArgsDict',
    'ConnectionKafkaSslCertificateArgs',
    'ConnectionKafkaSslCertificateArgsDict',
    'ConnectionKafkaSslCertificateAuthorityArgs',
    'ConnectionKafkaSslCertificateAuthorityArgsDict',
    'ConnectionKafkaSslCertificateAuthoritySecretArgs',
    'ConnectionKafkaSslCertificateAuthoritySecretArgsDict',
    'ConnectionKafkaSslCertificateSecretArgs',
    'ConnectionKafkaSslCertificateSecretArgsDict',
    'ConnectionKafkaSslKeyArgs',
    'ConnectionKafkaSslKeyArgsDict',
    'ConnectionMysqlAwsPrivatelinkArgs',
    'ConnectionMysqlAwsPrivatelinkArgsDict',
    'ConnectionMysqlPasswordArgs',
    'ConnectionMysqlPasswordArgsDict',
    'ConnectionMysqlSshTunnelArgs',
    'ConnectionMysqlSshTunnelArgsDict',
    'ConnectionMysqlSslCertificateArgs',
    'ConnectionMysqlSslCertificateArgsDict',
    'ConnectionMysqlSslCertificateAuthorityArgs',
    'ConnectionMysqlSslCertificateAuthorityArgsDict',
    'ConnectionMysqlSslCertificateAuthoritySecretArgs',
    'ConnectionMysqlSslCertificateAuthoritySecretArgsDict',
    'ConnectionMysqlSslCertificateSecretArgs',
    'ConnectionMysqlSslCertificateSecretArgsDict',
    'ConnectionMysqlSslKeyArgs',
    'ConnectionMysqlSslKeyArgsDict',
    'ConnectionMysqlUserArgs',
    'ConnectionMysqlUserArgsDict',
    'ConnectionMysqlUserSecretArgs',
    'ConnectionMysqlUserSecretArgsDict',
    'ConnectionPostgresAwsPrivatelinkArgs',
    'ConnectionPostgresAwsPrivatelinkArgsDict',
    'ConnectionPostgresPasswordArgs',
    'ConnectionPostgresPasswordArgsDict',
    'ConnectionPostgresSshTunnelArgs',
    'ConnectionPostgresSshTunnelArgsDict',
    'ConnectionPostgresSslCertificateArgs',
    'ConnectionPostgresSslCertificateArgsDict',
    'ConnectionPostgresSslCertificateAuthorityArgs',
    'ConnectionPostgresSslCertificateAuthorityArgsDict',
    'ConnectionPostgresSslCertificateAuthoritySecretArgs',
    'ConnectionPostgresSslCertificateAuthoritySecretArgsDict',
    'ConnectionPostgresSslCertificateSecretArgs',
    'ConnectionPostgresSslCertificateSecretArgsDict',
    'ConnectionPostgresSslKeyArgs',
    'ConnectionPostgresSslKeyArgsDict',
    'ConnectionPostgresUserArgs',
    'ConnectionPostgresUserArgsDict',
    'ConnectionPostgresUserSecretArgs',
    'ConnectionPostgresUserSecretArgsDict',
    'ConnectionSqlserverAwsPrivatelinkArgs',
    'ConnectionSqlserverAwsPrivatelinkArgsDict',
    'ConnectionSqlserverPasswordArgs',
    'ConnectionSqlserverPasswordArgsDict',
    'ConnectionSqlserverSshTunnelArgs',
    'ConnectionSqlserverSshTunnelArgsDict',
    'ConnectionSqlserverSslCertificateAuthorityArgs',
    'ConnectionSqlserverSslCertificateAuthorityArgsDict',
    'ConnectionSqlserverSslCertificateAuthoritySecretArgs',
    'ConnectionSqlserverSslCertificateAuthoritySecretArgsDict',
    'ConnectionSqlserverUserArgs',
    'ConnectionSqlserverUserArgsDict',
    'ConnectionSqlserverUserSecretArgs',
    'ConnectionSqlserverUserSecretArgsDict',
    'IndexColExprArgs',
    'IndexColExprArgsDict',
    'IndexObjNameArgs',
    'IndexObjNameArgsDict',
    'NetworkPolicyRuleArgs',
    'NetworkPolicyRuleArgsDict',
    'SinkKafkaEnvelopeArgs',
    'SinkKafkaEnvelopeArgsDict',
    'SinkKafkaFormatArgs',
    'SinkKafkaFormatArgsDict',
    'SinkKafkaFormatAvroArgs',
    'SinkKafkaFormatAvroArgsDict',
    'SinkKafkaFormatAvroAvroDocColumnArgs',
    'SinkKafkaFormatAvroAvroDocColumnArgsDict',
    'SinkKafkaFormatAvroAvroDocColumnObjectArgs',
    'SinkKafkaFormatAvroAvroDocColumnObjectArgsDict',
    'SinkKafkaFormatAvroAvroDocTypeArgs',
    'SinkKafkaFormatAvroAvroDocTypeArgsDict',
    'SinkKafkaFormatAvroAvroDocTypeObjectArgs',
    'SinkKafkaFormatAvroAvroDocTypeObjectArgsDict',
    'SinkKafkaFormatAvroSchemaRegistryConnectionArgs',
    'SinkKafkaFormatAvroSchemaRegistryConnectionArgsDict',
    'SinkKafkaFromArgs',
    'SinkKafkaFromArgsDict',
    'SinkKafkaKafkaConnectionArgs',
    'SinkKafkaKafkaConnectionArgsDict',
    'SourceKafkaEnvelopeArgs',
    'SourceKafkaEnvelopeArgsDict',
    'SourceKafkaEnvelopeUpsertOptionsArgs',
    'SourceKafkaEnvelopeUpsertOptionsArgsDict',
    'SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgs',
    'SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgsDict',
    'SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgs',
    'SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgsDict',
    'SourceKafkaExposeProgressArgs',
    'SourceKafkaExposeProgressArgsDict',
    'SourceKafkaFormatArgs',
    'SourceKafkaFormatArgsDict',
    'SourceKafkaFormatAvroArgs',
    'SourceKafkaFormatAvroArgsDict',
    'SourceKafkaFormatAvroSchemaRegistryConnectionArgs',
    'SourceKafkaFormatAvroSchemaRegistryConnectionArgsDict',
    'SourceKafkaFormatCsvArgs',
    'SourceKafkaFormatCsvArgsDict',
    'SourceKafkaFormatProtobufArgs',
    'SourceKafkaFormatProtobufArgsDict',
    'SourceKafkaFormatProtobufSchemaRegistryConnectionArgs',
    'SourceKafkaFormatProtobufSchemaRegistryConnectionArgsDict',
    'SourceKafkaKafkaConnectionArgs',
    'SourceKafkaKafkaConnectionArgsDict',
    'SourceKafkaKeyFormatArgs',
    'SourceKafkaKeyFormatArgsDict',
    'SourceKafkaKeyFormatAvroArgs',
    'SourceKafkaKeyFormatAvroArgsDict',
    'SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgs',
    'SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgsDict',
    'SourceKafkaKeyFormatCsvArgs',
    'SourceKafkaKeyFormatCsvArgsDict',
    'SourceKafkaKeyFormatProtobufArgs',
    'SourceKafkaKeyFormatProtobufArgsDict',
    'SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgs',
    'SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgsDict',
    'SourceKafkaValueFormatArgs',
    'SourceKafkaValueFormatArgsDict',
    'SourceKafkaValueFormatAvroArgs',
    'SourceKafkaValueFormatAvroArgsDict',
    'SourceKafkaValueFormatAvroSchemaRegistryConnectionArgs',
    'SourceKafkaValueFormatAvroSchemaRegistryConnectionArgsDict',
    'SourceKafkaValueFormatCsvArgs',
    'SourceKafkaValueFormatCsvArgsDict',
    'SourceKafkaValueFormatProtobufArgs',
    'SourceKafkaValueFormatProtobufArgsDict',
    'SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgs',
    'SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgsDict',
    'SourceLoadgenAuctionOptionsArgs',
    'SourceLoadgenAuctionOptionsArgsDict',
    'SourceLoadgenExposeProgressArgs',
    'SourceLoadgenExposeProgressArgsDict',
    'SourceLoadgenMarketingOptionsArgs',
    'SourceLoadgenMarketingOptionsArgsDict',
    'SourceLoadgenTpchOptionsArgs',
    'SourceLoadgenTpchOptionsArgsDict',
    'SourceMysqlExposeProgressArgs',
    'SourceMysqlExposeProgressArgsDict',
    'SourceMysqlMysqlConnectionArgs',
    'SourceMysqlMysqlConnectionArgsDict',
    'SourceMysqlTableArgs',
    'SourceMysqlTableArgsDict',
    'SourcePostgresExposeProgressArgs',
    'SourcePostgresExposeProgressArgsDict',
    'SourcePostgresPostgresConnectionArgs',
    'SourcePostgresPostgresConnectionArgsDict',
    'SourcePostgresTableArgs',
    'SourcePostgresTableArgsDict',
    'SourceSqlserverAwsPrivatelinkArgs',
    'SourceSqlserverAwsPrivatelinkArgsDict',
    'SourceSqlserverExposeProgressArgs',
    'SourceSqlserverExposeProgressArgsDict',
    'SourceSqlserverSqlserverConnectionArgs',
    'SourceSqlserverSqlserverConnectionArgsDict',
    'SourceSqlserverTableArgs',
    'SourceSqlserverTableArgsDict',
    'SourceWebhookCheckOptionArgs',
    'SourceWebhookCheckOptionArgsDict',
    'SourceWebhookCheckOptionFieldArgs',
    'SourceWebhookCheckOptionFieldArgsDict',
    'SourceWebhookCheckOptionFieldSecretArgs',
    'SourceWebhookCheckOptionFieldSecretArgsDict',
    'SourceWebhookIncludeHeaderArgs',
    'SourceWebhookIncludeHeaderArgsDict',
    'SourceWebhookIncludeHeadersArgs',
    'SourceWebhookIncludeHeadersArgsDict',
    'TableColumnArgs',
    'TableColumnArgsDict',
    'TypeListPropertiesArgs',
    'TypeListPropertiesArgsDict',
    'TypeMapPropertiesArgs',
    'TypeMapPropertiesArgsDict',
    'TypeRowPropertyArgs',
    'TypeRowPropertyArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterSchedulingArgsDict(TypedDict):
        on_refresh: NotRequired[pulumi.Input['ClusterSchedulingOnRefreshArgsDict']]
        """
        Configuration for refreshing the cluster.
        """
elif False:
    ClusterSchedulingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSchedulingArgs:
    def __init__(__self__, *,
                 on_refresh: Optional[pulumi.Input['ClusterSchedulingOnRefreshArgs']] = None):
        """
        :param pulumi.Input['ClusterSchedulingOnRefreshArgs'] on_refresh: Configuration for refreshing the cluster.
        """
        if on_refresh is not None:
            pulumi.set(__self__, "on_refresh", on_refresh)

    @_builtins.property
    @pulumi.getter(name="onRefresh")
    def on_refresh(self) -> Optional[pulumi.Input['ClusterSchedulingOnRefreshArgs']]:
        """
        Configuration for refreshing the cluster.
        """
        return pulumi.get(self, "on_refresh")

    @on_refresh.setter
    def on_refresh(self, value: Optional[pulumi.Input['ClusterSchedulingOnRefreshArgs']]):
        pulumi.set(self, "on_refresh", value)


if not MYPY:
    class ClusterSchedulingOnRefreshArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable scheduling to refresh the cluster.
        """
        hydration_time_estimate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Estimated time to hydrate the cluster during refresh.
        """
        rehydration_time_estimate: NotRequired[pulumi.Input[_builtins.str]]
        """
        Estimated time to rehydrate the cluster during refresh. This field is deprecated and will be removed in a future release. Use `hydration_time_estimate` instead.
        """
elif False:
    ClusterSchedulingOnRefreshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSchedulingOnRefreshArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 hydration_time_estimate: Optional[pulumi.Input[_builtins.str]] = None,
                 rehydration_time_estimate: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable scheduling to refresh the cluster.
        :param pulumi.Input[_builtins.str] hydration_time_estimate: Estimated time to hydrate the cluster during refresh.
        :param pulumi.Input[_builtins.str] rehydration_time_estimate: Estimated time to rehydrate the cluster during refresh. This field is deprecated and will be removed in a future release. Use `hydration_time_estimate` instead.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hydration_time_estimate is not None:
            pulumi.set(__self__, "hydration_time_estimate", hydration_time_estimate)
        if rehydration_time_estimate is not None:
            warnings.warn("""Use `hydration_time_estimate` instead.""", DeprecationWarning)
            pulumi.log.warn("""rehydration_time_estimate is deprecated: Use `hydration_time_estimate` instead.""")
        if rehydration_time_estimate is not None:
            pulumi.set(__self__, "rehydration_time_estimate", rehydration_time_estimate)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable scheduling to refresh the cluster.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="hydrationTimeEstimate")
    def hydration_time_estimate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Estimated time to hydrate the cluster during refresh.
        """
        return pulumi.get(self, "hydration_time_estimate")

    @hydration_time_estimate.setter
    def hydration_time_estimate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hydration_time_estimate", value)

    @_builtins.property
    @pulumi.getter(name="rehydrationTimeEstimate")
    @_utilities.deprecated("""Use `hydration_time_estimate` instead.""")
    def rehydration_time_estimate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Estimated time to rehydrate the cluster during refresh. This field is deprecated and will be removed in a future release. Use `hydration_time_estimate` instead.
        """
        return pulumi.get(self, "rehydration_time_estimate")

    @rehydration_time_estimate.setter
    def rehydration_time_estimate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rehydration_time_estimate", value)


if not MYPY:
    class ClusterWaitUntilReadyArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable wait*until*ready.
        """
        on_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Action to take on timeout: COMMIT|ROLLBACK
        """
        timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Max duration to wait for the new replicas to be ready.
        """
elif False:
    ClusterWaitUntilReadyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterWaitUntilReadyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 on_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 timeout: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable wait*until*ready.
        :param pulumi.Input[_builtins.str] on_timeout: Action to take on timeout: COMMIT|ROLLBACK
        :param pulumi.Input[_builtins.str] timeout: Max duration to wait for the new replicas to be ready.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if on_timeout is not None:
            pulumi.set(__self__, "on_timeout", on_timeout)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable wait*until*ready.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="onTimeout")
    def on_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Action to take on timeout: COMMIT|ROLLBACK
        """
        return pulumi.get(self, "on_timeout")

    @on_timeout.setter
    def on_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "on_timeout", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Max duration to wait for the new replicas to be ready.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ConnectionAwsAccessKeyIdArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionAwsAccessKeyIdSecretArgsDict']]
        """
        The `access_key_id` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `access_key_id` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionAwsAccessKeyIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAwsAccessKeyIdArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionAwsAccessKeyIdSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionAwsAccessKeyIdSecretArgs'] secret: The `access_key_id` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `access_key_id` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionAwsAccessKeyIdSecretArgs']]:
        """
        The `access_key_id` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionAwsAccessKeyIdSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `access_key_id` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionAwsAccessKeyIdSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The access*key*id name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The access*key*id database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The access*key*id schema name. Defaults to `public`.
        """
elif False:
    ConnectionAwsAccessKeyIdSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAwsAccessKeyIdSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The access*key*id name.
        :param pulumi.Input[_builtins.str] database_name: The access*key*id database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The access*key*id schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The access*key*id name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The access*key*id database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The access*key*id schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionAwsSecretAccessKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The secret*access*key name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret*access*key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret*access*key schema name. Defaults to `public`.
        """
elif False:
    ConnectionAwsSecretAccessKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAwsSecretAccessKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The secret*access*key name.
        :param pulumi.Input[_builtins.str] database_name: The secret*access*key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The secret*access*key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The secret*access*key name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret*access*key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret*access*key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionAwsSessionTokenArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionAwsSessionTokenSecretArgsDict']]
        """
        The `session_token` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `session_token` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionAwsSessionTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAwsSessionTokenArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionAwsSessionTokenSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionAwsSessionTokenSecretArgs'] secret: The `session_token` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `session_token` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionAwsSessionTokenSecretArgs']]:
        """
        The `session_token` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionAwsSessionTokenSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `session_token` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionAwsSessionTokenSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The session_token name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The session_token database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The session_token schema name. Defaults to `public`.
        """
elif False:
    ConnectionAwsSessionTokenSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAwsSessionTokenSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The session_token name.
        :param pulumi.Input[_builtins.str] database_name: The session_token database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The session_token schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The session_token name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The session_token database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The session_token schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistryAwsPrivatelinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The aws_privatelink name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
elif False:
    ConnectionConfluentSchemaRegistryAwsPrivatelinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistryAwsPrivatelinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The aws_privatelink name.
        :param pulumi.Input[_builtins.str] database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistryPasswordArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The password name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password schema name. Defaults to `public`.
        """
elif False:
    ConnectionConfluentSchemaRegistryPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistryPasswordArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The password name.
        :param pulumi.Input[_builtins.str] database_name: The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistrySshTunnelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssh_tunnel name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
elif False:
    ConnectionConfluentSchemaRegistrySshTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistrySshTunnelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssh_tunnel name.
        :param pulumi.Input[_builtins.str] database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistrySslCertificateArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateSecretArgsDict']]
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionConfluentSchemaRegistrySslCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistrySslCertificateArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateSecretArgs'] secret: The `ssl_certificate` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateSecretArgs']]:
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistrySslCertificateAuthorityArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgsDict']]
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionConfluentSchemaRegistrySslCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistrySslCertificateAuthorityArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgs'] secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgs']]:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl*certificate*authority name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
elif False:
    ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl*certificate*authority name.
        :param pulumi.Input[_builtins.str] database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistrySslCertificateSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl_certificate name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
elif False:
    ConnectionConfluentSchemaRegistrySslCertificateSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistrySslCertificateSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl_certificate name.
        :param pulumi.Input[_builtins.str] database_name: The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl_certificate schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl_certificate name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistrySslKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl_key name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_key schema name. Defaults to `public`.
        """
elif False:
    ConnectionConfluentSchemaRegistrySslKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistrySslKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl_key name.
        :param pulumi.Input[_builtins.str] database_name: The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl_key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistryUsernameArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionConfluentSchemaRegistryUsernameSecretArgsDict']]
        """
        The `username` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `username` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionConfluentSchemaRegistryUsernameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistryUsernameArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionConfluentSchemaRegistryUsernameSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionConfluentSchemaRegistryUsernameSecretArgs'] secret: The `username` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `username` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionConfluentSchemaRegistryUsernameSecretArgs']]:
        """
        The `username` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionConfluentSchemaRegistryUsernameSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `username` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionConfluentSchemaRegistryUsernameSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The username name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The username schema name. Defaults to `public`.
        """
elif False:
    ConnectionConfluentSchemaRegistryUsernameSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionConfluentSchemaRegistryUsernameSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The username name.
        :param pulumi.Input[_builtins.str] database_name: The username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The username schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The username name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The username schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaAwsConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The aws_connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_connection schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaAwsConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaAwsConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The aws_connection name.
        :param pulumi.Input[_builtins.str] database_name: The aws_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The aws_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The aws_connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaAwsPrivatelinkArgsDict(TypedDict):
        privatelink_connection: pulumi.Input['ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgsDict']
        """
        The AWS PrivateLink connection name in Materialize.
        """
        privatelink_connection_port: pulumi.Input[_builtins.int]
        """
        The port of the AWS PrivateLink connection.
        """
elif False:
    ConnectionKafkaAwsPrivatelinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaAwsPrivatelinkArgs:
    def __init__(__self__, *,
                 privatelink_connection: pulumi.Input['ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgs'],
                 privatelink_connection_port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input['ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgs'] privatelink_connection: The AWS PrivateLink connection name in Materialize.
        :param pulumi.Input[_builtins.int] privatelink_connection_port: The port of the AWS PrivateLink connection.
        """
        pulumi.set(__self__, "privatelink_connection", privatelink_connection)
        pulumi.set(__self__, "privatelink_connection_port", privatelink_connection_port)

    @_builtins.property
    @pulumi.getter(name="privatelinkConnection")
    def privatelink_connection(self) -> pulumi.Input['ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgs']:
        """
        The AWS PrivateLink connection name in Materialize.
        """
        return pulumi.get(self, "privatelink_connection")

    @privatelink_connection.setter
    def privatelink_connection(self, value: pulumi.Input['ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgs']):
        pulumi.set(self, "privatelink_connection", value)

    @_builtins.property
    @pulumi.getter(name="privatelinkConnectionPort")
    def privatelink_connection_port(self) -> pulumi.Input[_builtins.int]:
        """
        The port of the AWS PrivateLink connection.
        """
        return pulumi.get(self, "privatelink_connection_port")

    @privatelink_connection_port.setter
    def privatelink_connection_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "privatelink_connection_port", value)


if not MYPY:
    class ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The privatelink_connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The privatelink_connection schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The privatelink_connection name.
        :param pulumi.Input[_builtins.str] database_name: The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The privatelink_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The privatelink_connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The privatelink_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaKafkaBrokerArgsDict(TypedDict):
        broker: pulumi.Input[_builtins.str]
        """
        The Kafka broker, in the form of `host:port`.
        """
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The availability zone of the Kafka broker.
        """
        privatelink_connection: NotRequired[pulumi.Input['ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgsDict']]
        """
        The AWS PrivateLink connection name in Materialize.
        """
        ssh_tunnel: NotRequired[pulumi.Input['ConnectionKafkaKafkaBrokerSshTunnelArgsDict']]
        """
        The name of an SSH tunnel connection to route network traffic through by default.
        """
        target_group_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port of the target group associated with the Kafka broker.
        """
elif False:
    ConnectionKafkaKafkaBrokerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaKafkaBrokerArgs:
    def __init__(__self__, *,
                 broker: pulumi.Input[_builtins.str],
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 privatelink_connection: Optional[pulumi.Input['ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgs']] = None,
                 ssh_tunnel: Optional[pulumi.Input['ConnectionKafkaKafkaBrokerSshTunnelArgs']] = None,
                 target_group_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] broker: The Kafka broker, in the form of `host:port`.
        :param pulumi.Input[_builtins.str] availability_zone: The availability zone of the Kafka broker.
        :param pulumi.Input['ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgs'] privatelink_connection: The AWS PrivateLink connection name in Materialize.
        :param pulumi.Input['ConnectionKafkaKafkaBrokerSshTunnelArgs'] ssh_tunnel: The name of an SSH tunnel connection to route network traffic through by default.
        :param pulumi.Input[_builtins.int] target_group_port: The port of the target group associated with the Kafka broker.
        """
        pulumi.set(__self__, "broker", broker)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if privatelink_connection is not None:
            pulumi.set(__self__, "privatelink_connection", privatelink_connection)
        if ssh_tunnel is not None:
            pulumi.set(__self__, "ssh_tunnel", ssh_tunnel)
        if target_group_port is not None:
            pulumi.set(__self__, "target_group_port", target_group_port)

    @_builtins.property
    @pulumi.getter
    def broker(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka broker, in the form of `host:port`.
        """
        return pulumi.get(self, "broker")

    @broker.setter
    def broker(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "broker", value)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The availability zone of the Kafka broker.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="privatelinkConnection")
    def privatelink_connection(self) -> Optional[pulumi.Input['ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgs']]:
        """
        The AWS PrivateLink connection name in Materialize.
        """
        return pulumi.get(self, "privatelink_connection")

    @privatelink_connection.setter
    def privatelink_connection(self, value: Optional[pulumi.Input['ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgs']]):
        pulumi.set(self, "privatelink_connection", value)

    @_builtins.property
    @pulumi.getter(name="sshTunnel")
    def ssh_tunnel(self) -> Optional[pulumi.Input['ConnectionKafkaKafkaBrokerSshTunnelArgs']]:
        """
        The name of an SSH tunnel connection to route network traffic through by default.
        """
        return pulumi.get(self, "ssh_tunnel")

    @ssh_tunnel.setter
    def ssh_tunnel(self, value: Optional[pulumi.Input['ConnectionKafkaKafkaBrokerSshTunnelArgs']]):
        pulumi.set(self, "ssh_tunnel", value)

    @_builtins.property
    @pulumi.getter(name="targetGroupPort")
    def target_group_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port of the target group associated with the Kafka broker.
        """
        return pulumi.get(self, "target_group_port")

    @target_group_port.setter
    def target_group_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_group_port", value)


if not MYPY:
    class ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The privatelink_connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The privatelink_connection schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The privatelink_connection name.
        :param pulumi.Input[_builtins.str] database_name: The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The privatelink_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The privatelink_connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The privatelink_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaKafkaBrokerSshTunnelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssh_tunnel name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaKafkaBrokerSshTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaKafkaBrokerSshTunnelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssh_tunnel name.
        :param pulumi.Input[_builtins.str] database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaSaslPasswordArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The sasl_password name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sasl_password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sasl_password schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaSaslPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaSaslPasswordArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The sasl_password name.
        :param pulumi.Input[_builtins.str] database_name: The sasl_password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The sasl_password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The sasl_password name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sasl_password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sasl_password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaSaslUsernameArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionKafkaSaslUsernameSecretArgsDict']]
        """
        The `sasl_username` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `sasl_username` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionKafkaSaslUsernameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaSaslUsernameArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionKafkaSaslUsernameSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionKafkaSaslUsernameSecretArgs'] secret: The `sasl_username` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `sasl_username` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionKafkaSaslUsernameSecretArgs']]:
        """
        The `sasl_username` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionKafkaSaslUsernameSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `sasl_username` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionKafkaSaslUsernameSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The sasl_username name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sasl_username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sasl_username schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaSaslUsernameSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaSaslUsernameSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The sasl_username name.
        :param pulumi.Input[_builtins.str] database_name: The sasl_username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The sasl_username schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The sasl_username name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sasl_username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sasl_username schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaSshTunnelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssh_tunnel name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaSshTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaSshTunnelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssh_tunnel name.
        :param pulumi.Input[_builtins.str] database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaSslCertificateArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionKafkaSslCertificateSecretArgsDict']]
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionKafkaSslCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaSslCertificateArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionKafkaSslCertificateSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionKafkaSslCertificateSecretArgs'] secret: The `ssl_certificate` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionKafkaSslCertificateSecretArgs']]:
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionKafkaSslCertificateSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionKafkaSslCertificateAuthorityArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionKafkaSslCertificateAuthoritySecretArgsDict']]
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionKafkaSslCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaSslCertificateAuthorityArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionKafkaSslCertificateAuthoritySecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionKafkaSslCertificateAuthoritySecretArgs'] secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionKafkaSslCertificateAuthoritySecretArgs']]:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionKafkaSslCertificateAuthoritySecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionKafkaSslCertificateAuthoritySecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl*certificate*authority name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaSslCertificateAuthoritySecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaSslCertificateAuthoritySecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl*certificate*authority name.
        :param pulumi.Input[_builtins.str] database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaSslCertificateSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl_certificate name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaSslCertificateSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaSslCertificateSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl_certificate name.
        :param pulumi.Input[_builtins.str] database_name: The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl_certificate schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl_certificate name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionKafkaSslKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl_key name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_key schema name. Defaults to `public`.
        """
elif False:
    ConnectionKafkaSslKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionKafkaSslKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl_key name.
        :param pulumi.Input[_builtins.str] database_name: The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl_key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionMysqlAwsPrivatelinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The aws_privatelink name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
elif False:
    ConnectionMysqlAwsPrivatelinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlAwsPrivatelinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The aws_privatelink name.
        :param pulumi.Input[_builtins.str] database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionMysqlPasswordArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The password name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password schema name. Defaults to `public`.
        """
elif False:
    ConnectionMysqlPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlPasswordArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The password name.
        :param pulumi.Input[_builtins.str] database_name: The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionMysqlSshTunnelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssh_tunnel name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
elif False:
    ConnectionMysqlSshTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlSshTunnelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssh_tunnel name.
        :param pulumi.Input[_builtins.str] database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionMysqlSslCertificateArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionMysqlSslCertificateSecretArgsDict']]
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionMysqlSslCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlSslCertificateArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionMysqlSslCertificateSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionMysqlSslCertificateSecretArgs'] secret: The `ssl_certificate` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionMysqlSslCertificateSecretArgs']]:
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionMysqlSslCertificateSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionMysqlSslCertificateAuthorityArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionMysqlSslCertificateAuthoritySecretArgsDict']]
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionMysqlSslCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlSslCertificateAuthorityArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionMysqlSslCertificateAuthoritySecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionMysqlSslCertificateAuthoritySecretArgs'] secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionMysqlSslCertificateAuthoritySecretArgs']]:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionMysqlSslCertificateAuthoritySecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionMysqlSslCertificateAuthoritySecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl*certificate*authority name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
elif False:
    ConnectionMysqlSslCertificateAuthoritySecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlSslCertificateAuthoritySecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl*certificate*authority name.
        :param pulumi.Input[_builtins.str] database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionMysqlSslCertificateSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl_certificate name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
elif False:
    ConnectionMysqlSslCertificateSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlSslCertificateSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl_certificate name.
        :param pulumi.Input[_builtins.str] database_name: The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl_certificate schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl_certificate name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionMysqlSslKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl_key name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_key schema name. Defaults to `public`.
        """
elif False:
    ConnectionMysqlSslKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlSslKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl_key name.
        :param pulumi.Input[_builtins.str] database_name: The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl_key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionMysqlUserArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionMysqlUserSecretArgsDict']]
        """
        The `user` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `user` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionMysqlUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlUserArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionMysqlUserSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionMysqlUserSecretArgs'] secret: The `user` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `user` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionMysqlUserSecretArgs']]:
        """
        The `user` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionMysqlUserSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `user` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionMysqlUserSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The user name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user schema name. Defaults to `public`.
        """
elif False:
    ConnectionMysqlUserSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionMysqlUserSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The user name.
        :param pulumi.Input[_builtins.str] database_name: The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The user schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The user name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionPostgresAwsPrivatelinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The aws_privatelink name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
elif False:
    ConnectionPostgresAwsPrivatelinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresAwsPrivatelinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The aws_privatelink name.
        :param pulumi.Input[_builtins.str] database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionPostgresPasswordArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The password name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password schema name. Defaults to `public`.
        """
elif False:
    ConnectionPostgresPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresPasswordArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The password name.
        :param pulumi.Input[_builtins.str] database_name: The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionPostgresSshTunnelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssh_tunnel name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
elif False:
    ConnectionPostgresSshTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresSshTunnelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssh_tunnel name.
        :param pulumi.Input[_builtins.str] database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionPostgresSslCertificateArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionPostgresSslCertificateSecretArgsDict']]
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionPostgresSslCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresSslCertificateArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionPostgresSslCertificateSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionPostgresSslCertificateSecretArgs'] secret: The `ssl_certificate` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionPostgresSslCertificateSecretArgs']]:
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionPostgresSslCertificateSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionPostgresSslCertificateAuthorityArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionPostgresSslCertificateAuthoritySecretArgsDict']]
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionPostgresSslCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresSslCertificateAuthorityArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionPostgresSslCertificateAuthoritySecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionPostgresSslCertificateAuthoritySecretArgs'] secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionPostgresSslCertificateAuthoritySecretArgs']]:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionPostgresSslCertificateAuthoritySecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionPostgresSslCertificateAuthoritySecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl*certificate*authority name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
elif False:
    ConnectionPostgresSslCertificateAuthoritySecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresSslCertificateAuthoritySecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl*certificate*authority name.
        :param pulumi.Input[_builtins.str] database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionPostgresSslCertificateSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl_certificate name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
elif False:
    ConnectionPostgresSslCertificateSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresSslCertificateSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl_certificate name.
        :param pulumi.Input[_builtins.str] database_name: The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl_certificate schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl_certificate name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionPostgresSslKeyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl_key name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl_key schema name. Defaults to `public`.
        """
elif False:
    ConnectionPostgresSslKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresSslKeyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl_key name.
        :param pulumi.Input[_builtins.str] database_name: The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl_key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl_key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionPostgresUserArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionPostgresUserSecretArgsDict']]
        """
        The `user` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `user` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionPostgresUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresUserArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionPostgresUserSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionPostgresUserSecretArgs'] secret: The `user` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `user` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionPostgresUserSecretArgs']]:
        """
        The `user` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionPostgresUserSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `user` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionPostgresUserSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The user name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user schema name. Defaults to `public`.
        """
elif False:
    ConnectionPostgresUserSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionPostgresUserSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The user name.
        :param pulumi.Input[_builtins.str] database_name: The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The user schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The user name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionSqlserverAwsPrivatelinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The aws_privatelink name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
elif False:
    ConnectionSqlserverAwsPrivatelinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSqlserverAwsPrivatelinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The aws_privatelink name.
        :param pulumi.Input[_builtins.str] database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionSqlserverPasswordArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The password name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password schema name. Defaults to `public`.
        """
elif False:
    ConnectionSqlserverPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSqlserverPasswordArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The password name.
        :param pulumi.Input[_builtins.str] database_name: The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionSqlserverSshTunnelArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssh_tunnel name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
elif False:
    ConnectionSqlserverSshTunnelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSqlserverSshTunnelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssh_tunnel name.
        :param pulumi.Input[_builtins.str] database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionSqlserverSslCertificateAuthorityArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionSqlserverSslCertificateAuthoritySecretArgsDict']]
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionSqlserverSslCertificateAuthorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSqlserverSslCertificateAuthorityArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionSqlserverSslCertificateAuthoritySecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionSqlserverSslCertificateAuthoritySecretArgs'] secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionSqlserverSslCertificateAuthoritySecretArgs']]:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionSqlserverSslCertificateAuthoritySecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionSqlserverSslCertificateAuthoritySecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The ssl*certificate*authority name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
elif False:
    ConnectionSqlserverSslCertificateAuthoritySecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSqlserverSslCertificateAuthoritySecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The ssl*certificate*authority name.
        :param pulumi.Input[_builtins.str] database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class ConnectionSqlserverUserArgsDict(TypedDict):
        secret: NotRequired[pulumi.Input['ConnectionSqlserverUserSecretArgsDict']]
        """
        The `user` secret value. Conflicts with `text` within this block.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `user` text value. Conflicts with `secret` within this block
        """
elif False:
    ConnectionSqlserverUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSqlserverUserArgs:
    def __init__(__self__, *,
                 secret: Optional[pulumi.Input['ConnectionSqlserverUserSecretArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ConnectionSqlserverUserSecretArgs'] secret: The `user` secret value. Conflicts with `text` within this block.
        :param pulumi.Input[_builtins.str] text: The `user` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ConnectionSqlserverUserSecretArgs']]:
        """
        The `user` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ConnectionSqlserverUserSecretArgs']]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `user` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class ConnectionSqlserverUserSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The user name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user schema name. Defaults to `public`.
        """
elif False:
    ConnectionSqlserverUserSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSqlserverUserSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The user name.
        :param pulumi.Input[_builtins.str] database_name: The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The user schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The user name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class IndexColExprArgsDict(TypedDict):
        field: pulumi.Input[_builtins.str]
        """
        The name of the option you want to set.
        """
elif False:
    IndexColExprArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexColExprArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] field: The name of the option you want to set.
        """
        pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the option you want to set.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)


if not MYPY:
    class IndexObjNameArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The obj_name name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The obj_name database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The obj_name schema name. Defaults to `public`.
        """
elif False:
    IndexObjNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexObjNameArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The obj_name name.
        :param pulumi.Input[_builtins.str] database_name: The obj_name database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The obj_name schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The obj_name name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The obj_name database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The obj_name schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class NetworkPolicyRuleArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        The action to take for this rule. Currently only 'allow' is supported.
        """
        address: pulumi.Input[_builtins.str]
        """
        The CIDR block the rule will be applied to.
        """
        direction: pulumi.Input[_builtins.str]
        """
        The direction of traffic the rule applies to. Currently only 'ingress' is supported.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the rule.
        """
elif False:
    NetworkPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPolicyRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 address: pulumi.Input[_builtins.str],
                 direction: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] action: The action to take for this rule. Currently only 'allow' is supported.
        :param pulumi.Input[_builtins.str] address: The CIDR block the rule will be applied to.
        :param pulumi.Input[_builtins.str] direction: The direction of traffic the rule applies to. Currently only 'ingress' is supported.
        :param pulumi.Input[_builtins.str] name: The name of the rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        The action to take for this rule. Currently only 'allow' is supported.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        The CIDR block the rule will be applied to.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> pulumi.Input[_builtins.str]:
        """
        The direction of traffic the rule applies to. Currently only 'ingress' is supported.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "direction", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SinkKafkaEnvelopeArgsDict(TypedDict):
        debezium: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The generated schemas have a Debezium-style diff envelope to capture changes in the input view or source.
        """
        upsert: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The sink emits data with upsert semantics: updates and inserts for the given key are expressed as a value, and deletes are expressed as a null value payload in Kafka.
        """
elif False:
    SinkKafkaEnvelopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaEnvelopeArgs:
    def __init__(__self__, *,
                 debezium: Optional[pulumi.Input[_builtins.bool]] = None,
                 upsert: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] debezium: The generated schemas have a Debezium-style diff envelope to capture changes in the input view or source.
        :param pulumi.Input[_builtins.bool] upsert: The sink emits data with upsert semantics: updates and inserts for the given key are expressed as a value, and deletes are expressed as a null value payload in Kafka.
        """
        if debezium is not None:
            pulumi.set(__self__, "debezium", debezium)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @_builtins.property
    @pulumi.getter
    def debezium(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The generated schemas have a Debezium-style diff envelope to capture changes in the input view or source.
        """
        return pulumi.get(self, "debezium")

    @debezium.setter
    def debezium(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "debezium", value)

    @_builtins.property
    @pulumi.getter
    def upsert(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The sink emits data with upsert semantics: updates and inserts for the given key are expressed as a value, and deletes are expressed as a null value payload in Kafka.
        """
        return pulumi.get(self, "upsert")

    @upsert.setter
    def upsert(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "upsert", value)


if not MYPY:
    class SinkKafkaFormatArgsDict(TypedDict):
        avro: NotRequired[pulumi.Input['SinkKafkaFormatAvroArgsDict']]
        """
        Avro format.
        """
        json: NotRequired[pulumi.Input[_builtins.bool]]
        """
        JSON format.
        """
elif False:
    SinkKafkaFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaFormatArgs:
    def __init__(__self__, *,
                 avro: Optional[pulumi.Input['SinkKafkaFormatAvroArgs']] = None,
                 json: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['SinkKafkaFormatAvroArgs'] avro: Avro format.
        :param pulumi.Input[_builtins.bool] json: JSON format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if json is not None:
            pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def avro(self) -> Optional[pulumi.Input['SinkKafkaFormatAvroArgs']]:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @avro.setter
    def avro(self, value: Optional[pulumi.Input['SinkKafkaFormatAvroArgs']]):
        pulumi.set(self, "avro", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "json", value)


if not MYPY:
    class SinkKafkaFormatAvroArgsDict(TypedDict):
        schema_registry_connection: pulumi.Input['SinkKafkaFormatAvroSchemaRegistryConnectionArgsDict']
        """
        The name of a schema registry connection.
        """
        avro_doc_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['SinkKafkaFormatAvroAvroDocColumnArgsDict']]]]
        """
        Add column level documentation comment to the generated Avro schemas.
        """
        avro_doc_type: NotRequired[pulumi.Input['SinkKafkaFormatAvroAvroDocTypeArgsDict']]
        """
        Add top level documentation comment to the generated Avro schemas.
        """
        avro_key_fullname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full name of the Avro key schema.
        """
        avro_value_fullname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full name of the Avro value schema.
        """
        key_compatibility_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        If specified, set the Compatibility Level for the generated key schema.
        """
        value_compatibility_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        If specified, set the Compatibility Level for the generated value schema.
        """
elif False:
    SinkKafkaFormatAvroArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaFormatAvroArgs:
    def __init__(__self__, *,
                 schema_registry_connection: pulumi.Input['SinkKafkaFormatAvroSchemaRegistryConnectionArgs'],
                 avro_doc_columns: Optional[pulumi.Input[Sequence[pulumi.Input['SinkKafkaFormatAvroAvroDocColumnArgs']]]] = None,
                 avro_doc_type: Optional[pulumi.Input['SinkKafkaFormatAvroAvroDocTypeArgs']] = None,
                 avro_key_fullname: Optional[pulumi.Input[_builtins.str]] = None,
                 avro_value_fullname: Optional[pulumi.Input[_builtins.str]] = None,
                 key_compatibility_level: Optional[pulumi.Input[_builtins.str]] = None,
                 value_compatibility_level: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['SinkKafkaFormatAvroSchemaRegistryConnectionArgs'] schema_registry_connection: The name of a schema registry connection.
        :param pulumi.Input[Sequence[pulumi.Input['SinkKafkaFormatAvroAvroDocColumnArgs']]] avro_doc_columns: Add column level documentation comment to the generated Avro schemas.
        :param pulumi.Input['SinkKafkaFormatAvroAvroDocTypeArgs'] avro_doc_type: Add top level documentation comment to the generated Avro schemas.
        :param pulumi.Input[_builtins.str] avro_key_fullname: The full name of the Avro key schema.
        :param pulumi.Input[_builtins.str] avro_value_fullname: The full name of the Avro value schema.
        :param pulumi.Input[_builtins.str] key_compatibility_level: If specified, set the Compatibility Level for the generated key schema.
        :param pulumi.Input[_builtins.str] value_compatibility_level: If specified, set the Compatibility Level for the generated value schema.
        """
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if avro_doc_columns is not None:
            pulumi.set(__self__, "avro_doc_columns", avro_doc_columns)
        if avro_doc_type is not None:
            pulumi.set(__self__, "avro_doc_type", avro_doc_type)
        if avro_key_fullname is not None:
            pulumi.set(__self__, "avro_key_fullname", avro_key_fullname)
        if avro_value_fullname is not None:
            pulumi.set(__self__, "avro_value_fullname", avro_value_fullname)
        if key_compatibility_level is not None:
            pulumi.set(__self__, "key_compatibility_level", key_compatibility_level)
        if value_compatibility_level is not None:
            pulumi.set(__self__, "value_compatibility_level", value_compatibility_level)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> pulumi.Input['SinkKafkaFormatAvroSchemaRegistryConnectionArgs']:
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @schema_registry_connection.setter
    def schema_registry_connection(self, value: pulumi.Input['SinkKafkaFormatAvroSchemaRegistryConnectionArgs']):
        pulumi.set(self, "schema_registry_connection", value)

    @_builtins.property
    @pulumi.getter(name="avroDocColumns")
    def avro_doc_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SinkKafkaFormatAvroAvroDocColumnArgs']]]]:
        """
        Add column level documentation comment to the generated Avro schemas.
        """
        return pulumi.get(self, "avro_doc_columns")

    @avro_doc_columns.setter
    def avro_doc_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SinkKafkaFormatAvroAvroDocColumnArgs']]]]):
        pulumi.set(self, "avro_doc_columns", value)

    @_builtins.property
    @pulumi.getter(name="avroDocType")
    def avro_doc_type(self) -> Optional[pulumi.Input['SinkKafkaFormatAvroAvroDocTypeArgs']]:
        """
        Add top level documentation comment to the generated Avro schemas.
        """
        return pulumi.get(self, "avro_doc_type")

    @avro_doc_type.setter
    def avro_doc_type(self, value: Optional[pulumi.Input['SinkKafkaFormatAvroAvroDocTypeArgs']]):
        pulumi.set(self, "avro_doc_type", value)

    @_builtins.property
    @pulumi.getter(name="avroKeyFullname")
    def avro_key_fullname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full name of the Avro key schema.
        """
        return pulumi.get(self, "avro_key_fullname")

    @avro_key_fullname.setter
    def avro_key_fullname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "avro_key_fullname", value)

    @_builtins.property
    @pulumi.getter(name="avroValueFullname")
    def avro_value_fullname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full name of the Avro value schema.
        """
        return pulumi.get(self, "avro_value_fullname")

    @avro_value_fullname.setter
    def avro_value_fullname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "avro_value_fullname", value)

    @_builtins.property
    @pulumi.getter(name="keyCompatibilityLevel")
    def key_compatibility_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If specified, set the Compatibility Level for the generated key schema.
        """
        return pulumi.get(self, "key_compatibility_level")

    @key_compatibility_level.setter
    def key_compatibility_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_compatibility_level", value)

    @_builtins.property
    @pulumi.getter(name="valueCompatibilityLevel")
    def value_compatibility_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If specified, set the Compatibility Level for the generated value schema.
        """
        return pulumi.get(self, "value_compatibility_level")

    @value_compatibility_level.setter
    def value_compatibility_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_compatibility_level", value)


if not MYPY:
    class SinkKafkaFormatAvroAvroDocColumnArgsDict(TypedDict):
        column: pulumi.Input[_builtins.str]
        """
        Name of the column in the Avro schema to apply to.
        """
        doc: pulumi.Input[_builtins.str]
        """
        Documentation string.
        """
        object: pulumi.Input['SinkKafkaFormatAvroAvroDocColumnObjectArgsDict']
        """
        The object to apply the Avro documentation.
        """
        key: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Applies to the key schema.
        """
        value: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Applies to the value schema.
        """
elif False:
    SinkKafkaFormatAvroAvroDocColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaFormatAvroAvroDocColumnArgs:
    def __init__(__self__, *,
                 column: pulumi.Input[_builtins.str],
                 doc: pulumi.Input[_builtins.str],
                 object: pulumi.Input['SinkKafkaFormatAvroAvroDocColumnObjectArgs'],
                 key: Optional[pulumi.Input[_builtins.bool]] = None,
                 value: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] column: Name of the column in the Avro schema to apply to.
        :param pulumi.Input[_builtins.str] doc: Documentation string.
        :param pulumi.Input['SinkKafkaFormatAvroAvroDocColumnObjectArgs'] object: The object to apply the Avro documentation.
        :param pulumi.Input[_builtins.bool] key: Applies to the key schema.
        :param pulumi.Input[_builtins.bool] value: Applies to the value schema.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "doc", doc)
        pulumi.set(__self__, "object", object)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def column(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the column in the Avro schema to apply to.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "column", value)

    @_builtins.property
    @pulumi.getter
    def doc(self) -> pulumi.Input[_builtins.str]:
        """
        Documentation string.
        """
        return pulumi.get(self, "doc")

    @doc.setter
    def doc(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "doc", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> pulumi.Input['SinkKafkaFormatAvroAvroDocColumnObjectArgs']:
        """
        The object to apply the Avro documentation.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input['SinkKafkaFormatAvroAvroDocColumnObjectArgs']):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Applies to the key schema.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Applies to the value schema.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SinkKafkaFormatAvroAvroDocColumnObjectArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The object name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object schema name. Defaults to `public`.
        """
elif False:
    SinkKafkaFormatAvroAvroDocColumnObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaFormatAvroAvroDocColumnObjectArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The object name.
        :param pulumi.Input[_builtins.str] database_name: The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The object schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The object name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SinkKafkaFormatAvroAvroDocTypeArgsDict(TypedDict):
        doc: pulumi.Input[_builtins.str]
        """
        Documentation string.
        """
        object: pulumi.Input['SinkKafkaFormatAvroAvroDocTypeObjectArgsDict']
        """
        The object to apply the Avro documentation.
        """
        key: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Applies to the key schema.
        """
        value: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Applies to the value schema.
        """
elif False:
    SinkKafkaFormatAvroAvroDocTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaFormatAvroAvroDocTypeArgs:
    def __init__(__self__, *,
                 doc: pulumi.Input[_builtins.str],
                 object: pulumi.Input['SinkKafkaFormatAvroAvroDocTypeObjectArgs'],
                 key: Optional[pulumi.Input[_builtins.bool]] = None,
                 value: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] doc: Documentation string.
        :param pulumi.Input['SinkKafkaFormatAvroAvroDocTypeObjectArgs'] object: The object to apply the Avro documentation.
        :param pulumi.Input[_builtins.bool] key: Applies to the key schema.
        :param pulumi.Input[_builtins.bool] value: Applies to the value schema.
        """
        pulumi.set(__self__, "doc", doc)
        pulumi.set(__self__, "object", object)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def doc(self) -> pulumi.Input[_builtins.str]:
        """
        Documentation string.
        """
        return pulumi.get(self, "doc")

    @doc.setter
    def doc(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "doc", value)

    @_builtins.property
    @pulumi.getter
    def object(self) -> pulumi.Input['SinkKafkaFormatAvroAvroDocTypeObjectArgs']:
        """
        The object to apply the Avro documentation.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input['SinkKafkaFormatAvroAvroDocTypeObjectArgs']):
        pulumi.set(self, "object", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Applies to the key schema.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Applies to the value schema.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SinkKafkaFormatAvroAvroDocTypeObjectArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The object name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object schema name. Defaults to `public`.
        """
elif False:
    SinkKafkaFormatAvroAvroDocTypeObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaFormatAvroAvroDocTypeObjectArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The object name.
        :param pulumi.Input[_builtins.str] database_name: The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The object schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The object name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SinkKafkaFormatAvroSchemaRegistryConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The schema*registry*connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
elif False:
    SinkKafkaFormatAvroSchemaRegistryConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaFormatAvroSchemaRegistryConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The schema*registry*connection name.
        :param pulumi.Input[_builtins.str] database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SinkKafkaFromArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The from name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The from database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The from schema name. Defaults to `public`.
        """
elif False:
    SinkKafkaFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaFromArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The from name.
        :param pulumi.Input[_builtins.str] database_name: The from database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The from schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The from name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The from database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The from schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SinkKafkaKafkaConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The kafka_connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kafka_connection schema name. Defaults to `public`.
        """
elif False:
    SinkKafkaKafkaConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SinkKafkaKafkaConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The kafka_connection name.
        :param pulumi.Input[_builtins.str] database_name: The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The kafka_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The kafka_connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kafka_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceKafkaEnvelopeArgsDict(TypedDict):
        debezium: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use the Debezium envelope, which uses a diff envelope to handle CRUD operations.
        """
        none: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use an append-only envelope. This means that records will only be appended and cannot be updated or deleted.
        """
        upsert: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use the upsert envelope, which uses message keys to handle CRUD operations.
        """
        upsert_options: NotRequired[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsArgsDict']]
        """
        Options for the upsert envelope.
        """
elif False:
    SourceKafkaEnvelopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaEnvelopeArgs:
    def __init__(__self__, *,
                 debezium: Optional[pulumi.Input[_builtins.bool]] = None,
                 none: Optional[pulumi.Input[_builtins.bool]] = None,
                 upsert: Optional[pulumi.Input[_builtins.bool]] = None,
                 upsert_options: Optional[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] debezium: Use the Debezium envelope, which uses a diff envelope to handle CRUD operations.
        :param pulumi.Input[_builtins.bool] none: Use an append-only envelope. This means that records will only be appended and cannot be updated or deleted.
        :param pulumi.Input[_builtins.bool] upsert: Use the upsert envelope, which uses message keys to handle CRUD operations.
        :param pulumi.Input['SourceKafkaEnvelopeUpsertOptionsArgs'] upsert_options: Options for the upsert envelope.
        """
        if debezium is not None:
            pulumi.set(__self__, "debezium", debezium)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)
        if upsert_options is not None:
            pulumi.set(__self__, "upsert_options", upsert_options)

    @_builtins.property
    @pulumi.getter
    def debezium(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use the Debezium envelope, which uses a diff envelope to handle CRUD operations.
        """
        return pulumi.get(self, "debezium")

    @debezium.setter
    def debezium(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "debezium", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use an append-only envelope. This means that records will only be appended and cannot be updated or deleted.
        """
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "none", value)

    @_builtins.property
    @pulumi.getter
    def upsert(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use the upsert envelope, which uses message keys to handle CRUD operations.
        """
        return pulumi.get(self, "upsert")

    @upsert.setter
    def upsert(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "upsert", value)

    @_builtins.property
    @pulumi.getter(name="upsertOptions")
    def upsert_options(self) -> Optional[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsArgs']]:
        """
        Options for the upsert envelope.
        """
        return pulumi.get(self, "upsert_options")

    @upsert_options.setter
    def upsert_options(self, value: Optional[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsArgs']]):
        pulumi.set(self, "upsert_options", value)


if not MYPY:
    class SourceKafkaEnvelopeUpsertOptionsArgsDict(TypedDict):
        value_decoding_errors: NotRequired[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgsDict']]
        """
        Specify how to handle value decoding errors in the upsert envelope.
        """
elif False:
    SourceKafkaEnvelopeUpsertOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaEnvelopeUpsertOptionsArgs:
    def __init__(__self__, *,
                 value_decoding_errors: Optional[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgs']] = None):
        """
        :param pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgs'] value_decoding_errors: Specify how to handle value decoding errors in the upsert envelope.
        """
        if value_decoding_errors is not None:
            pulumi.set(__self__, "value_decoding_errors", value_decoding_errors)

    @_builtins.property
    @pulumi.getter(name="valueDecodingErrors")
    def value_decoding_errors(self) -> Optional[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgs']]:
        """
        Specify how to handle value decoding errors in the upsert envelope.
        """
        return pulumi.get(self, "value_decoding_errors")

    @value_decoding_errors.setter
    def value_decoding_errors(self, value: Optional[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgs']]):
        pulumi.set(self, "value_decoding_errors", value)


if not MYPY:
    class SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgsDict(TypedDict):
        inline: NotRequired[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgsDict']]
        """
        Configuration for inline value decoding errors.
        """
elif False:
    SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgs:
    def __init__(__self__, *,
                 inline: Optional[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgs']] = None):
        """
        :param pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgs'] inline: Configuration for inline value decoding errors.
        """
        if inline is not None:
            pulumi.set(__self__, "inline", inline)

    @_builtins.property
    @pulumi.getter
    def inline(self) -> Optional[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgs']]:
        """
        Configuration for inline value decoding errors.
        """
        return pulumi.get(self, "inline")

    @inline.setter
    def inline(self, value: Optional[pulumi.Input['SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgs']]):
        pulumi.set(self, "inline", value)


if not MYPY:
    class SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgsDict(TypedDict):
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify an alias for the value decoding errors column, to use an alternative name for the error column. If not specified, the column name will be `error`.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable inline value decoding errors.
        """
elif False:
    SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgs:
    def __init__(__self__, *,
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] alias: Specify an alias for the value decoding errors column, to use an alternative name for the error column. If not specified, the column name will be `error`.
        :param pulumi.Input[_builtins.bool] enabled: Enable inline value decoding errors.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify an alias for the value decoding errors column, to use an alternative name for the error column. If not specified, the column name will be `error`.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable inline value decoding errors.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SourceKafkaExposeProgressArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The expose_progress name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress schema name. Defaults to `public`.
        """
elif False:
    SourceKafkaExposeProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaExposeProgressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The expose_progress name.
        :param pulumi.Input[_builtins.str] database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceKafkaFormatArgsDict(TypedDict):
        avro: NotRequired[pulumi.Input['SourceKafkaFormatAvroArgsDict']]
        """
        Avro format.
        """
        bytes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        BYTES format.
        """
        csvs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SourceKafkaFormatCsvArgsDict']]]]
        """
        CSV format.
        """
        json: NotRequired[pulumi.Input[_builtins.bool]]
        """
        JSON format.
        """
        protobuf: NotRequired[pulumi.Input['SourceKafkaFormatProtobufArgsDict']]
        """
        Protobuf format.
        """
        text: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Text format.
        """
elif False:
    SourceKafkaFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaFormatArgs:
    def __init__(__self__, *,
                 avro: Optional[pulumi.Input['SourceKafkaFormatAvroArgs']] = None,
                 bytes: Optional[pulumi.Input[_builtins.bool]] = None,
                 csvs: Optional[pulumi.Input[Sequence[pulumi.Input['SourceKafkaFormatCsvArgs']]]] = None,
                 json: Optional[pulumi.Input[_builtins.bool]] = None,
                 protobuf: Optional[pulumi.Input['SourceKafkaFormatProtobufArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['SourceKafkaFormatAvroArgs'] avro: Avro format.
        :param pulumi.Input[_builtins.bool] bytes: BYTES format.
        :param pulumi.Input[Sequence[pulumi.Input['SourceKafkaFormatCsvArgs']]] csvs: CSV format.
        :param pulumi.Input[_builtins.bool] json: JSON format.
        :param pulumi.Input['SourceKafkaFormatProtobufArgs'] protobuf: Protobuf format.
        :param pulumi.Input[_builtins.bool] text: Text format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if protobuf is not None:
            pulumi.set(__self__, "protobuf", protobuf)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def avro(self) -> Optional[pulumi.Input['SourceKafkaFormatAvroArgs']]:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @avro.setter
    def avro(self, value: Optional[pulumi.Input['SourceKafkaFormatAvroArgs']]):
        pulumi.set(self, "avro", value)

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        BYTES format.
        """
        return pulumi.get(self, "bytes")

    @bytes.setter
    def bytes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bytes", value)

    @_builtins.property
    @pulumi.getter
    def csvs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceKafkaFormatCsvArgs']]]]:
        """
        CSV format.
        """
        return pulumi.get(self, "csvs")

    @csvs.setter
    def csvs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceKafkaFormatCsvArgs']]]]):
        pulumi.set(self, "csvs", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "json", value)

    @_builtins.property
    @pulumi.getter
    def protobuf(self) -> Optional[pulumi.Input['SourceKafkaFormatProtobufArgs']]:
        """
        Protobuf format.
        """
        return pulumi.get(self, "protobuf")

    @protobuf.setter
    def protobuf(self, value: Optional[pulumi.Input['SourceKafkaFormatProtobufArgs']]):
        pulumi.set(self, "protobuf", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Text format.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class SourceKafkaFormatAvroArgsDict(TypedDict):
        schema_registry_connection: pulumi.Input['SourceKafkaFormatAvroSchemaRegistryConnectionArgsDict']
        """
        The name of a schema registry connection.
        """
        key_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        How Materialize will define the Avro schema reader key strategy.
        """
        value_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        How Materialize will define the Avro schema reader value strategy.
        """
elif False:
    SourceKafkaFormatAvroArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaFormatAvroArgs:
    def __init__(__self__, *,
                 schema_registry_connection: pulumi.Input['SourceKafkaFormatAvroSchemaRegistryConnectionArgs'],
                 key_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 value_strategy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['SourceKafkaFormatAvroSchemaRegistryConnectionArgs'] schema_registry_connection: The name of a schema registry connection.
        :param pulumi.Input[_builtins.str] key_strategy: How Materialize will define the Avro schema reader key strategy.
        :param pulumi.Input[_builtins.str] value_strategy: How Materialize will define the Avro schema reader value strategy.
        """
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if key_strategy is not None:
            pulumi.set(__self__, "key_strategy", key_strategy)
        if value_strategy is not None:
            pulumi.set(__self__, "value_strategy", value_strategy)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> pulumi.Input['SourceKafkaFormatAvroSchemaRegistryConnectionArgs']:
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @schema_registry_connection.setter
    def schema_registry_connection(self, value: pulumi.Input['SourceKafkaFormatAvroSchemaRegistryConnectionArgs']):
        pulumi.set(self, "schema_registry_connection", value)

    @_builtins.property
    @pulumi.getter(name="keyStrategy")
    def key_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How Materialize will define the Avro schema reader key strategy.
        """
        return pulumi.get(self, "key_strategy")

    @key_strategy.setter
    def key_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_strategy", value)

    @_builtins.property
    @pulumi.getter(name="valueStrategy")
    def value_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How Materialize will define the Avro schema reader value strategy.
        """
        return pulumi.get(self, "value_strategy")

    @value_strategy.setter
    def value_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_strategy", value)


if not MYPY:
    class SourceKafkaFormatAvroSchemaRegistryConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The schema*registry*connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
elif False:
    SourceKafkaFormatAvroSchemaRegistryConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaFormatAvroSchemaRegistryConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The schema*registry*connection name.
        :param pulumi.Input[_builtins.str] database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceKafkaFormatCsvArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[_builtins.int]]
        """
        The columns to use for the source.
        """
        delimited_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        The delimiter to use for the source.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The number of columns and the name of each column using the header row.
        """
elif False:
    SourceKafkaFormatCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaFormatCsvArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[_builtins.int]] = None,
                 delimited_by: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] column: The columns to use for the source.
        :param pulumi.Input[_builtins.str] delimited_by: The delimiter to use for the source.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: The number of columns and the name of each column using the header row.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if delimited_by is not None:
            pulumi.set(__self__, "delimited_by", delimited_by)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The columns to use for the source.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "column", value)

    @_builtins.property
    @pulumi.getter(name="delimitedBy")
    def delimited_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The delimiter to use for the source.
        """
        return pulumi.get(self, "delimited_by")

    @delimited_by.setter
    def delimited_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimited_by", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The number of columns and the name of each column using the header row.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class SourceKafkaFormatProtobufArgsDict(TypedDict):
        message: pulumi.Input[_builtins.str]
        """
        The name of the Protobuf message to use for the source.
        """
        schema_registry_connection: pulumi.Input['SourceKafkaFormatProtobufSchemaRegistryConnectionArgsDict']
        """
        The name of a schema registry connection.
        """
elif False:
    SourceKafkaFormatProtobufArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaFormatProtobufArgs:
    def __init__(__self__, *,
                 message: pulumi.Input[_builtins.str],
                 schema_registry_connection: pulumi.Input['SourceKafkaFormatProtobufSchemaRegistryConnectionArgs']):
        """
        :param pulumi.Input[_builtins.str] message: The name of the Protobuf message to use for the source.
        :param pulumi.Input['SourceKafkaFormatProtobufSchemaRegistryConnectionArgs'] schema_registry_connection: The name of a schema registry connection.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)

    @_builtins.property
    @pulumi.getter
    def message(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Protobuf message to use for the source.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> pulumi.Input['SourceKafkaFormatProtobufSchemaRegistryConnectionArgs']:
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @schema_registry_connection.setter
    def schema_registry_connection(self, value: pulumi.Input['SourceKafkaFormatProtobufSchemaRegistryConnectionArgs']):
        pulumi.set(self, "schema_registry_connection", value)


if not MYPY:
    class SourceKafkaFormatProtobufSchemaRegistryConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The schema*registry*connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
elif False:
    SourceKafkaFormatProtobufSchemaRegistryConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaFormatProtobufSchemaRegistryConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The schema*registry*connection name.
        :param pulumi.Input[_builtins.str] database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceKafkaKafkaConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The kafka_connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kafka_connection schema name. Defaults to `public`.
        """
elif False:
    SourceKafkaKafkaConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaKafkaConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The kafka_connection name.
        :param pulumi.Input[_builtins.str] database_name: The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The kafka_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The kafka_connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kafka_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceKafkaKeyFormatArgsDict(TypedDict):
        avro: NotRequired[pulumi.Input['SourceKafkaKeyFormatAvroArgsDict']]
        """
        Avro format.
        """
        bytes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        BYTES format.
        """
        csvs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SourceKafkaKeyFormatCsvArgsDict']]]]
        """
        CSV format.
        """
        json: NotRequired[pulumi.Input[_builtins.bool]]
        """
        JSON format.
        """
        protobuf: NotRequired[pulumi.Input['SourceKafkaKeyFormatProtobufArgsDict']]
        """
        Protobuf format.
        """
        text: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Text format.
        """
elif False:
    SourceKafkaKeyFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaKeyFormatArgs:
    def __init__(__self__, *,
                 avro: Optional[pulumi.Input['SourceKafkaKeyFormatAvroArgs']] = None,
                 bytes: Optional[pulumi.Input[_builtins.bool]] = None,
                 csvs: Optional[pulumi.Input[Sequence[pulumi.Input['SourceKafkaKeyFormatCsvArgs']]]] = None,
                 json: Optional[pulumi.Input[_builtins.bool]] = None,
                 protobuf: Optional[pulumi.Input['SourceKafkaKeyFormatProtobufArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['SourceKafkaKeyFormatAvroArgs'] avro: Avro format.
        :param pulumi.Input[_builtins.bool] bytes: BYTES format.
        :param pulumi.Input[Sequence[pulumi.Input['SourceKafkaKeyFormatCsvArgs']]] csvs: CSV format.
        :param pulumi.Input[_builtins.bool] json: JSON format.
        :param pulumi.Input['SourceKafkaKeyFormatProtobufArgs'] protobuf: Protobuf format.
        :param pulumi.Input[_builtins.bool] text: Text format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if protobuf is not None:
            pulumi.set(__self__, "protobuf", protobuf)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def avro(self) -> Optional[pulumi.Input['SourceKafkaKeyFormatAvroArgs']]:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @avro.setter
    def avro(self, value: Optional[pulumi.Input['SourceKafkaKeyFormatAvroArgs']]):
        pulumi.set(self, "avro", value)

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        BYTES format.
        """
        return pulumi.get(self, "bytes")

    @bytes.setter
    def bytes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bytes", value)

    @_builtins.property
    @pulumi.getter
    def csvs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceKafkaKeyFormatCsvArgs']]]]:
        """
        CSV format.
        """
        return pulumi.get(self, "csvs")

    @csvs.setter
    def csvs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceKafkaKeyFormatCsvArgs']]]]):
        pulumi.set(self, "csvs", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "json", value)

    @_builtins.property
    @pulumi.getter
    def protobuf(self) -> Optional[pulumi.Input['SourceKafkaKeyFormatProtobufArgs']]:
        """
        Protobuf format.
        """
        return pulumi.get(self, "protobuf")

    @protobuf.setter
    def protobuf(self, value: Optional[pulumi.Input['SourceKafkaKeyFormatProtobufArgs']]):
        pulumi.set(self, "protobuf", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Text format.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class SourceKafkaKeyFormatAvroArgsDict(TypedDict):
        schema_registry_connection: pulumi.Input['SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgsDict']
        """
        The name of a schema registry connection.
        """
        key_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        How Materialize will define the Avro schema reader key strategy.
        """
        value_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        How Materialize will define the Avro schema reader value strategy.
        """
elif False:
    SourceKafkaKeyFormatAvroArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaKeyFormatAvroArgs:
    def __init__(__self__, *,
                 schema_registry_connection: pulumi.Input['SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgs'],
                 key_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 value_strategy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgs'] schema_registry_connection: The name of a schema registry connection.
        :param pulumi.Input[_builtins.str] key_strategy: How Materialize will define the Avro schema reader key strategy.
        :param pulumi.Input[_builtins.str] value_strategy: How Materialize will define the Avro schema reader value strategy.
        """
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if key_strategy is not None:
            pulumi.set(__self__, "key_strategy", key_strategy)
        if value_strategy is not None:
            pulumi.set(__self__, "value_strategy", value_strategy)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> pulumi.Input['SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgs']:
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @schema_registry_connection.setter
    def schema_registry_connection(self, value: pulumi.Input['SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgs']):
        pulumi.set(self, "schema_registry_connection", value)

    @_builtins.property
    @pulumi.getter(name="keyStrategy")
    def key_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How Materialize will define the Avro schema reader key strategy.
        """
        return pulumi.get(self, "key_strategy")

    @key_strategy.setter
    def key_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_strategy", value)

    @_builtins.property
    @pulumi.getter(name="valueStrategy")
    def value_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How Materialize will define the Avro schema reader value strategy.
        """
        return pulumi.get(self, "value_strategy")

    @value_strategy.setter
    def value_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_strategy", value)


if not MYPY:
    class SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The schema*registry*connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
elif False:
    SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The schema*registry*connection name.
        :param pulumi.Input[_builtins.str] database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceKafkaKeyFormatCsvArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[_builtins.int]]
        """
        The columns to use for the source.
        """
        delimited_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        The delimiter to use for the source.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The number of columns and the name of each column using the header row.
        """
elif False:
    SourceKafkaKeyFormatCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaKeyFormatCsvArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[_builtins.int]] = None,
                 delimited_by: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] column: The columns to use for the source.
        :param pulumi.Input[_builtins.str] delimited_by: The delimiter to use for the source.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: The number of columns and the name of each column using the header row.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if delimited_by is not None:
            pulumi.set(__self__, "delimited_by", delimited_by)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The columns to use for the source.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "column", value)

    @_builtins.property
    @pulumi.getter(name="delimitedBy")
    def delimited_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The delimiter to use for the source.
        """
        return pulumi.get(self, "delimited_by")

    @delimited_by.setter
    def delimited_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimited_by", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The number of columns and the name of each column using the header row.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class SourceKafkaKeyFormatProtobufArgsDict(TypedDict):
        message: pulumi.Input[_builtins.str]
        """
        The name of the Protobuf message to use for the source.
        """
        schema_registry_connection: pulumi.Input['SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgsDict']
        """
        The name of a schema registry connection.
        """
elif False:
    SourceKafkaKeyFormatProtobufArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaKeyFormatProtobufArgs:
    def __init__(__self__, *,
                 message: pulumi.Input[_builtins.str],
                 schema_registry_connection: pulumi.Input['SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgs']):
        """
        :param pulumi.Input[_builtins.str] message: The name of the Protobuf message to use for the source.
        :param pulumi.Input['SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgs'] schema_registry_connection: The name of a schema registry connection.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)

    @_builtins.property
    @pulumi.getter
    def message(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Protobuf message to use for the source.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> pulumi.Input['SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgs']:
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @schema_registry_connection.setter
    def schema_registry_connection(self, value: pulumi.Input['SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgs']):
        pulumi.set(self, "schema_registry_connection", value)


if not MYPY:
    class SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The schema*registry*connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
elif False:
    SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The schema*registry*connection name.
        :param pulumi.Input[_builtins.str] database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceKafkaValueFormatArgsDict(TypedDict):
        avro: NotRequired[pulumi.Input['SourceKafkaValueFormatAvroArgsDict']]
        """
        Avro format.
        """
        bytes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        BYTES format.
        """
        csvs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SourceKafkaValueFormatCsvArgsDict']]]]
        """
        CSV format.
        """
        json: NotRequired[pulumi.Input[_builtins.bool]]
        """
        JSON format.
        """
        protobuf: NotRequired[pulumi.Input['SourceKafkaValueFormatProtobufArgsDict']]
        """
        Protobuf format.
        """
        text: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Text format.
        """
elif False:
    SourceKafkaValueFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaValueFormatArgs:
    def __init__(__self__, *,
                 avro: Optional[pulumi.Input['SourceKafkaValueFormatAvroArgs']] = None,
                 bytes: Optional[pulumi.Input[_builtins.bool]] = None,
                 csvs: Optional[pulumi.Input[Sequence[pulumi.Input['SourceKafkaValueFormatCsvArgs']]]] = None,
                 json: Optional[pulumi.Input[_builtins.bool]] = None,
                 protobuf: Optional[pulumi.Input['SourceKafkaValueFormatProtobufArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['SourceKafkaValueFormatAvroArgs'] avro: Avro format.
        :param pulumi.Input[_builtins.bool] bytes: BYTES format.
        :param pulumi.Input[Sequence[pulumi.Input['SourceKafkaValueFormatCsvArgs']]] csvs: CSV format.
        :param pulumi.Input[_builtins.bool] json: JSON format.
        :param pulumi.Input['SourceKafkaValueFormatProtobufArgs'] protobuf: Protobuf format.
        :param pulumi.Input[_builtins.bool] text: Text format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if protobuf is not None:
            pulumi.set(__self__, "protobuf", protobuf)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def avro(self) -> Optional[pulumi.Input['SourceKafkaValueFormatAvroArgs']]:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @avro.setter
    def avro(self, value: Optional[pulumi.Input['SourceKafkaValueFormatAvroArgs']]):
        pulumi.set(self, "avro", value)

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        BYTES format.
        """
        return pulumi.get(self, "bytes")

    @bytes.setter
    def bytes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bytes", value)

    @_builtins.property
    @pulumi.getter
    def csvs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SourceKafkaValueFormatCsvArgs']]]]:
        """
        CSV format.
        """
        return pulumi.get(self, "csvs")

    @csvs.setter
    def csvs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SourceKafkaValueFormatCsvArgs']]]]):
        pulumi.set(self, "csvs", value)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "json", value)

    @_builtins.property
    @pulumi.getter
    def protobuf(self) -> Optional[pulumi.Input['SourceKafkaValueFormatProtobufArgs']]:
        """
        Protobuf format.
        """
        return pulumi.get(self, "protobuf")

    @protobuf.setter
    def protobuf(self, value: Optional[pulumi.Input['SourceKafkaValueFormatProtobufArgs']]):
        pulumi.set(self, "protobuf", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Text format.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class SourceKafkaValueFormatAvroArgsDict(TypedDict):
        schema_registry_connection: pulumi.Input['SourceKafkaValueFormatAvroSchemaRegistryConnectionArgsDict']
        """
        The name of a schema registry connection.
        """
        key_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        How Materialize will define the Avro schema reader key strategy.
        """
        value_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        How Materialize will define the Avro schema reader value strategy.
        """
elif False:
    SourceKafkaValueFormatAvroArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaValueFormatAvroArgs:
    def __init__(__self__, *,
                 schema_registry_connection: pulumi.Input['SourceKafkaValueFormatAvroSchemaRegistryConnectionArgs'],
                 key_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 value_strategy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['SourceKafkaValueFormatAvroSchemaRegistryConnectionArgs'] schema_registry_connection: The name of a schema registry connection.
        :param pulumi.Input[_builtins.str] key_strategy: How Materialize will define the Avro schema reader key strategy.
        :param pulumi.Input[_builtins.str] value_strategy: How Materialize will define the Avro schema reader value strategy.
        """
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if key_strategy is not None:
            pulumi.set(__self__, "key_strategy", key_strategy)
        if value_strategy is not None:
            pulumi.set(__self__, "value_strategy", value_strategy)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> pulumi.Input['SourceKafkaValueFormatAvroSchemaRegistryConnectionArgs']:
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @schema_registry_connection.setter
    def schema_registry_connection(self, value: pulumi.Input['SourceKafkaValueFormatAvroSchemaRegistryConnectionArgs']):
        pulumi.set(self, "schema_registry_connection", value)

    @_builtins.property
    @pulumi.getter(name="keyStrategy")
    def key_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How Materialize will define the Avro schema reader key strategy.
        """
        return pulumi.get(self, "key_strategy")

    @key_strategy.setter
    def key_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_strategy", value)

    @_builtins.property
    @pulumi.getter(name="valueStrategy")
    def value_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How Materialize will define the Avro schema reader value strategy.
        """
        return pulumi.get(self, "value_strategy")

    @value_strategy.setter
    def value_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_strategy", value)


if not MYPY:
    class SourceKafkaValueFormatAvroSchemaRegistryConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The schema*registry*connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
elif False:
    SourceKafkaValueFormatAvroSchemaRegistryConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaValueFormatAvroSchemaRegistryConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The schema*registry*connection name.
        :param pulumi.Input[_builtins.str] database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceKafkaValueFormatCsvArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[_builtins.int]]
        """
        The columns to use for the source.
        """
        delimited_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        The delimiter to use for the source.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The number of columns and the name of each column using the header row.
        """
elif False:
    SourceKafkaValueFormatCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaValueFormatCsvArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[_builtins.int]] = None,
                 delimited_by: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] column: The columns to use for the source.
        :param pulumi.Input[_builtins.str] delimited_by: The delimiter to use for the source.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: The number of columns and the name of each column using the header row.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if delimited_by is not None:
            pulumi.set(__self__, "delimited_by", delimited_by)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The columns to use for the source.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "column", value)

    @_builtins.property
    @pulumi.getter(name="delimitedBy")
    def delimited_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The delimiter to use for the source.
        """
        return pulumi.get(self, "delimited_by")

    @delimited_by.setter
    def delimited_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimited_by", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The number of columns and the name of each column using the header row.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class SourceKafkaValueFormatProtobufArgsDict(TypedDict):
        message: pulumi.Input[_builtins.str]
        """
        The name of the Protobuf message to use for the source.
        """
        schema_registry_connection: pulumi.Input['SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgsDict']
        """
        The name of a schema registry connection.
        """
elif False:
    SourceKafkaValueFormatProtobufArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaValueFormatProtobufArgs:
    def __init__(__self__, *,
                 message: pulumi.Input[_builtins.str],
                 schema_registry_connection: pulumi.Input['SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgs']):
        """
        :param pulumi.Input[_builtins.str] message: The name of the Protobuf message to use for the source.
        :param pulumi.Input['SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgs'] schema_registry_connection: The name of a schema registry connection.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)

    @_builtins.property
    @pulumi.getter
    def message(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Protobuf message to use for the source.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> pulumi.Input['SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgs']:
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @schema_registry_connection.setter
    def schema_registry_connection(self, value: pulumi.Input['SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgs']):
        pulumi.set(self, "schema_registry_connection", value)


if not MYPY:
    class SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The schema*registry*connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
elif False:
    SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The schema*registry*connection name.
        :param pulumi.Input[_builtins.str] database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceLoadgenAuctionOptionsArgsDict(TypedDict):
        scale_factor: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        tick_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
elif False:
    SourceLoadgenAuctionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceLoadgenAuctionOptionsArgs:
    def __init__(__self__, *,
                 scale_factor: Optional[pulumi.Input[_builtins.float]] = None,
                 tick_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] scale_factor: (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        :param pulumi.Input[_builtins.str] tick_interval: The interval at which the next datum should be emitted. Defaults to one second.
        """
        if scale_factor is not None:
            warnings.warn("""Scale factor is deprecated and will be removed in a future release.""", DeprecationWarning)
            pulumi.log.warn("""scale_factor is deprecated: Scale factor is deprecated and will be removed in a future release.""")
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if tick_interval is not None:
            pulumi.set(__self__, "tick_interval", tick_interval)

    @_builtins.property
    @pulumi.getter(name="scaleFactor")
    @_utilities.deprecated("""Scale factor is deprecated and will be removed in a future release.""")
    def scale_factor(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        return pulumi.get(self, "scale_factor")

    @scale_factor.setter
    def scale_factor(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "scale_factor", value)

    @_builtins.property
    @pulumi.getter(name="tickInterval")
    def tick_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
        return pulumi.get(self, "tick_interval")

    @tick_interval.setter
    def tick_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tick_interval", value)


if not MYPY:
    class SourceLoadgenExposeProgressArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The expose_progress name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress schema name. Defaults to `public`.
        """
elif False:
    SourceLoadgenExposeProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceLoadgenExposeProgressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The expose_progress name.
        :param pulumi.Input[_builtins.str] database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceLoadgenMarketingOptionsArgsDict(TypedDict):
        scale_factor: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        tick_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
elif False:
    SourceLoadgenMarketingOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceLoadgenMarketingOptionsArgs:
    def __init__(__self__, *,
                 scale_factor: Optional[pulumi.Input[_builtins.float]] = None,
                 tick_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] scale_factor: (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        :param pulumi.Input[_builtins.str] tick_interval: The interval at which the next datum should be emitted. Defaults to one second.
        """
        if scale_factor is not None:
            warnings.warn("""Scale factor is deprecated and will be removed in a future release.""", DeprecationWarning)
            pulumi.log.warn("""scale_factor is deprecated: Scale factor is deprecated and will be removed in a future release.""")
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if tick_interval is not None:
            pulumi.set(__self__, "tick_interval", tick_interval)

    @_builtins.property
    @pulumi.getter(name="scaleFactor")
    @_utilities.deprecated("""Scale factor is deprecated and will be removed in a future release.""")
    def scale_factor(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        return pulumi.get(self, "scale_factor")

    @scale_factor.setter
    def scale_factor(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "scale_factor", value)

    @_builtins.property
    @pulumi.getter(name="tickInterval")
    def tick_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
        return pulumi.get(self, "tick_interval")

    @tick_interval.setter
    def tick_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tick_interval", value)


if not MYPY:
    class SourceLoadgenTpchOptionsArgsDict(TypedDict):
        scale_factor: NotRequired[pulumi.Input[_builtins.float]]
        """
        The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        tick_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
elif False:
    SourceLoadgenTpchOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceLoadgenTpchOptionsArgs:
    def __init__(__self__, *,
                 scale_factor: Optional[pulumi.Input[_builtins.float]] = None,
                 tick_interval: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] scale_factor: The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        :param pulumi.Input[_builtins.str] tick_interval: The interval at which the next datum should be emitted. Defaults to one second.
        """
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if tick_interval is not None:
            pulumi.set(__self__, "tick_interval", tick_interval)

    @_builtins.property
    @pulumi.getter(name="scaleFactor")
    def scale_factor(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        return pulumi.get(self, "scale_factor")

    @scale_factor.setter
    def scale_factor(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "scale_factor", value)

    @_builtins.property
    @pulumi.getter(name="tickInterval")
    def tick_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
        return pulumi.get(self, "tick_interval")

    @tick_interval.setter
    def tick_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tick_interval", value)


if not MYPY:
    class SourceMysqlExposeProgressArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The expose_progress name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress schema name. Defaults to `public`.
        """
elif False:
    SourceMysqlExposeProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceMysqlExposeProgressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The expose_progress name.
        :param pulumi.Input[_builtins.str] database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceMysqlMysqlConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The mysql_connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mysql_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The mysql_connection schema name. Defaults to `public`.
        """
elif False:
    SourceMysqlMysqlConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceMysqlMysqlConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The mysql_connection name.
        :param pulumi.Input[_builtins.str] database_name: The mysql_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The mysql_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The mysql_connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mysql_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The mysql_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceMysqlTableArgsDict(TypedDict):
        upstream_name: pulumi.Input[_builtins.str]
        """
        The name of the table in the upstream MySQL database.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The database of the table in Materialize.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name for the table, used in Materialize.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema of the table in Materialize.
        """
        upstream_schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema of the table in the upstream MySQL database.
        """
elif False:
    SourceMysqlTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceMysqlTableArgs:
    def __init__(__self__, *,
                 upstream_name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] upstream_name: The name of the table in the upstream MySQL database.
        :param pulumi.Input[_builtins.str] database_name: The database of the table in Materialize.
        :param pulumi.Input[_builtins.str] name: The name for the table, used in Materialize.
        :param pulumi.Input[_builtins.str] schema_name: The schema of the table in Materialize.
        :param pulumi.Input[_builtins.str] upstream_schema_name: The schema of the table in the upstream MySQL database.
        """
        pulumi.set(__self__, "upstream_name", upstream_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if upstream_schema_name is not None:
            pulumi.set(__self__, "upstream_schema_name", upstream_schema_name)

    @_builtins.property
    @pulumi.getter(name="upstreamName")
    def upstream_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the table in the upstream MySQL database.
        """
        return pulumi.get(self, "upstream_name")

    @upstream_name.setter
    def upstream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "upstream_name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The database of the table in Materialize.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name for the table, used in Materialize.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema of the table in Materialize.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="upstreamSchemaName")
    def upstream_schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema of the table in the upstream MySQL database.
        """
        return pulumi.get(self, "upstream_schema_name")

    @upstream_schema_name.setter
    def upstream_schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upstream_schema_name", value)


if not MYPY:
    class SourcePostgresExposeProgressArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The expose_progress name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress schema name. Defaults to `public`.
        """
elif False:
    SourcePostgresExposeProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourcePostgresExposeProgressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The expose_progress name.
        :param pulumi.Input[_builtins.str] database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourcePostgresPostgresConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The postgres_connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The postgres_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The postgres_connection schema name. Defaults to `public`.
        """
elif False:
    SourcePostgresPostgresConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourcePostgresPostgresConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The postgres_connection name.
        :param pulumi.Input[_builtins.str] database_name: The postgres_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The postgres_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The postgres_connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The postgres_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The postgres_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourcePostgresTableArgsDict(TypedDict):
        upstream_name: pulumi.Input[_builtins.str]
        """
        The name of the table in the upstream Postgres database.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The database of the table in Materialize.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the table in Materialize.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema of the table in Materialize.
        """
        upstream_schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema of the table in the upstream Postgres database.
        """
elif False:
    SourcePostgresTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourcePostgresTableArgs:
    def __init__(__self__, *,
                 upstream_name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] upstream_name: The name of the table in the upstream Postgres database.
        :param pulumi.Input[_builtins.str] database_name: The database of the table in Materialize.
        :param pulumi.Input[_builtins.str] name: The name of the table in Materialize.
        :param pulumi.Input[_builtins.str] schema_name: The schema of the table in Materialize.
        :param pulumi.Input[_builtins.str] upstream_schema_name: The schema of the table in the upstream Postgres database.
        """
        pulumi.set(__self__, "upstream_name", upstream_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if upstream_schema_name is not None:
            pulumi.set(__self__, "upstream_schema_name", upstream_schema_name)

    @_builtins.property
    @pulumi.getter(name="upstreamName")
    def upstream_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the table in the upstream Postgres database.
        """
        return pulumi.get(self, "upstream_name")

    @upstream_name.setter
    def upstream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "upstream_name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The database of the table in Materialize.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the table in Materialize.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema of the table in Materialize.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="upstreamSchemaName")
    def upstream_schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema of the table in the upstream Postgres database.
        """
        return pulumi.get(self, "upstream_schema_name")

    @upstream_schema_name.setter
    def upstream_schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upstream_schema_name", value)


if not MYPY:
    class SourceSqlserverAwsPrivatelinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The aws_privatelink name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
elif False:
    SourceSqlserverAwsPrivatelinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceSqlserverAwsPrivatelinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The aws_privatelink name.
        :param pulumi.Input[_builtins.str] database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceSqlserverExposeProgressArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The expose_progress name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expose_progress schema name. Defaults to `public`.
        """
elif False:
    SourceSqlserverExposeProgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceSqlserverExposeProgressArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The expose_progress name.
        :param pulumi.Input[_builtins.str] database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceSqlserverSqlserverConnectionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The sqlserver_connection name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sqlserver_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The sqlserver_connection schema name. Defaults to `public`.
        """
elif False:
    SourceSqlserverSqlserverConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceSqlserverSqlserverConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The sqlserver_connection name.
        :param pulumi.Input[_builtins.str] database_name: The sqlserver_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The sqlserver_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The sqlserver_connection name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sqlserver_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The sqlserver_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceSqlserverTableArgsDict(TypedDict):
        upstream_name: pulumi.Input[_builtins.str]
        """
        The name of the table in the upstream SQL Server database.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The database of the table in Materialize.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name for the table, used in Materialize.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema of the table in Materialize.
        """
        upstream_schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The schema of the table in the upstream SQL Server database.
        """
elif False:
    SourceSqlserverTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceSqlserverTableArgs:
    def __init__(__self__, *,
                 upstream_name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] upstream_name: The name of the table in the upstream SQL Server database.
        :param pulumi.Input[_builtins.str] database_name: The database of the table in Materialize.
        :param pulumi.Input[_builtins.str] name: The name for the table, used in Materialize.
        :param pulumi.Input[_builtins.str] schema_name: The schema of the table in Materialize.
        :param pulumi.Input[_builtins.str] upstream_schema_name: The schema of the table in the upstream SQL Server database.
        """
        pulumi.set(__self__, "upstream_name", upstream_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if upstream_schema_name is not None:
            pulumi.set(__self__, "upstream_schema_name", upstream_schema_name)

    @_builtins.property
    @pulumi.getter(name="upstreamName")
    def upstream_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the table in the upstream SQL Server database.
        """
        return pulumi.get(self, "upstream_name")

    @upstream_name.setter
    def upstream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "upstream_name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The database of the table in Materialize.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name for the table, used in Materialize.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema of the table in Materialize.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)

    @_builtins.property
    @pulumi.getter(name="upstreamSchemaName")
    def upstream_schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The schema of the table in the upstream SQL Server database.
        """
        return pulumi.get(self, "upstream_schema_name")

    @upstream_schema_name.setter
    def upstream_schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upstream_schema_name", value)


if not MYPY:
    class SourceWebhookCheckOptionArgsDict(TypedDict):
        field: pulumi.Input['SourceWebhookCheckOptionFieldArgsDict']
        """
        The field for the check options.
        """
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        The alias for the check options.
        """
        bytes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Change type to `bytea`.
        """
elif False:
    SourceWebhookCheckOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceWebhookCheckOptionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input['SourceWebhookCheckOptionFieldArgs'],
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 bytes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['SourceWebhookCheckOptionFieldArgs'] field: The field for the check options.
        :param pulumi.Input[_builtins.str] alias: The alias for the check options.
        :param pulumi.Input[_builtins.bool] bytes: Change type to `bytea`.
        """
        pulumi.set(__self__, "field", field)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input['SourceWebhookCheckOptionFieldArgs']:
        """
        The field for the check options.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input['SourceWebhookCheckOptionFieldArgs']):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The alias for the check options.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Change type to `bytea`.
        """
        return pulumi.get(self, "bytes")

    @bytes.setter
    def bytes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bytes", value)


if not MYPY:
    class SourceWebhookCheckOptionFieldArgsDict(TypedDict):
        body: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The body for the check options.
        """
        headers: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The headers for the check options.
        """
        secret: NotRequired[pulumi.Input['SourceWebhookCheckOptionFieldSecretArgsDict']]
        """
        The secret for the check options.
        """
elif False:
    SourceWebhookCheckOptionFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceWebhookCheckOptionFieldArgs:
    def __init__(__self__, *,
                 body: Optional[pulumi.Input[_builtins.bool]] = None,
                 headers: Optional[pulumi.Input[_builtins.bool]] = None,
                 secret: Optional[pulumi.Input['SourceWebhookCheckOptionFieldSecretArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] body: The body for the check options.
        :param pulumi.Input[_builtins.bool] headers: The headers for the check options.
        :param pulumi.Input['SourceWebhookCheckOptionFieldSecretArgs'] secret: The secret for the check options.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The body for the check options.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "body", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The headers for the check options.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['SourceWebhookCheckOptionFieldSecretArgs']]:
        """
        The secret for the check options.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['SourceWebhookCheckOptionFieldSecretArgs']]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class SourceWebhookCheckOptionFieldSecretArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The secret name.
        """
        database_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret schema name. Defaults to `public`.
        """
elif False:
    SourceWebhookCheckOptionFieldSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceWebhookCheckOptionFieldSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 database_name: Optional[pulumi.Input[_builtins.str]] = None,
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The secret name.
        :param pulumi.Input[_builtins.str] database_name: The secret database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param pulumi.Input[_builtins.str] schema_name: The secret schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The secret name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class SourceWebhookIncludeHeaderArgsDict(TypedDict):
        header: pulumi.Input[_builtins.str]
        """
        The name for the header.
        """
        alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        The alias for the header.
        """
        bytes: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Change type to `bytea`.
        """
elif False:
    SourceWebhookIncludeHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceWebhookIncludeHeaderArgs:
    def __init__(__self__, *,
                 header: pulumi.Input[_builtins.str],
                 alias: Optional[pulumi.Input[_builtins.str]] = None,
                 bytes: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] header: The name for the header.
        :param pulumi.Input[_builtins.str] alias: The alias for the header.
        :param pulumi.Input[_builtins.bool] bytes: Change type to `bytea`.
        """
        pulumi.set(__self__, "header", header)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)

    @_builtins.property
    @pulumi.getter
    def header(self) -> pulumi.Input[_builtins.str]:
        """
        The name for the header.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header", value)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The alias for the header.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias", value)

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Change type to `bytea`.
        """
        return pulumi.get(self, "bytes")

    @bytes.setter
    def bytes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bytes", value)


if not MYPY:
    class SourceWebhookIncludeHeadersArgsDict(TypedDict):
        all: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Include all headers.
        """
        nots: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Headers that should be excluded.
        """
        onlies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Headers that should be included.
        """
elif False:
    SourceWebhookIncludeHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SourceWebhookIncludeHeadersArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input[_builtins.bool]] = None,
                 nots: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 onlies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] all: Include all headers.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] nots: Headers that should be excluded.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] onlies: Headers that should be included.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if nots is not None:
            pulumi.set(__self__, "nots", nots)
        if onlies is not None:
            pulumi.set(__self__, "onlies", onlies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Include all headers.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter
    def nots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Headers that should be excluded.
        """
        return pulumi.get(self, "nots")

    @nots.setter
    def nots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "nots", value)

    @_builtins.property
    @pulumi.getter
    def onlies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Headers that should be included.
        """
        return pulumi.get(self, "onlies")

    @onlies.setter
    def onlies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "onlies", value)


if not MYPY:
    class TableColumnArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the column to be created in the table.
        """
        type: pulumi.Input[_builtins.str]
        """
        The data type of the column indicated by name.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comment on an object in the database.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        A default value to use for the column in an INSERT statement if an explicit value is not provided. If not specified, `NULL` is assumed..
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Do not allow the column to contain `NULL` values. Columns without this constraint can contain `NULL` values.
        """
elif False:
    TableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableColumnArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the column to be created in the table.
        :param pulumi.Input[_builtins.str] type: The data type of the column indicated by name.
        :param pulumi.Input[_builtins.str] comment: Comment on an object in the database.
        :param pulumi.Input[_builtins.str] default: A default value to use for the column in an INSERT statement if an explicit value is not provided. If not specified, `NULL` is assumed..
        :param pulumi.Input[_builtins.bool] nullable: Do not allow the column to contain `NULL` values. Columns without this constraint can contain `NULL` values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the column to be created in the table.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The data type of the column indicated by name.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comment on an object in the database.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A default value to use for the column in an INSERT statement if an explicit value is not provided. If not specified, `NULL` is assumed..
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Do not allow the column to contain `NULL` values. Columns without this constraint can contain `NULL` values.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)


if not MYPY:
    class TypeListPropertiesArgsDict(TypedDict):
        element_type: pulumi.Input[_builtins.str]
        """
        Creates a custom list whose elements are of `ELEMENT TYPE`
        """
elif False:
    TypeListPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TypeListPropertiesArgs:
    def __init__(__self__, *,
                 element_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] element_type: Creates a custom list whose elements are of `ELEMENT TYPE`
        """
        pulumi.set(__self__, "element_type", element_type)

    @_builtins.property
    @pulumi.getter(name="elementType")
    def element_type(self) -> pulumi.Input[_builtins.str]:
        """
        Creates a custom list whose elements are of `ELEMENT TYPE`
        """
        return pulumi.get(self, "element_type")

    @element_type.setter
    def element_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "element_type", value)


if not MYPY:
    class TypeMapPropertiesArgsDict(TypedDict):
        key_type: pulumi.Input[_builtins.str]
        """
        Creates a custom map whose keys are of `KEY TYPE`. `KEY TYPE` must resolve to text.
        """
        value_type: pulumi.Input[_builtins.str]
        """
        Creates a custom map whose values are of `VALUE TYPE`.
        """
elif False:
    TypeMapPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TypeMapPropertiesArgs:
    def __init__(__self__, *,
                 key_type: pulumi.Input[_builtins.str],
                 value_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key_type: Creates a custom map whose keys are of `KEY TYPE`. `KEY TYPE` must resolve to text.
        :param pulumi.Input[_builtins.str] value_type: Creates a custom map whose values are of `VALUE TYPE`.
        """
        pulumi.set(__self__, "key_type", key_type)
        pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input[_builtins.str]:
        """
        Creates a custom map whose keys are of `KEY TYPE`. `KEY TYPE` must resolve to text.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[_builtins.str]:
        """
        Creates a custom map whose values are of `VALUE TYPE`.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class TypeRowPropertyArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        """
        The name of a field in a row type.
        """
        field_type: pulumi.Input[_builtins.str]
        """
        The data type of a field indicated by `FIELD NAME`.
        """
elif False:
    TypeRowPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TypeRowPropertyArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 field_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] field_name: The name of a field in a row type.
        :param pulumi.Input[_builtins.str] field_type: The data type of a field indicated by `FIELD NAME`.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of a field in a row type.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> pulumi.Input[_builtins.str]:
        """
        The data type of a field indicated by `FIELD NAME`.
        """
        return pulumi.get(self, "field_type")

    @field_type.setter
    def field_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_type", value)


