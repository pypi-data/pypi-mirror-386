# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ClusterScheduling',
    'ClusterSchedulingOnRefresh',
    'ClusterWaitUntilReady',
    'ConnectionAwsAccessKeyId',
    'ConnectionAwsAccessKeyIdSecret',
    'ConnectionAwsSecretAccessKey',
    'ConnectionAwsSessionToken',
    'ConnectionAwsSessionTokenSecret',
    'ConnectionConfluentSchemaRegistryAwsPrivatelink',
    'ConnectionConfluentSchemaRegistryPassword',
    'ConnectionConfluentSchemaRegistrySshTunnel',
    'ConnectionConfluentSchemaRegistrySslCertificate',
    'ConnectionConfluentSchemaRegistrySslCertificateAuthority',
    'ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret',
    'ConnectionConfluentSchemaRegistrySslCertificateSecret',
    'ConnectionConfluentSchemaRegistrySslKey',
    'ConnectionConfluentSchemaRegistryUsername',
    'ConnectionConfluentSchemaRegistryUsernameSecret',
    'ConnectionKafkaAwsConnection',
    'ConnectionKafkaAwsPrivatelink',
    'ConnectionKafkaAwsPrivatelinkPrivatelinkConnection',
    'ConnectionKafkaKafkaBroker',
    'ConnectionKafkaKafkaBrokerPrivatelinkConnection',
    'ConnectionKafkaKafkaBrokerSshTunnel',
    'ConnectionKafkaSaslPassword',
    'ConnectionKafkaSaslUsername',
    'ConnectionKafkaSaslUsernameSecret',
    'ConnectionKafkaSshTunnel',
    'ConnectionKafkaSslCertificate',
    'ConnectionKafkaSslCertificateAuthority',
    'ConnectionKafkaSslCertificateAuthoritySecret',
    'ConnectionKafkaSslCertificateSecret',
    'ConnectionKafkaSslKey',
    'ConnectionMysqlAwsPrivatelink',
    'ConnectionMysqlPassword',
    'ConnectionMysqlSshTunnel',
    'ConnectionMysqlSslCertificate',
    'ConnectionMysqlSslCertificateAuthority',
    'ConnectionMysqlSslCertificateAuthoritySecret',
    'ConnectionMysqlSslCertificateSecret',
    'ConnectionMysqlSslKey',
    'ConnectionMysqlUser',
    'ConnectionMysqlUserSecret',
    'ConnectionPostgresAwsPrivatelink',
    'ConnectionPostgresPassword',
    'ConnectionPostgresSshTunnel',
    'ConnectionPostgresSslCertificate',
    'ConnectionPostgresSslCertificateAuthority',
    'ConnectionPostgresSslCertificateAuthoritySecret',
    'ConnectionPostgresSslCertificateSecret',
    'ConnectionPostgresSslKey',
    'ConnectionPostgresUser',
    'ConnectionPostgresUserSecret',
    'ConnectionSqlserverAwsPrivatelink',
    'ConnectionSqlserverPassword',
    'ConnectionSqlserverSshTunnel',
    'ConnectionSqlserverSslCertificateAuthority',
    'ConnectionSqlserverSslCertificateAuthoritySecret',
    'ConnectionSqlserverUser',
    'ConnectionSqlserverUserSecret',
    'GetClusterReplicasClusterReplicaResult',
    'GetClustersClusterResult',
    'GetConnectionsConnectionResult',
    'GetDatabasesDatabaseResult',
    'GetIndexesIndexResult',
    'GetMaterializedViewsMaterializedViewResult',
    'GetNetworkPoliciesNetworkPolicyResult',
    'GetNetworkPoliciesNetworkPolicyRuleResult',
    'GetRolesRoleResult',
    'GetSCIMConfigsConfigurationResult',
    'GetSCIMGroupsGroupResult',
    'GetSCIMGroupsGroupRoleResult',
    'GetSCIMGroupsGroupUserResult',
    'GetSSOConfigSsoConfigResult',
    'GetSSOConfigSsoConfigDomainResult',
    'GetSSOConfigSsoConfigGroupResult',
    'GetSchemasSchemaResult',
    'GetSecretsSecretResult',
    'GetSinksSinkResult',
    'GetSourcesSourceResult',
    'GetSystemParametersParameterResult',
    'GetTablesTableResult',
    'GetTypesTypeResult',
    'GetViewsViewResult',
    'IndexColExpr',
    'IndexObjName',
    'NetworkPolicyRule',
    'RegionRegionResult',
    'SinkKafkaEnvelope',
    'SinkKafkaFormat',
    'SinkKafkaFormatAvro',
    'SinkKafkaFormatAvroAvroDocColumn',
    'SinkKafkaFormatAvroAvroDocColumnObject',
    'SinkKafkaFormatAvroAvroDocType',
    'SinkKafkaFormatAvroAvroDocTypeObject',
    'SinkKafkaFormatAvroSchemaRegistryConnection',
    'SinkKafkaFrom',
    'SinkKafkaKafkaConnection',
    'SourceKafkaEnvelope',
    'SourceKafkaEnvelopeUpsertOptions',
    'SourceKafkaEnvelopeUpsertOptionsValueDecodingErrors',
    'SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInline',
    'SourceKafkaExposeProgress',
    'SourceKafkaFormat',
    'SourceKafkaFormatAvro',
    'SourceKafkaFormatAvroSchemaRegistryConnection',
    'SourceKafkaFormatCsv',
    'SourceKafkaFormatProtobuf',
    'SourceKafkaFormatProtobufSchemaRegistryConnection',
    'SourceKafkaKafkaConnection',
    'SourceKafkaKeyFormat',
    'SourceKafkaKeyFormatAvro',
    'SourceKafkaKeyFormatAvroSchemaRegistryConnection',
    'SourceKafkaKeyFormatCsv',
    'SourceKafkaKeyFormatProtobuf',
    'SourceKafkaKeyFormatProtobufSchemaRegistryConnection',
    'SourceKafkaValueFormat',
    'SourceKafkaValueFormatAvro',
    'SourceKafkaValueFormatAvroSchemaRegistryConnection',
    'SourceKafkaValueFormatCsv',
    'SourceKafkaValueFormatProtobuf',
    'SourceKafkaValueFormatProtobufSchemaRegistryConnection',
    'SourceLoadgenAuctionOptions',
    'SourceLoadgenExposeProgress',
    'SourceLoadgenMarketingOptions',
    'SourceLoadgenTpchOptions',
    'SourceMysqlExposeProgress',
    'SourceMysqlMysqlConnection',
    'SourceMysqlTable',
    'SourcePostgresExposeProgress',
    'SourcePostgresPostgresConnection',
    'SourcePostgresTable',
    'SourceSqlserverAwsPrivatelink',
    'SourceSqlserverExposeProgress',
    'SourceSqlserverSqlserverConnection',
    'SourceSqlserverTable',
    'SourceWebhookCheckOption',
    'SourceWebhookCheckOptionField',
    'SourceWebhookCheckOptionFieldSecret',
    'SourceWebhookIncludeHeader',
    'SourceWebhookIncludeHeaders',
    'TableColumn',
    'TypeListProperties',
    'TypeMapProperties',
    'TypeRowProperty',
]

@pulumi.output_type
class ClusterScheduling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onRefresh":
            suggest = "on_refresh"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterScheduling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterScheduling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterScheduling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_refresh: Optional['outputs.ClusterSchedulingOnRefresh'] = None):
        """
        :param 'ClusterSchedulingOnRefreshArgs' on_refresh: Configuration for refreshing the cluster.
        """
        if on_refresh is not None:
            pulumi.set(__self__, "on_refresh", on_refresh)

    @_builtins.property
    @pulumi.getter(name="onRefresh")
    def on_refresh(self) -> Optional['outputs.ClusterSchedulingOnRefresh']:
        """
        Configuration for refreshing the cluster.
        """
        return pulumi.get(self, "on_refresh")


@pulumi.output_type
class ClusterSchedulingOnRefresh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hydrationTimeEstimate":
            suggest = "hydration_time_estimate"
        elif key == "rehydrationTimeEstimate":
            suggest = "rehydration_time_estimate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSchedulingOnRefresh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSchedulingOnRefresh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSchedulingOnRefresh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 hydration_time_estimate: Optional[_builtins.str] = None,
                 rehydration_time_estimate: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Enable scheduling to refresh the cluster.
        :param _builtins.str hydration_time_estimate: Estimated time to hydrate the cluster during refresh.
        :param _builtins.str rehydration_time_estimate: Estimated time to rehydrate the cluster during refresh. This field is deprecated and will be removed in a future release. Use `hydration_time_estimate` instead.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if hydration_time_estimate is not None:
            pulumi.set(__self__, "hydration_time_estimate", hydration_time_estimate)
        if rehydration_time_estimate is not None:
            pulumi.set(__self__, "rehydration_time_estimate", rehydration_time_estimate)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable scheduling to refresh the cluster.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="hydrationTimeEstimate")
    def hydration_time_estimate(self) -> Optional[_builtins.str]:
        """
        Estimated time to hydrate the cluster during refresh.
        """
        return pulumi.get(self, "hydration_time_estimate")

    @_builtins.property
    @pulumi.getter(name="rehydrationTimeEstimate")
    @_utilities.deprecated("""Use `hydration_time_estimate` instead.""")
    def rehydration_time_estimate(self) -> Optional[_builtins.str]:
        """
        Estimated time to rehydrate the cluster during refresh. This field is deprecated and will be removed in a future release. Use `hydration_time_estimate` instead.
        """
        return pulumi.get(self, "rehydration_time_estimate")


@pulumi.output_type
class ClusterWaitUntilReady(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onTimeout":
            suggest = "on_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterWaitUntilReady. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterWaitUntilReady.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterWaitUntilReady.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 on_timeout: Optional[_builtins.str] = None,
                 timeout: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Enable wait*until*ready.
        :param _builtins.str on_timeout: Action to take on timeout: COMMIT|ROLLBACK
        :param _builtins.str timeout: Max duration to wait for the new replicas to be ready.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if on_timeout is not None:
            pulumi.set(__self__, "on_timeout", on_timeout)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable wait*until*ready.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="onTimeout")
    def on_timeout(self) -> Optional[_builtins.str]:
        """
        Action to take on timeout: COMMIT|ROLLBACK
        """
        return pulumi.get(self, "on_timeout")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.str]:
        """
        Max duration to wait for the new replicas to be ready.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ConnectionAwsAccessKeyId(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionAwsAccessKeyIdSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionAwsAccessKeyIdSecretArgs' secret: The `access_key_id` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `access_key_id` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionAwsAccessKeyIdSecret']:
        """
        The `access_key_id` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `access_key_id` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionAwsAccessKeyIdSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionAwsAccessKeyIdSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionAwsAccessKeyIdSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionAwsAccessKeyIdSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The access*key*id name.
        :param _builtins.str database_name: The access*key*id database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The access*key*id schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The access*key*id name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The access*key*id database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The access*key*id schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionAwsSecretAccessKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionAwsSecretAccessKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionAwsSecretAccessKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionAwsSecretAccessKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The secret*access*key name.
        :param _builtins.str database_name: The secret*access*key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The secret*access*key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The secret*access*key name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The secret*access*key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The secret*access*key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionAwsSessionToken(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionAwsSessionTokenSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionAwsSessionTokenSecretArgs' secret: The `session_token` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `session_token` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionAwsSessionTokenSecret']:
        """
        The `session_token` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `session_token` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionAwsSessionTokenSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionAwsSessionTokenSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionAwsSessionTokenSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionAwsSessionTokenSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The session_token name.
        :param _builtins.str database_name: The session_token database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The session_token schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The session_token name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The session_token database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The session_token schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistryAwsPrivatelink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistryAwsPrivatelink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistryAwsPrivatelink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistryAwsPrivatelink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The aws_privatelink name.
        :param _builtins.str database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistryPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistryPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistryPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistryPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The password name.
        :param _builtins.str database_name: The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistrySshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistrySshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistrySshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssh_tunnel name.
        :param _builtins.str database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslCertificate(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionConfluentSchemaRegistrySslCertificateSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionConfluentSchemaRegistrySslCertificateSecretArgs' secret: The `ssl_certificate` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionConfluentSchemaRegistrySslCertificateSecret']:
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslCertificateAuthority(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecretArgs' secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret']:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistrySslCertificateAuthoritySecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl*certificate*authority name.
        :param _builtins.str database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslCertificateSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistrySslCertificateSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistrySslCertificateSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistrySslCertificateSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl_certificate name.
        :param _builtins.str database_name: The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl_certificate schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl_certificate name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistrySslKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistrySslKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistrySslKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistrySslKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl_key name.
        :param _builtins.str database_name: The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl_key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl_key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionConfluentSchemaRegistryUsername(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionConfluentSchemaRegistryUsernameSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionConfluentSchemaRegistryUsernameSecretArgs' secret: The `username` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `username` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionConfluentSchemaRegistryUsernameSecret']:
        """
        The `username` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `username` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionConfluentSchemaRegistryUsernameSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionConfluentSchemaRegistryUsernameSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionConfluentSchemaRegistryUsernameSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionConfluentSchemaRegistryUsernameSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The username name.
        :param _builtins.str database_name: The username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The username schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The username name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The username schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaAwsConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaAwsConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaAwsConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaAwsConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The aws_connection name.
        :param _builtins.str database_name: The aws_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The aws_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The aws_connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The aws_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The aws_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaAwsPrivatelink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privatelinkConnection":
            suggest = "privatelink_connection"
        elif key == "privatelinkConnectionPort":
            suggest = "privatelink_connection_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaAwsPrivatelink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaAwsPrivatelink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaAwsPrivatelink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 privatelink_connection: 'outputs.ConnectionKafkaAwsPrivatelinkPrivatelinkConnection',
                 privatelink_connection_port: _builtins.int):
        """
        :param 'ConnectionKafkaAwsPrivatelinkPrivatelinkConnectionArgs' privatelink_connection: The AWS PrivateLink connection name in Materialize.
        :param _builtins.int privatelink_connection_port: The port of the AWS PrivateLink connection.
        """
        pulumi.set(__self__, "privatelink_connection", privatelink_connection)
        pulumi.set(__self__, "privatelink_connection_port", privatelink_connection_port)

    @_builtins.property
    @pulumi.getter(name="privatelinkConnection")
    def privatelink_connection(self) -> 'outputs.ConnectionKafkaAwsPrivatelinkPrivatelinkConnection':
        """
        The AWS PrivateLink connection name in Materialize.
        """
        return pulumi.get(self, "privatelink_connection")

    @_builtins.property
    @pulumi.getter(name="privatelinkConnectionPort")
    def privatelink_connection_port(self) -> _builtins.int:
        """
        The port of the AWS PrivateLink connection.
        """
        return pulumi.get(self, "privatelink_connection_port")


@pulumi.output_type
class ConnectionKafkaAwsPrivatelinkPrivatelinkConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaAwsPrivatelinkPrivatelinkConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaAwsPrivatelinkPrivatelinkConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaAwsPrivatelinkPrivatelinkConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The privatelink_connection name.
        :param _builtins.str database_name: The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The privatelink_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The privatelink_connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The privatelink_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaKafkaBroker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "privatelinkConnection":
            suggest = "privatelink_connection"
        elif key == "sshTunnel":
            suggest = "ssh_tunnel"
        elif key == "targetGroupPort":
            suggest = "target_group_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaKafkaBroker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaKafkaBroker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaKafkaBroker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker: _builtins.str,
                 availability_zone: Optional[_builtins.str] = None,
                 privatelink_connection: Optional['outputs.ConnectionKafkaKafkaBrokerPrivatelinkConnection'] = None,
                 ssh_tunnel: Optional['outputs.ConnectionKafkaKafkaBrokerSshTunnel'] = None,
                 target_group_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str broker: The Kafka broker, in the form of `host:port`.
        :param _builtins.str availability_zone: The availability zone of the Kafka broker.
        :param 'ConnectionKafkaKafkaBrokerPrivatelinkConnectionArgs' privatelink_connection: The AWS PrivateLink connection name in Materialize.
        :param 'ConnectionKafkaKafkaBrokerSshTunnelArgs' ssh_tunnel: The name of an SSH tunnel connection to route network traffic through by default.
        :param _builtins.int target_group_port: The port of the target group associated with the Kafka broker.
        """
        pulumi.set(__self__, "broker", broker)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if privatelink_connection is not None:
            pulumi.set(__self__, "privatelink_connection", privatelink_connection)
        if ssh_tunnel is not None:
            pulumi.set(__self__, "ssh_tunnel", ssh_tunnel)
        if target_group_port is not None:
            pulumi.set(__self__, "target_group_port", target_group_port)

    @_builtins.property
    @pulumi.getter
    def broker(self) -> _builtins.str:
        """
        The Kafka broker, in the form of `host:port`.
        """
        return pulumi.get(self, "broker")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The availability zone of the Kafka broker.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="privatelinkConnection")
    def privatelink_connection(self) -> Optional['outputs.ConnectionKafkaKafkaBrokerPrivatelinkConnection']:
        """
        The AWS PrivateLink connection name in Materialize.
        """
        return pulumi.get(self, "privatelink_connection")

    @_builtins.property
    @pulumi.getter(name="sshTunnel")
    def ssh_tunnel(self) -> Optional['outputs.ConnectionKafkaKafkaBrokerSshTunnel']:
        """
        The name of an SSH tunnel connection to route network traffic through by default.
        """
        return pulumi.get(self, "ssh_tunnel")

    @_builtins.property
    @pulumi.getter(name="targetGroupPort")
    def target_group_port(self) -> Optional[_builtins.int]:
        """
        The port of the target group associated with the Kafka broker.
        """
        return pulumi.get(self, "target_group_port")


@pulumi.output_type
class ConnectionKafkaKafkaBrokerPrivatelinkConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaKafkaBrokerPrivatelinkConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaKafkaBrokerPrivatelinkConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaKafkaBrokerPrivatelinkConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The privatelink_connection name.
        :param _builtins.str database_name: The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The privatelink_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The privatelink_connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The privatelink_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The privatelink_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaKafkaBrokerSshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaKafkaBrokerSshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaKafkaBrokerSshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaKafkaBrokerSshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssh_tunnel name.
        :param _builtins.str database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSaslPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSaslPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSaslPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSaslPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The sasl_password name.
        :param _builtins.str database_name: The sasl_password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The sasl_password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The sasl_password name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The sasl_password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The sasl_password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSaslUsername(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionKafkaSaslUsernameSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionKafkaSaslUsernameSecretArgs' secret: The `sasl_username` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `sasl_username` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionKafkaSaslUsernameSecret']:
        """
        The `sasl_username` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `sasl_username` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionKafkaSaslUsernameSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSaslUsernameSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSaslUsernameSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSaslUsernameSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The sasl_username name.
        :param _builtins.str database_name: The sasl_username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The sasl_username schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The sasl_username name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The sasl_username database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The sasl_username schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssh_tunnel name.
        :param _builtins.str database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSslCertificate(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionKafkaSslCertificateSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionKafkaSslCertificateSecretArgs' secret: The `ssl_certificate` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionKafkaSslCertificateSecret']:
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionKafkaSslCertificateAuthority(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionKafkaSslCertificateAuthoritySecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionKafkaSslCertificateAuthoritySecretArgs' secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionKafkaSslCertificateAuthoritySecret']:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionKafkaSslCertificateAuthoritySecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSslCertificateAuthoritySecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSslCertificateAuthoritySecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSslCertificateAuthoritySecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl*certificate*authority name.
        :param _builtins.str database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSslCertificateSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSslCertificateSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSslCertificateSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSslCertificateSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl_certificate name.
        :param _builtins.str database_name: The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl_certificate schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl_certificate name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionKafkaSslKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionKafkaSslKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionKafkaSslKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionKafkaSslKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl_key name.
        :param _builtins.str database_name: The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl_key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl_key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionMysqlAwsPrivatelink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionMysqlAwsPrivatelink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionMysqlAwsPrivatelink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionMysqlAwsPrivatelink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The aws_privatelink name.
        :param _builtins.str database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionMysqlPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionMysqlPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionMysqlPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionMysqlPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The password name.
        :param _builtins.str database_name: The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionMysqlSshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionMysqlSshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionMysqlSshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionMysqlSshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssh_tunnel name.
        :param _builtins.str database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionMysqlSslCertificate(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionMysqlSslCertificateSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionMysqlSslCertificateSecretArgs' secret: The `ssl_certificate` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionMysqlSslCertificateSecret']:
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionMysqlSslCertificateAuthority(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionMysqlSslCertificateAuthoritySecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionMysqlSslCertificateAuthoritySecretArgs' secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionMysqlSslCertificateAuthoritySecret']:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionMysqlSslCertificateAuthoritySecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionMysqlSslCertificateAuthoritySecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionMysqlSslCertificateAuthoritySecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionMysqlSslCertificateAuthoritySecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl*certificate*authority name.
        :param _builtins.str database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionMysqlSslCertificateSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionMysqlSslCertificateSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionMysqlSslCertificateSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionMysqlSslCertificateSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl_certificate name.
        :param _builtins.str database_name: The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl_certificate schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl_certificate name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionMysqlSslKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionMysqlSslKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionMysqlSslKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionMysqlSslKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl_key name.
        :param _builtins.str database_name: The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl_key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl_key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionMysqlUser(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionMysqlUserSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionMysqlUserSecretArgs' secret: The `user` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `user` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionMysqlUserSecret']:
        """
        The `user` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `user` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionMysqlUserSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionMysqlUserSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionMysqlUserSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionMysqlUserSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The user name.
        :param _builtins.str database_name: The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The user schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The user name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The user schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresAwsPrivatelink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresAwsPrivatelink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresAwsPrivatelink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresAwsPrivatelink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The aws_privatelink name.
        :param _builtins.str database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The password name.
        :param _builtins.str database_name: The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresSshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresSshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresSshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresSshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssh_tunnel name.
        :param _builtins.str database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresSslCertificate(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionPostgresSslCertificateSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionPostgresSslCertificateSecretArgs' secret: The `ssl_certificate` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionPostgresSslCertificateSecret']:
        """
        The `ssl_certificate` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `ssl_certificate` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionPostgresSslCertificateAuthority(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionPostgresSslCertificateAuthoritySecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionPostgresSslCertificateAuthoritySecretArgs' secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionPostgresSslCertificateAuthoritySecret']:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionPostgresSslCertificateAuthoritySecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresSslCertificateAuthoritySecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresSslCertificateAuthoritySecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresSslCertificateAuthoritySecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl*certificate*authority name.
        :param _builtins.str database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresSslCertificateSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresSslCertificateSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresSslCertificateSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresSslCertificateSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl_certificate name.
        :param _builtins.str database_name: The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl_certificate schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl_certificate name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl_certificate database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl_certificate schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresSslKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresSslKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresSslKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresSslKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl_key name.
        :param _builtins.str database_name: The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl_key schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl_key name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl_key database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl_key schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionPostgresUser(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionPostgresUserSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionPostgresUserSecretArgs' secret: The `user` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `user` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionPostgresUserSecret']:
        """
        The `user` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `user` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionPostgresUserSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPostgresUserSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPostgresUserSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPostgresUserSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The user name.
        :param _builtins.str database_name: The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The user schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The user name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The user schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionSqlserverAwsPrivatelink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionSqlserverAwsPrivatelink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionSqlserverAwsPrivatelink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionSqlserverAwsPrivatelink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The aws_privatelink name.
        :param _builtins.str database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionSqlserverPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionSqlserverPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionSqlserverPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionSqlserverPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The password name.
        :param _builtins.str database_name: The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The password schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The password name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The password database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The password schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionSqlserverSshTunnel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionSqlserverSshTunnel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionSqlserverSshTunnel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionSqlserverSshTunnel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssh_tunnel name.
        :param _builtins.str database_name: The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssh_tunnel schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssh_tunnel name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssh_tunnel schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionSqlserverSslCertificateAuthority(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionSqlserverSslCertificateAuthoritySecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionSqlserverSslCertificateAuthoritySecretArgs' secret: The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionSqlserverSslCertificateAuthoritySecret']:
        """
        The `ssl_certificate_authority` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `ssl_certificate_authority` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionSqlserverSslCertificateAuthoritySecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionSqlserverSslCertificateAuthoritySecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionSqlserverSslCertificateAuthoritySecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionSqlserverSslCertificateAuthoritySecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The ssl*certificate*authority name.
        :param _builtins.str database_name: The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The ssl*certificate*authority schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The ssl*certificate*authority name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The ssl*certificate*authority schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class ConnectionSqlserverUser(dict):
    def __init__(__self__, *,
                 secret: Optional['outputs.ConnectionSqlserverUserSecret'] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param 'ConnectionSqlserverUserSecretArgs' secret: The `user` secret value. Conflicts with `text` within this block.
        :param _builtins.str text: The `user` text value. Conflicts with `secret` within this block
        """
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ConnectionSqlserverUserSecret']:
        """
        The `user` secret value. Conflicts with `text` within this block.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        The `user` text value. Conflicts with `secret` within this block
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class ConnectionSqlserverUserSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionSqlserverUserSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionSqlserverUserSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionSqlserverUserSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The user name.
        :param _builtins.str database_name: The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The user schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The user name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The user database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The user schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetClusterReplicasClusterReplicaResult(dict):
    def __init__(__self__, *,
                 availability_zone: _builtins.str,
                 cluster: _builtins.str,
                 disk: _builtins.bool,
                 id: _builtins.str,
                 name: _builtins.str,
                 size: _builtins.str):
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> _builtins.str:
        return pulumi.get(self, "cluster")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.bool:
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetClustersClusterResult(dict):
    def __init__(__self__, *,
                 disk: _builtins.bool,
                 id: _builtins.str,
                 managed: _builtins.bool,
                 name: _builtins.str,
                 replication_factor: _builtins.int,
                 size: _builtins.str):
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "managed", managed)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "replication_factor", replication_factor)
        pulumi.set(__self__, "size", size)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.bool:
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def managed(self) -> _builtins.bool:
        return pulumi.get(self, "managed")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> _builtins.int:
        return pulumi.get(self, "replication_factor")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetConnectionsConnectionResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDatabasesDatabaseResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetIndexesIndexResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 obj_database: _builtins.str,
                 obj_name: _builtins.str,
                 obj_schema: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "obj_database", obj_database)
        pulumi.set(__self__, "obj_name", obj_name)
        pulumi.set(__self__, "obj_schema", obj_schema)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="objDatabase")
    def obj_database(self) -> _builtins.str:
        return pulumi.get(self, "obj_database")

    @_builtins.property
    @pulumi.getter(name="objName")
    def obj_name(self) -> _builtins.str:
        return pulumi.get(self, "obj_name")

    @_builtins.property
    @pulumi.getter(name="objSchema")
    def obj_schema(self) -> _builtins.str:
        return pulumi.get(self, "obj_schema")


@pulumi.output_type
class GetMaterializedViewsMaterializedViewResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetNetworkPoliciesNetworkPolicyResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 rules: Sequence['outputs.GetNetworkPoliciesNetworkPolicyRuleResult']):
        """
        :param _builtins.str comment: The comment of the network policy.
        :param _builtins.str id: The ID of the network policy.
        :param _builtins.str name: The name of the network policy.
        :param Sequence['GetNetworkPoliciesNetworkPolicyRuleArgs'] rules: Rules for the network policy.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        The comment of the network policy.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the network policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the network policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.GetNetworkPoliciesNetworkPolicyRuleResult']:
        """
        Rules for the network policy.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetNetworkPoliciesNetworkPolicyRuleResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 address: _builtins.str,
                 direction: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str action: The action to take for this rule. Currently only 'allow' is supported.
        :param _builtins.str address: The CIDR block the rule will be applied to.
        :param _builtins.str direction: The direction of traffic the rule applies to. Currently only 'ingress' is supported.
        :param _builtins.str name: The name of the rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action to take for this rule. Currently only 'allow' is supported.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The CIDR block the rule will be applied to.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        The direction of traffic the rule applies to. Currently only 'ingress' is supported.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetRolesRoleResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSCIMConfigsConfigurationResult(dict):
    def __init__(__self__, *,
                 connection_name: _builtins.str,
                 created_at: _builtins.str,
                 id: _builtins.str,
                 source: _builtins.str,
                 sync_to_user_management: _builtins.bool,
                 tenant_id: _builtins.str):
        """
        :param _builtins.str connection_name: The name of the SCIM 2.0 connection.
        :param _builtins.str created_at: The creation timestamp of the SCIM 2.0 configuration.
        :param _builtins.str id: The unique identifier of the SCIM 2.0 configuration.
        :param _builtins.str source: The source of the SCIM 2.0 configuration.
        :param _builtins.bool sync_to_user_management: Indicates if the configuration is synced to user management.
        :param _builtins.str tenant_id: The tenant ID related to the SCIM 2.0 configuration.
        """
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "sync_to_user_management", sync_to_user_management)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        """
        The name of the SCIM 2.0 connection.
        """
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The creation timestamp of the SCIM 2.0 configuration.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier of the SCIM 2.0 configuration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The source of the SCIM 2.0 configuration.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="syncToUserManagement")
    def sync_to_user_management(self) -> _builtins.bool:
        """
        Indicates if the configuration is synced to user management.
        """
        return pulumi.get(self, "sync_to_user_management")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        The tenant ID related to the SCIM 2.0 configuration.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetSCIMGroupsGroupResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 managed_by: _builtins.str,
                 metadata: _builtins.str,
                 name: _builtins.str,
                 roles: Sequence['outputs.GetSCIMGroupsGroupRoleResult'],
                 users: Sequence['outputs.GetSCIMGroupsGroupUserResult']):
        """
        :param _builtins.str description: The description of the group.
        :param _builtins.str id: The ID of the group. This is a unique identifier for the group.
        :param _builtins.str managed_by: The ID of the user who manages the group.
        :param _builtins.str metadata: The metadata of the group.
        :param _builtins.str name: The name of the group.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "managed_by", managed_by)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the group.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the group. This is a unique identifier for the group.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="managedBy")
    def managed_by(self) -> _builtins.str:
        """
        The ID of the user who manages the group.
        """
        return pulumi.get(self, "managed_by")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> _builtins.str:
        """
        The metadata of the group.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the group.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetSCIMGroupsGroupRoleResult']:
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetSCIMGroupsGroupUserResult']:
        return pulumi.get(self, "users")


@pulumi.output_type
class GetSCIMGroupsGroupRoleResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 is_default: _builtins.bool,
                 key: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str description: The description of the role.
        :param _builtins.str id: The ID of the role. This is a unique identifier for the role.
        :param _builtins.bool is_default: Indicates whether the role is the default role.
        :param _builtins.str key: The key of the role.
        :param _builtins.str name: The name of the role.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the role.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the role. This is a unique identifier for the role.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        """
        Indicates whether the role is the default role.
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the role.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the role.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSCIMGroupsGroupUserResult(dict):
    def __init__(__self__, *,
                 email: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str email: The email of the user.
        :param _builtins.str id: The ID of the user. This is a unique identifier for the user.
        :param _builtins.str name: The name of the user.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email of the user.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the user. This is a unique identifier for the user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSSOConfigSsoConfigResult(dict):
    def __init__(__self__, *,
                 domains: Sequence['outputs.GetSSOConfigSsoConfigDomainResult'],
                 enabled: _builtins.bool,
                 groups: Sequence['outputs.GetSSOConfigSsoConfigGroupResult'],
                 id: _builtins.str,
                 oidc_client_id: _builtins.str,
                 oidc_secret: _builtins.str,
                 public_certificate: _builtins.str,
                 role_ids: Sequence[_builtins.str],
                 sign_request: _builtins.bool,
                 sso_endpoint: _builtins.str,
                 type: _builtins.str):
        """
        :param Sequence['GetSSOConfigSsoConfigDomainArgs'] domains: List of domains associated with the SSO configuration.
        :param _builtins.bool enabled: Whether SSO is enabled or not.
        :param Sequence['GetSSOConfigSsoConfigGroupArgs'] groups: List of groups associated with the SSO configuration.
        :param _builtins.str id: The ID of the SSO configuration.
        :param _builtins.str oidc_client_id: The client ID of the OIDC application.
        :param _builtins.str oidc_secret: The client secret of the OIDC application.
        :param _builtins.str public_certificate: The public certificate of the SSO service in PEM format.
        :param Sequence[_builtins.str] role_ids: List of the default role IDs associated with the SSO configuration. These roles will be assigned by default to users who sign up via SSO.
        :param _builtins.bool sign_request: Indicates whether the SSO request needs to be digitally signed.
        :param _builtins.str sso_endpoint: The URL endpoint for the SSO service.
        :param _builtins.str type: The type of SSO protocol being used (e.g., SAML, OIDC).
        """
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "groups", groups)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "oidc_client_id", oidc_client_id)
        pulumi.set(__self__, "oidc_secret", oidc_secret)
        pulumi.set(__self__, "public_certificate", public_certificate)
        pulumi.set(__self__, "role_ids", role_ids)
        pulumi.set(__self__, "sign_request", sign_request)
        pulumi.set(__self__, "sso_endpoint", sso_endpoint)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Sequence['outputs.GetSSOConfigSsoConfigDomainResult']:
        """
        List of domains associated with the SSO configuration.
        """
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether SSO is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Sequence['outputs.GetSSOConfigSsoConfigGroupResult']:
        """
        List of groups associated with the SSO configuration.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the SSO configuration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="oidcClientId")
    def oidc_client_id(self) -> _builtins.str:
        """
        The client ID of the OIDC application.
        """
        return pulumi.get(self, "oidc_client_id")

    @_builtins.property
    @pulumi.getter(name="oidcSecret")
    def oidc_secret(self) -> _builtins.str:
        """
        The client secret of the OIDC application.
        """
        return pulumi.get(self, "oidc_secret")

    @_builtins.property
    @pulumi.getter(name="publicCertificate")
    def public_certificate(self) -> _builtins.str:
        """
        The public certificate of the SSO service in PEM format.
        """
        return pulumi.get(self, "public_certificate")

    @_builtins.property
    @pulumi.getter(name="roleIds")
    def role_ids(self) -> Sequence[_builtins.str]:
        """
        List of the default role IDs associated with the SSO configuration. These roles will be assigned by default to users who sign up via SSO.
        """
        return pulumi.get(self, "role_ids")

    @_builtins.property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> _builtins.bool:
        """
        Indicates whether the SSO request needs to be digitally signed.
        """
        return pulumi.get(self, "sign_request")

    @_builtins.property
    @pulumi.getter(name="ssoEndpoint")
    def sso_endpoint(self) -> _builtins.str:
        """
        The URL endpoint for the SSO service.
        """
        return pulumi.get(self, "sso_endpoint")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of SSO protocol being used (e.g., SAML, OIDC).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSSOConfigSsoConfigDomainResult(dict):
    def __init__(__self__, *,
                 domain: _builtins.str,
                 id: _builtins.str,
                 validated: _builtins.bool):
        """
        :param _builtins.str domain: The domain name for the SSO domain configuration. This domain will be used to validate the SSO configuration and needs to be unique across all SSO configurations.
        :param _builtins.str id: The ID of the SSO domain configuration.
        :param _builtins.bool validated: Indicates whether the domain has been validated.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "validated", validated)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The domain name for the SSO domain configuration. This domain will be used to validate the SSO configuration and needs to be unique across all SSO configurations.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the SSO domain configuration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def validated(self) -> _builtins.bool:
        """
        Indicates whether the domain has been validated.
        """
        return pulumi.get(self, "validated")


@pulumi.output_type
class GetSSOConfigSsoConfigGroupResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 group: _builtins.str,
                 id: _builtins.str,
                 role_ids: Sequence[_builtins.str]):
        """
        :param _builtins.bool enabled: Indicates whether the group is enabled.
        :param _builtins.str group: The name of the SSO group.
        :param Sequence[_builtins.str] role_ids: List of role IDs associated with the group.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_ids", role_ids)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether the group is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def group(self) -> _builtins.str:
        """
        The name of the SSO group.
        """
        return pulumi.get(self, "group")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleIds")
    def role_ids(self) -> Sequence[_builtins.str]:
        """
        List of role IDs associated with the group.
        """
        return pulumi.get(self, "role_ids")


@pulumi.output_type
class GetSchemasSchemaResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSecretsSecretResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetSinksSinkResult(dict):
    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 connection_name: _builtins.str,
                 database_name: _builtins.str,
                 envelope_type: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str,
                 size: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "envelope_type", envelope_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="envelopeType")
    def envelope_type(self) -> _builtins.str:
        return pulumi.get(self, "envelope_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSourcesSourceResult(dict):
    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 connection_name: _builtins.str,
                 database_name: _builtins.str,
                 envelope_type: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str,
                 size: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "envelope_type", envelope_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="envelopeType")
    def envelope_type(self) -> _builtins.str:
        return pulumi.get(self, "envelope_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSystemParametersParameterResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 setting: _builtins.str):
        """
        :param _builtins.str description: The description of the system parameter.
        :param _builtins.str name: The name of the system parameter.
        :param _builtins.str setting: The value of the system parameter.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "setting", setting)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the system parameter.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the system parameter.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def setting(self) -> _builtins.str:
        """
        The value of the system parameter.
        """
        return pulumi.get(self, "setting")


@pulumi.output_type
class GetTablesTableResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetTypesTypeResult(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 database_name: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str):
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class GetViewsViewResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 schema_name: _builtins.str):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> _builtins.str:
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class IndexColExpr(dict):
    def __init__(__self__, *,
                 field: _builtins.str):
        """
        :param _builtins.str field: The name of the option you want to set.
        """
        pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        The name of the option you want to set.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class IndexObjName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexObjName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexObjName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexObjName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The obj_name name.
        :param _builtins.str database_name: The obj_name database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The obj_name schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The obj_name name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The obj_name database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The obj_name schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class NetworkPolicyRule(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 address: _builtins.str,
                 direction: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str action: The action to take for this rule. Currently only 'allow' is supported.
        :param _builtins.str address: The CIDR block the rule will be applied to.
        :param _builtins.str direction: The direction of traffic the rule applies to. Currently only 'ingress' is supported.
        :param _builtins.str name: The name of the rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action to take for this rule. Currently only 'allow' is supported.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The CIDR block the rule will be applied to.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> _builtins.str:
        """
        The direction of traffic the rule applies to. Currently only 'ingress' is supported.
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RegionRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 host: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str cloud_provider: The cloud provider of the region. Currently, only AWS is supported.
        :param _builtins.str host: The SQL host of the region. This is the hostname of the Materialize cluster in the region.
        :param _builtins.str name: The name of the region.
        :param _builtins.str url: The URL at which the Region API can be reached.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        The cloud provider of the region. Currently, only AWS is supported.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The SQL host of the region. This is the hostname of the Materialize cluster in the region.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the region.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The URL at which the Region API can be reached.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SinkKafkaEnvelope(dict):
    def __init__(__self__, *,
                 debezium: Optional[_builtins.bool] = None,
                 upsert: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool debezium: The generated schemas have a Debezium-style diff envelope to capture changes in the input view or source.
        :param _builtins.bool upsert: The sink emits data with upsert semantics: updates and inserts for the given key are expressed as a value, and deletes are expressed as a null value payload in Kafka.
        """
        if debezium is not None:
            pulumi.set(__self__, "debezium", debezium)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @_builtins.property
    @pulumi.getter
    def debezium(self) -> Optional[_builtins.bool]:
        """
        The generated schemas have a Debezium-style diff envelope to capture changes in the input view or source.
        """
        return pulumi.get(self, "debezium")

    @_builtins.property
    @pulumi.getter
    def upsert(self) -> Optional[_builtins.bool]:
        """
        The sink emits data with upsert semantics: updates and inserts for the given key are expressed as a value, and deletes are expressed as a null value payload in Kafka.
        """
        return pulumi.get(self, "upsert")


@pulumi.output_type
class SinkKafkaFormat(dict):
    def __init__(__self__, *,
                 avro: Optional['outputs.SinkKafkaFormatAvro'] = None,
                 json: Optional[_builtins.bool] = None):
        """
        :param 'SinkKafkaFormatAvroArgs' avro: Avro format.
        :param _builtins.bool json: JSON format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if json is not None:
            pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def avro(self) -> Optional['outputs.SinkKafkaFormatAvro']:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[_builtins.bool]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")


@pulumi.output_type
class SinkKafkaFormatAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"
        elif key == "avroDocColumns":
            suggest = "avro_doc_columns"
        elif key == "avroDocType":
            suggest = "avro_doc_type"
        elif key == "avroKeyFullname":
            suggest = "avro_key_fullname"
        elif key == "avroValueFullname":
            suggest = "avro_value_fullname"
        elif key == "keyCompatibilityLevel":
            suggest = "key_compatibility_level"
        elif key == "valueCompatibilityLevel":
            suggest = "value_compatibility_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaFormatAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaFormatAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaFormatAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_registry_connection: 'outputs.SinkKafkaFormatAvroSchemaRegistryConnection',
                 avro_doc_columns: Optional[Sequence['outputs.SinkKafkaFormatAvroAvroDocColumn']] = None,
                 avro_doc_type: Optional['outputs.SinkKafkaFormatAvroAvroDocType'] = None,
                 avro_key_fullname: Optional[_builtins.str] = None,
                 avro_value_fullname: Optional[_builtins.str] = None,
                 key_compatibility_level: Optional[_builtins.str] = None,
                 value_compatibility_level: Optional[_builtins.str] = None):
        """
        :param 'SinkKafkaFormatAvroSchemaRegistryConnectionArgs' schema_registry_connection: The name of a schema registry connection.
        :param Sequence['SinkKafkaFormatAvroAvroDocColumnArgs'] avro_doc_columns: Add column level documentation comment to the generated Avro schemas.
        :param 'SinkKafkaFormatAvroAvroDocTypeArgs' avro_doc_type: Add top level documentation comment to the generated Avro schemas.
        :param _builtins.str avro_key_fullname: The full name of the Avro key schema.
        :param _builtins.str avro_value_fullname: The full name of the Avro value schema.
        :param _builtins.str key_compatibility_level: If specified, set the Compatibility Level for the generated key schema.
        :param _builtins.str value_compatibility_level: If specified, set the Compatibility Level for the generated value schema.
        """
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if avro_doc_columns is not None:
            pulumi.set(__self__, "avro_doc_columns", avro_doc_columns)
        if avro_doc_type is not None:
            pulumi.set(__self__, "avro_doc_type", avro_doc_type)
        if avro_key_fullname is not None:
            pulumi.set(__self__, "avro_key_fullname", avro_key_fullname)
        if avro_value_fullname is not None:
            pulumi.set(__self__, "avro_value_fullname", avro_value_fullname)
        if key_compatibility_level is not None:
            pulumi.set(__self__, "key_compatibility_level", key_compatibility_level)
        if value_compatibility_level is not None:
            pulumi.set(__self__, "value_compatibility_level", value_compatibility_level)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SinkKafkaFormatAvroSchemaRegistryConnection':
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @_builtins.property
    @pulumi.getter(name="avroDocColumns")
    def avro_doc_columns(self) -> Optional[Sequence['outputs.SinkKafkaFormatAvroAvroDocColumn']]:
        """
        Add column level documentation comment to the generated Avro schemas.
        """
        return pulumi.get(self, "avro_doc_columns")

    @_builtins.property
    @pulumi.getter(name="avroDocType")
    def avro_doc_type(self) -> Optional['outputs.SinkKafkaFormatAvroAvroDocType']:
        """
        Add top level documentation comment to the generated Avro schemas.
        """
        return pulumi.get(self, "avro_doc_type")

    @_builtins.property
    @pulumi.getter(name="avroKeyFullname")
    def avro_key_fullname(self) -> Optional[_builtins.str]:
        """
        The full name of the Avro key schema.
        """
        return pulumi.get(self, "avro_key_fullname")

    @_builtins.property
    @pulumi.getter(name="avroValueFullname")
    def avro_value_fullname(self) -> Optional[_builtins.str]:
        """
        The full name of the Avro value schema.
        """
        return pulumi.get(self, "avro_value_fullname")

    @_builtins.property
    @pulumi.getter(name="keyCompatibilityLevel")
    def key_compatibility_level(self) -> Optional[_builtins.str]:
        """
        If specified, set the Compatibility Level for the generated key schema.
        """
        return pulumi.get(self, "key_compatibility_level")

    @_builtins.property
    @pulumi.getter(name="valueCompatibilityLevel")
    def value_compatibility_level(self) -> Optional[_builtins.str]:
        """
        If specified, set the Compatibility Level for the generated value schema.
        """
        return pulumi.get(self, "value_compatibility_level")


@pulumi.output_type
class SinkKafkaFormatAvroAvroDocColumn(dict):
    def __init__(__self__, *,
                 column: _builtins.str,
                 doc: _builtins.str,
                 object: 'outputs.SinkKafkaFormatAvroAvroDocColumnObject',
                 key: Optional[_builtins.bool] = None,
                 value: Optional[_builtins.bool] = None):
        """
        :param _builtins.str column: Name of the column in the Avro schema to apply to.
        :param _builtins.str doc: Documentation string.
        :param 'SinkKafkaFormatAvroAvroDocColumnObjectArgs' object: The object to apply the Avro documentation.
        :param _builtins.bool key: Applies to the key schema.
        :param _builtins.bool value: Applies to the value schema.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "doc", doc)
        pulumi.set(__self__, "object", object)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def column(self) -> _builtins.str:
        """
        Name of the column in the Avro schema to apply to.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter
    def doc(self) -> _builtins.str:
        """
        Documentation string.
        """
        return pulumi.get(self, "doc")

    @_builtins.property
    @pulumi.getter
    def object(self) -> 'outputs.SinkKafkaFormatAvroAvroDocColumnObject':
        """
        The object to apply the Avro documentation.
        """
        return pulumi.get(self, "object")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.bool]:
        """
        Applies to the key schema.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        """
        Applies to the value schema.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SinkKafkaFormatAvroAvroDocColumnObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaFormatAvroAvroDocColumnObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaFormatAvroAvroDocColumnObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaFormatAvroAvroDocColumnObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The object name.
        :param _builtins.str database_name: The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The object schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The object name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The object schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SinkKafkaFormatAvroAvroDocType(dict):
    def __init__(__self__, *,
                 doc: _builtins.str,
                 object: 'outputs.SinkKafkaFormatAvroAvroDocTypeObject',
                 key: Optional[_builtins.bool] = None,
                 value: Optional[_builtins.bool] = None):
        """
        :param _builtins.str doc: Documentation string.
        :param 'SinkKafkaFormatAvroAvroDocTypeObjectArgs' object: The object to apply the Avro documentation.
        :param _builtins.bool key: Applies to the key schema.
        :param _builtins.bool value: Applies to the value schema.
        """
        pulumi.set(__self__, "doc", doc)
        pulumi.set(__self__, "object", object)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def doc(self) -> _builtins.str:
        """
        Documentation string.
        """
        return pulumi.get(self, "doc")

    @_builtins.property
    @pulumi.getter
    def object(self) -> 'outputs.SinkKafkaFormatAvroAvroDocTypeObject':
        """
        The object to apply the Avro documentation.
        """
        return pulumi.get(self, "object")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.bool]:
        """
        Applies to the key schema.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        """
        Applies to the value schema.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SinkKafkaFormatAvroAvroDocTypeObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaFormatAvroAvroDocTypeObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaFormatAvroAvroDocTypeObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaFormatAvroAvroDocTypeObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The object name.
        :param _builtins.str database_name: The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The object schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The object name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The object database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The object schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SinkKafkaFormatAvroSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaFormatAvroSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The schema*registry*connection name.
        :param _builtins.str database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SinkKafkaFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The from name.
        :param _builtins.str database_name: The from database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The from schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The from name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The from database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The from schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SinkKafkaKafkaConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SinkKafkaKafkaConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SinkKafkaKafkaConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SinkKafkaKafkaConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The kafka_connection name.
        :param _builtins.str database_name: The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The kafka_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The kafka_connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The kafka_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaEnvelope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "upsertOptions":
            suggest = "upsert_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaEnvelope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaEnvelope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaEnvelope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 debezium: Optional[_builtins.bool] = None,
                 none: Optional[_builtins.bool] = None,
                 upsert: Optional[_builtins.bool] = None,
                 upsert_options: Optional['outputs.SourceKafkaEnvelopeUpsertOptions'] = None):
        """
        :param _builtins.bool debezium: Use the Debezium envelope, which uses a diff envelope to handle CRUD operations.
        :param _builtins.bool none: Use an append-only envelope. This means that records will only be appended and cannot be updated or deleted.
        :param _builtins.bool upsert: Use the upsert envelope, which uses message keys to handle CRUD operations.
        :param 'SourceKafkaEnvelopeUpsertOptionsArgs' upsert_options: Options for the upsert envelope.
        """
        if debezium is not None:
            pulumi.set(__self__, "debezium", debezium)
        if none is not None:
            pulumi.set(__self__, "none", none)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)
        if upsert_options is not None:
            pulumi.set(__self__, "upsert_options", upsert_options)

    @_builtins.property
    @pulumi.getter
    def debezium(self) -> Optional[_builtins.bool]:
        """
        Use the Debezium envelope, which uses a diff envelope to handle CRUD operations.
        """
        return pulumi.get(self, "debezium")

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[_builtins.bool]:
        """
        Use an append-only envelope. This means that records will only be appended and cannot be updated or deleted.
        """
        return pulumi.get(self, "none")

    @_builtins.property
    @pulumi.getter
    def upsert(self) -> Optional[_builtins.bool]:
        """
        Use the upsert envelope, which uses message keys to handle CRUD operations.
        """
        return pulumi.get(self, "upsert")

    @_builtins.property
    @pulumi.getter(name="upsertOptions")
    def upsert_options(self) -> Optional['outputs.SourceKafkaEnvelopeUpsertOptions']:
        """
        Options for the upsert envelope.
        """
        return pulumi.get(self, "upsert_options")


@pulumi.output_type
class SourceKafkaEnvelopeUpsertOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueDecodingErrors":
            suggest = "value_decoding_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaEnvelopeUpsertOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaEnvelopeUpsertOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaEnvelopeUpsertOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value_decoding_errors: Optional['outputs.SourceKafkaEnvelopeUpsertOptionsValueDecodingErrors'] = None):
        """
        :param 'SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsArgs' value_decoding_errors: Specify how to handle value decoding errors in the upsert envelope.
        """
        if value_decoding_errors is not None:
            pulumi.set(__self__, "value_decoding_errors", value_decoding_errors)

    @_builtins.property
    @pulumi.getter(name="valueDecodingErrors")
    def value_decoding_errors(self) -> Optional['outputs.SourceKafkaEnvelopeUpsertOptionsValueDecodingErrors']:
        """
        Specify how to handle value decoding errors in the upsert envelope.
        """
        return pulumi.get(self, "value_decoding_errors")


@pulumi.output_type
class SourceKafkaEnvelopeUpsertOptionsValueDecodingErrors(dict):
    def __init__(__self__, *,
                 inline: Optional['outputs.SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInline'] = None):
        """
        :param 'SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInlineArgs' inline: Configuration for inline value decoding errors.
        """
        if inline is not None:
            pulumi.set(__self__, "inline", inline)

    @_builtins.property
    @pulumi.getter
    def inline(self) -> Optional['outputs.SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInline']:
        """
        Configuration for inline value decoding errors.
        """
        return pulumi.get(self, "inline")


@pulumi.output_type
class SourceKafkaEnvelopeUpsertOptionsValueDecodingErrorsInline(dict):
    def __init__(__self__, *,
                 alias: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str alias: Specify an alias for the value decoding errors column, to use an alternative name for the error column. If not specified, the column name will be `error`.
        :param _builtins.bool enabled: Enable inline value decoding errors.
        """
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        Specify an alias for the value decoding errors column, to use an alternative name for the error column. If not specified, the column name will be `error`.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable inline value decoding errors.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SourceKafkaExposeProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaExposeProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaExposeProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaExposeProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The expose_progress name.
        :param _builtins.str database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaFormat(dict):
    def __init__(__self__, *,
                 avro: Optional['outputs.SourceKafkaFormatAvro'] = None,
                 bytes: Optional[_builtins.bool] = None,
                 csvs: Optional[Sequence['outputs.SourceKafkaFormatCsv']] = None,
                 json: Optional[_builtins.bool] = None,
                 protobuf: Optional['outputs.SourceKafkaFormatProtobuf'] = None,
                 text: Optional[_builtins.bool] = None):
        """
        :param 'SourceKafkaFormatAvroArgs' avro: Avro format.
        :param _builtins.bool bytes: BYTES format.
        :param Sequence['SourceKafkaFormatCsvArgs'] csvs: CSV format.
        :param _builtins.bool json: JSON format.
        :param 'SourceKafkaFormatProtobufArgs' protobuf: Protobuf format.
        :param _builtins.bool text: Text format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if protobuf is not None:
            pulumi.set(__self__, "protobuf", protobuf)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def avro(self) -> Optional['outputs.SourceKafkaFormatAvro']:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[_builtins.bool]:
        """
        BYTES format.
        """
        return pulumi.get(self, "bytes")

    @_builtins.property
    @pulumi.getter
    def csvs(self) -> Optional[Sequence['outputs.SourceKafkaFormatCsv']]:
        """
        CSV format.
        """
        return pulumi.get(self, "csvs")

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[_builtins.bool]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @_builtins.property
    @pulumi.getter
    def protobuf(self) -> Optional['outputs.SourceKafkaFormatProtobuf']:
        """
        Protobuf format.
        """
        return pulumi.get(self, "protobuf")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.bool]:
        """
        Text format.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class SourceKafkaFormatAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"
        elif key == "keyStrategy":
            suggest = "key_strategy"
        elif key == "valueStrategy":
            suggest = "value_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_registry_connection: 'outputs.SourceKafkaFormatAvroSchemaRegistryConnection',
                 key_strategy: Optional[_builtins.str] = None,
                 value_strategy: Optional[_builtins.str] = None):
        """
        :param 'SourceKafkaFormatAvroSchemaRegistryConnectionArgs' schema_registry_connection: The name of a schema registry connection.
        :param _builtins.str key_strategy: How Materialize will define the Avro schema reader key strategy.
        :param _builtins.str value_strategy: How Materialize will define the Avro schema reader value strategy.
        """
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if key_strategy is not None:
            pulumi.set(__self__, "key_strategy", key_strategy)
        if value_strategy is not None:
            pulumi.set(__self__, "value_strategy", value_strategy)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaFormatAvroSchemaRegistryConnection':
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @_builtins.property
    @pulumi.getter(name="keyStrategy")
    def key_strategy(self) -> Optional[_builtins.str]:
        """
        How Materialize will define the Avro schema reader key strategy.
        """
        return pulumi.get(self, "key_strategy")

    @_builtins.property
    @pulumi.getter(name="valueStrategy")
    def value_strategy(self) -> Optional[_builtins.str]:
        """
        How Materialize will define the Avro schema reader value strategy.
        """
        return pulumi.get(self, "value_strategy")


@pulumi.output_type
class SourceKafkaFormatAvroSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatAvroSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The schema*registry*connection name.
        :param _builtins.str database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaFormatCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimitedBy":
            suggest = "delimited_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.int] = None,
                 delimited_by: Optional[_builtins.str] = None,
                 headers: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int column: The columns to use for the source.
        :param _builtins.str delimited_by: The delimiter to use for the source.
        :param Sequence[_builtins.str] headers: The number of columns and the name of each column using the header row.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if delimited_by is not None:
            pulumi.set(__self__, "delimited_by", delimited_by)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.int]:
        """
        The columns to use for the source.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="delimitedBy")
    def delimited_by(self) -> Optional[_builtins.str]:
        """
        The delimiter to use for the source.
        """
        return pulumi.get(self, "delimited_by")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The number of columns and the name of each column using the header row.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class SourceKafkaFormatProtobuf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatProtobuf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatProtobuf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatProtobuf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: _builtins.str,
                 schema_registry_connection: 'outputs.SourceKafkaFormatProtobufSchemaRegistryConnection'):
        """
        :param _builtins.str message: The name of the Protobuf message to use for the source.
        :param 'SourceKafkaFormatProtobufSchemaRegistryConnectionArgs' schema_registry_connection: The name of a schema registry connection.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The name of the Protobuf message to use for the source.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaFormatProtobufSchemaRegistryConnection':
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")


@pulumi.output_type
class SourceKafkaFormatProtobufSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaFormatProtobufSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The schema*registry*connection name.
        :param _builtins.str database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaKafkaConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKafkaConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKafkaConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKafkaConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The kafka_connection name.
        :param _builtins.str database_name: The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The kafka_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The kafka_connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The kafka_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The kafka_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaKeyFormat(dict):
    def __init__(__self__, *,
                 avro: Optional['outputs.SourceKafkaKeyFormatAvro'] = None,
                 bytes: Optional[_builtins.bool] = None,
                 csvs: Optional[Sequence['outputs.SourceKafkaKeyFormatCsv']] = None,
                 json: Optional[_builtins.bool] = None,
                 protobuf: Optional['outputs.SourceKafkaKeyFormatProtobuf'] = None,
                 text: Optional[_builtins.bool] = None):
        """
        :param 'SourceKafkaKeyFormatAvroArgs' avro: Avro format.
        :param _builtins.bool bytes: BYTES format.
        :param Sequence['SourceKafkaKeyFormatCsvArgs'] csvs: CSV format.
        :param _builtins.bool json: JSON format.
        :param 'SourceKafkaKeyFormatProtobufArgs' protobuf: Protobuf format.
        :param _builtins.bool text: Text format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if protobuf is not None:
            pulumi.set(__self__, "protobuf", protobuf)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def avro(self) -> Optional['outputs.SourceKafkaKeyFormatAvro']:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[_builtins.bool]:
        """
        BYTES format.
        """
        return pulumi.get(self, "bytes")

    @_builtins.property
    @pulumi.getter
    def csvs(self) -> Optional[Sequence['outputs.SourceKafkaKeyFormatCsv']]:
        """
        CSV format.
        """
        return pulumi.get(self, "csvs")

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[_builtins.bool]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @_builtins.property
    @pulumi.getter
    def protobuf(self) -> Optional['outputs.SourceKafkaKeyFormatProtobuf']:
        """
        Protobuf format.
        """
        return pulumi.get(self, "protobuf")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.bool]:
        """
        Text format.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class SourceKafkaKeyFormatAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"
        elif key == "keyStrategy":
            suggest = "key_strategy"
        elif key == "valueStrategy":
            suggest = "value_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_registry_connection: 'outputs.SourceKafkaKeyFormatAvroSchemaRegistryConnection',
                 key_strategy: Optional[_builtins.str] = None,
                 value_strategy: Optional[_builtins.str] = None):
        """
        :param 'SourceKafkaKeyFormatAvroSchemaRegistryConnectionArgs' schema_registry_connection: The name of a schema registry connection.
        :param _builtins.str key_strategy: How Materialize will define the Avro schema reader key strategy.
        :param _builtins.str value_strategy: How Materialize will define the Avro schema reader value strategy.
        """
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if key_strategy is not None:
            pulumi.set(__self__, "key_strategy", key_strategy)
        if value_strategy is not None:
            pulumi.set(__self__, "value_strategy", value_strategy)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaKeyFormatAvroSchemaRegistryConnection':
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @_builtins.property
    @pulumi.getter(name="keyStrategy")
    def key_strategy(self) -> Optional[_builtins.str]:
        """
        How Materialize will define the Avro schema reader key strategy.
        """
        return pulumi.get(self, "key_strategy")

    @_builtins.property
    @pulumi.getter(name="valueStrategy")
    def value_strategy(self) -> Optional[_builtins.str]:
        """
        How Materialize will define the Avro schema reader value strategy.
        """
        return pulumi.get(self, "value_strategy")


@pulumi.output_type
class SourceKafkaKeyFormatAvroSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatAvroSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The schema*registry*connection name.
        :param _builtins.str database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaKeyFormatCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimitedBy":
            suggest = "delimited_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.int] = None,
                 delimited_by: Optional[_builtins.str] = None,
                 headers: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int column: The columns to use for the source.
        :param _builtins.str delimited_by: The delimiter to use for the source.
        :param Sequence[_builtins.str] headers: The number of columns and the name of each column using the header row.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if delimited_by is not None:
            pulumi.set(__self__, "delimited_by", delimited_by)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.int]:
        """
        The columns to use for the source.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="delimitedBy")
    def delimited_by(self) -> Optional[_builtins.str]:
        """
        The delimiter to use for the source.
        """
        return pulumi.get(self, "delimited_by")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The number of columns and the name of each column using the header row.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class SourceKafkaKeyFormatProtobuf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatProtobuf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatProtobuf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatProtobuf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: _builtins.str,
                 schema_registry_connection: 'outputs.SourceKafkaKeyFormatProtobufSchemaRegistryConnection'):
        """
        :param _builtins.str message: The name of the Protobuf message to use for the source.
        :param 'SourceKafkaKeyFormatProtobufSchemaRegistryConnectionArgs' schema_registry_connection: The name of a schema registry connection.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The name of the Protobuf message to use for the source.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaKeyFormatProtobufSchemaRegistryConnection':
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")


@pulumi.output_type
class SourceKafkaKeyFormatProtobufSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaKeyFormatProtobufSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaKeyFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaKeyFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The schema*registry*connection name.
        :param _builtins.str database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaValueFormat(dict):
    def __init__(__self__, *,
                 avro: Optional['outputs.SourceKafkaValueFormatAvro'] = None,
                 bytes: Optional[_builtins.bool] = None,
                 csvs: Optional[Sequence['outputs.SourceKafkaValueFormatCsv']] = None,
                 json: Optional[_builtins.bool] = None,
                 protobuf: Optional['outputs.SourceKafkaValueFormatProtobuf'] = None,
                 text: Optional[_builtins.bool] = None):
        """
        :param 'SourceKafkaValueFormatAvroArgs' avro: Avro format.
        :param _builtins.bool bytes: BYTES format.
        :param Sequence['SourceKafkaValueFormatCsvArgs'] csvs: CSV format.
        :param _builtins.bool json: JSON format.
        :param 'SourceKafkaValueFormatProtobufArgs' protobuf: Protobuf format.
        :param _builtins.bool text: Text format.
        """
        if avro is not None:
            pulumi.set(__self__, "avro", avro)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)
        if csvs is not None:
            pulumi.set(__self__, "csvs", csvs)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if protobuf is not None:
            pulumi.set(__self__, "protobuf", protobuf)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def avro(self) -> Optional['outputs.SourceKafkaValueFormatAvro']:
        """
        Avro format.
        """
        return pulumi.get(self, "avro")

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[_builtins.bool]:
        """
        BYTES format.
        """
        return pulumi.get(self, "bytes")

    @_builtins.property
    @pulumi.getter
    def csvs(self) -> Optional[Sequence['outputs.SourceKafkaValueFormatCsv']]:
        """
        CSV format.
        """
        return pulumi.get(self, "csvs")

    @_builtins.property
    @pulumi.getter
    def json(self) -> Optional[_builtins.bool]:
        """
        JSON format.
        """
        return pulumi.get(self, "json")

    @_builtins.property
    @pulumi.getter
    def protobuf(self) -> Optional['outputs.SourceKafkaValueFormatProtobuf']:
        """
        Protobuf format.
        """
        return pulumi.get(self, "protobuf")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.bool]:
        """
        Text format.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class SourceKafkaValueFormatAvro(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"
        elif key == "keyStrategy":
            suggest = "key_strategy"
        elif key == "valueStrategy":
            suggest = "value_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatAvro. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatAvro.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatAvro.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_registry_connection: 'outputs.SourceKafkaValueFormatAvroSchemaRegistryConnection',
                 key_strategy: Optional[_builtins.str] = None,
                 value_strategy: Optional[_builtins.str] = None):
        """
        :param 'SourceKafkaValueFormatAvroSchemaRegistryConnectionArgs' schema_registry_connection: The name of a schema registry connection.
        :param _builtins.str key_strategy: How Materialize will define the Avro schema reader key strategy.
        :param _builtins.str value_strategy: How Materialize will define the Avro schema reader value strategy.
        """
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)
        if key_strategy is not None:
            pulumi.set(__self__, "key_strategy", key_strategy)
        if value_strategy is not None:
            pulumi.set(__self__, "value_strategy", value_strategy)

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaValueFormatAvroSchemaRegistryConnection':
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")

    @_builtins.property
    @pulumi.getter(name="keyStrategy")
    def key_strategy(self) -> Optional[_builtins.str]:
        """
        How Materialize will define the Avro schema reader key strategy.
        """
        return pulumi.get(self, "key_strategy")

    @_builtins.property
    @pulumi.getter(name="valueStrategy")
    def value_strategy(self) -> Optional[_builtins.str]:
        """
        How Materialize will define the Avro schema reader value strategy.
        """
        return pulumi.get(self, "value_strategy")


@pulumi.output_type
class SourceKafkaValueFormatAvroSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatAvroSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatAvroSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The schema*registry*connection name.
        :param _builtins.str database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceKafkaValueFormatCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delimitedBy":
            suggest = "delimited_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.int] = None,
                 delimited_by: Optional[_builtins.str] = None,
                 headers: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int column: The columns to use for the source.
        :param _builtins.str delimited_by: The delimiter to use for the source.
        :param Sequence[_builtins.str] headers: The number of columns and the name of each column using the header row.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if delimited_by is not None:
            pulumi.set(__self__, "delimited_by", delimited_by)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.int]:
        """
        The columns to use for the source.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="delimitedBy")
    def delimited_by(self) -> Optional[_builtins.str]:
        """
        The delimiter to use for the source.
        """
        return pulumi.get(self, "delimited_by")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The number of columns and the name of each column using the header row.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class SourceKafkaValueFormatProtobuf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaRegistryConnection":
            suggest = "schema_registry_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatProtobuf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatProtobuf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatProtobuf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message: _builtins.str,
                 schema_registry_connection: 'outputs.SourceKafkaValueFormatProtobufSchemaRegistryConnection'):
        """
        :param _builtins.str message: The name of the Protobuf message to use for the source.
        :param 'SourceKafkaValueFormatProtobufSchemaRegistryConnectionArgs' schema_registry_connection: The name of a schema registry connection.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "schema_registry_connection", schema_registry_connection)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        The name of the Protobuf message to use for the source.
        """
        return pulumi.get(self, "message")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryConnection")
    def schema_registry_connection(self) -> 'outputs.SourceKafkaValueFormatProtobufSchemaRegistryConnection':
        """
        The name of a schema registry connection.
        """
        return pulumi.get(self, "schema_registry_connection")


@pulumi.output_type
class SourceKafkaValueFormatProtobufSchemaRegistryConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceKafkaValueFormatProtobufSchemaRegistryConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceKafkaValueFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceKafkaValueFormatProtobufSchemaRegistryConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The schema*registry*connection name.
        :param _builtins.str database_name: The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The schema*registry*connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The schema*registry*connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema*registry*connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceLoadgenAuctionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleFactor":
            suggest = "scale_factor"
        elif key == "tickInterval":
            suggest = "tick_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLoadgenAuctionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLoadgenAuctionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLoadgenAuctionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_factor: Optional[_builtins.float] = None,
                 tick_interval: Optional[_builtins.str] = None):
        """
        :param _builtins.float scale_factor: (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        :param _builtins.str tick_interval: The interval at which the next datum should be emitted. Defaults to one second.
        """
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if tick_interval is not None:
            pulumi.set(__self__, "tick_interval", tick_interval)

    @_builtins.property
    @pulumi.getter(name="scaleFactor")
    @_utilities.deprecated("""Scale factor is deprecated and will be removed in a future release.""")
    def scale_factor(self) -> Optional[_builtins.float]:
        """
        (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        return pulumi.get(self, "scale_factor")

    @_builtins.property
    @pulumi.getter(name="tickInterval")
    def tick_interval(self) -> Optional[_builtins.str]:
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
        return pulumi.get(self, "tick_interval")


@pulumi.output_type
class SourceLoadgenExposeProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLoadgenExposeProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLoadgenExposeProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLoadgenExposeProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The expose_progress name.
        :param _builtins.str database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceLoadgenMarketingOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleFactor":
            suggest = "scale_factor"
        elif key == "tickInterval":
            suggest = "tick_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLoadgenMarketingOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLoadgenMarketingOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLoadgenMarketingOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_factor: Optional[_builtins.float] = None,
                 tick_interval: Optional[_builtins.str] = None):
        """
        :param _builtins.float scale_factor: (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        :param _builtins.str tick_interval: The interval at which the next datum should be emitted. Defaults to one second.
        """
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if tick_interval is not None:
            pulumi.set(__self__, "tick_interval", tick_interval)

    @_builtins.property
    @pulumi.getter(name="scaleFactor")
    @_utilities.deprecated("""Scale factor is deprecated and will be removed in a future release.""")
    def scale_factor(self) -> Optional[_builtins.float]:
        """
        (Deprecated) The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        return pulumi.get(self, "scale_factor")

    @_builtins.property
    @pulumi.getter(name="tickInterval")
    def tick_interval(self) -> Optional[_builtins.str]:
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
        return pulumi.get(self, "tick_interval")


@pulumi.output_type
class SourceLoadgenTpchOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleFactor":
            suggest = "scale_factor"
        elif key == "tickInterval":
            suggest = "tick_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceLoadgenTpchOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceLoadgenTpchOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceLoadgenTpchOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_factor: Optional[_builtins.float] = None,
                 tick_interval: Optional[_builtins.str] = None):
        """
        :param _builtins.float scale_factor: The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        :param _builtins.str tick_interval: The interval at which the next datum should be emitted. Defaults to one second.
        """
        if scale_factor is not None:
            pulumi.set(__self__, "scale_factor", scale_factor)
        if tick_interval is not None:
            pulumi.set(__self__, "tick_interval", tick_interval)

    @_builtins.property
    @pulumi.getter(name="scaleFactor")
    def scale_factor(self) -> Optional[_builtins.float]:
        """
        The scale factor for the generator. Defaults to 0.01 (~ 10MB).
        """
        return pulumi.get(self, "scale_factor")

    @_builtins.property
    @pulumi.getter(name="tickInterval")
    def tick_interval(self) -> Optional[_builtins.str]:
        """
        The interval at which the next datum should be emitted. Defaults to one second.
        """
        return pulumi.get(self, "tick_interval")


@pulumi.output_type
class SourceMysqlExposeProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlExposeProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlExposeProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlExposeProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The expose_progress name.
        :param _builtins.str database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceMysqlMysqlConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlMysqlConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlMysqlConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlMysqlConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The mysql_connection name.
        :param _builtins.str database_name: The mysql_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The mysql_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The mysql_connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The mysql_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The mysql_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceMysqlTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "upstreamName":
            suggest = "upstream_name"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "upstreamSchemaName":
            suggest = "upstream_schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceMysqlTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceMysqlTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceMysqlTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 upstream_name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None,
                 upstream_schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str upstream_name: The name of the table in the upstream MySQL database.
        :param _builtins.str database_name: The database of the table in Materialize.
        :param _builtins.str name: The name for the table, used in Materialize.
        :param _builtins.str schema_name: The schema of the table in Materialize.
        :param _builtins.str upstream_schema_name: The schema of the table in the upstream MySQL database.
        """
        pulumi.set(__self__, "upstream_name", upstream_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if upstream_schema_name is not None:
            pulumi.set(__self__, "upstream_schema_name", upstream_schema_name)

    @_builtins.property
    @pulumi.getter(name="upstreamName")
    def upstream_name(self) -> _builtins.str:
        """
        The name of the table in the upstream MySQL database.
        """
        return pulumi.get(self, "upstream_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The database of the table in Materialize.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name for the table, used in Materialize.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema of the table in Materialize.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="upstreamSchemaName")
    def upstream_schema_name(self) -> Optional[_builtins.str]:
        """
        The schema of the table in the upstream MySQL database.
        """
        return pulumi.get(self, "upstream_schema_name")


@pulumi.output_type
class SourcePostgresExposeProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresExposeProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresExposeProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresExposeProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The expose_progress name.
        :param _builtins.str database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourcePostgresPostgresConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresPostgresConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresPostgresConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresPostgresConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The postgres_connection name.
        :param _builtins.str database_name: The postgres_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The postgres_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The postgres_connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The postgres_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The postgres_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourcePostgresTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "upstreamName":
            suggest = "upstream_name"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "upstreamSchemaName":
            suggest = "upstream_schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourcePostgresTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourcePostgresTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourcePostgresTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 upstream_name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None,
                 upstream_schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str upstream_name: The name of the table in the upstream Postgres database.
        :param _builtins.str database_name: The database of the table in Materialize.
        :param _builtins.str name: The name of the table in Materialize.
        :param _builtins.str schema_name: The schema of the table in Materialize.
        :param _builtins.str upstream_schema_name: The schema of the table in the upstream Postgres database.
        """
        pulumi.set(__self__, "upstream_name", upstream_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if upstream_schema_name is not None:
            pulumi.set(__self__, "upstream_schema_name", upstream_schema_name)

    @_builtins.property
    @pulumi.getter(name="upstreamName")
    def upstream_name(self) -> _builtins.str:
        """
        The name of the table in the upstream Postgres database.
        """
        return pulumi.get(self, "upstream_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The database of the table in Materialize.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the table in Materialize.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema of the table in Materialize.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="upstreamSchemaName")
    def upstream_schema_name(self) -> Optional[_builtins.str]:
        """
        The schema of the table in the upstream Postgres database.
        """
        return pulumi.get(self, "upstream_schema_name")


@pulumi.output_type
class SourceSqlserverAwsPrivatelink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSqlserverAwsPrivatelink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSqlserverAwsPrivatelink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSqlserverAwsPrivatelink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The aws_privatelink name.
        :param _builtins.str database_name: The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The aws_privatelink schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The aws_privatelink name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The aws_privatelink schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceSqlserverExposeProgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSqlserverExposeProgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSqlserverExposeProgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSqlserverExposeProgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The expose_progress name.
        :param _builtins.str database_name: The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The expose_progress schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The expose_progress name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The expose_progress schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceSqlserverSqlserverConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSqlserverSqlserverConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSqlserverSqlserverConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSqlserverSqlserverConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The sqlserver_connection name.
        :param _builtins.str database_name: The sqlserver_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The sqlserver_connection schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The sqlserver_connection name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The sqlserver_connection database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The sqlserver_connection schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceSqlserverTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "upstreamName":
            suggest = "upstream_name"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"
        elif key == "upstreamSchemaName":
            suggest = "upstream_schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceSqlserverTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceSqlserverTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceSqlserverTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 upstream_name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None,
                 upstream_schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str upstream_name: The name of the table in the upstream SQL Server database.
        :param _builtins.str database_name: The database of the table in Materialize.
        :param _builtins.str name: The name for the table, used in Materialize.
        :param _builtins.str schema_name: The schema of the table in Materialize.
        :param _builtins.str upstream_schema_name: The schema of the table in the upstream SQL Server database.
        """
        pulumi.set(__self__, "upstream_name", upstream_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)
        if upstream_schema_name is not None:
            pulumi.set(__self__, "upstream_schema_name", upstream_schema_name)

    @_builtins.property
    @pulumi.getter(name="upstreamName")
    def upstream_name(self) -> _builtins.str:
        """
        The name of the table in the upstream SQL Server database.
        """
        return pulumi.get(self, "upstream_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The database of the table in Materialize.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name for the table, used in Materialize.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The schema of the table in Materialize.
        """
        return pulumi.get(self, "schema_name")

    @_builtins.property
    @pulumi.getter(name="upstreamSchemaName")
    def upstream_schema_name(self) -> Optional[_builtins.str]:
        """
        The schema of the table in the upstream SQL Server database.
        """
        return pulumi.get(self, "upstream_schema_name")


@pulumi.output_type
class SourceWebhookCheckOption(dict):
    def __init__(__self__, *,
                 field: 'outputs.SourceWebhookCheckOptionField',
                 alias: Optional[_builtins.str] = None,
                 bytes: Optional[_builtins.bool] = None):
        """
        :param 'SourceWebhookCheckOptionFieldArgs' field: The field for the check options.
        :param _builtins.str alias: The alias for the check options.
        :param _builtins.bool bytes: Change type to `bytea`.
        """
        pulumi.set(__self__, "field", field)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)

    @_builtins.property
    @pulumi.getter
    def field(self) -> 'outputs.SourceWebhookCheckOptionField':
        """
        The field for the check options.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        The alias for the check options.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[_builtins.bool]:
        """
        Change type to `bytea`.
        """
        return pulumi.get(self, "bytes")


@pulumi.output_type
class SourceWebhookCheckOptionField(dict):
    def __init__(__self__, *,
                 body: Optional[_builtins.bool] = None,
                 headers: Optional[_builtins.bool] = None,
                 secret: Optional['outputs.SourceWebhookCheckOptionFieldSecret'] = None):
        """
        :param _builtins.bool body: The body for the check options.
        :param _builtins.bool headers: The headers for the check options.
        :param 'SourceWebhookCheckOptionFieldSecretArgs' secret: The secret for the check options.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def body(self) -> Optional[_builtins.bool]:
        """
        The body for the check options.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[_builtins.bool]:
        """
        The headers for the check options.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.SourceWebhookCheckOptionFieldSecret']:
        """
        The secret for the check options.
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class SourceWebhookCheckOptionFieldSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceWebhookCheckOptionFieldSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceWebhookCheckOptionFieldSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceWebhookCheckOptionFieldSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 database_name: Optional[_builtins.str] = None,
                 schema_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The secret name.
        :param _builtins.str database_name: The secret database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        :param _builtins.str schema_name: The secret schema name. Defaults to `public`.
        """
        pulumi.set(__self__, "name", name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The secret name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        The secret database name. Defaults to `MZ_DATABASE` environment variable if set or `materialize` if environment variable is not set.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[_builtins.str]:
        """
        The secret schema name. Defaults to `public`.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SourceWebhookIncludeHeader(dict):
    def __init__(__self__, *,
                 header: _builtins.str,
                 alias: Optional[_builtins.str] = None,
                 bytes: Optional[_builtins.bool] = None):
        """
        :param _builtins.str header: The name for the header.
        :param _builtins.str alias: The alias for the header.
        :param _builtins.bool bytes: Change type to `bytea`.
        """
        pulumi.set(__self__, "header", header)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)

    @_builtins.property
    @pulumi.getter
    def header(self) -> _builtins.str:
        """
        The name for the header.
        """
        return pulumi.get(self, "header")

    @_builtins.property
    @pulumi.getter
    def alias(self) -> Optional[_builtins.str]:
        """
        The alias for the header.
        """
        return pulumi.get(self, "alias")

    @_builtins.property
    @pulumi.getter
    def bytes(self) -> Optional[_builtins.bool]:
        """
        Change type to `bytea`.
        """
        return pulumi.get(self, "bytes")


@pulumi.output_type
class SourceWebhookIncludeHeaders(dict):
    def __init__(__self__, *,
                 all: Optional[_builtins.bool] = None,
                 nots: Optional[Sequence[_builtins.str]] = None,
                 onlies: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool all: Include all headers.
        :param Sequence[_builtins.str] nots: Headers that should be excluded.
        :param Sequence[_builtins.str] onlies: Headers that should be included.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if nots is not None:
            pulumi.set(__self__, "nots", nots)
        if onlies is not None:
            pulumi.set(__self__, "onlies", onlies)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Include all headers.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter
    def nots(self) -> Optional[Sequence[_builtins.str]]:
        """
        Headers that should be excluded.
        """
        return pulumi.get(self, "nots")

    @_builtins.property
    @pulumi.getter
    def onlies(self) -> Optional[Sequence[_builtins.str]]:
        """
        Headers that should be included.
        """
        return pulumi.get(self, "onlies")


@pulumi.output_type
class TableColumn(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 comment: Optional[_builtins.str] = None,
                 default: Optional[_builtins.str] = None,
                 nullable: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the column to be created in the table.
        :param _builtins.str type: The data type of the column indicated by name.
        :param _builtins.str comment: Comment on an object in the database.
        :param _builtins.str default: A default value to use for the column in an INSERT statement if an explicit value is not provided. If not specified, `NULL` is assumed..
        :param _builtins.bool nullable: Do not allow the column to contain `NULL` values. Columns without this constraint can contain `NULL` values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the column to be created in the table.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The data type of the column indicated by name.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[_builtins.str]:
        """
        Comment on an object in the database.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        A default value to use for the column in an INSERT statement if an explicit value is not provided. If not specified, `NULL` is assumed..
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Do not allow the column to contain `NULL` values. Columns without this constraint can contain `NULL` values.
        """
        return pulumi.get(self, "nullable")


@pulumi.output_type
class TypeListProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elementType":
            suggest = "element_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TypeListProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TypeListProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TypeListProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 element_type: _builtins.str):
        """
        :param _builtins.str element_type: Creates a custom list whose elements are of `ELEMENT TYPE`
        """
        pulumi.set(__self__, "element_type", element_type)

    @_builtins.property
    @pulumi.getter(name="elementType")
    def element_type(self) -> _builtins.str:
        """
        Creates a custom list whose elements are of `ELEMENT TYPE`
        """
        return pulumi.get(self, "element_type")


@pulumi.output_type
class TypeMapProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyType":
            suggest = "key_type"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TypeMapProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TypeMapProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TypeMapProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_type: _builtins.str,
                 value_type: _builtins.str):
        """
        :param _builtins.str key_type: Creates a custom map whose keys are of `KEY TYPE`. `KEY TYPE` must resolve to text.
        :param _builtins.str value_type: Creates a custom map whose values are of `VALUE TYPE`.
        """
        pulumi.set(__self__, "key_type", key_type)
        pulumi.set(__self__, "value_type", value_type)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> _builtins.str:
        """
        Creates a custom map whose keys are of `KEY TYPE`. `KEY TYPE` must resolve to text.
        """
        return pulumi.get(self, "key_type")

    @_builtins.property
    @pulumi.getter(name="valueType")
    def value_type(self) -> _builtins.str:
        """
        Creates a custom map whose values are of `VALUE TYPE`.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class TypeRowProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TypeRowProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TypeRowProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TypeRowProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 field_type: _builtins.str):
        """
        :param _builtins.str field_name: The name of a field in a row type.
        :param _builtins.str field_type: The data type of a field indicated by `FIELD NAME`.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        The name of a field in a row type.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> _builtins.str:
        """
        The data type of a field indicated by `FIELD NAME`.
        """
        return pulumi.get(self, "field_type")


