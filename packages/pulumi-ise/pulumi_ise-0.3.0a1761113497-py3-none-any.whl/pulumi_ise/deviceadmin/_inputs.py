# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AuthenticationRuleChildrenArgs',
    'AuthenticationRuleChildrenArgsDict',
    'AuthenticationRuleChildrenChildrenArgs',
    'AuthenticationRuleChildrenChildrenArgsDict',
    'AuthenticationRuleUpdateRanksRuleArgs',
    'AuthenticationRuleUpdateRanksRuleArgsDict',
    'AuthorizationExceptionRuleChildrenArgs',
    'AuthorizationExceptionRuleChildrenArgsDict',
    'AuthorizationExceptionRuleChildrenChildrenArgs',
    'AuthorizationExceptionRuleChildrenChildrenArgsDict',
    'AuthorizationExceptionRuleUpdateRanksRuleArgs',
    'AuthorizationExceptionRuleUpdateRanksRuleArgsDict',
    'AuthorizationGlobalExceptionRuleChildrenArgs',
    'AuthorizationGlobalExceptionRuleChildrenArgsDict',
    'AuthorizationGlobalExceptionRuleChildrenChildrenArgs',
    'AuthorizationGlobalExceptionRuleChildrenChildrenArgsDict',
    'AuthorizationGlobalExceptionRuleUpdateRanksRuleArgs',
    'AuthorizationGlobalExceptionRuleUpdateRanksRuleArgsDict',
    'AuthorizationRuleChildrenArgs',
    'AuthorizationRuleChildrenArgsDict',
    'AuthorizationRuleChildrenChildrenArgs',
    'AuthorizationRuleChildrenChildrenArgsDict',
    'AuthorizationRuleUpdateRanksRuleArgs',
    'AuthorizationRuleUpdateRanksRuleArgsDict',
    'ConditionChildrenArgs',
    'ConditionChildrenArgsDict',
    'ConditionChildrenChildrenArgs',
    'ConditionChildrenChildrenArgsDict',
    'PolicySetChildrenArgs',
    'PolicySetChildrenArgsDict',
    'PolicySetChildrenChildrenArgs',
    'PolicySetChildrenChildrenArgsDict',
    'PolicySetUpdateRanksPolicyArgs',
    'PolicySetUpdateRanksPolicyArgsDict',
    'TacacsCommandSetCommandArgs',
    'TacacsCommandSetCommandArgsDict',
    'TacacsProfileSessionAttributeArgs',
    'TacacsProfileSessionAttributeArgsDict',
]

MYPY = False

if not MYPY:
    class AuthenticationRuleChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        childrens: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthenticationRuleChildrenChildrenArgsDict']]]]
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
elif False:
    AuthenticationRuleChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationRuleChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 childrens: Optional[pulumi.Input[Sequence[pulumi.Input['AuthenticationRuleChildrenChildrenArgs']]]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
                 - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[Sequence[pulumi.Input['AuthenticationRuleChildrenChildrenArgs']]] childrens: List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if childrens is not None:
            pulumi.set(__self__, "childrens", childrens)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter
    def childrens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthenticationRuleChildrenChildrenArgs']]]]:
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        return pulumi.get(self, "childrens")

    @childrens.setter
    def childrens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthenticationRuleChildrenChildrenArgs']]]]):
        pulumi.set(self, "childrens", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AuthenticationRuleChildrenChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
elif False:
    AuthenticationRuleChildrenChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationRuleChildrenChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Condition type.
                 - Choices: `ConditionAttributes`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AuthenticationRuleUpdateRanksRuleArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication rule ID
        """
        rank: NotRequired[pulumi.Input[_builtins.int]]
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
elif False:
    AuthenticationRuleUpdateRanksRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationRuleUpdateRanksRuleArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Authentication rule ID
        :param pulumi.Input[_builtins.int] rank: The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication rule ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rank", value)


if not MYPY:
    class AuthorizationExceptionRuleChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        childrens: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthorizationExceptionRuleChildrenChildrenArgsDict']]]]
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
elif False:
    AuthorizationExceptionRuleChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationExceptionRuleChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 childrens: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationExceptionRuleChildrenChildrenArgs']]]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
                 - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[Sequence[pulumi.Input['AuthorizationExceptionRuleChildrenChildrenArgs']]] childrens: List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if childrens is not None:
            pulumi.set(__self__, "childrens", childrens)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter
    def childrens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationExceptionRuleChildrenChildrenArgs']]]]:
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        return pulumi.get(self, "childrens")

    @childrens.setter
    def childrens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationExceptionRuleChildrenChildrenArgs']]]]):
        pulumi.set(self, "childrens", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AuthorizationExceptionRuleChildrenChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
elif False:
    AuthorizationExceptionRuleChildrenChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationExceptionRuleChildrenChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Condition type.
                 - Choices: `ConditionAttributes`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AuthorizationExceptionRuleUpdateRanksRuleArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authorization rule ID
        """
        rank: NotRequired[pulumi.Input[_builtins.int]]
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
elif False:
    AuthorizationExceptionRuleUpdateRanksRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationExceptionRuleUpdateRanksRuleArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Authorization rule ID
        :param pulumi.Input[_builtins.int] rank: The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authorization rule ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rank", value)


if not MYPY:
    class AuthorizationGlobalExceptionRuleChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        childrens: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthorizationGlobalExceptionRuleChildrenChildrenArgsDict']]]]
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
elif False:
    AuthorizationGlobalExceptionRuleChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationGlobalExceptionRuleChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 childrens: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationGlobalExceptionRuleChildrenChildrenArgs']]]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
                 - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[Sequence[pulumi.Input['AuthorizationGlobalExceptionRuleChildrenChildrenArgs']]] childrens: List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if childrens is not None:
            pulumi.set(__self__, "childrens", childrens)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter
    def childrens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationGlobalExceptionRuleChildrenChildrenArgs']]]]:
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        return pulumi.get(self, "childrens")

    @childrens.setter
    def childrens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationGlobalExceptionRuleChildrenChildrenArgs']]]]):
        pulumi.set(self, "childrens", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AuthorizationGlobalExceptionRuleChildrenChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
elif False:
    AuthorizationGlobalExceptionRuleChildrenChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationGlobalExceptionRuleChildrenChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Condition type.
                 - Choices: `ConditionAttributes`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AuthorizationGlobalExceptionRuleUpdateRanksRuleArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authorization rule ID
        """
        rank: NotRequired[pulumi.Input[_builtins.int]]
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
elif False:
    AuthorizationGlobalExceptionRuleUpdateRanksRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationGlobalExceptionRuleUpdateRanksRuleArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Authorization rule ID
        :param pulumi.Input[_builtins.int] rank: The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authorization rule ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rank", value)


if not MYPY:
    class AuthorizationRuleChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        childrens: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleChildrenChildrenArgsDict']]]]
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
elif False:
    AuthorizationRuleChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationRuleChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 childrens: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleChildrenChildrenArgs']]]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
                 - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleChildrenChildrenArgs']]] childrens: List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if childrens is not None:
            pulumi.set(__self__, "childrens", childrens)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter
    def childrens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleChildrenChildrenArgs']]]]:
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        return pulumi.get(self, "childrens")

    @childrens.setter
    def childrens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationRuleChildrenChildrenArgs']]]]):
        pulumi.set(self, "childrens", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AuthorizationRuleChildrenChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
elif False:
    AuthorizationRuleChildrenChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationRuleChildrenChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Condition type.
                 - Choices: `ConditionAttributes`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class AuthorizationRuleUpdateRanksRuleArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authorization rule ID
        """
        rank: NotRequired[pulumi.Input[_builtins.int]]
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
elif False:
    AuthorizationRuleUpdateRanksRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationRuleUpdateRanksRuleArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 rank: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Authorization rule ID
        :param pulumi.Input[_builtins.int] rank: The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if rank is not None:
            pulumi.set(__self__, "rank", rank)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authorization rule ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rank", value)


if not MYPY:
    class ConditionChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        childrens: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConditionChildrenChildrenArgsDict']]]]
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Condition description
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Condition name
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
elif False:
    ConditionChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConditionChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 childrens: Optional[pulumi.Input[Sequence[pulumi.Input['ConditionChildrenChildrenArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
                 - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[Sequence[pulumi.Input['ConditionChildrenChildrenArgs']]] childrens: List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        :param pulumi.Input[_builtins.str] description: Condition description
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] name: Condition name
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if childrens is not None:
            pulumi.set(__self__, "childrens", childrens)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter
    def childrens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConditionChildrenChildrenArgs']]]]:
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        return pulumi.get(self, "childrens")

    @childrens.setter
    def childrens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConditionChildrenChildrenArgs']]]]):
        pulumi.set(self, "childrens", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Condition description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Condition name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class ConditionChildrenChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Condition description
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Condition name
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
elif False:
    ConditionChildrenChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConditionChildrenChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Condition type.
                 - Choices: `ConditionAttributes`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[_builtins.str] description: Condition description
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] name: Condition name
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Condition description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Condition name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class PolicySetChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        childrens: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicySetChildrenChildrenArgsDict']]]]
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
elif False:
    PolicySetChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySetChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 childrens: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySetChildrenChildrenArgs']]]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
                 - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[Sequence[pulumi.Input['PolicySetChildrenChildrenArgs']]] childrens: List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if childrens is not None:
            pulumi.set(__self__, "childrens", childrens)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates whether the record is the condition itself or a logical aggregation. Logical aggreation indicates that additional conditions are present under the children attribute.
          - Choices: `ConditionAndBlock`, `ConditionAttributes`, `ConditionOrBlock`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter
    def childrens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicySetChildrenChildrenArgs']]]]:
        """
        List of child conditions. `condition_type` must be one of `ConditionAndBlock` or `ConditionOrBlock`.
        """
        return pulumi.get(self, "childrens")

    @childrens.setter
    def childrens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicySetChildrenChildrenArgs']]]]):
        pulumi.set(self, "childrens", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`, `macContains`, `macEndsWith`, `macEquals`, `macIn`, `macNotContains`, `macNotEndsWith`, `macNotEquals`, `macNotIn`, `macNotStartsWith`, `macStartsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class PolicySetChildrenChildrenArgsDict(TypedDict):
        condition_type: pulumi.Input[_builtins.str]
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        attribute_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary attribute name
        """
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary name
        """
        dictionary_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Dictionary value
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID for condition
        """
        is_negate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whereas this condition is in negate mode
        """
        operator: NotRequired[pulumi.Input[_builtins.str]]
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
elif False:
    PolicySetChildrenChildrenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySetChildrenChildrenArgs:
    def __init__(__self__, *,
                 condition_type: pulumi.Input[_builtins.str],
                 attribute_name: Optional[pulumi.Input[_builtins.str]] = None,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_name: Optional[pulumi.Input[_builtins.str]] = None,
                 dictionary_value: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_negate: Optional[pulumi.Input[_builtins.bool]] = None,
                 operator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition_type: Condition type.
                 - Choices: `ConditionAttributes`, `ConditionReference`
        :param pulumi.Input[_builtins.str] attribute_name: Dictionary attribute name
        :param pulumi.Input[_builtins.str] attribute_value: Attribute value for condition. Value type is specified in dictionary object.
        :param pulumi.Input[_builtins.str] dictionary_name: Dictionary name
        :param pulumi.Input[_builtins.str] dictionary_value: Dictionary value
        :param pulumi.Input[_builtins.str] id: UUID for condition
        :param pulumi.Input[_builtins.bool] is_negate: Indicates whereas this condition is in negate mode
        :param pulumi.Input[_builtins.str] operator: Equality operator
                 - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        pulumi.set(__self__, "condition_type", condition_type)
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if dictionary_name is not None:
            pulumi.set(__self__, "dictionary_name", dictionary_name)
        if dictionary_value is not None:
            pulumi.set(__self__, "dictionary_value", dictionary_value)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_negate is not None:
            pulumi.set(__self__, "is_negate", is_negate)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="conditionType")
    def condition_type(self) -> pulumi.Input[_builtins.str]:
        """
        Condition type.
          - Choices: `ConditionAttributes`, `ConditionReference`
        """
        return pulumi.get(self, "condition_type")

    @condition_type.setter
    def condition_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition_type", value)

    @_builtins.property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary attribute name
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Attribute value for condition. Value type is specified in dictionary object.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryName")
    def dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary name
        """
        return pulumi.get(self, "dictionary_name")

    @dictionary_name.setter
    def dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryValue")
    def dictionary_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Dictionary value
        """
        return pulumi.get(self, "dictionary_value")

    @dictionary_value.setter
    def dictionary_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID for condition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isNegate")
    def is_negate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whereas this condition is in negate mode
        """
        return pulumi.get(self, "is_negate")

    @is_negate.setter
    def is_negate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_negate", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Equality operator
          - Choices: `contains`, `endsWith`, `equals`, `greaterOrEquals`, `greaterThan`, `in`, `ipEquals`, `ipGreaterThan`, `ipLessThan`, `ipNotEquals`, `lessOrEquals`, `lessThan`, `matches`, `notContains`, `notEndsWith`, `notEquals`, `notIn`, `notStartsWith`, `startsWith`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class PolicySetUpdateRanksPolicyArgsDict(TypedDict):
        rank: pulumi.Input[_builtins.int]
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Policy set ID
        """
elif False:
    PolicySetUpdateRanksPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySetUpdateRanksPolicyArgs:
    def __init__(__self__, *,
                 rank: pulumi.Input[_builtins.int],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] rank: The rank (priority) in relation to other rules. Lower rank is higher priority.
        :param pulumi.Input[_builtins.str] id: Policy set ID
        """
        pulumi.set(__self__, "rank", rank)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def rank(self) -> pulumi.Input[_builtins.int]:
        """
        The rank (priority) in relation to other rules. Lower rank is higher priority.
        """
        return pulumi.get(self, "rank")

    @rank.setter
    def rank(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rank", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Policy set ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class TacacsCommandSetCommandArgsDict(TypedDict):
        arguments: pulumi.Input[_builtins.str]
        """
        Command arguments
        """
        command: pulumi.Input[_builtins.str]
        """
        Command
        """
        grant: pulumi.Input[_builtins.str]
        """
        Grant
          - Choices: `PERMIT`, `DENY`, `DENY_ALWAYS`
        """
elif False:
    TacacsCommandSetCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TacacsCommandSetCommandArgs:
    def __init__(__self__, *,
                 arguments: pulumi.Input[_builtins.str],
                 command: pulumi.Input[_builtins.str],
                 grant: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arguments: Command arguments
        :param pulumi.Input[_builtins.str] command: Command
        :param pulumi.Input[_builtins.str] grant: Grant
                 - Choices: `PERMIT`, `DENY`, `DENY_ALWAYS`
        """
        pulumi.set(__self__, "arguments", arguments)
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "grant", grant)

    @_builtins.property
    @pulumi.getter
    def arguments(self) -> pulumi.Input[_builtins.str]:
        """
        Command arguments
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arguments", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> pulumi.Input[_builtins.str]:
        """
        Command
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter
    def grant(self) -> pulumi.Input[_builtins.str]:
        """
        Grant
          - Choices: `PERMIT`, `DENY`, `DENY_ALWAYS`
        """
        return pulumi.get(self, "grant")

    @grant.setter
    def grant(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "grant", value)


if not MYPY:
    class TacacsProfileSessionAttributeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name
        """
        type: pulumi.Input[_builtins.str]
        """
        Type
          - Choices: `MANDATORY`, `OPTIONAL`
        """
        value: pulumi.Input[_builtins.str]
        """
        Value
        """
elif False:
    TacacsProfileSessionAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TacacsProfileSessionAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name
        :param pulumi.Input[_builtins.str] type: Type
                 - Choices: `MANDATORY`, `OPTIONAL`
        :param pulumi.Input[_builtins.str] value: Value
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type
          - Choices: `MANDATORY`, `OPTIONAL`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


