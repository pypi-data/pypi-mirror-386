# Next.js Data Fetching Patterns

Complete guide to data fetching in Next.js App Router.

---

## Server-Side Data Fetching

### Async Server Components

```typescript
// app/posts/page.tsx
async function getPosts() {
  const res = await fetch('https://api.example.com/posts', {
    next: { revalidate: 3600 } // Cache for 1 hour
  })

  if (!res.ok) throw new Error('Failed to fetch posts')
  return res.json()
}

export default async function PostsPage() {
  const posts = await getPosts()

  return (
    <ul>
      {posts.map((post: any) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```

---

## Caching Strategies

### Static Data (Default)
```typescript
// Cached indefinitely
fetch('https://api.example.com/data')
```

### Revalidated Data
```typescript
// Revalidate every 60 seconds
fetch('https://api.example.com/data', {
  next: { revalidate: 60 }
})
```

### Dynamic Data
```typescript
// Never cache
fetch('https://api.example.com/data', {
  cache: 'no-store'
})
```

### Tag-based Revalidation
```typescript
// Tag for on-demand revalidation
fetch('https://api.example.com/data', {
  next: { tags: ['posts'] }
})

// Revalidate in API route
import { revalidateTag } from 'next/cache'
revalidateTag('posts')
```

---

## Streaming and Suspense

**Progressive Rendering**:

```typescript
import { Suspense } from 'react'

async function SlowComponent() {
  await new Promise(resolve => setTimeout(resolve, 3000))
  return <div>Slow content loaded!</div>
}

export default function Page() {
  return (
    <div>
      <h1>Page loads immediately</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <SlowComponent />
      </Suspense>
    </div>
  )
}
```

---

## Client-Side Data Fetching

{{#if state_library}}
### With {{state_library}}

```typescript
'use client'

import { useQuery } from '{{state_library_import}}'

export function Posts() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['posts'],
    queryFn: () => fetch('/api/posts').then(res => res.json())
  })

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <ul>
      {data.map((post: any) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```
{{else}}
### With React Hooks

```typescript
'use client'

import { useState, useEffect } from 'react'

export function Posts() {
  const [posts, setPosts] = useState([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    fetch('/api/posts')
      .then(res => res.json())
      .then(data => {
        setPosts(data)
        setLoading(false)
      })
  }, [])

  if (loading) return <div>Loading...</div>

  return (
    <ul>
      {posts.map((post: any) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  )
}
```
{{/if}}

---

## Best Practices

- ✅ Prefer Server Components for data fetching
- ✅ Use appropriate caching strategies
- ✅ Implement loading states with Suspense
- ✅ Handle errors gracefully
- ❌ Don't waterfall requests (use Promise.all)
- ❌ Don't fetch on client if can be done on server

---

**Part of**: {{skill_name}}
**Generated by SkillForge**
