[
  {
    "name": "notebook-edit_plan",
    "description": "Updates the notebook plan by generating a new plan based on the immediate action and the current notebook summary. Returns the generated plan.\n\nArgs:\n    immediate_action: What you are about to do next - be specific about the immediate task.\n    notebook_path: Path to the notebook file. System-managed, should not be set by LLM.\n\nReturns:\n    str: The generated plan in markdown format.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "immediate_action": {
          "title": "Immediate Action",
          "type": "string"
        },
        "notebook_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Notebook Path"
        }
      },
      "required": [
        "immediate_action"
      ],
      "title": "edit_planArguments"
    }
  },
  {
    "name": "notebook-read_cells",
    "description": "Reads the specified cells (max 5) and returns content as JSON.\n\nArgs:\n    notebook_path: Path to the notebook file. System-managed, should not be set by LLM.\n    start_index: int 0-based start index for cell slice. Default 0.\n    end_index: int 0-based end index (inclusive) for cell slice. Default -1 (last cell).\n\nReturns:\n    str: JSON string representing the notebook slice (cells, metadata).\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "notebook_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Notebook Path"
        },
        "start_index": {
          "default": 0,
          "title": "Start Index",
          "type": "integer"
        },
        "end_index": {
          "default": -1,
          "title": "End Index",
          "type": "integer"
        }
      },
      "title": "read_cellsArguments"
    }
  },
  {
    "name": "notebook-add_cell",
    "description": "Adds a new cell (code or markdown) to the specified notebook at an optional position, returning its unique ID.\n\nArgs:\n    position: 0-based index for insertion (Appends if null), cell_type: Type of cell (\"code\" or \"markdown\").\n    source: Initial source content for the cell.\n    summary: A summary of the cell's content.\n    notebook_path: Path to the notebook file. System-managed, should not be set by LLM.\nReturns:\n    str: The unique ID of the newly created cell.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "position": {
          "anyOf": [
            {
              "type": "integer"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Position"
        },
        "cell_type": {
          "title": "Cell Type",
          "type": "string",
          "enum": [
            "code",
            "markdown"
          ],
          "description": "Type of cell to add. Must be either 'code' or 'markdown'. 'raw' is not supported."
        },
        "source": {
          "title": "Source",
          "type": "string"
        },
        "summary": {
          "title": "Summary",
          "type": "string"
        },
        "notebook_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Notebook Path"
        }
      },
      "required": [
        "cell_type",
        "source",
        "summary"
      ],
      "title": "add_cellArguments"
    }
  },
  {
    "name": "notebook-remove_cells",
    "description": "Removes a list of cells from the specified notebook using their IDs. Returns True if at least one cell was removed.\n\nArgs:\n    cell_ids: A list of unique identifiers of the cells to remove.\n    notebook_path: Path to the notebook file. System-managed, should not be set by LLM.\n\nReturns:\n    bool: True if at least one cell was found and removed, False otherwise.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "cell_ids": {
          "items": {
            "type": "string"
          },
          "title": "Cell Ids",
          "type": "array"
        },
        "notebook_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Notebook Path"
        }
      },
      "required": [
        "cell_ids"
      ],
      "title": "remove_cellsArguments"
    }
  },
  {
    "name": "notebook-edit_cell",
    "description": "Modifies the source content of an existing cell. Returns True on success.\n\nArgs:\n    cell_id: Unique identifier of the cell to edit.\n    new_source: New source content for the cell.\n    summary: A summary of the cell's new content.\n    notebook_path: Path to the notebook file. System-managed, should not be set by LLM.\n\nReturns:\n    bool: True if the cell was found and updated, False otherwise.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "cell_id": {
          "title": "Cell Id",
          "type": "string"
        },
        "new_source": {
          "title": "New Source",
          "type": "string"
        },
        "summary": {
          "title": "Summary",
          "type": "string"
        },
        "notebook_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Notebook Path"
        }
      },
      "required": [
        "cell_id",
        "new_source",
        "summary"
      ],
      "title": "edit_cellArguments"
    }
  },
  {
    "name": "notebook-run_cell",
    "description": "Runs a code cell in the specified notebook and returns its formatted output.\n\nArgs:\n    cell_id: Unique identifier of the code cell to execute.\n    notebook_path: Path to the notebook file. System-managed, should not be set by LLM.\n    kernel_id: Specific kernel ID to use (system-managed and should not be set by LLM).\n\nReturns:\n    List[str]: Formatted output strings from the cell's execution.\nRaises:\n    ValueError: If cell_id is invalid or not a code cell.\n    RuntimeError: If kernel or server communication fails.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "cell_id": {
          "title": "Cell Id",
          "type": "string"
        },
        "notebook_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Notebook Path"
        },
        "kernel_id": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Kernel Id"
        }
      },
      "required": [
        "cell_id"
      ],
      "title": "run_cellArguments"
    }
  },
  {
    "name": "notebook-wait_user_reply",
    "description": "Displays a UI component to inform the user that the agent has completed its turn and is now waiting for a user reply.\n\nThis tool should be called as the final action in an assistant's turn after providing a complete response or asking a question. It signals that the agent is done processing and is awaiting the user's next instruction or answer.\n\nThe `recommended_next_prompts` field can be used to suggest up to three possible follow-up responses the user might choose from. These should be **valid, reasonable, and contextually relevant** to the conversation at the time the tool is called. They are meant to guide the user toward likely next actions or replies without restricting them.\n\nWhen generating these suggestions:\n- Include at most **three** prompts.\n- Ensure **each prompt is distinctly different** â€” do not provide multiple variations of the same phrase.\n- Suggestions should be short, clear, and actionable.\n- At least one suggestion should be a generic progression option such as \"Continue\".\n- Other prompts should be tailored to the specific conversation or content just presented.\n\nExamples of valid `recommended_next_prompts` for different contexts:\n- After explaining a concept: [\"Continue\", \"Can you give an example?\", \"Explain it in simpler terms\"]\n- After showing data: [\"Continue\", \"Show me a chart of this data\", \"Compare with last month\"]\n\nArgs:\n    notebook_path: Path to the notebook file. System-managed, should not be set by LLM.\n    recommended_next_prompts: An optional list of up to three distinct, relevant suggestions for how the user might respond next.\n\nReturns:\n    bool: True if the waiting reply box was shown successfully, False otherwise.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "notebook_path": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "type": "null"
            }
          ],
          "default": null,
          "title": "Notebook Path"
        },
        "recommended_next_prompts": {
          "items": {
            "type": "string"
          },
          "title": "Queries",
          "default": null,
          "type": "array"
        }
      },
      "title": "wait_user_replyArguments"
    }
  },
  {
    "name": "filesystem-read_dataset",
    "description": "Read lines from a dataset in data dir (max 10 lines)\n\nArgs:\n    filepath (str): Path to the file to read\n    start (int): Starting line default 0\n    end (int): Ending line default 10\n\nReturns:\n    str: JSON object with file contents or error message\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "filepath": {
          "title": "Filepath",
          "type": "string"
        },
        "start": {
          "default": 0,
          "title": "Start",
          "type": "integer"
        },
        "end": {
          "default": 10,
          "title": "End",
          "type": "integer"
        }
      },
      "required": [
        "filepath"
      ],
      "title": "read_datasetArguments"
    }
  },
  {
    "name": "web-search_dataset",
    "description": "\nSearch for tickers matching the provided query strings.\nThe search is performed using a fuzzy matching algorithm, so precise queries will generally yield better results.\n\nArgs:\n    queries: (List[str]) List of search strings to match against ticker symbols or names.\n    limit: Maximum number of results to return (default: 5, max: 10)\n\nReturns:\n    A list of matching ticker dictionaries, aggregated from all queries.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "queries": {
          "items": {
            "type": "string"
          },
          "title": "Queries",
          "type": "array"
        },
        "limit": {
          "default": 10,
          "title": "Limit",
          "type": "integer"
        }
      },
      "required": [
        "queries",
        "database_names"
      ],
      "title": "search_datasetArguments"
    }
  },
  {
    "name": "database-search_tables",
    "description": "Search database tables using semantic queries. This tool searches through the active database configuration's schema to find the most relevant tables matching each query.\n\nArgs:\n    queries: List of search queries to find relevant tables (required)\n    database_names: Optional list of database names to limit the search scope (optional)\n\nReturns:\n    JSON string with the top 10 most relevant tables per query, including table names, schema names, column information, primary keys, and foreign keys.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "queries": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Queries",
          "description": "List of search queries to find relevant tables"
        },
        "database_names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Database Names",
          "description": "List of database names to limit the search scope"
        }
      },
      "required": [
        "queries",
        "database_names"
      ],
      "title": "search_tablesArguments"
    }
  },
  {
    "name": "database-schema_search",
    "description": "Run an indexed schema search using the backend SchemaSearch service for the selected PostgreSQL, MySQL, or Snowflake connection.\n\nArgs:\n    queries: List of search queries to evaluate (required)\n    database_names: List containing exactly one database configuration name to target (required)\n    limit: Maximum number of results to return per query (default: 5, max: 10)\n\nReturns:\n    JSON string containing the search results grouped by query as returned by SchemaSearch.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "queries": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Queries",
          "description": "List of search queries to locate relevant tables"
        },
        "database_names": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Database Names",
          "description": "Database configuration names to limit the search scope (exactly one)",
          "minItems": 1,
          "maxItems": 1
        },
        "limit": {
          "type": "integer",
          "title": "Result Limit"
        }
      },
      "required": [
        "queries"
      ],
      "title": "schema_searchArguments"
    }
  },
  {
    "name": "database-read_databases",
    "description": "Read data from specific database tables found via search. This tool executes SELECT queries on the specified table in the active database configuration.\n\nArgs:\n    table_name: Name of the table to read from (required)\n    schema_name: Schema name (optional, defaults to 'public')\n    limit: Maximum number of rows to return (default: 10)\n    columns: Specific columns to select (optional, defaults to all columns)\n    where_clause: Optional WHERE clause for filtering data\n\nReturns:\n    JSON string with query results including the executed query and data rows.\n",
    "input_schema": {
      "type": "object",
      "properties": {
        "table_name": {
          "type": "string",
          "title": "Table Name",
          "description": "Name of the table to read from"
        },
        "schema_name": {
          "type": "string",
          "title": "Schema Name",
          "default": "public",
          "description": "Schema name (optional, defaults to 'public')"
        },
        "limit": {
          "type": "integer",
          "default": 10,
          "title": "Limit",
          "description": "Maximum number of rows to return"
        },
        "columns": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Columns",
          "description": "Specific columns to select (optional, defaults to all columns)"
        },
        "where_clause": {
          "type": "string",
          "title": "Where Clause",
          "description": "Optional WHERE clause for filtering data"
        }
      },
      "required": [
        "table_name"
      ],
      "title": "read_databasesArguments"
    }
  }
]
