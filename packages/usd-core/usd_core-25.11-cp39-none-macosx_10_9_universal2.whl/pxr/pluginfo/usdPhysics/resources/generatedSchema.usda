#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class PhysicsScene "PhysicsScene" (
    customData = {
        string userDocBrief = "General physics simulation properties, required for simulation."
    }
)
{
    vector3f physics:gravityDirection = (0, 0, 0) (
        customData = {
            string userDocBrief = "Gravity direction vector in simulation world space."
        }
        displayName = "Gravity Direction"
    )
    float physics:gravityMagnitude = -inf (
        customData = {
            string userDocBrief = "Gravity acceleration magnitude in simulation world space."
        }
        displayName = "Gravity Magnitude"
    )
}

class "PhysicsRigidBodyAPI" (
    customData = {
        string userDocBrief = """Applies physics body attributes to any UsdGeomXformable prim and
    marks that prim to be driven by a simulation."""
    }
)
{
    vector3f physics:angularVelocity = (0, 0, 0) (
        customData = {
            string userDocBrief = "Angular velocity in the same space as the node's xform."
        }
        displayName = "Angular Velocity"
    )
    bool physics:kinematicEnabled = 0 (
        customData = {
            string userDocBrief = "Determines whether the body is kinematic or not."
        }
        displayName = "Kinematic Enabled"
    )
    bool physics:rigidBodyEnabled = 1 (
        customData = {
            string userDocBrief = "Determines if this PhysicsRigidBodyAPI is enabled."
        }
        displayName = "Rigid Body Enabled"
    )
    rel physics:simulationOwner (
        customData = {
            string userDocBrief = "Single PhysicsScene that will simulate this body."
        }
        displayName = "Simulation Owner"
    )
    uniform bool physics:startsAsleep = 0 (
        customData = {
            string userDocBrief = "Determines if the body is asleep when the simulation starts."
        }
        displayName = "Starts as Asleep"
    )
    vector3f physics:velocity = (0, 0, 0) (
        customData = {
            string userDocBrief = "Linear velocity in the same space as the node's xform."
        }
        displayName = "Linear Velocity"
    )
}

class "PhysicsMassAPI" (
    customData = {
        string userDocBrief = "Defines explicit mass properties (mass, density, inertia etc.)."
    }
)
{
    point3f physics:centerOfMass = (-inf, -inf, -inf) (
        customData = {
            string userDocBrief = "Center of mass in the prim's local space."
        }
        displayName = "Center of Mass"
    )
    float physics:density = 0 (
        customData = {
            string userDocBrief = "If non-zero, specifies the density of the object."
        }
        displayName = "Density"
    )
    float3 physics:diagonalInertia = (0, 0, 0) (
        customData = {
            string userDocBrief = """If non-zero, specifies diagonalized inertia tensor along the 
        principal axes."""
        }
        displayName = "Diagonal Inertia"
    )
    float physics:mass = 0 (
        customData = {
            string userDocBrief = "If non-zero, directly specifies the mass of the object."
        }
        displayName = "Mass"
    )
    quatf physics:principalAxes = (0, 0, 0, 0) (
        customData = {
            string userDocBrief = """Orientation of the inertia tensor's principal axes in the 
        prim's local space."""
        }
        displayName = "Principal Axes"
    )
}

class "PhysicsCollisionAPI" (
    customData = {
        string userDocBrief = "Applies collision attributes to a UsdGeomXformable prim."
    }
)
{
    bool physics:collisionEnabled = 1 (
        customData = {
            string userDocBrief = "Determines if the PhysicsCollisionAPI is enabled."
        }
        displayName = "Collision Enabled"
    )
    rel physics:simulationOwner (
        customData = {
            string userDocBrief = "Single PhysicsScene that will simulate this collider."
        }
        displayName = "Simulation Owner"
    )
}

class "PhysicsMeshCollisionAPI" (
    customData = {
        string userDocBrief = "Attributes to control how a Mesh is made into a collider."
    }
)
{
    uniform token physics:approximation = "none" (
        allowedTokens = ["none", "convexDecomposition", "convexHull", "boundingSphere", "boundingCube", "meshSimplification"]
        customData = {
            string userDocBrief = """Determines the mesh's collision approximation:
\t\"none\" - The mesh geometry is used directly as a collider without any 
    approximation."""
        }
        displayName = "Approximation"
    )
}

class "PhysicsMaterialAPI" (
    customData = {
        string userDocBrief = "Adds simulation material properties to a Material."
    }
)
{
    float physics:density = 0 (
        customData = {
            string userDocBrief = "If non-zero, defines the density of the material."
        }
        displayName = "Density"
    )
    float physics:dynamicFriction = 0 (
        customData = {
            string userDocBrief = "Dynamic friction coefficient."
        }
        displayName = "Dynamic Friction"
    )
    float physics:restitution = 0 (
        customData = {
            string userDocBrief = "Restitution coefficient."
        }
        displayName = "Restitution"
    )
    float physics:staticFriction = 0 (
        customData = {
            string userDocBrief = "Static friction coefficient."
        }
        displayName = "Static Friction"
    )
}

class PhysicsCollisionGroup "PhysicsCollisionGroup" (
    apiSchemas = ["CollectionAPI:colliders"]
    customData = {
        string userDocBrief = "Defines a collision group for coarse filtering."
    }
)
{
    rel physics:filteredGroups (
        customData = {
            string userDocBrief = """References a list of PhysicsCollisionGroups with which 
        collisions should be ignored."""
        }
        displayName = "Filtered Groups"
    )
    bool physics:invertFilteredGroups (
        customData = {
            string userDocBrief = """Normally, the filter will disable collisions against the selected
        filter groups."""
        }
        displayName = "Invert Filtered Groups"
    )
    string physics:mergeGroup (
        customData = {
            string userDocBrief = """If non-empty, any collision groups in a stage with a matching
        mergeGroup should be considered to refer to the same collection."""
        }
        displayName = "Merge With Groups"
    )
}

class "PhysicsFilteredPairsAPI" (
    customData = {
        string userDocBrief = "API to describe fine-grained filtering."
    }
)
{
    rel physics:filteredPairs (
        customData = {
            string userDocBrief = "Relationship to objects that should be filtered."
        }
        displayName = "Filtered Pairs"
    )
}

class PhysicsJoint "PhysicsJoint" (
    customData = {
        string userDocBrief = "A joint constrains the movement of rigid bodies."
    }
)
{
    rel physics:body0 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 0"
    )
    rel physics:body1 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 1"
    )
    float physics:breakForce = inf (
        customData = {
            string userDocBrief = "Joint break force."
        }
        displayName = "Break Force"
    )
    float physics:breakTorque = inf (
        customData = {
            string userDocBrief = "Joint break torque."
        }
        displayName = "Break Torque"
    )
    bool physics:collisionEnabled = 0 (
        customData = {
            string userDocBrief = "Determines if the jointed subtrees should collide or not."
        }
        displayName = "Collision Enabled"
    )
    uniform bool physics:excludeFromArticulation = 0 (
        customData = {
            string userDocBrief = "Determines if the joint can be included in an Articulation."
        }
        displayName = "Exclude From Articulation"
    )
    bool physics:jointEnabled = 1 (
        customData = {
            string userDocBrief = "Determines if the joint is enabled."
        }
        displayName = "Joint Enabled"
    )
    point3f physics:localPos0 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body0's frame."
        }
        displayName = "Local Position 0"
    )
    point3f physics:localPos1 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body1's frame."
        }
        displayName = "Local Position 1"
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body0's frame."
        }
        displayName = "Local Rotation 0"
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body1's frame."
        }
        displayName = "Local Rotation 1"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PhysicsRevoluteJoint "PhysicsRevoluteJoint" (
    customData = {
        string userDocBrief = """Predefined revolute joint type (rotation along revolute joint
    axis is permitted.)."""
    }
)
{
    uniform token physics:axis = "X" (
        allowedTokens = ["X", "Y", "Z"]
        customData = {
            string userDocBrief = "Joint axis."
        }
        displayName = "Axis"
    )
    rel physics:body0 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 0"
    )
    rel physics:body1 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 1"
    )
    float physics:breakForce = inf (
        customData = {
            string userDocBrief = "Joint break force."
        }
        displayName = "Break Force"
    )
    float physics:breakTorque = inf (
        customData = {
            string userDocBrief = "Joint break torque."
        }
        displayName = "Break Torque"
    )
    bool physics:collisionEnabled = 0 (
        customData = {
            string userDocBrief = "Determines if the jointed subtrees should collide or not."
        }
        displayName = "Collision Enabled"
    )
    uniform bool physics:excludeFromArticulation = 0 (
        customData = {
            string userDocBrief = "Determines if the joint can be included in an Articulation."
        }
        displayName = "Exclude From Articulation"
    )
    bool physics:jointEnabled = 1 (
        customData = {
            string userDocBrief = "Determines if the joint is enabled."
        }
        displayName = "Joint Enabled"
    )
    point3f physics:localPos0 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body0's frame."
        }
        displayName = "Local Position 0"
    )
    point3f physics:localPos1 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body1's frame."
        }
        displayName = "Local Position 1"
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body0's frame."
        }
        displayName = "Local Rotation 0"
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body1's frame."
        }
        displayName = "Local Rotation 1"
    )
    float physics:lowerLimit = -inf (
        customData = {
            string userDocBrief = "Lower limit."
        }
        displayName = "Lower Limit"
    )
    float physics:upperLimit = inf (
        customData = {
            string userDocBrief = "Upper limit."
        }
        displayName = "Upper Limit"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PhysicsPrismaticJoint "PhysicsPrismaticJoint" (
    customData = {
        string userDocBrief = """Predefined prismatic joint type (translation along prismatic 
    joint axis is permitted.)."""
    }
)
{
    uniform token physics:axis = "X" (
        allowedTokens = ["X", "Y", "Z"]
        customData = {
            string userDocBrief = "Joint axis."
        }
        displayName = "Axis"
    )
    rel physics:body0 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 0"
    )
    rel physics:body1 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 1"
    )
    float physics:breakForce = inf (
        customData = {
            string userDocBrief = "Joint break force."
        }
        displayName = "Break Force"
    )
    float physics:breakTorque = inf (
        customData = {
            string userDocBrief = "Joint break torque."
        }
        displayName = "Break Torque"
    )
    bool physics:collisionEnabled = 0 (
        customData = {
            string userDocBrief = "Determines if the jointed subtrees should collide or not."
        }
        displayName = "Collision Enabled"
    )
    uniform bool physics:excludeFromArticulation = 0 (
        customData = {
            string userDocBrief = "Determines if the joint can be included in an Articulation."
        }
        displayName = "Exclude From Articulation"
    )
    bool physics:jointEnabled = 1 (
        customData = {
            string userDocBrief = "Determines if the joint is enabled."
        }
        displayName = "Joint Enabled"
    )
    point3f physics:localPos0 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body0's frame."
        }
        displayName = "Local Position 0"
    )
    point3f physics:localPos1 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body1's frame."
        }
        displayName = "Local Position 1"
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body0's frame."
        }
        displayName = "Local Rotation 0"
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body1's frame."
        }
        displayName = "Local Rotation 1"
    )
    float physics:lowerLimit = -inf (
        customData = {
            string userDocBrief = "Lower limit."
        }
        displayName = "Lower Limit"
    )
    float physics:upperLimit = inf (
        customData = {
            string userDocBrief = "Upper limit."
        }
        displayName = "Upper Limit"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PhysicsSphericalJoint "PhysicsSphericalJoint" (
    customData = {
        string userDocBrief = """Predefined spherical joint type (Removes linear degrees of 
    freedom, cone limit may restrict the motion in a given range.) It allows
    two limit values, which when equal create a circular, else an elliptic 
    cone limit around the limit axis."""
    }
)
{
    uniform token physics:axis = "X" (
        allowedTokens = ["X", "Y", "Z"]
        customData = {
            string userDocBrief = "Cone limit axis."
        }
        displayName = "Axis"
    )
    rel physics:body0 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 0"
    )
    rel physics:body1 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 1"
    )
    float physics:breakForce = inf (
        customData = {
            string userDocBrief = "Joint break force."
        }
        displayName = "Break Force"
    )
    float physics:breakTorque = inf (
        customData = {
            string userDocBrief = "Joint break torque."
        }
        displayName = "Break Torque"
    )
    bool physics:collisionEnabled = 0 (
        customData = {
            string userDocBrief = "Determines if the jointed subtrees should collide or not."
        }
        displayName = "Collision Enabled"
    )
    float physics:coneAngle0Limit = -1 (
        customData = {
            string userDocBrief = """Cone limit from the primary joint axis in the local0 frame 
        toward the next axis."""
        }
        displayName = "Cone Angle0 Limit"
    )
    float physics:coneAngle1Limit = -1 (
        customData = {
            string userDocBrief = """Cone limit from the primary joint axis in the local0 frame 
        toward the second to next axis."""
        }
        displayName = "Cone Angle1 Limit"
    )
    uniform bool physics:excludeFromArticulation = 0 (
        customData = {
            string userDocBrief = "Determines if the joint can be included in an Articulation."
        }
        displayName = "Exclude From Articulation"
    )
    bool physics:jointEnabled = 1 (
        customData = {
            string userDocBrief = "Determines if the joint is enabled."
        }
        displayName = "Joint Enabled"
    )
    point3f physics:localPos0 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body0's frame."
        }
        displayName = "Local Position 0"
    )
    point3f physics:localPos1 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body1's frame."
        }
        displayName = "Local Position 1"
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body0's frame."
        }
        displayName = "Local Rotation 0"
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body1's frame."
        }
        displayName = "Local Rotation 1"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PhysicsDistanceJoint "PhysicsDistanceJoint" (
    customData = {
        string userDocBrief = """Predefined distance joint type (Distance between rigid bodies
    may be limited to given minimum or maximum distance.)."""
    }
)
{
    rel physics:body0 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 0"
    )
    rel physics:body1 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 1"
    )
    float physics:breakForce = inf (
        customData = {
            string userDocBrief = "Joint break force."
        }
        displayName = "Break Force"
    )
    float physics:breakTorque = inf (
        customData = {
            string userDocBrief = "Joint break torque."
        }
        displayName = "Break Torque"
    )
    bool physics:collisionEnabled = 0 (
        customData = {
            string userDocBrief = "Determines if the jointed subtrees should collide or not."
        }
        displayName = "Collision Enabled"
    )
    uniform bool physics:excludeFromArticulation = 0 (
        customData = {
            string userDocBrief = "Determines if the joint can be included in an Articulation."
        }
        displayName = "Exclude From Articulation"
    )
    bool physics:jointEnabled = 1 (
        customData = {
            string userDocBrief = "Determines if the joint is enabled."
        }
        displayName = "Joint Enabled"
    )
    point3f physics:localPos0 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body0's frame."
        }
        displayName = "Local Position 0"
    )
    point3f physics:localPos1 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body1's frame."
        }
        displayName = "Local Position 1"
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body0's frame."
        }
        displayName = "Local Rotation 0"
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body1's frame."
        }
        displayName = "Local Rotation 1"
    )
    float physics:maxDistance = -1 (
        customData = {
            string userDocBrief = "Maximum distance."
        }
        displayName = "Maximum Distance"
    )
    float physics:minDistance = -1 (
        customData = {
            string userDocBrief = "Minimum distance."
        }
        displayName = "Minimum Distance"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class PhysicsFixedJoint "PhysicsFixedJoint" (
    customData = {
        string userDocBrief = """Predefined fixed joint type (All degrees of freedom are 
    removed.)."""
    }
)
{
    rel physics:body0 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 0"
    )
    rel physics:body1 (
        customData = {
            string userDocBrief = "Relationship to any UsdGeomXformable."
        }
        displayName = "Body 1"
    )
    float physics:breakForce = inf (
        customData = {
            string userDocBrief = "Joint break force."
        }
        displayName = "Break Force"
    )
    float physics:breakTorque = inf (
        customData = {
            string userDocBrief = "Joint break torque."
        }
        displayName = "Break Torque"
    )
    bool physics:collisionEnabled = 0 (
        customData = {
            string userDocBrief = "Determines if the jointed subtrees should collide or not."
        }
        displayName = "Collision Enabled"
    )
    uniform bool physics:excludeFromArticulation = 0 (
        customData = {
            string userDocBrief = "Determines if the joint can be included in an Articulation."
        }
        displayName = "Exclude From Articulation"
    )
    bool physics:jointEnabled = 1 (
        customData = {
            string userDocBrief = "Determines if the joint is enabled."
        }
        displayName = "Joint Enabled"
    )
    point3f physics:localPos0 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body0's frame."
        }
        displayName = "Local Position 0"
    )
    point3f physics:localPos1 = (0, 0, 0) (
        customData = {
            string userDocBrief = "Relative position of the joint frame to body1's frame."
        }
        displayName = "Local Position 1"
    )
    quatf physics:localRot0 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body0's frame."
        }
        displayName = "Local Rotation 0"
    )
    quatf physics:localRot1 = (1, 0, 0, 0) (
        customData = {
            string userDocBrief = "Relative orientation of the joint frame to body1's frame."
        }
        displayName = "Local Rotation 1"
    )
    rel proxyPrim (
        customData = {
            string userDocBrief = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.'''
        }
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        customData = {
            string userDocBrief = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals."""
        }
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        customData = {
            string userDocBrief = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.'''
        }
    )
}

class "PhysicsLimitAPI" (
    customData = {
        string userDocBrief = """The PhysicsLimitAPI can be applied to a PhysicsJoint and will
    restrict the movement along an axis."""
    }
)
{
    float limit:__INSTANCE_NAME__:physics:high = inf (
        displayName = "High Limit"
    )
    float limit:__INSTANCE_NAME__:physics:low = -inf (
        displayName = "Low Limit"
    )
}

class "PhysicsDriveAPI" (
    customData = {
        string userDocBrief = """The PhysicsDriveAPI when applied to any joint primitive will drive
    the joint towards a given target."""
    }
)
{
    float drive:__INSTANCE_NAME__:physics:damping = 0
    float drive:__INSTANCE_NAME__:physics:maxForce = inf (
        displayName = "Max Force"
    )
    float drive:__INSTANCE_NAME__:physics:stiffness = 0
    float drive:__INSTANCE_NAME__:physics:targetPosition = 0 (
        displayName = "Target Position"
    )
    float drive:__INSTANCE_NAME__:physics:targetVelocity = 0 (
        displayName = "Target Velocity"
    )
    uniform token drive:__INSTANCE_NAME__:physics:type = "force" (
        allowedTokens = ["force", "acceleration"]
        displayName = "Type"
    )
}

class "PhysicsArticulationRootAPI" (
    customData = {
        string userDocBrief = """PhysicsArticulationRootAPI can be applied to a scene graph node, 
    and marks the subtree rooted here for inclusion in one or more reduced 
    coordinate articulations."""
    }
)
{
}

