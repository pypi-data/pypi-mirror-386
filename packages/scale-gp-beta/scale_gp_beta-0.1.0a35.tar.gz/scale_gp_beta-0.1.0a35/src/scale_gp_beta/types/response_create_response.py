# File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import builtins
from typing import TYPE_CHECKING, Dict, List, Union, Optional
from typing_extensions import Literal, TypeAlias

from pydantic import Field as FieldInfo

from .._models import BaseModel
from .response import Response

__all__ = [
    "ResponseCreateResponse",
    "ResponseAudioDeltaEvent",
    "ResponseAudioDoneEvent",
    "ResponseAudioTranscriptDeltaEvent",
    "ResponseAudioTranscriptDoneEvent",
    "ResponseCodeInterpreterCallCodeDeltaEvent",
    "ResponseCodeInterpreterCallCodeDoneEvent",
    "ResponseCodeInterpreterCallCompletedEvent",
    "ResponseCodeInterpreterCallInProgressEvent",
    "ResponseCodeInterpreterCallInterpretingEvent",
    "ResponseCompletedEvent",
    "ResponseCompletedEventResponse",
    "ResponseCompletedEventResponseOutput",
    "ResponseCompletedEventResponseOutputResponseOutputMessage",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContent",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputText",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal",
    "ResponseCompletedEventResponseOutputResponseFileSearchToolCall",
    "ResponseCompletedEventResponseOutputResponseFileSearchToolCallResult",
    "ResponseCompletedEventResponseOutputResponseFunctionToolCall",
    "ResponseCompletedEventResponseOutputResponseFunctionWebSearch",
    "ResponseCompletedEventResponseOutputResponseFunctionWebSearchAction",
    "ResponseCompletedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseCompletedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseCompletedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseCompletedEventResponseOutputResponseComputerToolCall",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallAction",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseCompletedEventResponseOutputResponseComputerToolCallPendingSafetyCheck",
    "ResponseCompletedEventResponseOutputResponseReasoningItem",
    "ResponseCompletedEventResponseOutputResponseReasoningItemSummary",
    "ResponseCompletedEventResponseOutputResponseReasoningItemContent",
    "ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall",
    "ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCall",
    "ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCallOutput",
    "ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall",
    "ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction",
    "ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall",
    "ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools",
    "ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool",
    "ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest",
    "ResponseCompletedEventResponseOutputResponseCustomToolCall",
    "ResponseCompletedEventResponseToolChoice",
    "ResponseCompletedEventResponseToolChoiceToolChoiceAllowed",
    "ResponseCompletedEventResponseToolChoiceToolChoiceTypes",
    "ResponseCompletedEventResponseToolChoiceToolChoiceFunction",
    "ResponseCompletedEventResponseToolChoiceToolChoiceMcp",
    "ResponseCompletedEventResponseToolChoiceToolChoiceCustom",
    "ResponseCompletedEventResponseTool",
    "ResponseCompletedEventResponseToolFunctionTool",
    "ResponseCompletedEventResponseToolFileSearchTool",
    "ResponseCompletedEventResponseToolFileSearchToolFilters",
    "ResponseCompletedEventResponseToolFileSearchToolFiltersComparisonFilter",
    "ResponseCompletedEventResponseToolFileSearchToolFiltersCompoundFilter",
    "ResponseCompletedEventResponseToolFileSearchToolFiltersCompoundFilterFilter",
    "ResponseCompletedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter",
    "ResponseCompletedEventResponseToolFileSearchToolRankingOptions",
    "ResponseCompletedEventResponseToolWebSearchTool",
    "ResponseCompletedEventResponseToolWebSearchToolUserLocation",
    "ResponseCompletedEventResponseToolComputerTool",
    "ResponseCompletedEventResponseToolMcp",
    "ResponseCompletedEventResponseToolMcpAllowedTools",
    "ResponseCompletedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter",
    "ResponseCompletedEventResponseToolMcpRequireApproval",
    "ResponseCompletedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter",
    "ResponseCompletedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways",
    "ResponseCompletedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever",
    "ResponseCompletedEventResponseToolCodeInterpreter",
    "ResponseCompletedEventResponseToolCodeInterpreterContainer",
    "ResponseCompletedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto",
    "ResponseCompletedEventResponseToolImageGeneration",
    "ResponseCompletedEventResponseToolImageGenerationInputImageMask",
    "ResponseCompletedEventResponseToolLocalShell",
    "ResponseCompletedEventResponseToolCustomTool",
    "ResponseCompletedEventResponseToolCustomToolFormat",
    "ResponseCompletedEventResponseToolCustomToolFormatText",
    "ResponseCompletedEventResponseToolCustomToolFormatGrammar",
    "ResponseCompletedEventResponseError",
    "ResponseCompletedEventResponseIncompleteDetails",
    "ResponseCompletedEventResponseInstructionsUnionMember1",
    "ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessage",
    "ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1",
    "ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText",
    "ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage",
    "ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessage",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContent",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCall",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionToolCall",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseReasoningItem",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseReasoningItemContent",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput",
    "ResponseCompletedEventResponseInstructionsUnionMember1ResponseCustomToolCall",
    "ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference",
    "ResponseCompletedEventResponsePrompt",
    "ResponseCompletedEventResponsePromptVariables",
    "ResponseCompletedEventResponsePromptVariablesResponseInputText",
    "ResponseCompletedEventResponsePromptVariablesResponseInputImage",
    "ResponseCompletedEventResponsePromptVariablesResponseInputFile",
    "ResponseCompletedEventResponseReasoning",
    "ResponseCompletedEventResponseText",
    "ResponseCompletedEventResponseTextFormat",
    "ResponseCompletedEventResponseTextFormatResponseFormatText",
    "ResponseCompletedEventResponseTextFormatResponseFormatTextJsonSchemaConfig",
    "ResponseCompletedEventResponseTextFormatResponseFormatJsonObject",
    "ResponseCompletedEventResponseUsage",
    "ResponseCompletedEventResponseUsageInputTokensDetails",
    "ResponseCompletedEventResponseUsageOutputTokensDetails",
    "ResponseContentPartAddedEvent",
    "ResponseContentPartAddedEventPart",
    "ResponseContentPartAddedEventPartResponseOutputText",
    "ResponseContentPartAddedEventPartResponseOutputTextAnnotation",
    "ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseContentPartAddedEventPartResponseOutputTextLogprob",
    "ResponseContentPartAddedEventPartResponseOutputTextLogprobTopLogprob",
    "ResponseContentPartAddedEventPartResponseOutputRefusal",
    "ResponseContentPartDoneEvent",
    "ResponseContentPartDoneEventPart",
    "ResponseContentPartDoneEventPartResponseOutputText",
    "ResponseContentPartDoneEventPartResponseOutputTextAnnotation",
    "ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseContentPartDoneEventPartResponseOutputTextLogprob",
    "ResponseContentPartDoneEventPartResponseOutputTextLogprobTopLogprob",
    "ResponseContentPartDoneEventPartResponseOutputRefusal",
    "ResponseCreatedEvent",
    "ResponseCreatedEventResponse",
    "ResponseCreatedEventResponseOutput",
    "ResponseCreatedEventResponseOutputResponseOutputMessage",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContent",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputText",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal",
    "ResponseCreatedEventResponseOutputResponseFileSearchToolCall",
    "ResponseCreatedEventResponseOutputResponseFileSearchToolCallResult",
    "ResponseCreatedEventResponseOutputResponseFunctionToolCall",
    "ResponseCreatedEventResponseOutputResponseFunctionWebSearch",
    "ResponseCreatedEventResponseOutputResponseFunctionWebSearchAction",
    "ResponseCreatedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseCreatedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseCreatedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseCreatedEventResponseOutputResponseComputerToolCall",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallAction",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseCreatedEventResponseOutputResponseComputerToolCallPendingSafetyCheck",
    "ResponseCreatedEventResponseOutputResponseReasoningItem",
    "ResponseCreatedEventResponseOutputResponseReasoningItemSummary",
    "ResponseCreatedEventResponseOutputResponseReasoningItemContent",
    "ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall",
    "ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCall",
    "ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCallOutput",
    "ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall",
    "ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction",
    "ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall",
    "ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools",
    "ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool",
    "ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest",
    "ResponseCreatedEventResponseOutputResponseCustomToolCall",
    "ResponseCreatedEventResponseToolChoice",
    "ResponseCreatedEventResponseToolChoiceToolChoiceAllowed",
    "ResponseCreatedEventResponseToolChoiceToolChoiceTypes",
    "ResponseCreatedEventResponseToolChoiceToolChoiceFunction",
    "ResponseCreatedEventResponseToolChoiceToolChoiceMcp",
    "ResponseCreatedEventResponseToolChoiceToolChoiceCustom",
    "ResponseCreatedEventResponseTool",
    "ResponseCreatedEventResponseToolFunctionTool",
    "ResponseCreatedEventResponseToolFileSearchTool",
    "ResponseCreatedEventResponseToolFileSearchToolFilters",
    "ResponseCreatedEventResponseToolFileSearchToolFiltersComparisonFilter",
    "ResponseCreatedEventResponseToolFileSearchToolFiltersCompoundFilter",
    "ResponseCreatedEventResponseToolFileSearchToolFiltersCompoundFilterFilter",
    "ResponseCreatedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter",
    "ResponseCreatedEventResponseToolFileSearchToolRankingOptions",
    "ResponseCreatedEventResponseToolWebSearchTool",
    "ResponseCreatedEventResponseToolWebSearchToolUserLocation",
    "ResponseCreatedEventResponseToolComputerTool",
    "ResponseCreatedEventResponseToolMcp",
    "ResponseCreatedEventResponseToolMcpAllowedTools",
    "ResponseCreatedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter",
    "ResponseCreatedEventResponseToolMcpRequireApproval",
    "ResponseCreatedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter",
    "ResponseCreatedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways",
    "ResponseCreatedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever",
    "ResponseCreatedEventResponseToolCodeInterpreter",
    "ResponseCreatedEventResponseToolCodeInterpreterContainer",
    "ResponseCreatedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto",
    "ResponseCreatedEventResponseToolImageGeneration",
    "ResponseCreatedEventResponseToolImageGenerationInputImageMask",
    "ResponseCreatedEventResponseToolLocalShell",
    "ResponseCreatedEventResponseToolCustomTool",
    "ResponseCreatedEventResponseToolCustomToolFormat",
    "ResponseCreatedEventResponseToolCustomToolFormatText",
    "ResponseCreatedEventResponseToolCustomToolFormatGrammar",
    "ResponseCreatedEventResponseError",
    "ResponseCreatedEventResponseIncompleteDetails",
    "ResponseCreatedEventResponseInstructionsUnionMember1",
    "ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessage",
    "ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1",
    "ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText",
    "ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage",
    "ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessage",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContent",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCall",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionToolCall",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseReasoningItem",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseReasoningItemContent",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput",
    "ResponseCreatedEventResponseInstructionsUnionMember1ResponseCustomToolCall",
    "ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference",
    "ResponseCreatedEventResponsePrompt",
    "ResponseCreatedEventResponsePromptVariables",
    "ResponseCreatedEventResponsePromptVariablesResponseInputText",
    "ResponseCreatedEventResponsePromptVariablesResponseInputImage",
    "ResponseCreatedEventResponsePromptVariablesResponseInputFile",
    "ResponseCreatedEventResponseReasoning",
    "ResponseCreatedEventResponseText",
    "ResponseCreatedEventResponseTextFormat",
    "ResponseCreatedEventResponseTextFormatResponseFormatText",
    "ResponseCreatedEventResponseTextFormatResponseFormatTextJsonSchemaConfig",
    "ResponseCreatedEventResponseTextFormatResponseFormatJsonObject",
    "ResponseCreatedEventResponseUsage",
    "ResponseCreatedEventResponseUsageInputTokensDetails",
    "ResponseCreatedEventResponseUsageOutputTokensDetails",
    "ResponseErrorEvent",
    "ResponseFileSearchCallCompletedEvent",
    "ResponseFileSearchCallInProgressEvent",
    "ResponseFileSearchCallSearchingEvent",
    "ResponseFunctionCallArgumentsDeltaEvent",
    "ResponseFunctionCallArgumentsDoneEvent",
    "ResponseInProgressEvent",
    "ResponseInProgressEventResponse",
    "ResponseInProgressEventResponseOutput",
    "ResponseInProgressEventResponseOutputResponseOutputMessage",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContent",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputText",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputRefusal",
    "ResponseInProgressEventResponseOutputResponseFileSearchToolCall",
    "ResponseInProgressEventResponseOutputResponseFileSearchToolCallResult",
    "ResponseInProgressEventResponseOutputResponseFunctionToolCall",
    "ResponseInProgressEventResponseOutputResponseFunctionWebSearch",
    "ResponseInProgressEventResponseOutputResponseFunctionWebSearchAction",
    "ResponseInProgressEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseInProgressEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseInProgressEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseInProgressEventResponseOutputResponseComputerToolCall",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallAction",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseInProgressEventResponseOutputResponseComputerToolCallPendingSafetyCheck",
    "ResponseInProgressEventResponseOutputResponseReasoningItem",
    "ResponseInProgressEventResponseOutputResponseReasoningItemSummary",
    "ResponseInProgressEventResponseOutputResponseReasoningItemContent",
    "ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall",
    "ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCall",
    "ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCallOutput",
    "ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall",
    "ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction",
    "ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall",
    "ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools",
    "ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool",
    "ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest",
    "ResponseInProgressEventResponseOutputResponseCustomToolCall",
    "ResponseInProgressEventResponseToolChoice",
    "ResponseInProgressEventResponseToolChoiceToolChoiceAllowed",
    "ResponseInProgressEventResponseToolChoiceToolChoiceTypes",
    "ResponseInProgressEventResponseToolChoiceToolChoiceFunction",
    "ResponseInProgressEventResponseToolChoiceToolChoiceMcp",
    "ResponseInProgressEventResponseToolChoiceToolChoiceCustom",
    "ResponseInProgressEventResponseTool",
    "ResponseInProgressEventResponseToolFunctionTool",
    "ResponseInProgressEventResponseToolFileSearchTool",
    "ResponseInProgressEventResponseToolFileSearchToolFilters",
    "ResponseInProgressEventResponseToolFileSearchToolFiltersComparisonFilter",
    "ResponseInProgressEventResponseToolFileSearchToolFiltersCompoundFilter",
    "ResponseInProgressEventResponseToolFileSearchToolFiltersCompoundFilterFilter",
    "ResponseInProgressEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter",
    "ResponseInProgressEventResponseToolFileSearchToolRankingOptions",
    "ResponseInProgressEventResponseToolWebSearchTool",
    "ResponseInProgressEventResponseToolWebSearchToolUserLocation",
    "ResponseInProgressEventResponseToolComputerTool",
    "ResponseInProgressEventResponseToolMcp",
    "ResponseInProgressEventResponseToolMcpAllowedTools",
    "ResponseInProgressEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter",
    "ResponseInProgressEventResponseToolMcpRequireApproval",
    "ResponseInProgressEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter",
    "ResponseInProgressEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways",
    "ResponseInProgressEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever",
    "ResponseInProgressEventResponseToolCodeInterpreter",
    "ResponseInProgressEventResponseToolCodeInterpreterContainer",
    "ResponseInProgressEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto",
    "ResponseInProgressEventResponseToolImageGeneration",
    "ResponseInProgressEventResponseToolImageGenerationInputImageMask",
    "ResponseInProgressEventResponseToolLocalShell",
    "ResponseInProgressEventResponseToolCustomTool",
    "ResponseInProgressEventResponseToolCustomToolFormat",
    "ResponseInProgressEventResponseToolCustomToolFormatText",
    "ResponseInProgressEventResponseToolCustomToolFormatGrammar",
    "ResponseInProgressEventResponseError",
    "ResponseInProgressEventResponseIncompleteDetails",
    "ResponseInProgressEventResponseInstructionsUnionMember1",
    "ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessage",
    "ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1",
    "ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText",
    "ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage",
    "ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessage",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContent",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseFileSearchToolCall",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCall",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallAction",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearch",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionToolCall",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseReasoningItem",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseReasoningItemSummary",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseReasoningItemContent",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput",
    "ResponseInProgressEventResponseInstructionsUnionMember1ResponseCustomToolCall",
    "ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference",
    "ResponseInProgressEventResponsePrompt",
    "ResponseInProgressEventResponsePromptVariables",
    "ResponseInProgressEventResponsePromptVariablesResponseInputText",
    "ResponseInProgressEventResponsePromptVariablesResponseInputImage",
    "ResponseInProgressEventResponsePromptVariablesResponseInputFile",
    "ResponseInProgressEventResponseReasoning",
    "ResponseInProgressEventResponseText",
    "ResponseInProgressEventResponseTextFormat",
    "ResponseInProgressEventResponseTextFormatResponseFormatText",
    "ResponseInProgressEventResponseTextFormatResponseFormatTextJsonSchemaConfig",
    "ResponseInProgressEventResponseTextFormatResponseFormatJsonObject",
    "ResponseInProgressEventResponseUsage",
    "ResponseInProgressEventResponseUsageInputTokensDetails",
    "ResponseInProgressEventResponseUsageOutputTokensDetails",
    "ResponseFailedEvent",
    "ResponseFailedEventResponse",
    "ResponseFailedEventResponseOutput",
    "ResponseFailedEventResponseOutputResponseOutputMessage",
    "ResponseFailedEventResponseOutputResponseOutputMessageContent",
    "ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputText",
    "ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal",
    "ResponseFailedEventResponseOutputResponseFileSearchToolCall",
    "ResponseFailedEventResponseOutputResponseFileSearchToolCallResult",
    "ResponseFailedEventResponseOutputResponseFunctionToolCall",
    "ResponseFailedEventResponseOutputResponseFunctionWebSearch",
    "ResponseFailedEventResponseOutputResponseFunctionWebSearchAction",
    "ResponseFailedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseFailedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseFailedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseFailedEventResponseOutputResponseComputerToolCall",
    "ResponseFailedEventResponseOutputResponseComputerToolCallAction",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseFailedEventResponseOutputResponseComputerToolCallPendingSafetyCheck",
    "ResponseFailedEventResponseOutputResponseReasoningItem",
    "ResponseFailedEventResponseOutputResponseReasoningItemSummary",
    "ResponseFailedEventResponseOutputResponseReasoningItemContent",
    "ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall",
    "ResponseFailedEventResponseOutputResponseCodeInterpreterToolCall",
    "ResponseFailedEventResponseOutputResponseCodeInterpreterToolCallOutput",
    "ResponseFailedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseFailedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall",
    "ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction",
    "ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall",
    "ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools",
    "ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool",
    "ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest",
    "ResponseFailedEventResponseOutputResponseCustomToolCall",
    "ResponseFailedEventResponseToolChoice",
    "ResponseFailedEventResponseToolChoiceToolChoiceAllowed",
    "ResponseFailedEventResponseToolChoiceToolChoiceTypes",
    "ResponseFailedEventResponseToolChoiceToolChoiceFunction",
    "ResponseFailedEventResponseToolChoiceToolChoiceMcp",
    "ResponseFailedEventResponseToolChoiceToolChoiceCustom",
    "ResponseFailedEventResponseTool",
    "ResponseFailedEventResponseToolFunctionTool",
    "ResponseFailedEventResponseToolFileSearchTool",
    "ResponseFailedEventResponseToolFileSearchToolFilters",
    "ResponseFailedEventResponseToolFileSearchToolFiltersComparisonFilter",
    "ResponseFailedEventResponseToolFileSearchToolFiltersCompoundFilter",
    "ResponseFailedEventResponseToolFileSearchToolFiltersCompoundFilterFilter",
    "ResponseFailedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter",
    "ResponseFailedEventResponseToolFileSearchToolRankingOptions",
    "ResponseFailedEventResponseToolWebSearchTool",
    "ResponseFailedEventResponseToolWebSearchToolUserLocation",
    "ResponseFailedEventResponseToolComputerTool",
    "ResponseFailedEventResponseToolMcp",
    "ResponseFailedEventResponseToolMcpAllowedTools",
    "ResponseFailedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter",
    "ResponseFailedEventResponseToolMcpRequireApproval",
    "ResponseFailedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter",
    "ResponseFailedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways",
    "ResponseFailedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever",
    "ResponseFailedEventResponseToolCodeInterpreter",
    "ResponseFailedEventResponseToolCodeInterpreterContainer",
    "ResponseFailedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto",
    "ResponseFailedEventResponseToolImageGeneration",
    "ResponseFailedEventResponseToolImageGenerationInputImageMask",
    "ResponseFailedEventResponseToolLocalShell",
    "ResponseFailedEventResponseToolCustomTool",
    "ResponseFailedEventResponseToolCustomToolFormat",
    "ResponseFailedEventResponseToolCustomToolFormatText",
    "ResponseFailedEventResponseToolCustomToolFormatGrammar",
    "ResponseFailedEventResponseError",
    "ResponseFailedEventResponseIncompleteDetails",
    "ResponseFailedEventResponseInstructionsUnionMember1",
    "ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessage",
    "ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1",
    "ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText",
    "ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage",
    "ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessage",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContent",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCall",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionToolCall",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseReasoningItem",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseReasoningItemContent",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput",
    "ResponseFailedEventResponseInstructionsUnionMember1ResponseCustomToolCall",
    "ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference",
    "ResponseFailedEventResponsePrompt",
    "ResponseFailedEventResponsePromptVariables",
    "ResponseFailedEventResponsePromptVariablesResponseInputText",
    "ResponseFailedEventResponsePromptVariablesResponseInputImage",
    "ResponseFailedEventResponsePromptVariablesResponseInputFile",
    "ResponseFailedEventResponseReasoning",
    "ResponseFailedEventResponseText",
    "ResponseFailedEventResponseTextFormat",
    "ResponseFailedEventResponseTextFormatResponseFormatText",
    "ResponseFailedEventResponseTextFormatResponseFormatTextJsonSchemaConfig",
    "ResponseFailedEventResponseTextFormatResponseFormatJsonObject",
    "ResponseFailedEventResponseUsage",
    "ResponseFailedEventResponseUsageInputTokensDetails",
    "ResponseFailedEventResponseUsageOutputTokensDetails",
    "ResponseIncompleteEvent",
    "ResponseIncompleteEventResponse",
    "ResponseIncompleteEventResponseOutput",
    "ResponseIncompleteEventResponseOutputResponseOutputMessage",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContent",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputText",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputRefusal",
    "ResponseIncompleteEventResponseOutputResponseFileSearchToolCall",
    "ResponseIncompleteEventResponseOutputResponseFileSearchToolCallResult",
    "ResponseIncompleteEventResponseOutputResponseFunctionToolCall",
    "ResponseIncompleteEventResponseOutputResponseFunctionWebSearch",
    "ResponseIncompleteEventResponseOutputResponseFunctionWebSearchAction",
    "ResponseIncompleteEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseIncompleteEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseIncompleteEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCall",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallAction",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseIncompleteEventResponseOutputResponseComputerToolCallPendingSafetyCheck",
    "ResponseIncompleteEventResponseOutputResponseReasoningItem",
    "ResponseIncompleteEventResponseOutputResponseReasoningItemSummary",
    "ResponseIncompleteEventResponseOutputResponseReasoningItemContent",
    "ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall",
    "ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCall",
    "ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCallOutput",
    "ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall",
    "ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction",
    "ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall",
    "ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools",
    "ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool",
    "ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest",
    "ResponseIncompleteEventResponseOutputResponseCustomToolCall",
    "ResponseIncompleteEventResponseToolChoice",
    "ResponseIncompleteEventResponseToolChoiceToolChoiceAllowed",
    "ResponseIncompleteEventResponseToolChoiceToolChoiceTypes",
    "ResponseIncompleteEventResponseToolChoiceToolChoiceFunction",
    "ResponseIncompleteEventResponseToolChoiceToolChoiceMcp",
    "ResponseIncompleteEventResponseToolChoiceToolChoiceCustom",
    "ResponseIncompleteEventResponseTool",
    "ResponseIncompleteEventResponseToolFunctionTool",
    "ResponseIncompleteEventResponseToolFileSearchTool",
    "ResponseIncompleteEventResponseToolFileSearchToolFilters",
    "ResponseIncompleteEventResponseToolFileSearchToolFiltersComparisonFilter",
    "ResponseIncompleteEventResponseToolFileSearchToolFiltersCompoundFilter",
    "ResponseIncompleteEventResponseToolFileSearchToolFiltersCompoundFilterFilter",
    "ResponseIncompleteEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter",
    "ResponseIncompleteEventResponseToolFileSearchToolRankingOptions",
    "ResponseIncompleteEventResponseToolWebSearchTool",
    "ResponseIncompleteEventResponseToolWebSearchToolUserLocation",
    "ResponseIncompleteEventResponseToolComputerTool",
    "ResponseIncompleteEventResponseToolMcp",
    "ResponseIncompleteEventResponseToolMcpAllowedTools",
    "ResponseIncompleteEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter",
    "ResponseIncompleteEventResponseToolMcpRequireApproval",
    "ResponseIncompleteEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter",
    "ResponseIncompleteEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways",
    "ResponseIncompleteEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever",
    "ResponseIncompleteEventResponseToolCodeInterpreter",
    "ResponseIncompleteEventResponseToolCodeInterpreterContainer",
    "ResponseIncompleteEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto",
    "ResponseIncompleteEventResponseToolImageGeneration",
    "ResponseIncompleteEventResponseToolImageGenerationInputImageMask",
    "ResponseIncompleteEventResponseToolLocalShell",
    "ResponseIncompleteEventResponseToolCustomTool",
    "ResponseIncompleteEventResponseToolCustomToolFormat",
    "ResponseIncompleteEventResponseToolCustomToolFormatText",
    "ResponseIncompleteEventResponseToolCustomToolFormatGrammar",
    "ResponseIncompleteEventResponseError",
    "ResponseIncompleteEventResponseIncompleteDetails",
    "ResponseIncompleteEventResponseInstructionsUnionMember1",
    "ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessage",
    "ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1",
    "ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText",
    "ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage",
    "ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessage",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContent",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFileSearchToolCall",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCall",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallAction",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearch",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionToolCall",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseReasoningItem",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseReasoningItemSummary",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseReasoningItemContent",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput",
    "ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCustomToolCall",
    "ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference",
    "ResponseIncompleteEventResponsePrompt",
    "ResponseIncompleteEventResponsePromptVariables",
    "ResponseIncompleteEventResponsePromptVariablesResponseInputText",
    "ResponseIncompleteEventResponsePromptVariablesResponseInputImage",
    "ResponseIncompleteEventResponsePromptVariablesResponseInputFile",
    "ResponseIncompleteEventResponseReasoning",
    "ResponseIncompleteEventResponseText",
    "ResponseIncompleteEventResponseTextFormat",
    "ResponseIncompleteEventResponseTextFormatResponseFormatText",
    "ResponseIncompleteEventResponseTextFormatResponseFormatTextJsonSchemaConfig",
    "ResponseIncompleteEventResponseTextFormatResponseFormatJsonObject",
    "ResponseIncompleteEventResponseUsage",
    "ResponseIncompleteEventResponseUsageInputTokensDetails",
    "ResponseIncompleteEventResponseUsageOutputTokensDetails",
    "ResponseOutputItemAddedEvent",
    "ResponseOutputItemAddedEventItem",
    "ResponseOutputItemAddedEventItemResponseOutputMessage",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContent",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputText",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputRefusal",
    "ResponseOutputItemAddedEventItemResponseFileSearchToolCall",
    "ResponseOutputItemAddedEventItemResponseFileSearchToolCallResult",
    "ResponseOutputItemAddedEventItemResponseFunctionToolCall",
    "ResponseOutputItemAddedEventItemResponseFunctionWebSearch",
    "ResponseOutputItemAddedEventItemResponseFunctionWebSearchAction",
    "ResponseOutputItemAddedEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseOutputItemAddedEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseOutputItemAddedEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseOutputItemAddedEventItemResponseComputerToolCall",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallAction",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseOutputItemAddedEventItemResponseComputerToolCallPendingSafetyCheck",
    "ResponseOutputItemAddedEventItemResponseReasoningItem",
    "ResponseOutputItemAddedEventItemResponseReasoningItemSummary",
    "ResponseOutputItemAddedEventItemResponseReasoningItemContent",
    "ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemImageGenerationCall",
    "ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCall",
    "ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCallOutput",
    "ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemLocalShellCall",
    "ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemLocalShellCallAction",
    "ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpCall",
    "ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpListTools",
    "ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpListToolsTool",
    "ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpApprovalRequest",
    "ResponseOutputItemAddedEventItemResponseCustomToolCall",
    "ResponseOutputItemDoneEvent",
    "ResponseOutputItemDoneEventItem",
    "ResponseOutputItemDoneEventItemResponseOutputMessage",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContent",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputText",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputRefusal",
    "ResponseOutputItemDoneEventItemResponseFileSearchToolCall",
    "ResponseOutputItemDoneEventItemResponseFileSearchToolCallResult",
    "ResponseOutputItemDoneEventItemResponseFunctionToolCall",
    "ResponseOutputItemDoneEventItemResponseFunctionWebSearch",
    "ResponseOutputItemDoneEventItemResponseFunctionWebSearchAction",
    "ResponseOutputItemDoneEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseOutputItemDoneEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseOutputItemDoneEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseOutputItemDoneEventItemResponseComputerToolCall",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallAction",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseOutputItemDoneEventItemResponseComputerToolCallPendingSafetyCheck",
    "ResponseOutputItemDoneEventItemResponseReasoningItem",
    "ResponseOutputItemDoneEventItemResponseReasoningItemSummary",
    "ResponseOutputItemDoneEventItemResponseReasoningItemContent",
    "ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemImageGenerationCall",
    "ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCall",
    "ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCallOutput",
    "ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemLocalShellCall",
    "ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemLocalShellCallAction",
    "ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpCall",
    "ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpListTools",
    "ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpListToolsTool",
    "ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpApprovalRequest",
    "ResponseOutputItemDoneEventItemResponseCustomToolCall",
    "ResponseReasoningSummaryPartAddedEvent",
    "ResponseReasoningSummaryPartAddedEventPart",
    "ResponseReasoningSummaryPartDoneEvent",
    "ResponseReasoningSummaryPartDoneEventPart",
    "ResponseReasoningSummaryTextDeltaEvent",
    "ResponseReasoningSummaryTextDoneEvent",
    "ResponseReasoningTextDeltaEvent",
    "ResponseReasoningTextDoneEvent",
    "ResponseRefusalDeltaEvent",
    "ResponseRefusalDoneEvent",
    "ResponseTextDeltaEvent",
    "ResponseTextDeltaEventLogprob",
    "ResponseTextDeltaEventLogprobTopLogprob",
    "ResponseTextDoneEvent",
    "ResponseTextDoneEventLogprob",
    "ResponseTextDoneEventLogprobTopLogprob",
    "ResponseWebSearchCallCompletedEvent",
    "ResponseWebSearchCallInProgressEvent",
    "ResponseWebSearchCallSearchingEvent",
    "ResponseImageGenCallCompletedEvent",
    "ResponseImageGenCallGeneratingEvent",
    "ResponseImageGenCallInProgressEvent",
    "ResponseImageGenCallPartialImageEvent",
    "ResponseMcpCallArgumentsDeltaEvent",
    "ResponseMcpCallArgumentsDoneEvent",
    "ResponseMcpCallCompletedEvent",
    "ResponseMcpCallFailedEvent",
    "ResponseMcpCallInProgressEvent",
    "ResponseMcpListToolsCompletedEvent",
    "ResponseMcpListToolsFailedEvent",
    "ResponseMcpListToolsInProgressEvent",
    "ResponseOutputTextAnnotationAddedEvent",
    "ResponseQueuedEvent",
    "ResponseQueuedEventResponse",
    "ResponseQueuedEventResponseOutput",
    "ResponseQueuedEventResponseOutputResponseOutputMessage",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContent",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputText",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal",
    "ResponseQueuedEventResponseOutputResponseFileSearchToolCall",
    "ResponseQueuedEventResponseOutputResponseFileSearchToolCallResult",
    "ResponseQueuedEventResponseOutputResponseFunctionToolCall",
    "ResponseQueuedEventResponseOutputResponseFunctionWebSearch",
    "ResponseQueuedEventResponseOutputResponseFunctionWebSearchAction",
    "ResponseQueuedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseQueuedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseQueuedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseQueuedEventResponseOutputResponseComputerToolCall",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallAction",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseQueuedEventResponseOutputResponseComputerToolCallPendingSafetyCheck",
    "ResponseQueuedEventResponseOutputResponseReasoningItem",
    "ResponseQueuedEventResponseOutputResponseReasoningItemSummary",
    "ResponseQueuedEventResponseOutputResponseReasoningItemContent",
    "ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall",
    "ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCall",
    "ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCallOutput",
    "ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall",
    "ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction",
    "ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall",
    "ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools",
    "ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool",
    "ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest",
    "ResponseQueuedEventResponseOutputResponseCustomToolCall",
    "ResponseQueuedEventResponseToolChoice",
    "ResponseQueuedEventResponseToolChoiceToolChoiceAllowed",
    "ResponseQueuedEventResponseToolChoiceToolChoiceTypes",
    "ResponseQueuedEventResponseToolChoiceToolChoiceFunction",
    "ResponseQueuedEventResponseToolChoiceToolChoiceMcp",
    "ResponseQueuedEventResponseToolChoiceToolChoiceCustom",
    "ResponseQueuedEventResponseTool",
    "ResponseQueuedEventResponseToolFunctionTool",
    "ResponseQueuedEventResponseToolFileSearchTool",
    "ResponseQueuedEventResponseToolFileSearchToolFilters",
    "ResponseQueuedEventResponseToolFileSearchToolFiltersComparisonFilter",
    "ResponseQueuedEventResponseToolFileSearchToolFiltersCompoundFilter",
    "ResponseQueuedEventResponseToolFileSearchToolFiltersCompoundFilterFilter",
    "ResponseQueuedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter",
    "ResponseQueuedEventResponseToolFileSearchToolRankingOptions",
    "ResponseQueuedEventResponseToolWebSearchTool",
    "ResponseQueuedEventResponseToolWebSearchToolUserLocation",
    "ResponseQueuedEventResponseToolComputerTool",
    "ResponseQueuedEventResponseToolMcp",
    "ResponseQueuedEventResponseToolMcpAllowedTools",
    "ResponseQueuedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter",
    "ResponseQueuedEventResponseToolMcpRequireApproval",
    "ResponseQueuedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter",
    "ResponseQueuedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways",
    "ResponseQueuedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever",
    "ResponseQueuedEventResponseToolCodeInterpreter",
    "ResponseQueuedEventResponseToolCodeInterpreterContainer",
    "ResponseQueuedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto",
    "ResponseQueuedEventResponseToolImageGeneration",
    "ResponseQueuedEventResponseToolImageGenerationInputImageMask",
    "ResponseQueuedEventResponseToolLocalShell",
    "ResponseQueuedEventResponseToolCustomTool",
    "ResponseQueuedEventResponseToolCustomToolFormat",
    "ResponseQueuedEventResponseToolCustomToolFormatText",
    "ResponseQueuedEventResponseToolCustomToolFormatGrammar",
    "ResponseQueuedEventResponseError",
    "ResponseQueuedEventResponseIncompleteDetails",
    "ResponseQueuedEventResponseInstructionsUnionMember1",
    "ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessage",
    "ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1",
    "ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText",
    "ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage",
    "ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessage",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContent",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCall",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionToolCall",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseReasoningItem",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseReasoningItemContent",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput",
    "ResponseQueuedEventResponseInstructionsUnionMember1ResponseCustomToolCall",
    "ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference",
    "ResponseQueuedEventResponsePrompt",
    "ResponseQueuedEventResponsePromptVariables",
    "ResponseQueuedEventResponsePromptVariablesResponseInputText",
    "ResponseQueuedEventResponsePromptVariablesResponseInputImage",
    "ResponseQueuedEventResponsePromptVariablesResponseInputFile",
    "ResponseQueuedEventResponseReasoning",
    "ResponseQueuedEventResponseText",
    "ResponseQueuedEventResponseTextFormat",
    "ResponseQueuedEventResponseTextFormatResponseFormatText",
    "ResponseQueuedEventResponseTextFormatResponseFormatTextJsonSchemaConfig",
    "ResponseQueuedEventResponseTextFormatResponseFormatJsonObject",
    "ResponseQueuedEventResponseUsage",
    "ResponseQueuedEventResponseUsageInputTokensDetails",
    "ResponseQueuedEventResponseUsageOutputTokensDetails",
    "ResponseCustomToolCallInputDeltaEvent",
    "ResponseCustomToolCallInputDoneEvent",
    "GenericResponseEvent",
]


class ResponseAudioDeltaEvent(BaseModel):
    delta: str

    sequence_number: int

    type: Literal["response.audio.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseAudioDoneEvent(BaseModel):
    sequence_number: int

    type: Literal["response.audio.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseAudioTranscriptDeltaEvent(BaseModel):
    delta: str

    sequence_number: int

    type: Literal["response.audio.transcript.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseAudioTranscriptDoneEvent(BaseModel):
    sequence_number: int

    type: Literal["response.audio.transcript.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCodeInterpreterCallCodeDeltaEvent(BaseModel):
    delta: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.code_interpreter_call_code.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCodeInterpreterCallCodeDoneEvent(BaseModel):
    code: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.code_interpreter_call_code.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCodeInterpreterCallCompletedEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.code_interpreter_call.completed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCodeInterpreterCallInProgressEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.code_interpreter_call.in_progress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCodeInterpreterCallInterpretingEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.code_interpreter_call.interpreting"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseOutputResponseOutputMessageContent: TypeAlias = Union[
    ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputText,
    ResponseCompletedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseCompletedEventResponseOutputResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseCompletedEventResponseOutputResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseCompletedEventResponseOutputResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseOutputResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseCompletedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseCompletedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseCompletedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseCompletedEventResponseOutputResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseCompletedEventResponseOutputResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseOutputResponseComputerToolCallAction: TypeAlias = Union[
    ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseCompletedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseCompletedEventResponseOutputResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseCompletedEventResponseOutputResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[ResponseCompletedEventResponseOutputResponseComputerToolCallPendingSafetyCheck]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseCompletedEventResponseOutputResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseCompletedEventResponseOutputResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall(BaseModel):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[List[ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCallOutput]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction(BaseModel):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool(BaseModel):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseOutputResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseOutput: TypeAlias = Union[
    ResponseCompletedEventResponseOutputResponseOutputMessage,
    ResponseCompletedEventResponseOutputResponseFileSearchToolCall,
    ResponseCompletedEventResponseOutputResponseFunctionToolCall,
    ResponseCompletedEventResponseOutputResponseFunctionWebSearch,
    ResponseCompletedEventResponseOutputResponseComputerToolCall,
    ResponseCompletedEventResponseOutputResponseReasoningItem,
    ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall,
    ResponseCompletedEventResponseOutputResponseCodeInterpreterToolCall,
    ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall,
    ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall,
    ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools,
    ResponseCompletedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest,
    ResponseCompletedEventResponseOutputResponseCustomToolCall,
]


class ResponseCompletedEventResponseToolChoiceToolChoiceAllowed(BaseModel):
    mode: Literal["auto", "required"]

    tools: List[Dict[str, object]]

    type: Literal["allowed_tools"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolChoiceToolChoiceTypes(BaseModel):
    type: Literal[
        "file_search",
        "web_search_preview",
        "computer_use_preview",
        "web_search_preview_2025_03_11",
        "image_generation",
        "code_interpreter",
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolChoiceToolChoiceFunction(BaseModel):
    name: str

    type: Literal["function"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolChoiceToolChoiceMcp(BaseModel):
    server_label: str

    type: Literal["mcp"]

    name: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolChoiceToolChoiceCustom(BaseModel):
    name: str

    type: Literal["custom"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseToolChoice: TypeAlias = Union[
    Literal["none", "auto", "required"],
    ResponseCompletedEventResponseToolChoiceToolChoiceAllowed,
    ResponseCompletedEventResponseToolChoiceToolChoiceTypes,
    ResponseCompletedEventResponseToolChoiceToolChoiceFunction,
    ResponseCompletedEventResponseToolChoiceToolChoiceMcp,
    ResponseCompletedEventResponseToolChoiceToolChoiceCustom,
]


class ResponseCompletedEventResponseToolFunctionTool(BaseModel):
    name: str

    type: Literal["function"]

    description: Optional[str] = None

    parameters: Optional[Dict[str, object]] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolFileSearchToolFiltersComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseToolFileSearchToolFiltersCompoundFilterFilter: TypeAlias = Union[
    ResponseCompletedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter, object
]


class ResponseCompletedEventResponseToolFileSearchToolFiltersCompoundFilter(BaseModel):
    filters: List[ResponseCompletedEventResponseToolFileSearchToolFiltersCompoundFilterFilter]

    type: Literal["and", "or"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseToolFileSearchToolFilters: TypeAlias = Union[
    ResponseCompletedEventResponseToolFileSearchToolFiltersComparisonFilter,
    ResponseCompletedEventResponseToolFileSearchToolFiltersCompoundFilter,
]


class ResponseCompletedEventResponseToolFileSearchToolRankingOptions(BaseModel):
    ranker: Optional[Literal["auto", "default-2024-11-15"]] = None

    score_threshold: Optional[float] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolFileSearchTool(BaseModel):
    type: Literal["file_search"]

    vector_store_ids: List[str]

    filters: Optional[ResponseCompletedEventResponseToolFileSearchToolFilters] = None

    max_num_results: Optional[int] = None

    ranking_options: Optional[ResponseCompletedEventResponseToolFileSearchToolRankingOptions] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolWebSearchToolUserLocation(BaseModel):
    type: Literal["approximate"]

    city: Optional[str] = None

    country: Optional[str] = None

    region: Optional[str] = None

    timezone: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolWebSearchTool(BaseModel):
    type: Literal["web_search_preview", "web_search_preview_2025_03_11"]

    search_context_size: Optional[Literal["low", "medium", "high"]] = None

    user_location: Optional[ResponseCompletedEventResponseToolWebSearchToolUserLocation] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolComputerTool(BaseModel):
    display_height: int

    display_width: int

    environment: Literal["windows", "mac", "linux", "ubuntu", "browser"]

    type: Literal["computer_use_preview"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseToolMcpAllowedTools: TypeAlias = Union[
    List[str], ResponseCompletedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter
]


class ResponseCompletedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter(BaseModel):
    always: Optional[
        ResponseCompletedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways
    ] = None

    never: Optional[
        ResponseCompletedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseToolMcpRequireApproval: TypeAlias = Union[
    ResponseCompletedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter,
    Literal["always", "never"],
]


class ResponseCompletedEventResponseToolMcp(BaseModel):
    server_label: str

    server_url: str

    type: Literal["mcp"]

    allowed_tools: Optional[ResponseCompletedEventResponseToolMcpAllowedTools] = None

    headers: Optional[Dict[str, str]] = None

    require_approval: Optional[ResponseCompletedEventResponseToolMcpRequireApproval] = None

    server_description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto(
    BaseModel
):
    type: Literal["auto"]

    file_ids: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseToolCodeInterpreterContainer: TypeAlias = Union[
    str, ResponseCompletedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto
]


class ResponseCompletedEventResponseToolCodeInterpreter(BaseModel):
    container: ResponseCompletedEventResponseToolCodeInterpreterContainer

    type: Literal["code_interpreter"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolImageGenerationInputImageMask(BaseModel):
    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolImageGeneration(BaseModel):
    type: Literal["image_generation"]

    background: Optional[Literal["transparent", "opaque", "auto"]] = None

    input_fidelity: Optional[Literal["high", "low"]] = None

    input_image_mask: Optional[ResponseCompletedEventResponseToolImageGenerationInputImageMask] = None

    model: Optional[Literal["gpt-image-1"]] = None

    moderation: Optional[Literal["auto", "low"]] = None

    output_compression: Optional[int] = None

    output_format: Optional[Literal["png", "webp", "jpeg"]] = None

    partial_images: Optional[int] = None

    quality: Optional[Literal["low", "medium", "high", "auto"]] = None

    size: Optional[Literal["1024x1024", "1024x1536", "1536x1024", "auto"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolLocalShell(BaseModel):
    type: Literal["local_shell"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolCustomToolFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseToolCustomToolFormatGrammar(BaseModel):
    definition: str

    syntax: Literal["lark", "regex"]

    type: Literal["grammar"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseToolCustomToolFormat: TypeAlias = Union[
    ResponseCompletedEventResponseToolCustomToolFormatText, ResponseCompletedEventResponseToolCustomToolFormatGrammar
]


class ResponseCompletedEventResponseToolCustomTool(BaseModel):
    name: str

    type: Literal["custom"]

    description: Optional[str] = None

    format: Optional[ResponseCompletedEventResponseToolCustomToolFormat] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseTool: TypeAlias = Union[
    ResponseCompletedEventResponseToolFunctionTool,
    ResponseCompletedEventResponseToolFileSearchTool,
    ResponseCompletedEventResponseToolWebSearchTool,
    ResponseCompletedEventResponseToolComputerTool,
    ResponseCompletedEventResponseToolMcp,
    ResponseCompletedEventResponseToolCodeInterpreter,
    ResponseCompletedEventResponseToolImageGeneration,
    ResponseCompletedEventResponseToolLocalShell,
    ResponseCompletedEventResponseToolCustomTool,
]


class ResponseCompletedEventResponseError(BaseModel):
    code: Literal[
        "server_error",
        "rate_limit_exceeded",
        "invalid_prompt",
        "vector_store_timeout",
        "invalid_image",
        "invalid_image_format",
        "invalid_base64_image",
        "invalid_image_url",
        "image_too_large",
        "image_too_small",
        "image_parse_error",
        "image_content_policy_violation",
        "invalid_image_mode",
        "image_file_too_large",
        "unsupported_image_media_type",
        "empty_image_file",
        "failed_to_download_image",
        "image_file_not_found",
    ]

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseIncompleteDetails(BaseModel):
    reason: Optional[Literal["max_output_tokens", "content_filter"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1: TypeAlias = Union[
    ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText,
    ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage,
    ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile,
]


class ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessage(BaseModel):
    content: Union[str, List[ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1]]

    role: Literal["user", "assistant", "system", "developer"]

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent: TypeAlias = Union[
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile,
]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage(BaseModel):
    content: List[
        ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent
    ]

    role: Literal["user", "system", "developer"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[
        ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation
    ]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[
            ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob
        ]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal(
    BaseModel
):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContent: TypeAlias = Union[
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseCompletedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult]] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction: TypeAlias = Union[
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[
        ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck
    ]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput(
    BaseModel
):
    type: Literal["computer_screenshot"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck(
    BaseModel
):
    id: str

    code: Optional[str] = None

    message: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput(
    BaseModel
):
    call_id: str

    output: ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput

    type: Literal["computer_call_output"]

    id: Optional[str] = None

    acknowledged_safety_checks: Optional[
        List[
            ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck
        ]
    ] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput(
    BaseModel
):
    call_id: str

    output: str

    type: Literal["function_call_output"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseCompletedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseCompletedEventResponseInstructionsUnionMember1ResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall(
    BaseModel
):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[
        List[ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction(
    BaseModel
):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall(
    BaseModel
):
    id: str

    action: (
        ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction
    )

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput(
    BaseModel
):
    id: str

    output: str

    type: Literal["local_shell_call_output"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool(
    BaseModel
):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools(
    BaseModel
):
    id: str

    server_label: str

    tools: List[
        ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool
    ]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest(
    BaseModel
):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse(
    BaseModel
):
    approval_request_id: str

    approve: bool

    type: Literal["mcp_approval_response"]

    id: Optional[str] = None

    reason: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput(BaseModel):
    call_id: str

    output: str

    type: Literal["custom_tool_call_output"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1ResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference(
    BaseModel
):
    id: str

    type: Optional[Literal["item_reference"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseInstructionsUnionMember1: TypeAlias = Union[
    ResponseCompletedEventResponseInstructionsUnionMember1EasyInputMessage,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseOutputMessage,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseComputerToolCall,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseFunctionToolCall,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseReasoningItem,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput,
    ResponseCompletedEventResponseInstructionsUnionMember1ResponseCustomToolCall,
    ResponseCompletedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference,
]


class ResponseCompletedEventResponsePromptVariablesResponseInputText(BaseModel):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponsePromptVariablesResponseInputImage(BaseModel):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponsePromptVariablesResponseInputFile(BaseModel):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponsePromptVariables: TypeAlias = Union[
    str,
    ResponseCompletedEventResponsePromptVariablesResponseInputText,
    ResponseCompletedEventResponsePromptVariablesResponseInputImage,
    ResponseCompletedEventResponsePromptVariablesResponseInputFile,
]


class ResponseCompletedEventResponsePrompt(BaseModel):
    id: str

    variables: Optional[Dict[str, ResponseCompletedEventResponsePromptVariables]] = None

    version: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseReasoning(BaseModel):
    effort: Optional[Literal["minimal", "low", "medium", "high"]] = None

    generate_summary: Optional[Literal["auto", "concise", "detailed"]] = None

    summary: Optional[Literal["auto", "concise", "detailed"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseTextFormatResponseFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseTextFormatResponseFormatTextJsonSchemaConfig(BaseModel):
    name: str

    schema_: Dict[str, object] = FieldInfo(alias="schema")

    type: Literal["json_schema"]

    description: Optional[str] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseTextFormatResponseFormatJsonObject(BaseModel):
    type: Literal["json_object"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCompletedEventResponseTextFormat: TypeAlias = Union[
    ResponseCompletedEventResponseTextFormatResponseFormatText,
    ResponseCompletedEventResponseTextFormatResponseFormatTextJsonSchemaConfig,
    ResponseCompletedEventResponseTextFormatResponseFormatJsonObject,
]


class ResponseCompletedEventResponseText(BaseModel):
    format: Optional[ResponseCompletedEventResponseTextFormat] = None

    verbosity: Optional[Literal["low", "medium", "high"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseUsageInputTokensDetails(BaseModel):
    cached_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseUsageOutputTokensDetails(BaseModel):
    reasoning_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponseUsage(BaseModel):
    input_tokens: int

    input_tokens_details: ResponseCompletedEventResponseUsageInputTokensDetails

    output_tokens: int

    output_tokens_details: ResponseCompletedEventResponseUsageOutputTokensDetails

    total_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCompletedEventResponse(BaseModel):
    id: str

    created_at: float

    model: Union[
        Literal[
            "gpt-5",
            "gpt-5-mini",
            "gpt-5-nano",
            "gpt-5-2025-08-07",
            "gpt-5-mini-2025-08-07",
            "gpt-5-nano-2025-08-07",
            "gpt-5-chat-latest",
            "gpt-4.1",
            "gpt-4.1-mini",
            "gpt-4.1-nano",
            "gpt-4.1-2025-04-14",
            "gpt-4.1-mini-2025-04-14",
            "gpt-4.1-nano-2025-04-14",
            "o4-mini",
            "o4-mini-2025-04-16",
            "o3",
            "o3-2025-04-16",
            "o3-mini",
            "o3-mini-2025-01-31",
            "o1",
            "o1-2024-12-17",
            "o1-preview",
            "o1-preview-2024-09-12",
            "o1-mini",
            "o1-mini-2024-09-12",
            "gpt-4o",
            "gpt-4o-2024-11-20",
            "gpt-4o-2024-08-06",
            "gpt-4o-2024-05-13",
            "gpt-4o-audio-preview",
            "gpt-4o-audio-preview-2024-10-01",
            "gpt-4o-audio-preview-2024-12-17",
            "gpt-4o-audio-preview-2025-06-03",
            "gpt-4o-mini-audio-preview",
            "gpt-4o-mini-audio-preview-2024-12-17",
            "gpt-4o-search-preview",
            "gpt-4o-mini-search-preview",
            "gpt-4o-search-preview-2025-03-11",
            "gpt-4o-mini-search-preview-2025-03-11",
            "chatgpt-4o-latest",
            "codex-mini-latest",
            "gpt-4o-mini",
            "gpt-4o-mini-2024-07-18",
            "gpt-4-turbo",
            "gpt-4-turbo-2024-04-09",
            "gpt-4-0125-preview",
            "gpt-4-turbo-preview",
            "gpt-4-1106-preview",
            "gpt-4-vision-preview",
            "gpt-4",
            "gpt-4-0314",
            "gpt-4-0613",
            "gpt-4-32k",
            "gpt-4-32k-0314",
            "gpt-4-32k-0613",
            "gpt-3.5-turbo",
            "gpt-3.5-turbo-16k",
            "gpt-3.5-turbo-0301",
            "gpt-3.5-turbo-0613",
            "gpt-3.5-turbo-1106",
            "gpt-3.5-turbo-0125",
            "gpt-3.5-turbo-16k-0613",
            "o1-pro",
            "o1-pro-2025-03-19",
            "o3-pro",
            "o3-pro-2025-06-10",
            "o3-deep-research",
            "o3-deep-research-2025-06-26",
            "o4-mini-deep-research",
            "o4-mini-deep-research-2025-06-26",
            "computer-use-preview",
            "computer-use-preview-2025-03-11",
        ],
        str,
    ]

    object: Literal["response"]

    output: List[ResponseCompletedEventResponseOutput]

    parallel_tool_calls: bool

    tool_choice: ResponseCompletedEventResponseToolChoice

    tools: List[ResponseCompletedEventResponseTool]

    background: Optional[bool] = None

    error: Optional[ResponseCompletedEventResponseError] = None

    incomplete_details: Optional[ResponseCompletedEventResponseIncompleteDetails] = None

    instructions: Union[str, List[ResponseCompletedEventResponseInstructionsUnionMember1], None] = None

    max_output_tokens: Optional[int] = None

    max_tool_calls: Optional[int] = None

    metadata: Optional[Dict[str, str]] = None

    previous_response_id: Optional[str] = None

    prompt: Optional[ResponseCompletedEventResponsePrompt] = None

    prompt_cache_key: Optional[str] = None

    reasoning: Optional[ResponseCompletedEventResponseReasoning] = None

    safety_identifier: Optional[str] = None

    service_tier: Optional[Literal["auto", "default", "flex", "scale", "priority"]] = None

    status: Optional[Literal["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]] = None

    temperature: Optional[float] = None

    text: Optional[ResponseCompletedEventResponseText] = None

    top_logprobs: Optional[int] = None

    top_p: Optional[float] = None

    truncation: Optional[Literal["auto", "disabled"]] = None

    usage: Optional[ResponseCompletedEventResponseUsage] = None

    user: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, builtins.object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> builtins.object: ...
    else:
        __pydantic_extra__: Dict[str, builtins.object]


class ResponseCompletedEvent(BaseModel):
    response: ResponseCompletedEventResponse

    sequence_number: int

    type: Literal["response.completed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseContentPartAddedEventPartResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseContentPartAddedEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseContentPartAddedEventPartResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartAddedEventPartResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[ResponseContentPartAddedEventPartResponseOutputTextLogprobTopLogprob]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartAddedEventPartResponseOutputText(BaseModel):
    annotations: List[ResponseContentPartAddedEventPartResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[List[ResponseContentPartAddedEventPartResponseOutputTextLogprob]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartAddedEventPartResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseContentPartAddedEventPart: TypeAlias = Union[
    ResponseContentPartAddedEventPartResponseOutputText, ResponseContentPartAddedEventPartResponseOutputRefusal
]


class ResponseContentPartAddedEvent(BaseModel):
    content_index: int

    item_id: str

    output_index: int

    part: ResponseContentPartAddedEventPart

    sequence_number: int

    type: Literal["response.content_part.added"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseContentPartDoneEventPartResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseContentPartDoneEventPartResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseContentPartDoneEventPartResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartDoneEventPartResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[ResponseContentPartDoneEventPartResponseOutputTextLogprobTopLogprob]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartDoneEventPartResponseOutputText(BaseModel):
    annotations: List[ResponseContentPartDoneEventPartResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[List[ResponseContentPartDoneEventPartResponseOutputTextLogprob]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseContentPartDoneEventPartResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseContentPartDoneEventPart: TypeAlias = Union[
    ResponseContentPartDoneEventPartResponseOutputText, ResponseContentPartDoneEventPartResponseOutputRefusal
]


class ResponseContentPartDoneEvent(BaseModel):
    content_index: int

    item_id: str

    output_index: int

    part: ResponseContentPartDoneEventPart

    sequence_number: int

    type: Literal["response.content_part.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseOutputResponseOutputMessageContent: TypeAlias = Union[
    ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputText,
    ResponseCreatedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseCreatedEventResponseOutputResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseCreatedEventResponseOutputResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseCreatedEventResponseOutputResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseOutputResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseCreatedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseCreatedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseCreatedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseCreatedEventResponseOutputResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseCreatedEventResponseOutputResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseOutputResponseComputerToolCallAction: TypeAlias = Union[
    ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseCreatedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseCreatedEventResponseOutputResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseCreatedEventResponseOutputResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[ResponseCreatedEventResponseOutputResponseComputerToolCallPendingSafetyCheck]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseCreatedEventResponseOutputResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseCreatedEventResponseOutputResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall(BaseModel):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[List[ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCallOutput]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction(BaseModel):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool(BaseModel):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseOutputResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseOutput: TypeAlias = Union[
    ResponseCreatedEventResponseOutputResponseOutputMessage,
    ResponseCreatedEventResponseOutputResponseFileSearchToolCall,
    ResponseCreatedEventResponseOutputResponseFunctionToolCall,
    ResponseCreatedEventResponseOutputResponseFunctionWebSearch,
    ResponseCreatedEventResponseOutputResponseComputerToolCall,
    ResponseCreatedEventResponseOutputResponseReasoningItem,
    ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall,
    ResponseCreatedEventResponseOutputResponseCodeInterpreterToolCall,
    ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall,
    ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall,
    ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools,
    ResponseCreatedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest,
    ResponseCreatedEventResponseOutputResponseCustomToolCall,
]


class ResponseCreatedEventResponseToolChoiceToolChoiceAllowed(BaseModel):
    mode: Literal["auto", "required"]

    tools: List[Dict[str, object]]

    type: Literal["allowed_tools"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolChoiceToolChoiceTypes(BaseModel):
    type: Literal[
        "file_search",
        "web_search_preview",
        "computer_use_preview",
        "web_search_preview_2025_03_11",
        "image_generation",
        "code_interpreter",
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolChoiceToolChoiceFunction(BaseModel):
    name: str

    type: Literal["function"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolChoiceToolChoiceMcp(BaseModel):
    server_label: str

    type: Literal["mcp"]

    name: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolChoiceToolChoiceCustom(BaseModel):
    name: str

    type: Literal["custom"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseToolChoice: TypeAlias = Union[
    Literal["none", "auto", "required"],
    ResponseCreatedEventResponseToolChoiceToolChoiceAllowed,
    ResponseCreatedEventResponseToolChoiceToolChoiceTypes,
    ResponseCreatedEventResponseToolChoiceToolChoiceFunction,
    ResponseCreatedEventResponseToolChoiceToolChoiceMcp,
    ResponseCreatedEventResponseToolChoiceToolChoiceCustom,
]


class ResponseCreatedEventResponseToolFunctionTool(BaseModel):
    name: str

    type: Literal["function"]

    description: Optional[str] = None

    parameters: Optional[Dict[str, object]] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolFileSearchToolFiltersComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseToolFileSearchToolFiltersCompoundFilterFilter: TypeAlias = Union[
    ResponseCreatedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter, object
]


class ResponseCreatedEventResponseToolFileSearchToolFiltersCompoundFilter(BaseModel):
    filters: List[ResponseCreatedEventResponseToolFileSearchToolFiltersCompoundFilterFilter]

    type: Literal["and", "or"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseToolFileSearchToolFilters: TypeAlias = Union[
    ResponseCreatedEventResponseToolFileSearchToolFiltersComparisonFilter,
    ResponseCreatedEventResponseToolFileSearchToolFiltersCompoundFilter,
]


class ResponseCreatedEventResponseToolFileSearchToolRankingOptions(BaseModel):
    ranker: Optional[Literal["auto", "default-2024-11-15"]] = None

    score_threshold: Optional[float] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolFileSearchTool(BaseModel):
    type: Literal["file_search"]

    vector_store_ids: List[str]

    filters: Optional[ResponseCreatedEventResponseToolFileSearchToolFilters] = None

    max_num_results: Optional[int] = None

    ranking_options: Optional[ResponseCreatedEventResponseToolFileSearchToolRankingOptions] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolWebSearchToolUserLocation(BaseModel):
    type: Literal["approximate"]

    city: Optional[str] = None

    country: Optional[str] = None

    region: Optional[str] = None

    timezone: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolWebSearchTool(BaseModel):
    type: Literal["web_search_preview", "web_search_preview_2025_03_11"]

    search_context_size: Optional[Literal["low", "medium", "high"]] = None

    user_location: Optional[ResponseCreatedEventResponseToolWebSearchToolUserLocation] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolComputerTool(BaseModel):
    display_height: int

    display_width: int

    environment: Literal["windows", "mac", "linux", "ubuntu", "browser"]

    type: Literal["computer_use_preview"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseToolMcpAllowedTools: TypeAlias = Union[
    List[str], ResponseCreatedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter
]


class ResponseCreatedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter(BaseModel):
    always: Optional[
        ResponseCreatedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways
    ] = None

    never: Optional[ResponseCreatedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseToolMcpRequireApproval: TypeAlias = Union[
    ResponseCreatedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter,
    Literal["always", "never"],
]


class ResponseCreatedEventResponseToolMcp(BaseModel):
    server_label: str

    server_url: str

    type: Literal["mcp"]

    allowed_tools: Optional[ResponseCreatedEventResponseToolMcpAllowedTools] = None

    headers: Optional[Dict[str, str]] = None

    require_approval: Optional[ResponseCreatedEventResponseToolMcpRequireApproval] = None

    server_description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto(
    BaseModel
):
    type: Literal["auto"]

    file_ids: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseToolCodeInterpreterContainer: TypeAlias = Union[
    str, ResponseCreatedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto
]


class ResponseCreatedEventResponseToolCodeInterpreter(BaseModel):
    container: ResponseCreatedEventResponseToolCodeInterpreterContainer

    type: Literal["code_interpreter"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolImageGenerationInputImageMask(BaseModel):
    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolImageGeneration(BaseModel):
    type: Literal["image_generation"]

    background: Optional[Literal["transparent", "opaque", "auto"]] = None

    input_fidelity: Optional[Literal["high", "low"]] = None

    input_image_mask: Optional[ResponseCreatedEventResponseToolImageGenerationInputImageMask] = None

    model: Optional[Literal["gpt-image-1"]] = None

    moderation: Optional[Literal["auto", "low"]] = None

    output_compression: Optional[int] = None

    output_format: Optional[Literal["png", "webp", "jpeg"]] = None

    partial_images: Optional[int] = None

    quality: Optional[Literal["low", "medium", "high", "auto"]] = None

    size: Optional[Literal["1024x1024", "1024x1536", "1536x1024", "auto"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolLocalShell(BaseModel):
    type: Literal["local_shell"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolCustomToolFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseToolCustomToolFormatGrammar(BaseModel):
    definition: str

    syntax: Literal["lark", "regex"]

    type: Literal["grammar"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseToolCustomToolFormat: TypeAlias = Union[
    ResponseCreatedEventResponseToolCustomToolFormatText, ResponseCreatedEventResponseToolCustomToolFormatGrammar
]


class ResponseCreatedEventResponseToolCustomTool(BaseModel):
    name: str

    type: Literal["custom"]

    description: Optional[str] = None

    format: Optional[ResponseCreatedEventResponseToolCustomToolFormat] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseTool: TypeAlias = Union[
    ResponseCreatedEventResponseToolFunctionTool,
    ResponseCreatedEventResponseToolFileSearchTool,
    ResponseCreatedEventResponseToolWebSearchTool,
    ResponseCreatedEventResponseToolComputerTool,
    ResponseCreatedEventResponseToolMcp,
    ResponseCreatedEventResponseToolCodeInterpreter,
    ResponseCreatedEventResponseToolImageGeneration,
    ResponseCreatedEventResponseToolLocalShell,
    ResponseCreatedEventResponseToolCustomTool,
]


class ResponseCreatedEventResponseError(BaseModel):
    code: Literal[
        "server_error",
        "rate_limit_exceeded",
        "invalid_prompt",
        "vector_store_timeout",
        "invalid_image",
        "invalid_image_format",
        "invalid_base64_image",
        "invalid_image_url",
        "image_too_large",
        "image_too_small",
        "image_parse_error",
        "image_content_policy_violation",
        "invalid_image_mode",
        "image_file_too_large",
        "unsupported_image_media_type",
        "empty_image_file",
        "failed_to_download_image",
        "image_file_not_found",
    ]

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseIncompleteDetails(BaseModel):
    reason: Optional[Literal["max_output_tokens", "content_filter"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1: TypeAlias = Union[
    ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText,
    ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage,
    ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile,
]


class ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessage(BaseModel):
    content: Union[str, List[ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1]]

    role: Literal["user", "assistant", "system", "developer"]

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent: TypeAlias = Union[
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile,
]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage(BaseModel):
    content: List[
        ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent
    ]

    role: Literal["user", "system", "developer"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[
        ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation
    ]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContent: TypeAlias = Union[
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseCreatedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction: TypeAlias = Union[
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[
        ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck
    ]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput(
    BaseModel
):
    type: Literal["computer_screenshot"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck(
    BaseModel
):
    id: str

    code: Optional[str] = None

    message: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput(
    BaseModel
):
    call_id: str

    output: ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput

    type: Literal["computer_call_output"]

    id: Optional[str] = None

    acknowledged_safety_checks: Optional[
        List[
            ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck
        ]
    ] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput(
    BaseModel
):
    call_id: str

    output: str

    type: Literal["function_call_output"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseCreatedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseCreatedEventResponseInstructionsUnionMember1ResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall(
    BaseModel
):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[
        List[ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction(
    BaseModel
):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall(
    BaseModel
):
    id: str

    action: (
        ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction
    )

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput(
    BaseModel
):
    id: str

    output: str

    type: Literal["local_shell_call_output"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool(
    BaseModel
):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[
        ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool
    ]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest(
    BaseModel
):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse(
    BaseModel
):
    approval_request_id: str

    approve: bool

    type: Literal["mcp_approval_response"]

    id: Optional[str] = None

    reason: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput(BaseModel):
    call_id: str

    output: str

    type: Literal["custom_tool_call_output"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1ResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference(BaseModel):
    id: str

    type: Optional[Literal["item_reference"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseInstructionsUnionMember1: TypeAlias = Union[
    ResponseCreatedEventResponseInstructionsUnionMember1EasyInputMessage,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseOutputMessage,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseComputerToolCall,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseFunctionToolCall,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseReasoningItem,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput,
    ResponseCreatedEventResponseInstructionsUnionMember1ResponseCustomToolCall,
    ResponseCreatedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference,
]


class ResponseCreatedEventResponsePromptVariablesResponseInputText(BaseModel):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponsePromptVariablesResponseInputImage(BaseModel):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponsePromptVariablesResponseInputFile(BaseModel):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponsePromptVariables: TypeAlias = Union[
    str,
    ResponseCreatedEventResponsePromptVariablesResponseInputText,
    ResponseCreatedEventResponsePromptVariablesResponseInputImage,
    ResponseCreatedEventResponsePromptVariablesResponseInputFile,
]


class ResponseCreatedEventResponsePrompt(BaseModel):
    id: str

    variables: Optional[Dict[str, ResponseCreatedEventResponsePromptVariables]] = None

    version: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseReasoning(BaseModel):
    effort: Optional[Literal["minimal", "low", "medium", "high"]] = None

    generate_summary: Optional[Literal["auto", "concise", "detailed"]] = None

    summary: Optional[Literal["auto", "concise", "detailed"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseTextFormatResponseFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseTextFormatResponseFormatTextJsonSchemaConfig(BaseModel):
    name: str

    schema_: Dict[str, object] = FieldInfo(alias="schema")

    type: Literal["json_schema"]

    description: Optional[str] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseTextFormatResponseFormatJsonObject(BaseModel):
    type: Literal["json_object"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreatedEventResponseTextFormat: TypeAlias = Union[
    ResponseCreatedEventResponseTextFormatResponseFormatText,
    ResponseCreatedEventResponseTextFormatResponseFormatTextJsonSchemaConfig,
    ResponseCreatedEventResponseTextFormatResponseFormatJsonObject,
]


class ResponseCreatedEventResponseText(BaseModel):
    format: Optional[ResponseCreatedEventResponseTextFormat] = None

    verbosity: Optional[Literal["low", "medium", "high"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseUsageInputTokensDetails(BaseModel):
    cached_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseUsageOutputTokensDetails(BaseModel):
    reasoning_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponseUsage(BaseModel):
    input_tokens: int

    input_tokens_details: ResponseCreatedEventResponseUsageInputTokensDetails

    output_tokens: int

    output_tokens_details: ResponseCreatedEventResponseUsageOutputTokensDetails

    total_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCreatedEventResponse(BaseModel):
    id: str

    created_at: float

    model: Union[
        Literal[
            "gpt-5",
            "gpt-5-mini",
            "gpt-5-nano",
            "gpt-5-2025-08-07",
            "gpt-5-mini-2025-08-07",
            "gpt-5-nano-2025-08-07",
            "gpt-5-chat-latest",
            "gpt-4.1",
            "gpt-4.1-mini",
            "gpt-4.1-nano",
            "gpt-4.1-2025-04-14",
            "gpt-4.1-mini-2025-04-14",
            "gpt-4.1-nano-2025-04-14",
            "o4-mini",
            "o4-mini-2025-04-16",
            "o3",
            "o3-2025-04-16",
            "o3-mini",
            "o3-mini-2025-01-31",
            "o1",
            "o1-2024-12-17",
            "o1-preview",
            "o1-preview-2024-09-12",
            "o1-mini",
            "o1-mini-2024-09-12",
            "gpt-4o",
            "gpt-4o-2024-11-20",
            "gpt-4o-2024-08-06",
            "gpt-4o-2024-05-13",
            "gpt-4o-audio-preview",
            "gpt-4o-audio-preview-2024-10-01",
            "gpt-4o-audio-preview-2024-12-17",
            "gpt-4o-audio-preview-2025-06-03",
            "gpt-4o-mini-audio-preview",
            "gpt-4o-mini-audio-preview-2024-12-17",
            "gpt-4o-search-preview",
            "gpt-4o-mini-search-preview",
            "gpt-4o-search-preview-2025-03-11",
            "gpt-4o-mini-search-preview-2025-03-11",
            "chatgpt-4o-latest",
            "codex-mini-latest",
            "gpt-4o-mini",
            "gpt-4o-mini-2024-07-18",
            "gpt-4-turbo",
            "gpt-4-turbo-2024-04-09",
            "gpt-4-0125-preview",
            "gpt-4-turbo-preview",
            "gpt-4-1106-preview",
            "gpt-4-vision-preview",
            "gpt-4",
            "gpt-4-0314",
            "gpt-4-0613",
            "gpt-4-32k",
            "gpt-4-32k-0314",
            "gpt-4-32k-0613",
            "gpt-3.5-turbo",
            "gpt-3.5-turbo-16k",
            "gpt-3.5-turbo-0301",
            "gpt-3.5-turbo-0613",
            "gpt-3.5-turbo-1106",
            "gpt-3.5-turbo-0125",
            "gpt-3.5-turbo-16k-0613",
            "o1-pro",
            "o1-pro-2025-03-19",
            "o3-pro",
            "o3-pro-2025-06-10",
            "o3-deep-research",
            "o3-deep-research-2025-06-26",
            "o4-mini-deep-research",
            "o4-mini-deep-research-2025-06-26",
            "computer-use-preview",
            "computer-use-preview-2025-03-11",
        ],
        str,
    ]

    object: Literal["response"]

    output: List[ResponseCreatedEventResponseOutput]

    parallel_tool_calls: bool

    tool_choice: ResponseCreatedEventResponseToolChoice

    tools: List[ResponseCreatedEventResponseTool]

    background: Optional[bool] = None

    error: Optional[ResponseCreatedEventResponseError] = None

    incomplete_details: Optional[ResponseCreatedEventResponseIncompleteDetails] = None

    instructions: Union[str, List[ResponseCreatedEventResponseInstructionsUnionMember1], None] = None

    max_output_tokens: Optional[int] = None

    max_tool_calls: Optional[int] = None

    metadata: Optional[Dict[str, str]] = None

    previous_response_id: Optional[str] = None

    prompt: Optional[ResponseCreatedEventResponsePrompt] = None

    prompt_cache_key: Optional[str] = None

    reasoning: Optional[ResponseCreatedEventResponseReasoning] = None

    safety_identifier: Optional[str] = None

    service_tier: Optional[Literal["auto", "default", "flex", "scale", "priority"]] = None

    status: Optional[Literal["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]] = None

    temperature: Optional[float] = None

    text: Optional[ResponseCreatedEventResponseText] = None

    top_logprobs: Optional[int] = None

    top_p: Optional[float] = None

    truncation: Optional[Literal["auto", "disabled"]] = None

    usage: Optional[ResponseCreatedEventResponseUsage] = None

    user: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, builtins.object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> builtins.object: ...
    else:
        __pydantic_extra__: Dict[str, builtins.object]


class ResponseCreatedEvent(BaseModel):
    response: ResponseCreatedEventResponse

    sequence_number: int

    type: Literal["response.created"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseErrorEvent(BaseModel):
    message: str

    sequence_number: int

    type: Literal["error"]

    code: Optional[str] = None

    param: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFileSearchCallCompletedEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.file_search_call.completed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFileSearchCallInProgressEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.file_search_call.in_progress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFileSearchCallSearchingEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.file_search_call.searching"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFunctionCallArgumentsDeltaEvent(BaseModel):
    delta: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.function_call_arguments.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFunctionCallArgumentsDoneEvent(BaseModel):
    arguments: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.function_call_arguments.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseOutputResponseOutputMessageContent: TypeAlias = Union[
    ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputText,
    ResponseInProgressEventResponseOutputResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseInProgressEventResponseOutputResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseInProgressEventResponseOutputResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseInProgressEventResponseOutputResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseOutputResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseInProgressEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseInProgressEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseInProgressEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseInProgressEventResponseOutputResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseInProgressEventResponseOutputResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseOutputResponseComputerToolCallAction: TypeAlias = Union[
    ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseInProgressEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseInProgressEventResponseOutputResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseInProgressEventResponseOutputResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[ResponseInProgressEventResponseOutputResponseComputerToolCallPendingSafetyCheck]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseInProgressEventResponseOutputResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseInProgressEventResponseOutputResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall(BaseModel):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[List[ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCallOutput]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction(BaseModel):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool(BaseModel):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseOutputResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseOutput: TypeAlias = Union[
    ResponseInProgressEventResponseOutputResponseOutputMessage,
    ResponseInProgressEventResponseOutputResponseFileSearchToolCall,
    ResponseInProgressEventResponseOutputResponseFunctionToolCall,
    ResponseInProgressEventResponseOutputResponseFunctionWebSearch,
    ResponseInProgressEventResponseOutputResponseComputerToolCall,
    ResponseInProgressEventResponseOutputResponseReasoningItem,
    ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall,
    ResponseInProgressEventResponseOutputResponseCodeInterpreterToolCall,
    ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall,
    ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall,
    ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools,
    ResponseInProgressEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest,
    ResponseInProgressEventResponseOutputResponseCustomToolCall,
]


class ResponseInProgressEventResponseToolChoiceToolChoiceAllowed(BaseModel):
    mode: Literal["auto", "required"]

    tools: List[Dict[str, object]]

    type: Literal["allowed_tools"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolChoiceToolChoiceTypes(BaseModel):
    type: Literal[
        "file_search",
        "web_search_preview",
        "computer_use_preview",
        "web_search_preview_2025_03_11",
        "image_generation",
        "code_interpreter",
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolChoiceToolChoiceFunction(BaseModel):
    name: str

    type: Literal["function"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolChoiceToolChoiceMcp(BaseModel):
    server_label: str

    type: Literal["mcp"]

    name: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolChoiceToolChoiceCustom(BaseModel):
    name: str

    type: Literal["custom"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseToolChoice: TypeAlias = Union[
    Literal["none", "auto", "required"],
    ResponseInProgressEventResponseToolChoiceToolChoiceAllowed,
    ResponseInProgressEventResponseToolChoiceToolChoiceTypes,
    ResponseInProgressEventResponseToolChoiceToolChoiceFunction,
    ResponseInProgressEventResponseToolChoiceToolChoiceMcp,
    ResponseInProgressEventResponseToolChoiceToolChoiceCustom,
]


class ResponseInProgressEventResponseToolFunctionTool(BaseModel):
    name: str

    type: Literal["function"]

    description: Optional[str] = None

    parameters: Optional[Dict[str, object]] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolFileSearchToolFiltersComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseToolFileSearchToolFiltersCompoundFilterFilter: TypeAlias = Union[
    ResponseInProgressEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter, object
]


class ResponseInProgressEventResponseToolFileSearchToolFiltersCompoundFilter(BaseModel):
    filters: List[ResponseInProgressEventResponseToolFileSearchToolFiltersCompoundFilterFilter]

    type: Literal["and", "or"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseToolFileSearchToolFilters: TypeAlias = Union[
    ResponseInProgressEventResponseToolFileSearchToolFiltersComparisonFilter,
    ResponseInProgressEventResponseToolFileSearchToolFiltersCompoundFilter,
]


class ResponseInProgressEventResponseToolFileSearchToolRankingOptions(BaseModel):
    ranker: Optional[Literal["auto", "default-2024-11-15"]] = None

    score_threshold: Optional[float] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolFileSearchTool(BaseModel):
    type: Literal["file_search"]

    vector_store_ids: List[str]

    filters: Optional[ResponseInProgressEventResponseToolFileSearchToolFilters] = None

    max_num_results: Optional[int] = None

    ranking_options: Optional[ResponseInProgressEventResponseToolFileSearchToolRankingOptions] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolWebSearchToolUserLocation(BaseModel):
    type: Literal["approximate"]

    city: Optional[str] = None

    country: Optional[str] = None

    region: Optional[str] = None

    timezone: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolWebSearchTool(BaseModel):
    type: Literal["web_search_preview", "web_search_preview_2025_03_11"]

    search_context_size: Optional[Literal["low", "medium", "high"]] = None

    user_location: Optional[ResponseInProgressEventResponseToolWebSearchToolUserLocation] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolComputerTool(BaseModel):
    display_height: int

    display_width: int

    environment: Literal["windows", "mac", "linux", "ubuntu", "browser"]

    type: Literal["computer_use_preview"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseToolMcpAllowedTools: TypeAlias = Union[
    List[str], ResponseInProgressEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter
]


class ResponseInProgressEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter(BaseModel):
    always: Optional[
        ResponseInProgressEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways
    ] = None

    never: Optional[
        ResponseInProgressEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseToolMcpRequireApproval: TypeAlias = Union[
    ResponseInProgressEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter,
    Literal["always", "never"],
]


class ResponseInProgressEventResponseToolMcp(BaseModel):
    server_label: str

    server_url: str

    type: Literal["mcp"]

    allowed_tools: Optional[ResponseInProgressEventResponseToolMcpAllowedTools] = None

    headers: Optional[Dict[str, str]] = None

    require_approval: Optional[ResponseInProgressEventResponseToolMcpRequireApproval] = None

    server_description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto(
    BaseModel
):
    type: Literal["auto"]

    file_ids: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseToolCodeInterpreterContainer: TypeAlias = Union[
    str, ResponseInProgressEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto
]


class ResponseInProgressEventResponseToolCodeInterpreter(BaseModel):
    container: ResponseInProgressEventResponseToolCodeInterpreterContainer

    type: Literal["code_interpreter"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolImageGenerationInputImageMask(BaseModel):
    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolImageGeneration(BaseModel):
    type: Literal["image_generation"]

    background: Optional[Literal["transparent", "opaque", "auto"]] = None

    input_fidelity: Optional[Literal["high", "low"]] = None

    input_image_mask: Optional[ResponseInProgressEventResponseToolImageGenerationInputImageMask] = None

    model: Optional[Literal["gpt-image-1"]] = None

    moderation: Optional[Literal["auto", "low"]] = None

    output_compression: Optional[int] = None

    output_format: Optional[Literal["png", "webp", "jpeg"]] = None

    partial_images: Optional[int] = None

    quality: Optional[Literal["low", "medium", "high", "auto"]] = None

    size: Optional[Literal["1024x1024", "1024x1536", "1536x1024", "auto"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolLocalShell(BaseModel):
    type: Literal["local_shell"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolCustomToolFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseToolCustomToolFormatGrammar(BaseModel):
    definition: str

    syntax: Literal["lark", "regex"]

    type: Literal["grammar"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseToolCustomToolFormat: TypeAlias = Union[
    ResponseInProgressEventResponseToolCustomToolFormatText, ResponseInProgressEventResponseToolCustomToolFormatGrammar
]


class ResponseInProgressEventResponseToolCustomTool(BaseModel):
    name: str

    type: Literal["custom"]

    description: Optional[str] = None

    format: Optional[ResponseInProgressEventResponseToolCustomToolFormat] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseTool: TypeAlias = Union[
    ResponseInProgressEventResponseToolFunctionTool,
    ResponseInProgressEventResponseToolFileSearchTool,
    ResponseInProgressEventResponseToolWebSearchTool,
    ResponseInProgressEventResponseToolComputerTool,
    ResponseInProgressEventResponseToolMcp,
    ResponseInProgressEventResponseToolCodeInterpreter,
    ResponseInProgressEventResponseToolImageGeneration,
    ResponseInProgressEventResponseToolLocalShell,
    ResponseInProgressEventResponseToolCustomTool,
]


class ResponseInProgressEventResponseError(BaseModel):
    code: Literal[
        "server_error",
        "rate_limit_exceeded",
        "invalid_prompt",
        "vector_store_timeout",
        "invalid_image",
        "invalid_image_format",
        "invalid_base64_image",
        "invalid_image_url",
        "image_too_large",
        "image_too_small",
        "image_parse_error",
        "image_content_policy_violation",
        "invalid_image_mode",
        "image_file_too_large",
        "unsupported_image_media_type",
        "empty_image_file",
        "failed_to_download_image",
        "image_file_not_found",
    ]

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseIncompleteDetails(BaseModel):
    reason: Optional[Literal["max_output_tokens", "content_filter"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1: TypeAlias = Union[
    ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText,
    ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage,
    ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile,
]


class ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessage(BaseModel):
    content: Union[
        str, List[ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1]
    ]

    role: Literal["user", "assistant", "system", "developer"]

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent: TypeAlias = Union[
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile,
]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage(BaseModel):
    content: List[
        ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent
    ]

    role: Literal["user", "system", "developer"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[
        ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation
    ]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[
            ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob
        ]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal(
    BaseModel
):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContent: TypeAlias = Union[
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseInProgressEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult]] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallAction: TypeAlias = Union[
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[
        ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck
    ]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput(
    BaseModel
):
    type: Literal["computer_screenshot"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck(
    BaseModel
):
    id: str

    code: Optional[str] = None

    message: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput(
    BaseModel
):
    call_id: str

    output: ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput

    type: Literal["computer_call_output"]

    id: Optional[str] = None

    acknowledged_safety_checks: Optional[
        List[
            ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck
        ]
    ] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput(
    BaseModel
):
    call_id: str

    output: str

    type: Literal["function_call_output"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseInProgressEventResponseInstructionsUnionMember1ResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseInProgressEventResponseInstructionsUnionMember1ResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall(
    BaseModel
):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[
        List[ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction(
    BaseModel
):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall(
    BaseModel
):
    id: str

    action: (
        ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction
    )

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput(
    BaseModel
):
    id: str

    output: str

    type: Literal["local_shell_call_output"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool(
    BaseModel
):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools(
    BaseModel
):
    id: str

    server_label: str

    tools: List[
        ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool
    ]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest(
    BaseModel
):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse(
    BaseModel
):
    approval_request_id: str

    approve: bool

    type: Literal["mcp_approval_response"]

    id: Optional[str] = None

    reason: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput(BaseModel):
    call_id: str

    output: str

    type: Literal["custom_tool_call_output"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1ResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference(
    BaseModel
):
    id: str

    type: Optional[Literal["item_reference"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseInstructionsUnionMember1: TypeAlias = Union[
    ResponseInProgressEventResponseInstructionsUnionMember1EasyInputMessage,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseOutputMessage,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseFileSearchToolCall,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseComputerToolCall,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionWebSearch,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseFunctionToolCall,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseReasoningItem,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput,
    ResponseInProgressEventResponseInstructionsUnionMember1ResponseCustomToolCall,
    ResponseInProgressEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference,
]


class ResponseInProgressEventResponsePromptVariablesResponseInputText(BaseModel):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponsePromptVariablesResponseInputImage(BaseModel):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponsePromptVariablesResponseInputFile(BaseModel):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponsePromptVariables: TypeAlias = Union[
    str,
    ResponseInProgressEventResponsePromptVariablesResponseInputText,
    ResponseInProgressEventResponsePromptVariablesResponseInputImage,
    ResponseInProgressEventResponsePromptVariablesResponseInputFile,
]


class ResponseInProgressEventResponsePrompt(BaseModel):
    id: str

    variables: Optional[Dict[str, ResponseInProgressEventResponsePromptVariables]] = None

    version: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseReasoning(BaseModel):
    effort: Optional[Literal["minimal", "low", "medium", "high"]] = None

    generate_summary: Optional[Literal["auto", "concise", "detailed"]] = None

    summary: Optional[Literal["auto", "concise", "detailed"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseTextFormatResponseFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseTextFormatResponseFormatTextJsonSchemaConfig(BaseModel):
    name: str

    schema_: Dict[str, object] = FieldInfo(alias="schema")

    type: Literal["json_schema"]

    description: Optional[str] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseTextFormatResponseFormatJsonObject(BaseModel):
    type: Literal["json_object"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseInProgressEventResponseTextFormat: TypeAlias = Union[
    ResponseInProgressEventResponseTextFormatResponseFormatText,
    ResponseInProgressEventResponseTextFormatResponseFormatTextJsonSchemaConfig,
    ResponseInProgressEventResponseTextFormatResponseFormatJsonObject,
]


class ResponseInProgressEventResponseText(BaseModel):
    format: Optional[ResponseInProgressEventResponseTextFormat] = None

    verbosity: Optional[Literal["low", "medium", "high"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseUsageInputTokensDetails(BaseModel):
    cached_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseUsageOutputTokensDetails(BaseModel):
    reasoning_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponseUsage(BaseModel):
    input_tokens: int

    input_tokens_details: ResponseInProgressEventResponseUsageInputTokensDetails

    output_tokens: int

    output_tokens_details: ResponseInProgressEventResponseUsageOutputTokensDetails

    total_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseInProgressEventResponse(BaseModel):
    id: str

    created_at: float

    model: Union[
        Literal[
            "gpt-5",
            "gpt-5-mini",
            "gpt-5-nano",
            "gpt-5-2025-08-07",
            "gpt-5-mini-2025-08-07",
            "gpt-5-nano-2025-08-07",
            "gpt-5-chat-latest",
            "gpt-4.1",
            "gpt-4.1-mini",
            "gpt-4.1-nano",
            "gpt-4.1-2025-04-14",
            "gpt-4.1-mini-2025-04-14",
            "gpt-4.1-nano-2025-04-14",
            "o4-mini",
            "o4-mini-2025-04-16",
            "o3",
            "o3-2025-04-16",
            "o3-mini",
            "o3-mini-2025-01-31",
            "o1",
            "o1-2024-12-17",
            "o1-preview",
            "o1-preview-2024-09-12",
            "o1-mini",
            "o1-mini-2024-09-12",
            "gpt-4o",
            "gpt-4o-2024-11-20",
            "gpt-4o-2024-08-06",
            "gpt-4o-2024-05-13",
            "gpt-4o-audio-preview",
            "gpt-4o-audio-preview-2024-10-01",
            "gpt-4o-audio-preview-2024-12-17",
            "gpt-4o-audio-preview-2025-06-03",
            "gpt-4o-mini-audio-preview",
            "gpt-4o-mini-audio-preview-2024-12-17",
            "gpt-4o-search-preview",
            "gpt-4o-mini-search-preview",
            "gpt-4o-search-preview-2025-03-11",
            "gpt-4o-mini-search-preview-2025-03-11",
            "chatgpt-4o-latest",
            "codex-mini-latest",
            "gpt-4o-mini",
            "gpt-4o-mini-2024-07-18",
            "gpt-4-turbo",
            "gpt-4-turbo-2024-04-09",
            "gpt-4-0125-preview",
            "gpt-4-turbo-preview",
            "gpt-4-1106-preview",
            "gpt-4-vision-preview",
            "gpt-4",
            "gpt-4-0314",
            "gpt-4-0613",
            "gpt-4-32k",
            "gpt-4-32k-0314",
            "gpt-4-32k-0613",
            "gpt-3.5-turbo",
            "gpt-3.5-turbo-16k",
            "gpt-3.5-turbo-0301",
            "gpt-3.5-turbo-0613",
            "gpt-3.5-turbo-1106",
            "gpt-3.5-turbo-0125",
            "gpt-3.5-turbo-16k-0613",
            "o1-pro",
            "o1-pro-2025-03-19",
            "o3-pro",
            "o3-pro-2025-06-10",
            "o3-deep-research",
            "o3-deep-research-2025-06-26",
            "o4-mini-deep-research",
            "o4-mini-deep-research-2025-06-26",
            "computer-use-preview",
            "computer-use-preview-2025-03-11",
        ],
        str,
    ]

    object: Literal["response"]

    output: List[ResponseInProgressEventResponseOutput]

    parallel_tool_calls: bool

    tool_choice: ResponseInProgressEventResponseToolChoice

    tools: List[ResponseInProgressEventResponseTool]

    background: Optional[bool] = None

    error: Optional[ResponseInProgressEventResponseError] = None

    incomplete_details: Optional[ResponseInProgressEventResponseIncompleteDetails] = None

    instructions: Union[str, List[ResponseInProgressEventResponseInstructionsUnionMember1], None] = None

    max_output_tokens: Optional[int] = None

    max_tool_calls: Optional[int] = None

    metadata: Optional[Dict[str, str]] = None

    previous_response_id: Optional[str] = None

    prompt: Optional[ResponseInProgressEventResponsePrompt] = None

    prompt_cache_key: Optional[str] = None

    reasoning: Optional[ResponseInProgressEventResponseReasoning] = None

    safety_identifier: Optional[str] = None

    service_tier: Optional[Literal["auto", "default", "flex", "scale", "priority"]] = None

    status: Optional[Literal["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]] = None

    temperature: Optional[float] = None

    text: Optional[ResponseInProgressEventResponseText] = None

    top_logprobs: Optional[int] = None

    top_p: Optional[float] = None

    truncation: Optional[Literal["auto", "disabled"]] = None

    usage: Optional[ResponseInProgressEventResponseUsage] = None

    user: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, builtins.object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> builtins.object: ...
    else:
        __pydantic_extra__: Dict[str, builtins.object]


class ResponseInProgressEvent(BaseModel):
    response: ResponseInProgressEventResponse

    sequence_number: int

    type: Literal["response.in_progress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[List[ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob]] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseOutputResponseOutputMessageContent: TypeAlias = Union[
    ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputText,
    ResponseFailedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseFailedEventResponseOutputResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseFailedEventResponseOutputResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseFailedEventResponseOutputResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseOutputResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseFailedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseFailedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseFailedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseFailedEventResponseOutputResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseFailedEventResponseOutputResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseOutputResponseComputerToolCallAction: TypeAlias = Union[
    ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseFailedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseFailedEventResponseOutputResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseFailedEventResponseOutputResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[ResponseFailedEventResponseOutputResponseComputerToolCallPendingSafetyCheck]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseFailedEventResponseOutputResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseFailedEventResponseOutputResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall(BaseModel):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseOutputResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseFailedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseFailedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseFailedEventResponseOutputResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[List[ResponseFailedEventResponseOutputResponseCodeInterpreterToolCallOutput]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction(BaseModel):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool(BaseModel):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseOutputResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseOutput: TypeAlias = Union[
    ResponseFailedEventResponseOutputResponseOutputMessage,
    ResponseFailedEventResponseOutputResponseFileSearchToolCall,
    ResponseFailedEventResponseOutputResponseFunctionToolCall,
    ResponseFailedEventResponseOutputResponseFunctionWebSearch,
    ResponseFailedEventResponseOutputResponseComputerToolCall,
    ResponseFailedEventResponseOutputResponseReasoningItem,
    ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall,
    ResponseFailedEventResponseOutputResponseCodeInterpreterToolCall,
    ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall,
    ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall,
    ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools,
    ResponseFailedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest,
    ResponseFailedEventResponseOutputResponseCustomToolCall,
]


class ResponseFailedEventResponseToolChoiceToolChoiceAllowed(BaseModel):
    mode: Literal["auto", "required"]

    tools: List[Dict[str, object]]

    type: Literal["allowed_tools"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolChoiceToolChoiceTypes(BaseModel):
    type: Literal[
        "file_search",
        "web_search_preview",
        "computer_use_preview",
        "web_search_preview_2025_03_11",
        "image_generation",
        "code_interpreter",
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolChoiceToolChoiceFunction(BaseModel):
    name: str

    type: Literal["function"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolChoiceToolChoiceMcp(BaseModel):
    server_label: str

    type: Literal["mcp"]

    name: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolChoiceToolChoiceCustom(BaseModel):
    name: str

    type: Literal["custom"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseToolChoice: TypeAlias = Union[
    Literal["none", "auto", "required"],
    ResponseFailedEventResponseToolChoiceToolChoiceAllowed,
    ResponseFailedEventResponseToolChoiceToolChoiceTypes,
    ResponseFailedEventResponseToolChoiceToolChoiceFunction,
    ResponseFailedEventResponseToolChoiceToolChoiceMcp,
    ResponseFailedEventResponseToolChoiceToolChoiceCustom,
]


class ResponseFailedEventResponseToolFunctionTool(BaseModel):
    name: str

    type: Literal["function"]

    description: Optional[str] = None

    parameters: Optional[Dict[str, object]] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolFileSearchToolFiltersComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseToolFileSearchToolFiltersCompoundFilterFilter: TypeAlias = Union[
    ResponseFailedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter, object
]


class ResponseFailedEventResponseToolFileSearchToolFiltersCompoundFilter(BaseModel):
    filters: List[ResponseFailedEventResponseToolFileSearchToolFiltersCompoundFilterFilter]

    type: Literal["and", "or"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseToolFileSearchToolFilters: TypeAlias = Union[
    ResponseFailedEventResponseToolFileSearchToolFiltersComparisonFilter,
    ResponseFailedEventResponseToolFileSearchToolFiltersCompoundFilter,
]


class ResponseFailedEventResponseToolFileSearchToolRankingOptions(BaseModel):
    ranker: Optional[Literal["auto", "default-2024-11-15"]] = None

    score_threshold: Optional[float] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolFileSearchTool(BaseModel):
    type: Literal["file_search"]

    vector_store_ids: List[str]

    filters: Optional[ResponseFailedEventResponseToolFileSearchToolFilters] = None

    max_num_results: Optional[int] = None

    ranking_options: Optional[ResponseFailedEventResponseToolFileSearchToolRankingOptions] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolWebSearchToolUserLocation(BaseModel):
    type: Literal["approximate"]

    city: Optional[str] = None

    country: Optional[str] = None

    region: Optional[str] = None

    timezone: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolWebSearchTool(BaseModel):
    type: Literal["web_search_preview", "web_search_preview_2025_03_11"]

    search_context_size: Optional[Literal["low", "medium", "high"]] = None

    user_location: Optional[ResponseFailedEventResponseToolWebSearchToolUserLocation] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolComputerTool(BaseModel):
    display_height: int

    display_width: int

    environment: Literal["windows", "mac", "linux", "ubuntu", "browser"]

    type: Literal["computer_use_preview"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseToolMcpAllowedTools: TypeAlias = Union[
    List[str], ResponseFailedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter
]


class ResponseFailedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter(BaseModel):
    always: Optional[ResponseFailedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways] = (
        None
    )

    never: Optional[ResponseFailedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseToolMcpRequireApproval: TypeAlias = Union[
    ResponseFailedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter, Literal["always", "never"]
]


class ResponseFailedEventResponseToolMcp(BaseModel):
    server_label: str

    server_url: str

    type: Literal["mcp"]

    allowed_tools: Optional[ResponseFailedEventResponseToolMcpAllowedTools] = None

    headers: Optional[Dict[str, str]] = None

    require_approval: Optional[ResponseFailedEventResponseToolMcpRequireApproval] = None

    server_description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto(BaseModel):
    type: Literal["auto"]

    file_ids: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseToolCodeInterpreterContainer: TypeAlias = Union[
    str, ResponseFailedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto
]


class ResponseFailedEventResponseToolCodeInterpreter(BaseModel):
    container: ResponseFailedEventResponseToolCodeInterpreterContainer

    type: Literal["code_interpreter"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolImageGenerationInputImageMask(BaseModel):
    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolImageGeneration(BaseModel):
    type: Literal["image_generation"]

    background: Optional[Literal["transparent", "opaque", "auto"]] = None

    input_fidelity: Optional[Literal["high", "low"]] = None

    input_image_mask: Optional[ResponseFailedEventResponseToolImageGenerationInputImageMask] = None

    model: Optional[Literal["gpt-image-1"]] = None

    moderation: Optional[Literal["auto", "low"]] = None

    output_compression: Optional[int] = None

    output_format: Optional[Literal["png", "webp", "jpeg"]] = None

    partial_images: Optional[int] = None

    quality: Optional[Literal["low", "medium", "high", "auto"]] = None

    size: Optional[Literal["1024x1024", "1024x1536", "1536x1024", "auto"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolLocalShell(BaseModel):
    type: Literal["local_shell"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolCustomToolFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseToolCustomToolFormatGrammar(BaseModel):
    definition: str

    syntax: Literal["lark", "regex"]

    type: Literal["grammar"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseToolCustomToolFormat: TypeAlias = Union[
    ResponseFailedEventResponseToolCustomToolFormatText, ResponseFailedEventResponseToolCustomToolFormatGrammar
]


class ResponseFailedEventResponseToolCustomTool(BaseModel):
    name: str

    type: Literal["custom"]

    description: Optional[str] = None

    format: Optional[ResponseFailedEventResponseToolCustomToolFormat] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseTool: TypeAlias = Union[
    ResponseFailedEventResponseToolFunctionTool,
    ResponseFailedEventResponseToolFileSearchTool,
    ResponseFailedEventResponseToolWebSearchTool,
    ResponseFailedEventResponseToolComputerTool,
    ResponseFailedEventResponseToolMcp,
    ResponseFailedEventResponseToolCodeInterpreter,
    ResponseFailedEventResponseToolImageGeneration,
    ResponseFailedEventResponseToolLocalShell,
    ResponseFailedEventResponseToolCustomTool,
]


class ResponseFailedEventResponseError(BaseModel):
    code: Literal[
        "server_error",
        "rate_limit_exceeded",
        "invalid_prompt",
        "vector_store_timeout",
        "invalid_image",
        "invalid_image_format",
        "invalid_base64_image",
        "invalid_image_url",
        "image_too_large",
        "image_too_small",
        "image_parse_error",
        "image_content_policy_violation",
        "invalid_image_mode",
        "image_file_too_large",
        "unsupported_image_media_type",
        "empty_image_file",
        "failed_to_download_image",
        "image_file_not_found",
    ]

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseIncompleteDetails(BaseModel):
    reason: Optional[Literal["max_output_tokens", "content_filter"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1: TypeAlias = Union[
    ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText,
    ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage,
    ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile,
]


class ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessage(BaseModel):
    content: Union[str, List[ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1]]

    role: Literal["user", "assistant", "system", "developer"]

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent: TypeAlias = Union[
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile,
]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage(BaseModel):
    content: List[
        ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent
    ]

    role: Literal["user", "system", "developer"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[
        ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation
    ]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContent: TypeAlias = Union[
    ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseFailedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction: TypeAlias = Union[
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[
        ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck
    ]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput(
    BaseModel
):
    type: Literal["computer_screenshot"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck(
    BaseModel
):
    id: str

    code: Optional[str] = None

    message: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput(
    BaseModel
):
    call_id: str

    output: (
        ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput
    )

    type: Literal["computer_call_output"]

    id: Optional[str] = None

    acknowledged_safety_checks: Optional[
        List[
            ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck
        ]
    ] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput(
    BaseModel
):
    call_id: str

    output: str

    type: Literal["function_call_output"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseFailedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseFailedEventResponseInstructionsUnionMember1ResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall(
    BaseModel
):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[
        List[ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction(
    BaseModel
):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput(
    BaseModel
):
    id: str

    output: str

    type: Literal["local_shell_call_output"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool(
    BaseModel
):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[
        ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool
    ]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest(
    BaseModel
):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse(
    BaseModel
):
    approval_request_id: str

    approve: bool

    type: Literal["mcp_approval_response"]

    id: Optional[str] = None

    reason: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput(BaseModel):
    call_id: str

    output: str

    type: Literal["custom_tool_call_output"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1ResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference(BaseModel):
    id: str

    type: Optional[Literal["item_reference"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseInstructionsUnionMember1: TypeAlias = Union[
    ResponseFailedEventResponseInstructionsUnionMember1EasyInputMessage,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseOutputMessage,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseComputerToolCall,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseFunctionToolCall,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseReasoningItem,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput,
    ResponseFailedEventResponseInstructionsUnionMember1ResponseCustomToolCall,
    ResponseFailedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference,
]


class ResponseFailedEventResponsePromptVariablesResponseInputText(BaseModel):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponsePromptVariablesResponseInputImage(BaseModel):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponsePromptVariablesResponseInputFile(BaseModel):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponsePromptVariables: TypeAlias = Union[
    str,
    ResponseFailedEventResponsePromptVariablesResponseInputText,
    ResponseFailedEventResponsePromptVariablesResponseInputImage,
    ResponseFailedEventResponsePromptVariablesResponseInputFile,
]


class ResponseFailedEventResponsePrompt(BaseModel):
    id: str

    variables: Optional[Dict[str, ResponseFailedEventResponsePromptVariables]] = None

    version: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseReasoning(BaseModel):
    effort: Optional[Literal["minimal", "low", "medium", "high"]] = None

    generate_summary: Optional[Literal["auto", "concise", "detailed"]] = None

    summary: Optional[Literal["auto", "concise", "detailed"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseTextFormatResponseFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseTextFormatResponseFormatTextJsonSchemaConfig(BaseModel):
    name: str

    schema_: Dict[str, object] = FieldInfo(alias="schema")

    type: Literal["json_schema"]

    description: Optional[str] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseTextFormatResponseFormatJsonObject(BaseModel):
    type: Literal["json_object"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseFailedEventResponseTextFormat: TypeAlias = Union[
    ResponseFailedEventResponseTextFormatResponseFormatText,
    ResponseFailedEventResponseTextFormatResponseFormatTextJsonSchemaConfig,
    ResponseFailedEventResponseTextFormatResponseFormatJsonObject,
]


class ResponseFailedEventResponseText(BaseModel):
    format: Optional[ResponseFailedEventResponseTextFormat] = None

    verbosity: Optional[Literal["low", "medium", "high"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseUsageInputTokensDetails(BaseModel):
    cached_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseUsageOutputTokensDetails(BaseModel):
    reasoning_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponseUsage(BaseModel):
    input_tokens: int

    input_tokens_details: ResponseFailedEventResponseUsageInputTokensDetails

    output_tokens: int

    output_tokens_details: ResponseFailedEventResponseUsageOutputTokensDetails

    total_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseFailedEventResponse(BaseModel):
    id: str

    created_at: float

    model: Union[
        Literal[
            "gpt-5",
            "gpt-5-mini",
            "gpt-5-nano",
            "gpt-5-2025-08-07",
            "gpt-5-mini-2025-08-07",
            "gpt-5-nano-2025-08-07",
            "gpt-5-chat-latest",
            "gpt-4.1",
            "gpt-4.1-mini",
            "gpt-4.1-nano",
            "gpt-4.1-2025-04-14",
            "gpt-4.1-mini-2025-04-14",
            "gpt-4.1-nano-2025-04-14",
            "o4-mini",
            "o4-mini-2025-04-16",
            "o3",
            "o3-2025-04-16",
            "o3-mini",
            "o3-mini-2025-01-31",
            "o1",
            "o1-2024-12-17",
            "o1-preview",
            "o1-preview-2024-09-12",
            "o1-mini",
            "o1-mini-2024-09-12",
            "gpt-4o",
            "gpt-4o-2024-11-20",
            "gpt-4o-2024-08-06",
            "gpt-4o-2024-05-13",
            "gpt-4o-audio-preview",
            "gpt-4o-audio-preview-2024-10-01",
            "gpt-4o-audio-preview-2024-12-17",
            "gpt-4o-audio-preview-2025-06-03",
            "gpt-4o-mini-audio-preview",
            "gpt-4o-mini-audio-preview-2024-12-17",
            "gpt-4o-search-preview",
            "gpt-4o-mini-search-preview",
            "gpt-4o-search-preview-2025-03-11",
            "gpt-4o-mini-search-preview-2025-03-11",
            "chatgpt-4o-latest",
            "codex-mini-latest",
            "gpt-4o-mini",
            "gpt-4o-mini-2024-07-18",
            "gpt-4-turbo",
            "gpt-4-turbo-2024-04-09",
            "gpt-4-0125-preview",
            "gpt-4-turbo-preview",
            "gpt-4-1106-preview",
            "gpt-4-vision-preview",
            "gpt-4",
            "gpt-4-0314",
            "gpt-4-0613",
            "gpt-4-32k",
            "gpt-4-32k-0314",
            "gpt-4-32k-0613",
            "gpt-3.5-turbo",
            "gpt-3.5-turbo-16k",
            "gpt-3.5-turbo-0301",
            "gpt-3.5-turbo-0613",
            "gpt-3.5-turbo-1106",
            "gpt-3.5-turbo-0125",
            "gpt-3.5-turbo-16k-0613",
            "o1-pro",
            "o1-pro-2025-03-19",
            "o3-pro",
            "o3-pro-2025-06-10",
            "o3-deep-research",
            "o3-deep-research-2025-06-26",
            "o4-mini-deep-research",
            "o4-mini-deep-research-2025-06-26",
            "computer-use-preview",
            "computer-use-preview-2025-03-11",
        ],
        str,
    ]

    object: Literal["response"]

    output: List[ResponseFailedEventResponseOutput]

    parallel_tool_calls: bool

    tool_choice: ResponseFailedEventResponseToolChoice

    tools: List[ResponseFailedEventResponseTool]

    background: Optional[bool] = None

    error: Optional[ResponseFailedEventResponseError] = None

    incomplete_details: Optional[ResponseFailedEventResponseIncompleteDetails] = None

    instructions: Union[str, List[ResponseFailedEventResponseInstructionsUnionMember1], None] = None

    max_output_tokens: Optional[int] = None

    max_tool_calls: Optional[int] = None

    metadata: Optional[Dict[str, str]] = None

    previous_response_id: Optional[str] = None

    prompt: Optional[ResponseFailedEventResponsePrompt] = None

    prompt_cache_key: Optional[str] = None

    reasoning: Optional[ResponseFailedEventResponseReasoning] = None

    safety_identifier: Optional[str] = None

    service_tier: Optional[Literal["auto", "default", "flex", "scale", "priority"]] = None

    status: Optional[Literal["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]] = None

    temperature: Optional[float] = None

    text: Optional[ResponseFailedEventResponseText] = None

    top_logprobs: Optional[int] = None

    top_p: Optional[float] = None

    truncation: Optional[Literal["auto", "disabled"]] = None

    usage: Optional[ResponseFailedEventResponseUsage] = None

    user: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, builtins.object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> builtins.object: ...
    else:
        __pydantic_extra__: Dict[str, builtins.object]


class ResponseFailedEvent(BaseModel):
    response: ResponseFailedEventResponse

    sequence_number: int

    type: Literal["response.failed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseOutputResponseOutputMessageContent: TypeAlias = Union[
    ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputText,
    ResponseIncompleteEventResponseOutputResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseIncompleteEventResponseOutputResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseIncompleteEventResponseOutputResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseIncompleteEventResponseOutputResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseOutputResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseIncompleteEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseIncompleteEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseIncompleteEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseIncompleteEventResponseOutputResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseIncompleteEventResponseOutputResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseOutputResponseComputerToolCallAction: TypeAlias = Union[
    ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseIncompleteEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseIncompleteEventResponseOutputResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseIncompleteEventResponseOutputResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[ResponseIncompleteEventResponseOutputResponseComputerToolCallPendingSafetyCheck]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseIncompleteEventResponseOutputResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseIncompleteEventResponseOutputResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall(BaseModel):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[List[ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCallOutput]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction(BaseModel):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool(BaseModel):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseOutputResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseOutput: TypeAlias = Union[
    ResponseIncompleteEventResponseOutputResponseOutputMessage,
    ResponseIncompleteEventResponseOutputResponseFileSearchToolCall,
    ResponseIncompleteEventResponseOutputResponseFunctionToolCall,
    ResponseIncompleteEventResponseOutputResponseFunctionWebSearch,
    ResponseIncompleteEventResponseOutputResponseComputerToolCall,
    ResponseIncompleteEventResponseOutputResponseReasoningItem,
    ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall,
    ResponseIncompleteEventResponseOutputResponseCodeInterpreterToolCall,
    ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall,
    ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall,
    ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools,
    ResponseIncompleteEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest,
    ResponseIncompleteEventResponseOutputResponseCustomToolCall,
]


class ResponseIncompleteEventResponseToolChoiceToolChoiceAllowed(BaseModel):
    mode: Literal["auto", "required"]

    tools: List[Dict[str, object]]

    type: Literal["allowed_tools"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolChoiceToolChoiceTypes(BaseModel):
    type: Literal[
        "file_search",
        "web_search_preview",
        "computer_use_preview",
        "web_search_preview_2025_03_11",
        "image_generation",
        "code_interpreter",
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolChoiceToolChoiceFunction(BaseModel):
    name: str

    type: Literal["function"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolChoiceToolChoiceMcp(BaseModel):
    server_label: str

    type: Literal["mcp"]

    name: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolChoiceToolChoiceCustom(BaseModel):
    name: str

    type: Literal["custom"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseToolChoice: TypeAlias = Union[
    Literal["none", "auto", "required"],
    ResponseIncompleteEventResponseToolChoiceToolChoiceAllowed,
    ResponseIncompleteEventResponseToolChoiceToolChoiceTypes,
    ResponseIncompleteEventResponseToolChoiceToolChoiceFunction,
    ResponseIncompleteEventResponseToolChoiceToolChoiceMcp,
    ResponseIncompleteEventResponseToolChoiceToolChoiceCustom,
]


class ResponseIncompleteEventResponseToolFunctionTool(BaseModel):
    name: str

    type: Literal["function"]

    description: Optional[str] = None

    parameters: Optional[Dict[str, object]] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolFileSearchToolFiltersComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseToolFileSearchToolFiltersCompoundFilterFilter: TypeAlias = Union[
    ResponseIncompleteEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter, object
]


class ResponseIncompleteEventResponseToolFileSearchToolFiltersCompoundFilter(BaseModel):
    filters: List[ResponseIncompleteEventResponseToolFileSearchToolFiltersCompoundFilterFilter]

    type: Literal["and", "or"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseToolFileSearchToolFilters: TypeAlias = Union[
    ResponseIncompleteEventResponseToolFileSearchToolFiltersComparisonFilter,
    ResponseIncompleteEventResponseToolFileSearchToolFiltersCompoundFilter,
]


class ResponseIncompleteEventResponseToolFileSearchToolRankingOptions(BaseModel):
    ranker: Optional[Literal["auto", "default-2024-11-15"]] = None

    score_threshold: Optional[float] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolFileSearchTool(BaseModel):
    type: Literal["file_search"]

    vector_store_ids: List[str]

    filters: Optional[ResponseIncompleteEventResponseToolFileSearchToolFilters] = None

    max_num_results: Optional[int] = None

    ranking_options: Optional[ResponseIncompleteEventResponseToolFileSearchToolRankingOptions] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolWebSearchToolUserLocation(BaseModel):
    type: Literal["approximate"]

    city: Optional[str] = None

    country: Optional[str] = None

    region: Optional[str] = None

    timezone: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolWebSearchTool(BaseModel):
    type: Literal["web_search_preview", "web_search_preview_2025_03_11"]

    search_context_size: Optional[Literal["low", "medium", "high"]] = None

    user_location: Optional[ResponseIncompleteEventResponseToolWebSearchToolUserLocation] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolComputerTool(BaseModel):
    display_height: int

    display_width: int

    environment: Literal["windows", "mac", "linux", "ubuntu", "browser"]

    type: Literal["computer_use_preview"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseToolMcpAllowedTools: TypeAlias = Union[
    List[str], ResponseIncompleteEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter
]


class ResponseIncompleteEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter(BaseModel):
    always: Optional[
        ResponseIncompleteEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways
    ] = None

    never: Optional[
        ResponseIncompleteEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseToolMcpRequireApproval: TypeAlias = Union[
    ResponseIncompleteEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter,
    Literal["always", "never"],
]


class ResponseIncompleteEventResponseToolMcp(BaseModel):
    server_label: str

    server_url: str

    type: Literal["mcp"]

    allowed_tools: Optional[ResponseIncompleteEventResponseToolMcpAllowedTools] = None

    headers: Optional[Dict[str, str]] = None

    require_approval: Optional[ResponseIncompleteEventResponseToolMcpRequireApproval] = None

    server_description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto(
    BaseModel
):
    type: Literal["auto"]

    file_ids: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseToolCodeInterpreterContainer: TypeAlias = Union[
    str, ResponseIncompleteEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto
]


class ResponseIncompleteEventResponseToolCodeInterpreter(BaseModel):
    container: ResponseIncompleteEventResponseToolCodeInterpreterContainer

    type: Literal["code_interpreter"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolImageGenerationInputImageMask(BaseModel):
    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolImageGeneration(BaseModel):
    type: Literal["image_generation"]

    background: Optional[Literal["transparent", "opaque", "auto"]] = None

    input_fidelity: Optional[Literal["high", "low"]] = None

    input_image_mask: Optional[ResponseIncompleteEventResponseToolImageGenerationInputImageMask] = None

    model: Optional[Literal["gpt-image-1"]] = None

    moderation: Optional[Literal["auto", "low"]] = None

    output_compression: Optional[int] = None

    output_format: Optional[Literal["png", "webp", "jpeg"]] = None

    partial_images: Optional[int] = None

    quality: Optional[Literal["low", "medium", "high", "auto"]] = None

    size: Optional[Literal["1024x1024", "1024x1536", "1536x1024", "auto"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolLocalShell(BaseModel):
    type: Literal["local_shell"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolCustomToolFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseToolCustomToolFormatGrammar(BaseModel):
    definition: str

    syntax: Literal["lark", "regex"]

    type: Literal["grammar"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseToolCustomToolFormat: TypeAlias = Union[
    ResponseIncompleteEventResponseToolCustomToolFormatText, ResponseIncompleteEventResponseToolCustomToolFormatGrammar
]


class ResponseIncompleteEventResponseToolCustomTool(BaseModel):
    name: str

    type: Literal["custom"]

    description: Optional[str] = None

    format: Optional[ResponseIncompleteEventResponseToolCustomToolFormat] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseTool: TypeAlias = Union[
    ResponseIncompleteEventResponseToolFunctionTool,
    ResponseIncompleteEventResponseToolFileSearchTool,
    ResponseIncompleteEventResponseToolWebSearchTool,
    ResponseIncompleteEventResponseToolComputerTool,
    ResponseIncompleteEventResponseToolMcp,
    ResponseIncompleteEventResponseToolCodeInterpreter,
    ResponseIncompleteEventResponseToolImageGeneration,
    ResponseIncompleteEventResponseToolLocalShell,
    ResponseIncompleteEventResponseToolCustomTool,
]


class ResponseIncompleteEventResponseError(BaseModel):
    code: Literal[
        "server_error",
        "rate_limit_exceeded",
        "invalid_prompt",
        "vector_store_timeout",
        "invalid_image",
        "invalid_image_format",
        "invalid_base64_image",
        "invalid_image_url",
        "image_too_large",
        "image_too_small",
        "image_parse_error",
        "image_content_policy_violation",
        "invalid_image_mode",
        "image_file_too_large",
        "unsupported_image_media_type",
        "empty_image_file",
        "failed_to_download_image",
        "image_file_not_found",
    ]

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseIncompleteDetails(BaseModel):
    reason: Optional[Literal["max_output_tokens", "content_filter"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1: TypeAlias = Union[
    ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText,
    ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage,
    ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile,
]


class ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessage(BaseModel):
    content: Union[
        str, List[ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1]
    ]

    role: Literal["user", "assistant", "system", "developer"]

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent: TypeAlias = Union[
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile,
]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage(BaseModel):
    content: List[
        ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent
    ]

    role: Literal["user", "system", "developer"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[
        ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation
    ]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[
            ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob
        ]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal(
    BaseModel
):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContent: TypeAlias = Union[
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult]] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallAction: TypeAlias = Union[
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[
        ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck
    ]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput(
    BaseModel
):
    type: Literal["computer_screenshot"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck(
    BaseModel
):
    id: str

    code: Optional[str] = None

    message: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput(
    BaseModel
):
    call_id: str

    output: ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput

    type: Literal["computer_call_output"]

    id: Optional[str] = None

    acknowledged_safety_checks: Optional[
        List[
            ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck
        ]
    ] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput(
    BaseModel
):
    call_id: str

    output: str

    type: Literal["function_call_output"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseIncompleteEventResponseInstructionsUnionMember1ResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseIncompleteEventResponseInstructionsUnionMember1ResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall(
    BaseModel
):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[
        List[ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction(
    BaseModel
):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall(
    BaseModel
):
    id: str

    action: (
        ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction
    )

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput(
    BaseModel
):
    id: str

    output: str

    type: Literal["local_shell_call_output"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool(
    BaseModel
):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools(
    BaseModel
):
    id: str

    server_label: str

    tools: List[
        ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool
    ]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest(
    BaseModel
):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse(
    BaseModel
):
    approval_request_id: str

    approve: bool

    type: Literal["mcp_approval_response"]

    id: Optional[str] = None

    reason: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput(BaseModel):
    call_id: str

    output: str

    type: Literal["custom_tool_call_output"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference(
    BaseModel
):
    id: str

    type: Optional[Literal["item_reference"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseInstructionsUnionMember1: TypeAlias = Union[
    ResponseIncompleteEventResponseInstructionsUnionMember1EasyInputMessage,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseOutputMessage,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFileSearchToolCall,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseComputerToolCall,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionWebSearch,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseFunctionToolCall,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseReasoningItem,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput,
    ResponseIncompleteEventResponseInstructionsUnionMember1ResponseCustomToolCall,
    ResponseIncompleteEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference,
]


class ResponseIncompleteEventResponsePromptVariablesResponseInputText(BaseModel):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponsePromptVariablesResponseInputImage(BaseModel):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponsePromptVariablesResponseInputFile(BaseModel):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponsePromptVariables: TypeAlias = Union[
    str,
    ResponseIncompleteEventResponsePromptVariablesResponseInputText,
    ResponseIncompleteEventResponsePromptVariablesResponseInputImage,
    ResponseIncompleteEventResponsePromptVariablesResponseInputFile,
]


class ResponseIncompleteEventResponsePrompt(BaseModel):
    id: str

    variables: Optional[Dict[str, ResponseIncompleteEventResponsePromptVariables]] = None

    version: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseReasoning(BaseModel):
    effort: Optional[Literal["minimal", "low", "medium", "high"]] = None

    generate_summary: Optional[Literal["auto", "concise", "detailed"]] = None

    summary: Optional[Literal["auto", "concise", "detailed"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseTextFormatResponseFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseTextFormatResponseFormatTextJsonSchemaConfig(BaseModel):
    name: str

    schema_: Dict[str, object] = FieldInfo(alias="schema")

    type: Literal["json_schema"]

    description: Optional[str] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseTextFormatResponseFormatJsonObject(BaseModel):
    type: Literal["json_object"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseIncompleteEventResponseTextFormat: TypeAlias = Union[
    ResponseIncompleteEventResponseTextFormatResponseFormatText,
    ResponseIncompleteEventResponseTextFormatResponseFormatTextJsonSchemaConfig,
    ResponseIncompleteEventResponseTextFormatResponseFormatJsonObject,
]


class ResponseIncompleteEventResponseText(BaseModel):
    format: Optional[ResponseIncompleteEventResponseTextFormat] = None

    verbosity: Optional[Literal["low", "medium", "high"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseUsageInputTokensDetails(BaseModel):
    cached_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseUsageOutputTokensDetails(BaseModel):
    reasoning_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponseUsage(BaseModel):
    input_tokens: int

    input_tokens_details: ResponseIncompleteEventResponseUsageInputTokensDetails

    output_tokens: int

    output_tokens_details: ResponseIncompleteEventResponseUsageOutputTokensDetails

    total_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseIncompleteEventResponse(BaseModel):
    id: str

    created_at: float

    model: Union[
        Literal[
            "gpt-5",
            "gpt-5-mini",
            "gpt-5-nano",
            "gpt-5-2025-08-07",
            "gpt-5-mini-2025-08-07",
            "gpt-5-nano-2025-08-07",
            "gpt-5-chat-latest",
            "gpt-4.1",
            "gpt-4.1-mini",
            "gpt-4.1-nano",
            "gpt-4.1-2025-04-14",
            "gpt-4.1-mini-2025-04-14",
            "gpt-4.1-nano-2025-04-14",
            "o4-mini",
            "o4-mini-2025-04-16",
            "o3",
            "o3-2025-04-16",
            "o3-mini",
            "o3-mini-2025-01-31",
            "o1",
            "o1-2024-12-17",
            "o1-preview",
            "o1-preview-2024-09-12",
            "o1-mini",
            "o1-mini-2024-09-12",
            "gpt-4o",
            "gpt-4o-2024-11-20",
            "gpt-4o-2024-08-06",
            "gpt-4o-2024-05-13",
            "gpt-4o-audio-preview",
            "gpt-4o-audio-preview-2024-10-01",
            "gpt-4o-audio-preview-2024-12-17",
            "gpt-4o-audio-preview-2025-06-03",
            "gpt-4o-mini-audio-preview",
            "gpt-4o-mini-audio-preview-2024-12-17",
            "gpt-4o-search-preview",
            "gpt-4o-mini-search-preview",
            "gpt-4o-search-preview-2025-03-11",
            "gpt-4o-mini-search-preview-2025-03-11",
            "chatgpt-4o-latest",
            "codex-mini-latest",
            "gpt-4o-mini",
            "gpt-4o-mini-2024-07-18",
            "gpt-4-turbo",
            "gpt-4-turbo-2024-04-09",
            "gpt-4-0125-preview",
            "gpt-4-turbo-preview",
            "gpt-4-1106-preview",
            "gpt-4-vision-preview",
            "gpt-4",
            "gpt-4-0314",
            "gpt-4-0613",
            "gpt-4-32k",
            "gpt-4-32k-0314",
            "gpt-4-32k-0613",
            "gpt-3.5-turbo",
            "gpt-3.5-turbo-16k",
            "gpt-3.5-turbo-0301",
            "gpt-3.5-turbo-0613",
            "gpt-3.5-turbo-1106",
            "gpt-3.5-turbo-0125",
            "gpt-3.5-turbo-16k-0613",
            "o1-pro",
            "o1-pro-2025-03-19",
            "o3-pro",
            "o3-pro-2025-06-10",
            "o3-deep-research",
            "o3-deep-research-2025-06-26",
            "o4-mini-deep-research",
            "o4-mini-deep-research-2025-06-26",
            "computer-use-preview",
            "computer-use-preview-2025-03-11",
        ],
        str,
    ]

    object: Literal["response"]

    output: List[ResponseIncompleteEventResponseOutput]

    parallel_tool_calls: bool

    tool_choice: ResponseIncompleteEventResponseToolChoice

    tools: List[ResponseIncompleteEventResponseTool]

    background: Optional[bool] = None

    error: Optional[ResponseIncompleteEventResponseError] = None

    incomplete_details: Optional[ResponseIncompleteEventResponseIncompleteDetails] = None

    instructions: Union[str, List[ResponseIncompleteEventResponseInstructionsUnionMember1], None] = None

    max_output_tokens: Optional[int] = None

    max_tool_calls: Optional[int] = None

    metadata: Optional[Dict[str, str]] = None

    previous_response_id: Optional[str] = None

    prompt: Optional[ResponseIncompleteEventResponsePrompt] = None

    prompt_cache_key: Optional[str] = None

    reasoning: Optional[ResponseIncompleteEventResponseReasoning] = None

    safety_identifier: Optional[str] = None

    service_tier: Optional[Literal["auto", "default", "flex", "scale", "priority"]] = None

    status: Optional[Literal["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]] = None

    temperature: Optional[float] = None

    text: Optional[ResponseIncompleteEventResponseText] = None

    top_logprobs: Optional[int] = None

    top_p: Optional[float] = None

    truncation: Optional[Literal["auto", "disabled"]] = None

    usage: Optional[ResponseIncompleteEventResponseUsage] = None

    user: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, builtins.object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> builtins.object: ...
    else:
        __pydantic_extra__: Dict[str, builtins.object]


class ResponseIncompleteEvent(BaseModel):
    response: ResponseIncompleteEventResponse

    sequence_number: int

    type: Literal["response.incomplete"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextLogprobTopLogprob]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[List[ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputTextLogprob]] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemAddedEventItemResponseOutputMessageContent: TypeAlias = Union[
    ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputText,
    ResponseOutputItemAddedEventItemResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseOutputItemAddedEventItemResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseOutputItemAddedEventItemResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseOutputItemAddedEventItemResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemAddedEventItemResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseOutputItemAddedEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseOutputItemAddedEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseOutputItemAddedEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseOutputItemAddedEventItemResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseOutputItemAddedEventItemResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemAddedEventItemResponseComputerToolCallAction: TypeAlias = Union[
    ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseOutputItemAddedEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseOutputItemAddedEventItemResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseOutputItemAddedEventItemResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[ResponseOutputItemAddedEventItemResponseComputerToolCallPendingSafetyCheck]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseOutputItemAddedEventItemResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseOutputItemAddedEventItemResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemImageGenerationCall(BaseModel):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[List[ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCallOutput]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemLocalShellCallAction(BaseModel):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpListToolsTool(BaseModel):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpListToolsTool]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpApprovalRequest(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemAddedEventItemResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemAddedEventItem: TypeAlias = Union[
    ResponseOutputItemAddedEventItemResponseOutputMessage,
    ResponseOutputItemAddedEventItemResponseFileSearchToolCall,
    ResponseOutputItemAddedEventItemResponseFunctionToolCall,
    ResponseOutputItemAddedEventItemResponseFunctionWebSearch,
    ResponseOutputItemAddedEventItemResponseComputerToolCall,
    ResponseOutputItemAddedEventItemResponseReasoningItem,
    ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemImageGenerationCall,
    ResponseOutputItemAddedEventItemResponseCodeInterpreterToolCall,
    ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemLocalShellCall,
    ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpCall,
    ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpListTools,
    ResponseOutputItemAddedEventItemOpenAITypesResponsesResponseOutputItemMcpApprovalRequest,
    ResponseOutputItemAddedEventItemResponseCustomToolCall,
]


class ResponseOutputItemAddedEvent(BaseModel):
    item: ResponseOutputItemAddedEventItem

    output_index: int

    sequence_number: int

    type: Literal["response.output_item.added"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextLogprobTopLogprob]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[List[ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputTextLogprob]] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemDoneEventItemResponseOutputMessageContent: TypeAlias = Union[
    ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputText,
    ResponseOutputItemDoneEventItemResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseOutputItemDoneEventItemResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseOutputItemDoneEventItemResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseOutputItemDoneEventItemResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemDoneEventItemResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseOutputItemDoneEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseOutputItemDoneEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseOutputItemDoneEventItemResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseOutputItemDoneEventItemResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseOutputItemDoneEventItemResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemDoneEventItemResponseComputerToolCallAction: TypeAlias = Union[
    ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseOutputItemDoneEventItemResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseOutputItemDoneEventItemResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseOutputItemDoneEventItemResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[ResponseOutputItemDoneEventItemResponseComputerToolCallPendingSafetyCheck]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseOutputItemDoneEventItemResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseOutputItemDoneEventItemResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemImageGenerationCall(BaseModel):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[List[ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCallOutput]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemLocalShellCallAction(BaseModel):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpListToolsTool(BaseModel):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpListToolsTool]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpApprovalRequest(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputItemDoneEventItemResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseOutputItemDoneEventItem: TypeAlias = Union[
    ResponseOutputItemDoneEventItemResponseOutputMessage,
    ResponseOutputItemDoneEventItemResponseFileSearchToolCall,
    ResponseOutputItemDoneEventItemResponseFunctionToolCall,
    ResponseOutputItemDoneEventItemResponseFunctionWebSearch,
    ResponseOutputItemDoneEventItemResponseComputerToolCall,
    ResponseOutputItemDoneEventItemResponseReasoningItem,
    ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemImageGenerationCall,
    ResponseOutputItemDoneEventItemResponseCodeInterpreterToolCall,
    ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemLocalShellCall,
    ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpCall,
    ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpListTools,
    ResponseOutputItemDoneEventItemOpenAITypesResponsesResponseOutputItemMcpApprovalRequest,
    ResponseOutputItemDoneEventItemResponseCustomToolCall,
]


class ResponseOutputItemDoneEvent(BaseModel):
    item: ResponseOutputItemDoneEventItem

    output_index: int

    sequence_number: int

    type: Literal["response.output_item.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseReasoningSummaryPartAddedEventPart(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseReasoningSummaryPartAddedEvent(BaseModel):
    item_id: str

    output_index: int

    part: ResponseReasoningSummaryPartAddedEventPart

    sequence_number: int

    summary_index: int

    type: Literal["response.reasoning_summary_part.added"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseReasoningSummaryPartDoneEventPart(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseReasoningSummaryPartDoneEvent(BaseModel):
    item_id: str

    output_index: int

    part: ResponseReasoningSummaryPartDoneEventPart

    sequence_number: int

    summary_index: int

    type: Literal["response.reasoning_summary_part.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseReasoningSummaryTextDeltaEvent(BaseModel):
    delta: str

    item_id: str

    output_index: int

    sequence_number: int

    summary_index: int

    type: Literal["response.reasoning_summary_text.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseReasoningSummaryTextDoneEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    summary_index: int

    text: str

    type: Literal["response.reasoning_summary_text.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseReasoningTextDeltaEvent(BaseModel):
    content_index: int

    delta: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.reasoning_text.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseReasoningTextDoneEvent(BaseModel):
    content_index: int

    item_id: str

    output_index: int

    sequence_number: int

    text: str

    type: Literal["response.reasoning_text.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseRefusalDeltaEvent(BaseModel):
    content_index: int

    delta: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.refusal.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseRefusalDoneEvent(BaseModel):
    content_index: int

    item_id: str

    output_index: int

    refusal: str

    sequence_number: int

    type: Literal["response.refusal.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseTextDeltaEventLogprobTopLogprob(BaseModel):
    token: Optional[str] = None

    logprob: Optional[float] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseTextDeltaEventLogprob(BaseModel):
    token: str

    logprob: float

    top_logprobs: Optional[List[ResponseTextDeltaEventLogprobTopLogprob]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseTextDeltaEvent(BaseModel):
    content_index: int

    delta: str

    item_id: str

    logprobs: List[ResponseTextDeltaEventLogprob]

    output_index: int

    sequence_number: int

    type: Literal["response.output_text.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseTextDoneEventLogprobTopLogprob(BaseModel):
    token: Optional[str] = None

    logprob: Optional[float] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseTextDoneEventLogprob(BaseModel):
    token: str

    logprob: float

    top_logprobs: Optional[List[ResponseTextDoneEventLogprobTopLogprob]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseTextDoneEvent(BaseModel):
    content_index: int

    item_id: str

    logprobs: List[ResponseTextDoneEventLogprob]

    output_index: int

    sequence_number: int

    text: str

    type: Literal["response.output_text.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseWebSearchCallCompletedEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.web_search_call.completed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseWebSearchCallInProgressEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.web_search_call.in_progress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseWebSearchCallSearchingEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.web_search_call.searching"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseImageGenCallCompletedEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.image_generation_call.completed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseImageGenCallGeneratingEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.image_generation_call.generating"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseImageGenCallInProgressEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.image_generation_call.in_progress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseImageGenCallPartialImageEvent(BaseModel):
    item_id: str

    output_index: int

    partial_image_b64: str

    partial_image_index: int

    sequence_number: int

    type: Literal["response.image_generation_call.partial_image"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseMcpCallArgumentsDeltaEvent(BaseModel):
    delta: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.mcp_call_arguments.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseMcpCallArgumentsDoneEvent(BaseModel):
    arguments: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.mcp_call_arguments.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseMcpCallCompletedEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.mcp_call.completed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseMcpCallFailedEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.mcp_call.failed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseMcpCallInProgressEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.mcp_call.in_progress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseMcpListToolsCompletedEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.mcp_list_tools.completed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseMcpListToolsFailedEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.mcp_list_tools.failed"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseMcpListToolsInProgressEvent(BaseModel):
    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.mcp_list_tools.in_progress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseOutputTextAnnotationAddedEvent(BaseModel):
    annotation: object

    annotation_index: int

    content_index: int

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.output_text.annotation.added"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob(BaseModel):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprobTopLogprob]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextAnnotation]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[List[ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputTextLogprob]] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseOutputResponseOutputMessageContent: TypeAlias = Union[
    ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputText,
    ResponseQueuedEventResponseOutputResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseQueuedEventResponseOutputResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseQueuedEventResponseOutputResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseQueuedEventResponseOutputResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseOutputResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseQueuedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseQueuedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseQueuedEventResponseOutputResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseQueuedEventResponseOutputResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseQueuedEventResponseOutputResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseOutputResponseComputerToolCallAction: TypeAlias = Union[
    ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseQueuedEventResponseOutputResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseQueuedEventResponseOutputResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseQueuedEventResponseOutputResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[ResponseQueuedEventResponseOutputResponseComputerToolCallPendingSafetyCheck]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseQueuedEventResponseOutputResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseQueuedEventResponseOutputResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall(BaseModel):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[List[ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCallOutput]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction(BaseModel):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool(BaseModel):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListToolsTool]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseOutputResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseOutput: TypeAlias = Union[
    ResponseQueuedEventResponseOutputResponseOutputMessage,
    ResponseQueuedEventResponseOutputResponseFileSearchToolCall,
    ResponseQueuedEventResponseOutputResponseFunctionToolCall,
    ResponseQueuedEventResponseOutputResponseFunctionWebSearch,
    ResponseQueuedEventResponseOutputResponseComputerToolCall,
    ResponseQueuedEventResponseOutputResponseReasoningItem,
    ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemImageGenerationCall,
    ResponseQueuedEventResponseOutputResponseCodeInterpreterToolCall,
    ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemLocalShellCall,
    ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpCall,
    ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpListTools,
    ResponseQueuedEventResponseOutputOpenAITypesResponsesResponseOutputItemMcpApprovalRequest,
    ResponseQueuedEventResponseOutputResponseCustomToolCall,
]


class ResponseQueuedEventResponseToolChoiceToolChoiceAllowed(BaseModel):
    mode: Literal["auto", "required"]

    tools: List[Dict[str, object]]

    type: Literal["allowed_tools"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolChoiceToolChoiceTypes(BaseModel):
    type: Literal[
        "file_search",
        "web_search_preview",
        "computer_use_preview",
        "web_search_preview_2025_03_11",
        "image_generation",
        "code_interpreter",
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolChoiceToolChoiceFunction(BaseModel):
    name: str

    type: Literal["function"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolChoiceToolChoiceMcp(BaseModel):
    server_label: str

    type: Literal["mcp"]

    name: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolChoiceToolChoiceCustom(BaseModel):
    name: str

    type: Literal["custom"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseToolChoice: TypeAlias = Union[
    Literal["none", "auto", "required"],
    ResponseQueuedEventResponseToolChoiceToolChoiceAllowed,
    ResponseQueuedEventResponseToolChoiceToolChoiceTypes,
    ResponseQueuedEventResponseToolChoiceToolChoiceFunction,
    ResponseQueuedEventResponseToolChoiceToolChoiceMcp,
    ResponseQueuedEventResponseToolChoiceToolChoiceCustom,
]


class ResponseQueuedEventResponseToolFunctionTool(BaseModel):
    name: str

    type: Literal["function"]

    description: Optional[str] = None

    parameters: Optional[Dict[str, object]] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolFileSearchToolFiltersComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter(BaseModel):
    key: str

    type: Literal["eq", "ne", "gt", "gte", "lt", "lte"]

    value: Union[str, float, bool]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseToolFileSearchToolFiltersCompoundFilterFilter: TypeAlias = Union[
    ResponseQueuedEventResponseToolFileSearchToolFiltersCompoundFilterFilterComparisonFilter, object
]


class ResponseQueuedEventResponseToolFileSearchToolFiltersCompoundFilter(BaseModel):
    filters: List[ResponseQueuedEventResponseToolFileSearchToolFiltersCompoundFilterFilter]

    type: Literal["and", "or"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseToolFileSearchToolFilters: TypeAlias = Union[
    ResponseQueuedEventResponseToolFileSearchToolFiltersComparisonFilter,
    ResponseQueuedEventResponseToolFileSearchToolFiltersCompoundFilter,
]


class ResponseQueuedEventResponseToolFileSearchToolRankingOptions(BaseModel):
    ranker: Optional[Literal["auto", "default-2024-11-15"]] = None

    score_threshold: Optional[float] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolFileSearchTool(BaseModel):
    type: Literal["file_search"]

    vector_store_ids: List[str]

    filters: Optional[ResponseQueuedEventResponseToolFileSearchToolFilters] = None

    max_num_results: Optional[int] = None

    ranking_options: Optional[ResponseQueuedEventResponseToolFileSearchToolRankingOptions] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolWebSearchToolUserLocation(BaseModel):
    type: Literal["approximate"]

    city: Optional[str] = None

    country: Optional[str] = None

    region: Optional[str] = None

    timezone: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolWebSearchTool(BaseModel):
    type: Literal["web_search_preview", "web_search_preview_2025_03_11"]

    search_context_size: Optional[Literal["low", "medium", "high"]] = None

    user_location: Optional[ResponseQueuedEventResponseToolWebSearchToolUserLocation] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolComputerTool(BaseModel):
    display_height: int

    display_width: int

    environment: Literal["windows", "mac", "linux", "ubuntu", "browser"]

    type: Literal["computer_use_preview"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseToolMcpAllowedTools: TypeAlias = Union[
    List[str], ResponseQueuedEventResponseToolMcpAllowedToolsMcpAllowedToolsMcpAllowedToolsFilter
]


class ResponseQueuedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever(BaseModel):
    tool_names: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter(BaseModel):
    always: Optional[ResponseQueuedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterAlways] = (
        None
    )

    never: Optional[ResponseQueuedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilterNever] = (
        None
    )

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseToolMcpRequireApproval: TypeAlias = Union[
    ResponseQueuedEventResponseToolMcpRequireApprovalMcpRequireApprovalMcpToolApprovalFilter, Literal["always", "never"]
]


class ResponseQueuedEventResponseToolMcp(BaseModel):
    server_label: str

    server_url: str

    type: Literal["mcp"]

    allowed_tools: Optional[ResponseQueuedEventResponseToolMcpAllowedTools] = None

    headers: Optional[Dict[str, str]] = None

    require_approval: Optional[ResponseQueuedEventResponseToolMcpRequireApproval] = None

    server_description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto(BaseModel):
    type: Literal["auto"]

    file_ids: Optional[List[str]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseToolCodeInterpreterContainer: TypeAlias = Union[
    str, ResponseQueuedEventResponseToolCodeInterpreterContainerCodeInterpreterContainerCodeInterpreterToolAuto
]


class ResponseQueuedEventResponseToolCodeInterpreter(BaseModel):
    container: ResponseQueuedEventResponseToolCodeInterpreterContainer

    type: Literal["code_interpreter"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolImageGenerationInputImageMask(BaseModel):
    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolImageGeneration(BaseModel):
    type: Literal["image_generation"]

    background: Optional[Literal["transparent", "opaque", "auto"]] = None

    input_fidelity: Optional[Literal["high", "low"]] = None

    input_image_mask: Optional[ResponseQueuedEventResponseToolImageGenerationInputImageMask] = None

    model: Optional[Literal["gpt-image-1"]] = None

    moderation: Optional[Literal["auto", "low"]] = None

    output_compression: Optional[int] = None

    output_format: Optional[Literal["png", "webp", "jpeg"]] = None

    partial_images: Optional[int] = None

    quality: Optional[Literal["low", "medium", "high", "auto"]] = None

    size: Optional[Literal["1024x1024", "1024x1536", "1536x1024", "auto"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolLocalShell(BaseModel):
    type: Literal["local_shell"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolCustomToolFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseToolCustomToolFormatGrammar(BaseModel):
    definition: str

    syntax: Literal["lark", "regex"]

    type: Literal["grammar"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseToolCustomToolFormat: TypeAlias = Union[
    ResponseQueuedEventResponseToolCustomToolFormatText, ResponseQueuedEventResponseToolCustomToolFormatGrammar
]


class ResponseQueuedEventResponseToolCustomTool(BaseModel):
    name: str

    type: Literal["custom"]

    description: Optional[str] = None

    format: Optional[ResponseQueuedEventResponseToolCustomToolFormat] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseTool: TypeAlias = Union[
    ResponseQueuedEventResponseToolFunctionTool,
    ResponseQueuedEventResponseToolFileSearchTool,
    ResponseQueuedEventResponseToolWebSearchTool,
    ResponseQueuedEventResponseToolComputerTool,
    ResponseQueuedEventResponseToolMcp,
    ResponseQueuedEventResponseToolCodeInterpreter,
    ResponseQueuedEventResponseToolImageGeneration,
    ResponseQueuedEventResponseToolLocalShell,
    ResponseQueuedEventResponseToolCustomTool,
]


class ResponseQueuedEventResponseError(BaseModel):
    code: Literal[
        "server_error",
        "rate_limit_exceeded",
        "invalid_prompt",
        "vector_store_timeout",
        "invalid_image",
        "invalid_image_format",
        "invalid_base64_image",
        "invalid_image_url",
        "image_too_large",
        "image_too_small",
        "image_parse_error",
        "image_content_policy_violation",
        "invalid_image_mode",
        "image_file_too_large",
        "unsupported_image_media_type",
        "empty_image_file",
        "failed_to_download_image",
        "image_file_not_found",
    ]

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseIncompleteDetails(BaseModel):
    reason: Optional[Literal["max_output_tokens", "content_filter"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1: TypeAlias = Union[
    ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputText,
    ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputImage,
    ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1ResponseInputFile,
]


class ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessage(BaseModel):
    content: Union[str, List[ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessageContentUnionMember1]]

    role: Literal["user", "assistant", "system", "developer"]

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText(
    BaseModel
):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage(
    BaseModel
):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile(
    BaseModel
):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent: TypeAlias = Union[
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputText,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputImage,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContentResponseInputFile,
]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage(BaseModel):
    content: List[
        ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessageContent
    ]

    role: Literal["user", "system", "developer"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    type: Optional[Literal["message"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation(
    BaseModel
):
    file_id: str

    filename: str

    index: int

    type: Literal["file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation(
    BaseModel
):
    end_index: int

    start_index: int

    title: str

    type: Literal["url_citation"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation(
    BaseModel
):
    container_id: str

    end_index: int

    file_id: str

    filename: str

    start_index: int

    type: Literal["container_file_citation"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath(
    BaseModel
):
    file_id: str

    index: int

    type: Literal["file_path"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation: TypeAlias = Union[
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFileCitation,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationURLCitation,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationContainerFileCitation,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotationOpenAITypesResponsesResponseOutputTextAnnotationFilePath,
]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob(
    BaseModel
):
    token: str

    bytes: List[int]

    logprob: float

    top_logprobs: List[
        ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprobTopLogprob
    ]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText(BaseModel):
    annotations: List[
        ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextAnnotation
    ]

    text: str

    type: Literal["output_text"]

    logprobs: Optional[
        List[ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputTextLogprob]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal(BaseModel):
    refusal: str

    type: Literal["refusal"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContent: TypeAlias = Union[
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputText,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContentResponseOutputRefusal,
]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessage(BaseModel):
    id: str

    content: List[ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessageContent]

    role: Literal["assistant"]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["message"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult(BaseModel):
    attributes: Optional[Dict[str, Union[str, float, bool]]] = None

    file_id: Optional[str] = None

    filename: Optional[str] = None

    score: Optional[float] = None

    text: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall(BaseModel):
    id: str

    queries: List[str]

    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"]

    type: Literal["file_search_call"]

    results: Optional[List[ResponseQueuedEventResponseInstructionsUnionMember1ResponseFileSearchToolCallResult]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick(
    BaseModel
):
    button: Literal["left", "right", "wheel", "back", "forward"]

    type: Literal["click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick(
    BaseModel
):
    type: Literal["double_click"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath(
    BaseModel
):
    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag(
    BaseModel
):
    path: List[
        ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDragPath
    ]

    type: Literal["drag"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress(
    BaseModel
):
    keys: List[str]

    type: Literal["keypress"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove(
    BaseModel
):
    type: Literal["move"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot(
    BaseModel
):
    type: Literal["screenshot"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll(
    BaseModel
):
    scroll_x: int

    scroll_y: int

    type: Literal["scroll"]

    x: int

    y: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType(
    BaseModel
):
    text: str

    type: Literal["type"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait(
    BaseModel
):
    type: Literal["wait"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction: TypeAlias = Union[
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionClick,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDoubleClick,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionDrag,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionKeypress,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionMove,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScreenshot,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionScroll,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionType,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallActionOpenAITypesResponsesResponseComputerToolCallActionWait,
]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck(BaseModel):
    id: str

    code: str

    message: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCall(BaseModel):
    id: str

    action: ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallAction

    call_id: str

    pending_safety_checks: List[
        ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCallPendingSafetyCheck
    ]

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["computer_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput(
    BaseModel
):
    type: Literal["computer_screenshot"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck(
    BaseModel
):
    id: str

    code: Optional[str] = None

    message: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput(
    BaseModel
):
    call_id: str

    output: (
        ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputOutput
    )

    type: Literal["computer_call_output"]

    id: Optional[str] = None

    acknowledged_safety_checks: Optional[
        List[
            ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutputAcknowledgedSafetyCheck
        ]
    ] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch(
    BaseModel
):
    query: str

    type: Literal["search"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage(
    BaseModel
):
    type: Literal["open_page"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind(
    BaseModel
):
    pattern: str

    type: Literal["find"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction: TypeAlias = Union[
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionSearch,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionOpenPage,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchActionOpenAITypesResponsesResponseFunctionWebSearchActionFind,
]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch(BaseModel):
    id: str

    action: ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearchAction

    status: Literal["in_progress", "searching", "completed", "failed"]

    type: Literal["web_search_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionToolCall(BaseModel):
    arguments: str

    call_id: str

    name: str

    type: Literal["function_call"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput(
    BaseModel
):
    call_id: str

    output: str

    type: Literal["function_call_output"]

    id: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary(BaseModel):
    text: str

    type: Literal["summary_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseReasoningItemContent(BaseModel):
    text: str

    type: Literal["reasoning_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseReasoningItem(BaseModel):
    id: str

    summary: List[ResponseQueuedEventResponseInstructionsUnionMember1ResponseReasoningItemSummary]

    type: Literal["reasoning"]

    content: Optional[List[ResponseQueuedEventResponseInstructionsUnionMember1ResponseReasoningItemContent]] = None

    encrypted_content: Optional[str] = None

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall(
    BaseModel
):
    id: str

    status: Literal["in_progress", "completed", "generating", "failed"]

    type: Literal["image_generation_call"]

    result: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs(
    BaseModel
):
    logs: str

    type: Literal["logs"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage(
    BaseModel
):
    type: Literal["image"]

    url: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput: TypeAlias = Union[
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputLogs,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutputOpenAITypesResponsesResponseCodeInterpreterToolCallOutputImage,
]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall(BaseModel):
    id: str

    container_id: str

    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"]

    type: Literal["code_interpreter_call"]

    code: Optional[str] = None

    outputs: Optional[
        List[ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCallOutput]
    ] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction(
    BaseModel
):
    command: List[str]

    env: Dict[str, str]

    type: Literal["exec"]

    timeout_ms: Optional[int] = None

    user: Optional[str] = None

    working_directory: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall(BaseModel):
    id: str

    action: ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallAction

    call_id: str

    status: Literal["in_progress", "completed", "incomplete"]

    type: Literal["local_shell_call"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput(
    BaseModel
):
    id: str

    output: str

    type: Literal["local_shell_call_output"]

    status: Optional[Literal["in_progress", "completed", "incomplete"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool(
    BaseModel
):
    input_schema: object

    name: str

    annotations: Optional[object] = None

    description: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools(BaseModel):
    id: str

    server_label: str

    tools: List[
        ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListToolsTool
    ]

    type: Literal["mcp_list_tools"]

    error: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest(
    BaseModel
):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_approval_request"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse(
    BaseModel
):
    approval_request_id: str

    approve: bool

    type: Literal["mcp_approval_response"]

    id: Optional[str] = None

    reason: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall(BaseModel):
    id: str

    arguments: str

    name: str

    server_label: str

    type: Literal["mcp_call"]

    error: Optional[str] = None

    output: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput(BaseModel):
    call_id: str

    output: str

    type: Literal["custom_tool_call_output"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1ResponseCustomToolCall(BaseModel):
    call_id: str

    input: str

    name: str

    type: Literal["custom_tool_call"]

    id: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference(BaseModel):
    id: str

    type: Optional[Literal["item_reference"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseInstructionsUnionMember1: TypeAlias = Union[
    ResponseQueuedEventResponseInstructionsUnionMember1EasyInputMessage,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMessage,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseOutputMessage,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseFileSearchToolCall,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseComputerToolCall,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemComputerCallOutput,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionWebSearch,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseFunctionToolCall,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemFunctionCallOutput,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseReasoningItem,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemImageGenerationCall,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseCodeInterpreterToolCall,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCall,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemLocalShellCallOutput,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpListTools,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalRequest,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpApprovalResponse,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemMcpCall,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseCustomToolCallOutput,
    ResponseQueuedEventResponseInstructionsUnionMember1ResponseCustomToolCall,
    ResponseQueuedEventResponseInstructionsUnionMember1OpenAITypesResponsesResponseInputItemItemReference,
]


class ResponseQueuedEventResponsePromptVariablesResponseInputText(BaseModel):
    text: str

    type: Literal["input_text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponsePromptVariablesResponseInputImage(BaseModel):
    detail: Literal["low", "high", "auto"]

    type: Literal["input_image"]

    file_id: Optional[str] = None

    image_url: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponsePromptVariablesResponseInputFile(BaseModel):
    type: Literal["input_file"]

    file_data: Optional[str] = None

    file_id: Optional[str] = None

    file_url: Optional[str] = None

    filename: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponsePromptVariables: TypeAlias = Union[
    str,
    ResponseQueuedEventResponsePromptVariablesResponseInputText,
    ResponseQueuedEventResponsePromptVariablesResponseInputImage,
    ResponseQueuedEventResponsePromptVariablesResponseInputFile,
]


class ResponseQueuedEventResponsePrompt(BaseModel):
    id: str

    variables: Optional[Dict[str, ResponseQueuedEventResponsePromptVariables]] = None

    version: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseReasoning(BaseModel):
    effort: Optional[Literal["minimal", "low", "medium", "high"]] = None

    generate_summary: Optional[Literal["auto", "concise", "detailed"]] = None

    summary: Optional[Literal["auto", "concise", "detailed"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseTextFormatResponseFormatText(BaseModel):
    type: Literal["text"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseTextFormatResponseFormatTextJsonSchemaConfig(BaseModel):
    name: str

    schema_: Dict[str, object] = FieldInfo(alias="schema")

    type: Literal["json_schema"]

    description: Optional[str] = None

    strict: Optional[bool] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseTextFormatResponseFormatJsonObject(BaseModel):
    type: Literal["json_object"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseQueuedEventResponseTextFormat: TypeAlias = Union[
    ResponseQueuedEventResponseTextFormatResponseFormatText,
    ResponseQueuedEventResponseTextFormatResponseFormatTextJsonSchemaConfig,
    ResponseQueuedEventResponseTextFormatResponseFormatJsonObject,
]


class ResponseQueuedEventResponseText(BaseModel):
    format: Optional[ResponseQueuedEventResponseTextFormat] = None

    verbosity: Optional[Literal["low", "medium", "high"]] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseUsageInputTokensDetails(BaseModel):
    cached_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseUsageOutputTokensDetails(BaseModel):
    reasoning_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponseUsage(BaseModel):
    input_tokens: int

    input_tokens_details: ResponseQueuedEventResponseUsageInputTokensDetails

    output_tokens: int

    output_tokens_details: ResponseQueuedEventResponseUsageOutputTokensDetails

    total_tokens: int

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseQueuedEventResponse(BaseModel):
    id: str

    created_at: float

    model: Union[
        Literal[
            "gpt-5",
            "gpt-5-mini",
            "gpt-5-nano",
            "gpt-5-2025-08-07",
            "gpt-5-mini-2025-08-07",
            "gpt-5-nano-2025-08-07",
            "gpt-5-chat-latest",
            "gpt-4.1",
            "gpt-4.1-mini",
            "gpt-4.1-nano",
            "gpt-4.1-2025-04-14",
            "gpt-4.1-mini-2025-04-14",
            "gpt-4.1-nano-2025-04-14",
            "o4-mini",
            "o4-mini-2025-04-16",
            "o3",
            "o3-2025-04-16",
            "o3-mini",
            "o3-mini-2025-01-31",
            "o1",
            "o1-2024-12-17",
            "o1-preview",
            "o1-preview-2024-09-12",
            "o1-mini",
            "o1-mini-2024-09-12",
            "gpt-4o",
            "gpt-4o-2024-11-20",
            "gpt-4o-2024-08-06",
            "gpt-4o-2024-05-13",
            "gpt-4o-audio-preview",
            "gpt-4o-audio-preview-2024-10-01",
            "gpt-4o-audio-preview-2024-12-17",
            "gpt-4o-audio-preview-2025-06-03",
            "gpt-4o-mini-audio-preview",
            "gpt-4o-mini-audio-preview-2024-12-17",
            "gpt-4o-search-preview",
            "gpt-4o-mini-search-preview",
            "gpt-4o-search-preview-2025-03-11",
            "gpt-4o-mini-search-preview-2025-03-11",
            "chatgpt-4o-latest",
            "codex-mini-latest",
            "gpt-4o-mini",
            "gpt-4o-mini-2024-07-18",
            "gpt-4-turbo",
            "gpt-4-turbo-2024-04-09",
            "gpt-4-0125-preview",
            "gpt-4-turbo-preview",
            "gpt-4-1106-preview",
            "gpt-4-vision-preview",
            "gpt-4",
            "gpt-4-0314",
            "gpt-4-0613",
            "gpt-4-32k",
            "gpt-4-32k-0314",
            "gpt-4-32k-0613",
            "gpt-3.5-turbo",
            "gpt-3.5-turbo-16k",
            "gpt-3.5-turbo-0301",
            "gpt-3.5-turbo-0613",
            "gpt-3.5-turbo-1106",
            "gpt-3.5-turbo-0125",
            "gpt-3.5-turbo-16k-0613",
            "o1-pro",
            "o1-pro-2025-03-19",
            "o3-pro",
            "o3-pro-2025-06-10",
            "o3-deep-research",
            "o3-deep-research-2025-06-26",
            "o4-mini-deep-research",
            "o4-mini-deep-research-2025-06-26",
            "computer-use-preview",
            "computer-use-preview-2025-03-11",
        ],
        str,
    ]

    object: Literal["response"]

    output: List[ResponseQueuedEventResponseOutput]

    parallel_tool_calls: bool

    tool_choice: ResponseQueuedEventResponseToolChoice

    tools: List[ResponseQueuedEventResponseTool]

    background: Optional[bool] = None

    error: Optional[ResponseQueuedEventResponseError] = None

    incomplete_details: Optional[ResponseQueuedEventResponseIncompleteDetails] = None

    instructions: Union[str, List[ResponseQueuedEventResponseInstructionsUnionMember1], None] = None

    max_output_tokens: Optional[int] = None

    max_tool_calls: Optional[int] = None

    metadata: Optional[Dict[str, str]] = None

    previous_response_id: Optional[str] = None

    prompt: Optional[ResponseQueuedEventResponsePrompt] = None

    prompt_cache_key: Optional[str] = None

    reasoning: Optional[ResponseQueuedEventResponseReasoning] = None

    safety_identifier: Optional[str] = None

    service_tier: Optional[Literal["auto", "default", "flex", "scale", "priority"]] = None

    status: Optional[Literal["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"]] = None

    temperature: Optional[float] = None

    text: Optional[ResponseQueuedEventResponseText] = None

    top_logprobs: Optional[int] = None

    top_p: Optional[float] = None

    truncation: Optional[Literal["auto", "disabled"]] = None

    usage: Optional[ResponseQueuedEventResponseUsage] = None

    user: Optional[str] = None

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, builtins.object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> builtins.object: ...
    else:
        __pydantic_extra__: Dict[str, builtins.object]


class ResponseQueuedEvent(BaseModel):
    response: ResponseQueuedEventResponse

    sequence_number: int

    type: Literal["response.queued"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCustomToolCallInputDeltaEvent(BaseModel):
    delta: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.custom_tool_call_input.delta"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class ResponseCustomToolCallInputDoneEvent(BaseModel):
    input: str

    item_id: str

    output_index: int

    sequence_number: int

    type: Literal["response.custom_tool_call_input.done"]

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


class GenericResponseEvent(BaseModel):
    type: str

    if TYPE_CHECKING:
        # Some versions of Pydantic <2.8.0 have a bug and don’t allow assigning a
        # value to this field, so for compatibility we avoid doing it at runtime.
        __pydantic_extra__: Dict[str, object] = FieldInfo(init=False)  # pyright: ignore[reportIncompatibleVariableOverride]

        # Stub to indicate that arbitrary properties are accepted.
        # To access properties that are not valid identifiers you can use `getattr`, e.g.
        # `getattr(obj, '$type')`
        def __getattr__(self, attr: str) -> object: ...
    else:
        __pydantic_extra__: Dict[str, object]


ResponseCreateResponse: TypeAlias = Union[
    Response,
    ResponseAudioDeltaEvent,
    ResponseAudioDoneEvent,
    ResponseAudioTranscriptDeltaEvent,
    ResponseAudioTranscriptDoneEvent,
    ResponseCodeInterpreterCallCodeDeltaEvent,
    ResponseCodeInterpreterCallCodeDoneEvent,
    ResponseCodeInterpreterCallCompletedEvent,
    ResponseCodeInterpreterCallInProgressEvent,
    ResponseCodeInterpreterCallInterpretingEvent,
    ResponseCompletedEvent,
    ResponseContentPartAddedEvent,
    ResponseContentPartDoneEvent,
    ResponseCreatedEvent,
    ResponseErrorEvent,
    ResponseFileSearchCallCompletedEvent,
    ResponseFileSearchCallInProgressEvent,
    ResponseFileSearchCallSearchingEvent,
    ResponseFunctionCallArgumentsDeltaEvent,
    ResponseFunctionCallArgumentsDoneEvent,
    ResponseInProgressEvent,
    ResponseFailedEvent,
    ResponseIncompleteEvent,
    ResponseOutputItemAddedEvent,
    ResponseOutputItemDoneEvent,
    ResponseReasoningSummaryPartAddedEvent,
    ResponseReasoningSummaryPartDoneEvent,
    ResponseReasoningSummaryTextDeltaEvent,
    ResponseReasoningSummaryTextDoneEvent,
    ResponseReasoningTextDeltaEvent,
    ResponseReasoningTextDoneEvent,
    ResponseRefusalDeltaEvent,
    ResponseRefusalDoneEvent,
    ResponseTextDeltaEvent,
    ResponseTextDoneEvent,
    ResponseWebSearchCallCompletedEvent,
    ResponseWebSearchCallInProgressEvent,
    ResponseWebSearchCallSearchingEvent,
    ResponseImageGenCallCompletedEvent,
    ResponseImageGenCallGeneratingEvent,
    ResponseImageGenCallInProgressEvent,
    ResponseImageGenCallPartialImageEvent,
    ResponseMcpCallArgumentsDeltaEvent,
    ResponseMcpCallArgumentsDoneEvent,
    ResponseMcpCallCompletedEvent,
    ResponseMcpCallFailedEvent,
    ResponseMcpCallInProgressEvent,
    ResponseMcpListToolsCompletedEvent,
    ResponseMcpListToolsFailedEvent,
    ResponseMcpListToolsInProgressEvent,
    ResponseOutputTextAnnotationAddedEvent,
    ResponseQueuedEvent,
    ResponseCustomToolCallInputDeltaEvent,
    ResponseCustomToolCallInputDoneEvent,
    GenericResponseEvent,
]
