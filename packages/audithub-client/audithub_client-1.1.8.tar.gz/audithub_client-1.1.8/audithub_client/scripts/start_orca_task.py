import logging
import sys
from pathlib import Path
from typing import Annotated, Optional

from cyclopts import Parameter

from ..api.monitor_task import MonitorTaskArgs, api_monitor_task
from ..api.start_orca_task import (
    Hint,
    HintAdHoc,
    HintFromVersion,
    OrCaParameters,
    StartOrCaTaskArgs,
    VSpec,
    VSpecAdHoc,
    VSpecFromVersion,
    api_start_orca_task,
)
from ..library.invocation_common import (
    AuditHubContextType,
    OrganizationIdType,
    ProjectIdType,
    TaskWaitType,
    VersionIdType,
    app,
)
from ..library.orca_utils import restructure_fuzzing_blacklist

logger = logging.getLogger(__name__)


@app.command
def start_orca_task(
    *,
    organization_id: OrganizationIdType,
    project_id: ProjectIdType,
    version_id: VersionIdType,
    name: Optional[str] = None,
    timeout: Optional[int] = None,
    detect_reentrancy: bool = False,
    fuzz_pure: Annotated[Optional[bool], Parameter(negative_bool=())] = None,
    fuzz_targets: Annotated[
        Optional[list[str]], Parameter(consume_multiple=True, negative_iterable=())
    ] = None,
    fuzzing_blacklist: Annotated[
        Optional[list[str]], Parameter(consume_multiple=True, negative_iterable=())
    ] = None,
    fork_network: Optional[str] = None,
    fork_block_number: Optional[int] = None,
    embedded_specs: Annotated[
        Optional[list[str]], Parameter(consume_multiple=True, negative_iterable=())
    ] = None,
    ad_hoc_specs: Annotated[
        Optional[list[str]], Parameter(consume_multiple=True, negative_iterable=())
    ] = None,
    embedded_hints: Annotated[
        Optional[list[str]], Parameter(consume_multiple=True, negative_iterable=())
    ] = None,
    ad_hoc_hints: Annotated[
        Optional[list[str]], Parameter(consume_multiple=True, negative_iterable=())
    ] = None,
    deployment_script_path: Optional[str] = None,
    wait: TaskWaitType = False,
    rpc_context: AuditHubContextType,
):
    """
    Start an OrCa fuzzing campaign. Outputs the task id.

    Parameters
    ----------
    name:
        An optional task name for this task. If not specified, one will automatically be generated by AuditHub.

    timeout:
        An optional timeout value in seconds

    source:
        The path, relative to the version root, of the .picus file to process.

    detect_reentrancy:
        If enabled, accounts simulated by OrCa will attempt to make reentrant calls when they are called or receive native currency.

    fuzz_pure:
        Enable fuzzing of functions that do not alter contract state.

    fuzz_targets:
        List of contract names. If specified, OrCa will only try to fuzz the specified contracts.

    fuzzing_blacklist:
        List of the contract/function pairs to be ignored during the fuzzing process. Specify them as a list of 'contract.function' strings.

    fork_network:
        Optionally, a network to fork from. For valid values, please run "ah get-configuration fork_networks" and use the "code" field.

    fork_block_number:
        The number of the last block to fork

    embedded_specs:
        A list of relative paths, from the version archive root, for V specs to use that are embedded in the version archive.

    ad_hoc_specs:
        A list of file paths, at the local filesystem, for V specs to use that exist in the machine invoking this script.
        Note that, the filename submitted to AuditHub will only be the filename part, without any folder information.

    embedded_hints:
        A list of relative paths, from the version archive root, for hints to use that are embedded in the version archive.

    ad_hoc_hints:
        A list of file paths, at the local filesystem, for hints to use that exist in the machine invoking this script.
        Note that, the filename submitted to AuditHub will only be the filename part, without any folder information.

    deployment_script_path:
        An optional deployment script path to be used during deployment. If provided, it overrides the value set in project level.

    """

    specs: list[VSpec] = []
    for spec in embedded_specs or []:
        specs.append(VSpecFromVersion(relative_path=spec))

    for local_file in [Path(spec) for spec in ad_hoc_specs or []]:
        specs.append(
            VSpecAdHoc(
                filename=local_file.name,
                contents=local_file.read_text(encoding="UTF-8"),
            )
        )

    hints: list[Hint] = []
    for hint in embedded_hints or []:
        hints.append(HintFromVersion(relative_path=hint))

    for local_file in [Path(hint) for hint in ad_hoc_hints or []]:
        hints.append(
            HintAdHoc(
                filename=local_file.name,
                contents=local_file.read_text(encoding="UTF-8"),
            )
        )

    if fork_block_number is not None and fork_network is None:
        print(
            "ERROR: You can only specify a fork block number when also specifying a fork network"
        )
        sys.exit(1)

    try:
        rpc_input = StartOrCaTaskArgs(
            organization_id=organization_id,
            project_id=project_id,
            version_id=version_id,
            name=name,
            parameters=OrCaParameters(
                timeout=timeout,
                disable_user_proxies=not detect_reentrancy,
                fuzz_pure=fuzz_pure,
                fuzz_targets=fuzz_targets,
                fuzzing_blacklist=restructure_fuzzing_blacklist(fuzzing_blacklist),
                fork_network=fork_network,
                fork_block_number=fork_block_number,
            ),
            specs=specs,
            hints=hints,
            deployment_script_path_override=deployment_script_path,
        )
        logger.debug("Starting...")
        logger.debug(str(input))
        ret = api_start_orca_task(rpc_context, rpc_input)
        logger.debug("Response: %s", ret)
        task_id = ret["task_id"]
        print(task_id)
        if wait:
            result = api_monitor_task(
                rpc_context,
                MonitorTaskArgs(organization_id=organization_id, task_id=task_id),
            )
        logger.debug("Finished.")
        if wait and not result:
            sys.exit(1)
    except Exception as ex:
        logger.error("Error %s", str(ex), exc_info=ex)
