from typing import Optional
from typing import Callable
from typing import Any
from typing import List
from typing import Tuple
from leaf_register.metadata import MetadataManager
from leaf.error_handler.error_holder import ErrorHolder


class PhaseModule:
    """
    Manages distinct phases within a ProcessAdapter to ensure tasks
    execute in sequence for each phase. PhaseModule allows related
    processes to be grouped. For example, equipment may run multiple
    processes, each with discrete phases (start, measurement, stop).
    """

    def __init__(
        self,
        term_builder: Callable,
        metadata_manager: Optional[MetadataManager] = None,
        interpreter: Optional[Any] = None,
        error_holder: Optional[ErrorHolder] = None,
    ) -> None:
        """
        Initialize the PhaseModule with essential components.

        Args:
            term_builder (Callable): A function from the metadata_manager to
                                     construct the action term for each phase.
            metadata_manager (Optional[MetadataManager]): Manages metadata for the phase.
            interpreter (Optional[AbstractInterpreter]): An interpreter to process data if needed.
            error_holder (Optional[ErrorHolder]): An error holder to manage phase errors.
        """
        self._interpreter = interpreter
        self._term_builder = term_builder
        self._metadata_manager = metadata_manager
        self._error_holder = error_holder

    def get_term(self) -> Any:
        """
        Retrieve the term generated by the term builder.

        Returns:
            Any: The term generated by the term builder.
        """
        return self._term_builder()

    def is_activated(self, topic: Any) -> bool:
        """
        Check if the given topic matches the term builder.

        Args:
            topic (Any): The topic to check activation against.

        Returns:
            bool: True if the topic matches the term builder, False otherwise.
        """
        topic_instance = topic()
        return topic_instance == self._term_builder()

    def set_interpreter(self, interpreter: 'AbstractInterpreter') -> None:
        """
        Set or update the interpreter for the phase.

        Args:
            interpreter (AbstractInterpreter): The interpreter to be used for processing data.
        """
        self._interpreter = interpreter

    def update(self, data: Optional[Any] = None, **kwargs: Any) -> List[Tuple[str, Any]]:
        """
        Builds the topic that is specifically bound to this phase.

        Args:
            data (Optional[Any]): Optional data associated with the phase.
            **kwargs (Any): Additional arguments to build the action term.

        Returns:
            list: A list of tuples containing the action term and data.
        """
        return [(self._term_builder(**kwargs), data)]

    def set_error_holder(self, error_holder: ErrorHolder) -> None:
        """
        Set or update the error holder to manage exceptions in this phase.

        Args:
            error_holder (ErrorHolder): The error holder for errors in the phase.
        """
        self._error_holder = error_holder

    def set_metadata_manager(self, manager: MetadataManager) -> None:
        """
        Set or update the metadata manager.

        Args:
            manager (MetadataManager): The metadata manager to be set.
        """
        self._metadata_manager = manager
        if isinstance(self._term_builder, str):
            self._term_builder = eval(f"self._{self._term_builder}")

    def _handle_exception(self, exception: Exception) -> None:
        """
        Handle exceptions by passing them to the error holder or raising them.

        Args:
            exception (Exception): The exception to handle.
        """
        if self._error_holder is not None:
            self._error_holder.add_error(exception)
        else:
            raise exception
