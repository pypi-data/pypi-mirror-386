import logging
import urllib.parse
from typing import List, Literal, Optional

from videoipath_automation_tool.apps.topology.model.actions.validate_topology_update import ValidateTopologyUpdateData
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_base_device import BaseDevice
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_codec_vertex import CodecVertex
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_generic_vertex import GenericVertex
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_ip_vertex import IpVertex
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_n_graph_element import NGraphElement
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_n_graph_resource_transform import (
    NGraphResourceTransform,
)
from videoipath_automation_tool.apps.topology.model.n_graph_elements.topology_unidirectional_edge import (
    UnidirectionalEdge,
)
from videoipath_automation_tool.apps.topology.model.topology_device import TopologyDevice, TopologyDeviceConfiguration
from videoipath_automation_tool.apps.topology.model.topology_device_configuration_compare import (
    TopologyDeviceComparison,
)
from videoipath_automation_tool.connector.models.request_rest_v2 import RequestV2Patch, RequestV2Post
from videoipath_automation_tool.connector.models.response_rest_v2 import ResponseV2Patch
from videoipath_automation_tool.connector.vip_connector import VideoIPathConnector
from videoipath_automation_tool.utils.cross_app_utils import create_fallback_logger
from videoipath_automation_tool.validators.device_id import validate_device_id
from videoipath_automation_tool.validators.device_id_including_virtual import validate_device_id_including_virtual


class TopologyAPI:
    def __init__(self, vip_connector: VideoIPathConnector, logger: Optional[logging.Logger] = None):
        """
        Class for VideoIPath topology API.

        Args:
            vip_connector (VideoIPathConnector): VideoIPathConnector instance to handle the connection to the VideoIPath-Server.
            logger (Optional[logging.Logger]): Logger instance. If `None`, a fallback logger is used.
        """

        # --- Setup Logging ---
        self._logger = logger or create_fallback_logger("videoipath_automation_tool_topology_api")
        self.vip_connector = vip_connector

        self._logger.debug("Topology API initialized.")

    # --- Fetching device and element configuration ---
    def get_device_from_topology(self, device_id: str) -> TopologyDevice:
        """Get a topology device by its device id.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            TopologyDevice: TopologyDevice object.
        """
        device_configuration = self._fetch_device_configuration_from_topology(device_id)
        # device_status = ... (prepared for future use)
        return TopologyDevice(configuration=device_configuration)

    def get_device_from_driver(self, device_id: str) -> TopologyDevice:
        """Get a device generated by VideoIPath via the driver.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            TopologyDevice: TopologyDevice object.
        """
        device_configuration = self._fetch_device_configuration_from_driver(device_id)
        return TopologyDevice(configuration=device_configuration)

    def get_element_by_label(
        self,
        label: str,
        mode: Literal["user_defined", "factory"] = "user_defined",
        filter_type: Literal[
            "all",
            "base_device",
            "codec_vertex",
            "generic_vertex",
            "ip_vertex",
            "unidirectional_edge",
            "n_graph_resource_transform",
        ] = "all",
    ) -> (
        BaseDevice
        | CodecVertex
        | GenericVertex
        | IpVertex
        | UnidirectionalEdge
        | NGraphResourceTransform
        | List[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform]
    ):
        """Get an element by its label.

        Args:
            label (str): Label of the element.
            mode (Literal[&quot;user_defined&quot;, &quot;factory&quot;], optional): Search mode. Defaults to "user_defined".
            filter_type (Literal[&quot;all&quot;, &quot;base_device&quot;, &quot;codec_vertex&quot;, &quot;generic_vertex&quot;, &quot;ip_vertex&quot;, &quot;unidirectional_edge&quot;, &quot;n_graph_resource_transform&quot;], optional): Filter type. Defaults to "all".

        Returns:
            nGraph element object or list of objects.
        """
        filter_string = ""
        if filter_type == "base_device":
            filter_string = "and type='baseDevice'"
        elif filter_type == "codec_vertex":
            filter_string = "and type='codecVertex'"
        elif filter_type == "generic_vertex":
            filter_string = "and type='genericVertex'"
        elif filter_type == "ip_vertex":
            filter_string = "and type='ipVertex'"
        elif filter_type == "unidirectional_edge":
            filter_string = "and type='unidirectionalEdge'"
        elif filter_type == "n_graph_resource_transform":
            filter_string = "and type='nGraphResourceTransform'"
        elif filter_type != "all":
            raise ValueError(f"Unknown filter_type: {filter_type}")

        escaped_label = urllib.parse.quote(label, safe="")

        if mode == "user_defined":
            path = f"/rest/v2/data/config/network/nGraphElements/* where descriptor.label='{escaped_label}' {filter_string} /**"
        elif mode == "factory":
            path = f"/rest/v2/data/config/network/nGraphElements/* where fDescriptor.label='{escaped_label}' {filter_string} /**"
        print(path)
        response = self.vip_connector.rest.get(path)

        payload_data = response.data["config"]["network"]["nGraphElements"]["_items"]
        if len(payload_data) > 1:
            self._logger.warning(f"Multiple nGraphElements with label '{label}' found.")
            return [self._validate_nGraphElement(item) for item in payload_data]
        elif len(payload_data) == 1:
            return self._validate_nGraphElement(payload_data[0])
        else:
            raise ValueError(f"nGraphElement with label '{label}' not found.")

    def _fetch_device_configuration_from_topology(self, device_id: str) -> TopologyDeviceConfiguration:
        """Get a topology device by its device id.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            TopologyDeviceConfiguration: TopologyDeviceConfiguration object.
        """
        vertex_list = self._fetch_all_nGraphElements_by_device_id(device_id)
        device_configuration = self._build_device_configuration(device_id, vertex_list)
        return TopologyDeviceConfiguration.model_validate(device_configuration)

    def _fetch_device_configuration_from_driver(self, device_id: str) -> TopologyDeviceConfiguration:
        """Get a device generated by VideoIPath via the driver.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            TopologyDevice: TopologyDeviceConfiguration object.
        """
        vertex_list = self._fetch_all_elements_from_nGraphFromDrivers_by_device_id(device_id)
        device_configuration = self._build_device_configuration(device_id, vertex_list)
        return TopologyDeviceConfiguration.model_validate(device_configuration)

    def _fetch_all_nGraphElements_by_device_id(
        self, device_id: str
    ) -> list[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform]:
        """Get all corresponding nGraphElements to a device (given by device id).

        Args:
            device_id (str): Device Id (e.g. "device1")

        Raises:
            ValueError: If device_id does not start with 'device' or 'virtual'.

        Returns:
            list[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform]: List of nGraphElement objects of the corresponding device.
        """
        device_id = validate_device_id_including_virtual(device_id)

        base_device = BaseDevice.model_validate(self._fetch_nGraphElement_by_key(device_id))
        codec_vertices = self._fetch_filtered_nGraph_elements_by_device_id(device_id, "codecVertex")
        generic_vertices = self._fetch_filtered_nGraph_elements_by_device_id(device_id, "genericVertex")
        ip_vertices = self._fetch_filtered_nGraph_elements_by_device_id(device_id, "ipVertex")
        unidirectional_edges = self._fetch_filtered_nGraph_elements_by_device_id(device_id, "unidirectionalEdge")
        resource_transform_edges = self._fetch_filtered_nGraph_elements_by_device_id(
            device_id, "nGraphResourceTransform"
        )

        return (
            [base_device]
            + codec_vertices
            + generic_vertices
            + ip_vertices
            + unidirectional_edges
            + resource_transform_edges
        )

    def _fetch_all_elements_from_nGraphFromDrivers_by_device_id(
        self, device_id: str
    ) -> List[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform]:
        """Get all corresponding nGraphFromDrivers to a device (given by device id).

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            List[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform]: List of nGraphElement objects of the corresponding device from the nGraphFromDrivers.
        """
        device_id = validate_device_id(device_id)

        data = self.vip_connector.rest.get(
            f"/rest/v2/data/status/network/nGraphFromDrivers/* where _id='{device_id}' /**"
        )

        if data is None:
            raise ValueError(f"nGraphElement with deviceId {device_id} not found.")

        return_data = {}
        for key in data.data["status"]["network"]["nGraphFromDrivers"]["_items"][0]:
            if key != "_id" and key != "_vid":
                return_data[key] = data.data["status"]["network"]["nGraphFromDrivers"]["_items"][0][key]
                return_data[key]["_id"] = key
                return_data[key]["_vid"] = key
                return_data[key]["_rev"] = None

        nGraphElement_list = []
        for element in return_data:
            nGraphElement_list.append(self._validate_nGraphElement(return_data[element]))

        return nGraphElement_list

    def _build_device_configuration(
        self,
        device_id: str,
        vertex_list: List[
            BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform
        ],
    ) -> dict:
        device_configuration = {
            "base_device": None,
            "codec_vertices": [],
            "generic_vertices": [],
            "ip_vertices": [],
            "internal_edges": [],
            "external_edges": [],
            "resource_transform_edges": [],
        }
        for vertex in vertex_list:
            if isinstance(vertex, BaseDevice):
                device_configuration["base_device"] = vertex
            elif isinstance(vertex, CodecVertex):
                device_configuration["codec_vertices"].append(vertex)
            elif isinstance(vertex, GenericVertex):
                device_configuration["generic_vertices"].append(vertex)
            elif isinstance(vertex, IpVertex):
                device_configuration["ip_vertices"].append(vertex)
            elif isinstance(vertex, UnidirectionalEdge):
                if vertex.fromId.startswith(device_id + ".") and vertex.toId.startswith(device_id + "."):
                    device_configuration["internal_edges"].append(vertex)
                # xor condition
                elif (vertex.fromId.startswith(device_id + ".") and not vertex.toId.startswith(device_id + ".")) or (
                    not vertex.fromId.startswith(device_id + ".") and vertex.toId.startswith(device_id + ".")
                ):
                    device_configuration["external_edges"].append(vertex)
                else:
                    raise ValueError(f"Unknown edge type: {vertex}")
            elif isinstance(vertex, NGraphResourceTransform):
                device_configuration["resource_transform_edges"].append(vertex)
            else:
                raise ValueError(f"Unknown vertex type: {vertex}")
        return device_configuration

    def _fetch_filtered_nGraph_elements_by_device_id(
        self,
        device_id: str,
        type_filter: Literal[
            "codecVertex", "genericVertex", "ipVertex", "unidirectionalEdge", "baseDevice", "nGraphResourceTransform"
        ],
    ) -> List[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform]:
        """Get a list type-filtered list of nGraphElement objects corresponding to a device (given by device id).

        Args:
            device_id (str): Device Id (e.g. "device1")
            type_filter (Literal[&quot;codecVertex&quot;, &quot;genericVertex&quot;, &quot;ipVertex&quot;, &quot;unidirectionalEdge&quot;, &quot;baseDevice&quot;]): Type filter for the nGraphElement objects.

        Returns:
            List[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform]: List of nGraphElement objects of the corresponding device with the given type filter.
        """
        return_data = []
        device_id = validate_device_id_including_virtual(device_id)

        if type_filter == "baseDevice":
            return_data.append(BaseDevice.model_validate(self._fetch_nGraphElement_by_key(device_id)))

        elif type_filter == "codecVertex":
            api_response = self.vip_connector.rest.get(
                f"/rest/v2/data/config/network/nGraphElements/* where deviceId='{device_id}' and type='codecVertex' /**"
            )
            if api_response is None:
                raise ValueError(f"nGraphElement with deviceId {device_id} and type {type_filter} not found.")
            if api_response.data["config"]["network"]["nGraphElements"]["_items"]:
                for item in api_response.data["config"]["network"]["nGraphElements"]["_items"]:
                    return_data.append(CodecVertex.model_validate(item))

        elif type_filter == "genericVertex":
            api_response = self.vip_connector.rest.get(
                f"/rest/v2/data/config/network/nGraphElements/* where deviceId='{device_id}' and type='genericVertex' /**"
            )
            if api_response is None:
                raise ValueError(f"nGraphElement with deviceId {device_id} and type {type_filter} not found.")
            if api_response.data["config"]["network"]["nGraphElements"]["_items"]:
                for item in api_response.data["config"]["network"]["nGraphElements"]["_items"]:
                    return_data.append(GenericVertex.model_validate(item))

        elif type_filter == "ipVertex":
            api_response = self.vip_connector.rest.get(
                f"/rest/v2/data/config/network/nGraphElements/* where deviceId='{device_id}' and type='ipVertex' /**"
            )
            if api_response is None:
                raise ValueError(f"nGraphElement with deviceId {device_id} and type {type_filter} not found.")
            if api_response.data["config"]["network"]["nGraphElements"]["_items"]:
                for item in api_response.data["config"]["network"]["nGraphElements"]["_items"]:
                    return_data.append(IpVertex.model_validate(item))

        elif type_filter == "unidirectionalEdge" or type_filter == "nGraphResourceTransform":
            # Attention: This is a special case!
            # The only way to get all edges corresponding to a device is to fetch edgesByDevice.
            # The response data does not contain revision information, which is necessary for configuration changes.
            # Therefore all revision values are fetched first and merged with the edge config data.

            # 1. Fetch revision data
            revision_data = self.vip_connector.rest.get(
                f"/rest/v2/data/config/network/nGraphElements/* where type = '{type_filter}' /id,rev,vid"
            )
            rev_dict = {}
            for item in revision_data.data["config"]["network"]["nGraphElements"]["_items"]:
                id = item["_id"]
                rev = item["_rev"]
                rev_dict[id] = rev

            # 2. Fetch edge data
            api_response = self.vip_connector.rest.get(
                f"/rest/v2/data/status/network/edgesByDevice/* where _id='{device_id}' /**"
            )
            if api_response is None:
                raise ValueError(f"nGraphElement with deviceId {device_id} and type {type_filter} not found.")
            edge_list = []
            if api_response.data["status"]["network"]["edgesByDevice"]["_items"]:
                for item in api_response.data["status"]["network"]["edgesByDevice"]["_items"][0]:
                    if item == "_id" or item == "_vid":
                        continue
                    item_data = api_response.data["status"]["network"]["edgesByDevice"]["_items"][0][item]
                    if item_data["type"] != type_filter:
                        self._logger.debug(
                            f"Edge with id {item} has type {item_data['type']}, but expected type {type_filter}. Skipping."
                        )
                        continue
                    edge_list.append(
                        {
                            "_id": item,
                            "_vid": item,
                            "_rev": None,
                            **item_data,
                        }
                    )

            # 3. Merge revision data with edge data and validate
            for edge in edge_list:
                edge["_rev"] = rev_dict[edge["_id"]]
                if type_filter == "unidirectionalEdge":
                    return_data.append(UnidirectionalEdge.model_validate(edge))
                elif type_filter == "nGraphResourceTransform":
                    return_data.append(NGraphResourceTransform.model_validate(edge))

        elif type_filter == "ipTransformVertex":
            raise ValueError("'ipTransformVertex' not implemented yet.")

        elif type_filter == "routerVertex":
            raise ValueError("'routerVertex' not implemented yet.")

        else:
            raise ValueError(f"Unsupported type_filter: {type_filter}")

        return return_data

    def _fetch_nGraphElement_by_key(
        self, key: str
    ) -> BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform:
        """Get a nGraphElement by its key.

        Args:
            key (str): Key of the nGraphElement.

        Returns:
            BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform: nGraphElement object.
        """
        response = self.vip_connector.rest.get(f"/rest/v2/data/config/network/nGraphElements/* where _id='{key}' /**")
        if response.data is None:
            raise ValueError(f"nGraphElement with key {key} not found.")
        if response.data["config"]["network"]["nGraphElements"]["_items"]:
            data = response.data["config"]["network"]["nGraphElements"]["_items"][0]
            return self._validate_nGraphElement(data)
        else:
            raise ValueError(f"nGraphElement with key {key} not found.")

    def _validate_nGraphElement(
        self, dict: dict
    ) -> BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform:
        """Validate dict of nGraphElement and return a nGraphElement object of the correct type.

        Args:
            dict (dict): Dictionary containing the nGraphElement data from the API.

        Returns:
            BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform: nGraphElement object of the correct type.
        """

        if "type" not in dict:
            raise ValueError("nGraphElement type not found.")
        if dict["type"] == "baseDevice":
            return BaseDevice(**dict)
        elif dict["type"] == "codecVertex":
            return CodecVertex(**dict)
        elif dict["type"] == "genericVertex":
            return GenericVertex(**dict)
        elif dict["type"] == "ipVertex":
            return IpVertex(**dict)
        elif dict["type"] == "unidirectionalEdge":
            return UnidirectionalEdge(**dict)
        elif dict["type"] == "nGraphResourceTransform":
            return NGraphResourceTransform(**dict)
        elif dict["type"] == "ipTransformVertex":
            raise ValueError("'ipTransformVertex' not implemented yet.")
        elif dict["type"] == "routerVertex":
            raise ValueError("'routerVertex' not implemented yet.")
        else:
            raise ValueError(f"Unknown / unsupported nGraphElement type: {dict['type']}")

    # --- Check if device configuration is available ---
    def check_device_from_driver_available(self, device_id: str) -> bool:
        """Check if the representation generated by a driver is available for a device.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            bool: True if the representation generated by a driver is available, False otherwise.
        """
        device_id = validate_device_id(device_id)

        data = self.vip_connector.rest.get(
            f"/rest/v2/data/status/network/nGraphFromDrivers/* where _id='{device_id}' /*"
        )

        if not data:
            return False

        items = data.data.get("status", {}).get("network", {}).get("nGraphFromDrivers", {}).get("_items")
        if not items:
            return False

        if device_id in items[0]:
            return True

        self._logger.error(f"Data is available, but device {device_id} not found. Data: {data}")
        return False

    def check_device_in_topology_available(self, device_id: str) -> bool:
        """Check if a device exists in the topology.

        Args:
            device_id (str): Device Id (e.g. "device1" or "virtual.0")

        Returns:
            bool: True if the device exists, False otherwise.
        """
        device_id = validate_device_id_including_virtual(device_id)

        data = self.vip_connector.rest.get(f"/rest/v2/data/config/network/nGraphElements/* where _id='{device_id}' /*")

        if not data:
            return False

        items = data.data.get("config", {}).get("network", {}).get("nGraphElements", {}).get("_items")
        if not items:
            return False

        if items[0].get("_id") == device_id:
            return True

        self._logger.error(f"Data is available, but device {device_id} not found in nGraphElements. Data: {data}")
        return False

    # --- Check sync status of a device ---
    def get_all_device_sync_status(self):
        """Get the synchronization status of all devices in the topology.

        Returns:
            dict: Dictionary with the sync status of all devices. Format: {device_id: sync_status}
            Possible sync_status values: `InSync`, `Missing`, `NoContact`, `NoDriver`, `Changed`, `Virtual`

        Raises:
            ValueError: If no nGraphSyncStatus data is found.
        """
        sync_status_response = self.vip_connector.rest.get("/rest/v2/data/status/network/nGraphSyncStatus/**")

        sync_status = sync_status_response.data["status"]["network"]["nGraphSyncStatus"]["_items"]
        if len(sync_status) == 0:
            raise ValueError("No nGraphSyncStatus data found.")

        def is_valid(device_id):
            try:
                validate_device_id(device_id)
                return True
            except ValueError:
                return False

        return {
            item["_id"]: item["_value"]
            for item in sync_status
            if isinstance(item, dict) and "_id" in item and is_valid(item["_id"])
        }

    def get_device_sync_status(self, device_id: str) -> str:
        """Get the sync status of a base device.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            str: Sync status of the base device. Possible values: `InSync`, `Missing`, `NoContact`, `NoDriver`, `Changed`, `Virtual`

        Raises:
            ValueError: If no nGraphSyncStatus data is found.
        """
        device_id = validate_device_id(device_id)
        sync_status_response = self.vip_connector.rest.get(
            f"/rest/v2/data/status/network/nGraphSyncStatus/* where _id='{device_id}' /**"
        )

        sync_status = sync_status_response.data["status"]["network"]["nGraphSyncStatus"]["_items"]
        if len(sync_status) == 0:
            raise ValueError("No nGraphSyncStatus data found.")
        if len(sync_status) > 1:
            self._logger.warning(f"Multiple nGraphSyncStatus data found for device {device_id}.")

        return sync_status[0]["_value"]

    def get_element_sync_status(self, element_id: str) -> str:
        """Get the sync status of a nGraphElement.

        Args:
            element_id (str): Element Id (e.g. "element1")

        Returns:
            str: Sync status of the nGraphElement. Possible values: `InSync`, `Missing`, `NoContact`, `NoDriver`, `Changed`, `Virtual`

        Raises:
            ValueError: If no nGraphSyncStatus data is found.
        """
        response = self.vip_connector.rest.get(
            f"/rest/v2/data/status/network/nGraphSyncStatus/* where _id='{element_id}' /**"
        )
        sync_status = response.data["status"]["network"]["nGraphSyncStatus"]["_items"]
        if len(sync_status) == 0:
            raise ValueError("No nGraphSyncStatus data found.")
        if len(sync_status) > 1:
            self._logger.warning(f"Multiple nGraphSyncStatus data found for element {element_id}.")
        return sync_status[0]["_value"]

    def get_device_elements_sync_status(self, device_id: str) -> dict:
        """Get the sync status of all elements of a device.

        Note: By now, the sync status of all present elements on server side is fetched. This includes elements that are not part of the device configuration and generates a lot of traffic.


        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            dict: Dictionary with the sync status of all elements of the device. Format: {element_id: sync_status}
            Possible sync_status values: `InSync`, `Missing`, `NoContact`, `NoDriver`, `Changed`, `Virtual`

        Raises:
            ValueError: If no nGraphSyncStatus data is found.
        """
        device_id = validate_device_id(device_id)

        # all corresponding elements
        element_list = self._fetch_all_nGraphElements_by_device_id(device_id)
        element_ids = [element.id for element in element_list]
        device_elements_sync_status = {}

        sync_status_response = self.vip_connector.rest.get("/rest/v2/data/status/network/nGraphSyncStatus/**")

        all_elements_sync_status = sync_status_response.data["status"]["network"]["nGraphSyncStatus"]["_items"]
        if len(all_elements_sync_status) == 0:
            raise ValueError("No nGraphSyncStatus data found.")

        for element in all_elements_sync_status:
            if element["_id"] in element_ids:
                device_elements_sync_status[element["_id"]] = element["_value"]

        return device_elements_sync_status

    # def check_sync_status
    # ...

    # --- Compare devices ---
    def analyze_device_configuration_changes_local(
        self, reference_device: TopologyDevice, staged_device: TopologyDevice
    ) -> "TopologyDeviceComparison":
        """Analyze the changes between two devices locally.

        Args:
            reference_device (TopologyDevice): Reference device.
            staged_device (TopologyDevice): Staged device.

        Returns:
            TopologyCompareDevices: TopologyCompareDevices object.
        """
        return TopologyDeviceComparison.analyze_topology_devices(reference_device, staged_device)

    def analyze_device_configuration_changes(self, staged_device: TopologyDevice) -> "TopologyDeviceComparison":
        """Analyze the changes between a staged device and the device in the topology.

        Args:
            staged_device (TopologyDevice): Staged device.

        Returns:
            TopologyCompareDevices: TopologyCompareDevices object.
        """
        if not self.check_device_in_topology_available(staged_device.configuration.base_device.id):
            raise ValueError(f"Device with id {staged_device.configuration.base_device.id} not found in the topology.")
        reference_device = self.get_device_from_topology(staged_device.configuration.base_device.id)
        return TopologyDeviceComparison.analyze_topology_devices(reference_device, staged_device)

    # --- Validate and apply changes ---
    def validate_topology_update(self, device_difference: TopologyDeviceComparison):
        """Validate change operation in the topology.

        Args:
            device_difference (TopologyCompareDevices): TopologyCompareDevices object.

        """
        remove_list = device_difference.get_removed_elements()
        changed_list = device_difference.get_changed_elements()

        added_list = []
        for element in changed_list:
            added_list.append(element.staged_element)
        added_list.extend(
            device_difference.get_added_elements()
        )  # Note: added_list contains the elements that are added or updated!

        body = self._generate_validateTopologyUpdate_post_payload(added_list, remove_list)
        return self.vip_connector.rest.post("/rest/v2/actions/status/pathman/validateTopologyUpdate", body)

    def validate_topology_remove(self, device: TopologyDevice):
        """Validate remove operation in the topology.

        Args:
            device (TopologyDevice): TopologyDevice object.

        """
        remove_list = (
            [device.configuration.base_device]
            + device.configuration.codec_vertices
            + device.configuration.generic_vertices
            + device.configuration.ip_vertices
            + device.configuration.internal_edges
            + device.configuration.external_edges
            + device.configuration.resource_transform_edges
        )
        if len(remove_list) == 0:
            raise ValueError("No elements to remove.")
        body = self._generate_validateTopologyUpdate_post_payload(added_elements=[], removed_elements=remove_list)
        return self.vip_connector.rest.post("/rest/v2/actions/status/pathman/validateTopologyUpdate", body)

    def apply_device_configuration_changes(self, device_difference: TopologyDeviceComparison) -> ResponseV2Patch | None:
        """Sync the calculated changes to the topology.

        Args:
            device_difference (TopologyCompareDevices): TopologyCompareDevices object.

        Returns:
            RequestRestV2 | None: RequestRestV2 object or None if no changes are necessary.
        """
        add_list = []
        update_list = []
        remove_list = []

        add_list = device_difference.get_added_elements()
        update_compare = device_difference.get_changed_elements()
        if len(update_compare) > 0:
            update_staged_elements = [element.staged_element for element in update_compare]
        else:
            update_staged_elements = []
        remove_list = device_difference.get_removed_elements()

        for element in update_staged_elements:
            update_list.append(self._apply_reference_revision_to_element(element, device_difference.reference_device))

        body = self._generate_nGraphElements_patch_payload(
            add_elements=add_list, update_elements=update_list, remove_elements=remove_list
        )

        if len(body.actions) > 0:
            return self.vip_connector.rest.patch("/rest/v2/data/config/network/nGraphElements", body)
        else:
            return None

    def add_device_initially(self, device: TopologyDevice):
        """Add a device to the topology.

        Args:
            device (TopologyDevice): TopologyDevice object.

        Returns:
            RequestRestV2: RequestRestV2 object.
        """
        add_list = (
            [device.configuration.base_device]
            + device.configuration.codec_vertices
            + device.configuration.generic_vertices
            + device.configuration.ip_vertices
            + device.configuration.internal_edges
            + device.configuration.external_edges
            + device.configuration.resource_transform_edges
        )
        body = self._generate_nGraphElements_patch_payload(
            add_elements=add_list, update_elements=[], remove_elements=[]
        )
        return self.vip_connector.rest.patch("/rest/v2/data/config/network/nGraphElements", body)

    def remove_device_by_id(self, device_id: str):
        """Remove a device from the topology.

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            RequestRestV2: RequestRestV2 object.
        """
        device_id = validate_device_id(device_id)

        corresponding_elements = self._fetch_all_nGraphElements_by_device_id(device_id)
        print(corresponding_elements)

    def remove_device(
        self,
        device: TopologyDevice,
    ):
        """Remove a device from the topology.

        Args:
            device (TopologyDevice): TopologyDevice object.

        Returns:
            RequestRestV2: RequestRestV2 object.
        """

        remove_list = (
            [device.configuration.base_device]
            + device.configuration.codec_vertices
            + device.configuration.generic_vertices
            + device.configuration.ip_vertices
            + device.configuration.internal_edges
            + device.configuration.external_edges
            + device.configuration.resource_transform_edges
        )

        body = self._generate_nGraphElements_patch_payload(
            add_elements=[], update_elements=[], remove_elements=remove_list
        )
        return self.vip_connector.rest.patch("/rest/v2/data/config/network/nGraphElements", body)

    def add_element(
        self,
        element: BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform,
    ):
        """Add a single nGraphElement.

        Args:
            element (BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform): nGraphElement object.

        Returns:
            RequestRestV2: RequestRestV2 object.
        """
        body = self._generate_nGraphElements_patch_payload(
            add_elements=[element], update_elements=[], remove_elements=[]
        )
        return self.vip_connector.rest.patch("/rest/v2/data/config/network/nGraphElements", body)

    def update_element(
        self,
        element: BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform,
    ):
        """Update a single nGraphElement.

        Args:
            element (BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform): nGraphElement object.

        Returns:
            RequestRestV2: RequestRestV2 object.
        """
        body = self._generate_nGraphElements_patch_payload(
            add_elements=[], update_elements=[element], remove_elements=[]
        )
        return self.vip_connector.rest.patch("/rest/v2/data/config/network/nGraphElements", body)

    def remove_element(
        self,
        element: BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform,
    ):
        """Remove a single nGraphElement.

        Args:
            element (BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform): nGraphElement object.

        Returns:
            RequestRestV2: RequestRestV2 object.
        """
        body = self._generate_nGraphElements_patch_payload(
            add_elements=[], update_elements=[], remove_elements=[element]
        )
        return self.vip_connector.rest.patch("/rest/v2/data/config/network/nGraphElements", body)

    # --- Utility functions ---

    def _apply_reference_revision_to_element(
        self,
        element: BaseDevice
        | CodecVertex
        | GenericVertex
        | IpVertex
        | UnidirectionalEdge
        | NGraphResourceTransform
        | NGraphElement,
        reference_device: TopologyDevice,
    ) -> (
        BaseDevice
        | CodecVertex
        | GenericVertex
        | IpVertex
        | UnidirectionalEdge
        | NGraphResourceTransform
        | NGraphElement
    ):
        """Use the revision from the reference device for a given element.

        Args:
            element (BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform): Element to update.
            reference_device (TopologyDevice): Reference device.

        Returns:
            BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform: Updated element.
        """
        reference_element = reference_device.configuration.get_nGraphElement_by_id(element.id)
        if not reference_element:
            raise ValueError(f"Reference element with id {element.id} not found.")
        if not reference_element.rev:
            raise ValueError(f"Reference element with id {element.id} has no revision.")
        element.rev = reference_element.rev
        return element

    # --- Targeted Device Lookup Methods ---
    def get_device_id_by_user_defined_label(self, label: str) -> Optional[str | List[str]]:
        """Method to get a device id by user-defined label from VideoIPath-Topology

        Args:
            label (str): User-defined label

        Returns:
            Optional[str | List[str]]: Device id, None if label does not exist, List of device ids if multiple devices with the same label exist
        """
        if not label:
            raise ValueError("Label must not be empty.")

        escaped_label = urllib.parse.quote(label, safe="")
        url = f"/rest/v2/data/config/network/nGraphElements/* where descriptor.label='{escaped_label}' /_id"
        response = self.vip_connector.rest.get(url)

        if response.data and response.data["config"]["network"]["nGraphElements"]["_items"]:
            if len(response.data["config"]["network"]["nGraphElements"]["_items"]) == 1:
                return response.data["config"]["network"]["nGraphElements"]["_items"][0]["_id"]
            elif len(response.data["config"]["network"]["nGraphElements"]["_items"]) > 1:
                return [device["_id"] for device in response.data["config"]["network"]["nGraphElements"]["_items"]]
        return None

    def _list_all_devices_in_topology(self) -> Optional[List[str]]:
        """List all device ids in the topology.

        Returns:
            Optional[List[str]]: List of device ids.
        """
        response = self.vip_connector.rest.get(
            "/rest/v2/data/config/network/nGraphElements/* where type='baseDevice' /_id"
        )
        if response.data and response.data["config"]["network"]["nGraphElements"]["_items"]:
            return [device["_id"] for device in response.data["config"]["network"]["nGraphElements"]["_items"]]
        return None

    def _list_all_element_ids_from_nGraphFromDrivers_by_device_id(self, device_id: str) -> List[str]:
        """List all corresponding nGraphFromDriver ids to a device (given by device id).

        Args:
            device_id (str): Device Id (e.g. "device1")

        Returns:
            List[str]: List of nGraphElement ids of the corresponding device from the nGraphFromDrivers.
        """
        device_id = validate_device_id(device_id)

        data = self.vip_connector.rest.get(
            f"/rest/v2/data/status/network/nGraphFromDrivers/* where _id='{device_id}' /*"
        )

        if data is None or len(data.data["status"]["network"]["nGraphFromDrivers"]["_items"]) == 0:
            raise ValueError(f"nGraphElement with deviceId {device_id} not found in nGraphFromDrivers.")

        return [
            key
            for key in data.data["status"]["network"]["nGraphFromDrivers"]["_items"][0]
            if key not in {"_id", "_vid"}
        ]

    def _get_driver_device_id_by_factory_label(self, label: str) -> Optional[str | List[str]]:
        """Method to get a device id by factory label from nGraphFromDrivers

        Args:
            label (str): Factory label

        Returns:
            Optional[str | List[str]]: Device id, None if label does not exist, List of device ids if multiple devices with the same label exist
        """
        if not label:
            raise ValueError("Label must not be empty.")

        escaped_label = urllib.parse.quote(label, safe="")
        url = f"/rest/v2/data/status/network/nGraphFromDrivers/*/* where fDescriptor.label='{escaped_label}' /_id"
        response = self.vip_connector.rest.get(url)

        ids = []
        if response.data and response.data["status"]["network"]["nGraphFromDrivers"]["_items"]:
            for device in response.data["status"]["network"]["nGraphFromDrivers"]["_items"]:
                if device["_id"] and device["_id"] in device.keys():
                    ids.append(device["_id"])

        if len(ids) == 1:
            return ids[0]
        elif len(ids) > 1:
            return ids
        return None

    def get_device_id_by_factory_label(
        self, label: str, include_from_drivers: bool = True
    ) -> Optional[str | List[str]]:
        """Method to get a device id by factory label from VideoIPath-Topology

        Args:
            label (str): Factory label
            include_from_drivers (bool): Include nGraphFromDrivers in search. Defaults to True.

        Returns:
            Optional[str | List[str]]: Device id, None if label does not exist, List of device ids if multiple devices with the same label exist
        """
        if not label:
            raise ValueError("Label must not be empty.")

        escaped_label = urllib.parse.quote(label, safe="")
        url_topology = f"/rest/v2/data/config/network/nGraphElements/* where fDescriptor.label='{escaped_label}' /_id"
        response_topology = self.vip_connector.rest.get(url_topology)

        topology_ids = []
        if response_topology.data and response_topology.data["config"]["network"]["nGraphElements"]["_items"]:
            topology_ids = [
                device["_id"] for device in response_topology.data["config"]["network"]["nGraphElements"]["_items"]
            ]

        if include_from_drivers:
            driver_ids = self._get_driver_device_id_by_factory_label(label)
            if driver_ids:
                if not isinstance(driver_ids, list):
                    driver_ids = [driver_ids]

                devices_in_topology = self._list_all_devices_in_topology()
                if devices_in_topology:
                    driver_ids = [item for item in driver_ids if item not in devices_in_topology]
            else:
                driver_ids = []
            all_ids = list(set(topology_ids + driver_ids))
        else:
            all_ids = topology_ids

        if len(all_ids) == 1:
            return all_ids[0]
        elif len(all_ids) > 1:
            return all_ids
        return None

    def get_device_id_by_canonical_label(
        self, label: str, include_from_drivers: bool = True
    ) -> Optional[str | List[str]]:
        """Method to get a device id by canonical label from VideoIPath-Topology

        Args:
            label (str): Canonical label
            include_from_drivers (bool): Include nGraphFromDrivers in search. Defaults to True.

        Returns:
            Optional[str | List[str]]: Device id, None if label does not exist, List of device ids if multiple devices with the same label exist
        """
        if not label:
            raise ValueError("Label must not be empty.")

        escaped_label = urllib.parse.quote(label, safe="")

        url_all_devices = f"/rest/v2/data/config/network/nGraphElements/* where (descriptor.label='{escaped_label}') or (fDescriptor.label='{escaped_label}' and descriptor.label='') /_id"
        response_topology_all_devices = self.vip_connector.rest.get(url_all_devices)

        topology_ids = []
        if (
            response_topology_all_devices.data
            and response_topology_all_devices.data["config"]["network"]["nGraphElements"]["_items"]
        ):
            topology_ids = [
                device["_id"]
                for device in response_topology_all_devices.data["config"]["network"]["nGraphElements"]["_items"]
            ]

        if include_from_drivers:
            driver_ids = self._get_driver_device_id_by_factory_label(label)
            if driver_ids:
                if not isinstance(driver_ids, list):
                    driver_ids = [driver_ids]

                devices_in_topology = self._list_all_devices_in_topology()
                if devices_in_topology:
                    driver_ids = [item for item in driver_ids if item not in devices_in_topology]
            else:
                driver_ids = []
            all_ids = list(set(topology_ids + driver_ids))
        else:
            all_ids = topology_ids

        if len(all_ids) == 1:
            return all_ids[0]
        elif len(all_ids) > 1:
            return all_ids
        return None

    # --- Virtual devices ---

    def get_next_virtual_device_id(self):
        """Check the highest present virtual device id and return the next one."""
        response = self.vip_connector.rest.get(
            "/rest/v2/data/config/network/nGraphElements/* where isVirtual=true and type='baseDevice' /id"
        )
        ids = [
            int(item["_id"].replace("virtual.", ""))
            for item in response.data["config"]["network"]["nGraphElements"]["_items"]
            if type(item["_id"]) is str and item["_id"].startswith("virtual.")
        ]
        max_id = max(ids) if ids else 0
        return f"virtual.{max_id + 1}"

    # --- Positioning ---
    def get_all_device_positions(self) -> dict:
        """
        Retrieves the x and y positions of all devices in the topology.

        Returns:
            dict[str, dict[str, float]]: A dictionary where each key is a device ID
            and each value is a dictionary containing 'x' and 'y' coordinates.

        Raises:
            ValueError: If the response from the server is invalid or incomplete.
        """
        response_data = self.vip_connector.rest.get(
            "/rest/v2/data/config/network/nGraphElements/* where type = 'baseDevice' /maps/0/x,y"
        )

        positions = {
            item["_id"]: {"x": item["maps"][0]["x"], "y": item["maps"][0]["y"]}
            for item in response_data.data.get("config", {})
            .get("network", {})
            .get("nGraphElements", {})
            .get("_items", [])
            if "maps" in item and item["maps"] and "x" in item["maps"][0] and "y" in item["maps"][0]
        }
        return positions

    def get_device_position(self, device_id: str) -> tuple[float, float]:
        """
        Get the position (x, y) of a device in the Inspect Topology.

        Args:
            device_id (str): Device ID (e.g., "device1").

        Returns:
            tuple[int, int]: The (x, y) position of the device.

        Raises:
            ValueError: If the device_id is invalid or the device position is not found.
        """

        validate_device_id_including_virtual(device_id)

        data = self.vip_connector.rest.get(
            f"/rest/v2/data/config/network/nGraphElements/* where _id='{device_id}' /maps/0/x,y"
        ).data

        elements = data["config"]["network"]["nGraphElements"].get("_items", [])

        if not elements:
            raise ValueError(f"Device with id {device_id} not found.")

        maps = elements[0].get("maps", [])

        if len(maps) == 0:
            raise ValueError(f"Device position for device with id {device_id} could not be found.")

        try:
            x = float(maps[0]["x"])
            y = float(maps[0]["y"])
        except (KeyError, TypeError, ValueError):
            raise ValueError(f"Invalid or missing coordinates for device {device_id}.")

        return x, y

    def _convert_coordinate_to_float(self, coordinate: float | int) -> float:
        """
        Converts a coordinate to a float with `.0`, truncating any decimal places.

        This ensures compatibility with the Inspect Topology, which uses integer-based coordinates,
        while the API expects float data types.

        Args:
            coordinate (float | int): The coordinate value to be converted.

        Returns:
            float: The truncated coordinate as a float with `.0`.

        Raises:
            TypeError: If the input is not an int or float.
        """

        if isinstance(coordinate, (int, float)):
            return float(int(coordinate))

        raise TypeError(f"Invalid type for coordinate: {type(coordinate).__name__}. Expected int or float.")

    def set_device_position(
        self,
        device_id: str,
        x: int | float,
        y: int | float,
        mode: Literal["absolute", "relative"] = "absolute",
        inspect_app_format=True,
    ) -> ResponseV2Patch:
        """Set the position of a device in the topology immediately.

        Args:
            device_id (str): Device Id (e.g. "device1")
            x (int): Devices new X position.
            y (int): Devices new Y position.
            mode (Literal["absolute", "relative"], optional): Positioning mode. Defaults to "absolute".
            inspect_app_format (bool, optional): Use the format of the Inspect-App. Defaults to True.


        Returns:
            RequestRestV2: RequestRestV2 object
        """
        device_id = validate_device_id_including_virtual(device_id)

        base_device = self._fetch_nGraphElement_by_key(device_id)
        if not isinstance(base_device, BaseDevice):
            raise ValueError(f"Expected 'BaseDevice', got '{type(base_device).__name__}'.")

        if not base_device:
            raise ValueError(f"Device with id {device_id} not found.")

        if inspect_app_format:
            x = self._convert_coordinate_to_float(x)
            y = self._convert_coordinate_to_float(y)

        if mode == "relative":
            base_device.maps[0].x += float(x)
            base_device.maps[0].y += float(y)
        elif mode == "absolute":
            base_device.maps[0].x = float(x)
            base_device.maps[0].y = float(y)
        else:
            raise ValueError("Mode must be 'absolute' or 'relative'")

        body = self._generate_nGraphElements_patch_payload(
            add_elements=[], update_elements=[base_device], remove_elements=[]
        )
        resp = self.vip_connector.rest.patch("/rest/v2/data/config/network/nGraphElements", body)

        return resp

    # --- Building the RequestRestV2Patch object ---
    def _generate_nGraphElements_patch_payload(
        self,
        add_elements: Optional[
            List[
                BaseDevice
                | CodecVertex
                | GenericVertex
                | IpVertex
                | UnidirectionalEdge
                | NGraphResourceTransform
                | NGraphElement
            ]
        ],
        update_elements: Optional[
            List[
                BaseDevice
                | CodecVertex
                | GenericVertex
                | IpVertex
                | UnidirectionalEdge
                | NGraphResourceTransform
                | NGraphElement
            ]
        ],
        remove_elements: Optional[
            List[
                BaseDevice
                | CodecVertex
                | GenericVertex
                | IpVertex
                | UnidirectionalEdge
                | NGraphResourceTransform
                | NGraphElement
            ]
        ],
    ) -> "RequestV2Patch":
        """Generate a RequestRestV2Patch object for updating nGraphElements configuration.

        Args:
            add_elements (Optional[List[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform | NGraphElement]]): List of elements which should be added.
            update_elements (Optional[List[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform | NGraphElement]]): List of elements which should be updated.
            remove_elements (Optional[List[BaseDevice | CodecVertex | GenericVertex | IpVertex | UnidirectionalEdge | NGraphResourceTransform | NGraphElement]]): List of elements which should be removed.

        Returns:
            RequestRestV2: RequestRestV2 object.

        """
        body = RequestV2Patch()

        if add_elements:
            for element in add_elements:
                body.add(element)

        if update_elements:
            for element in update_elements:
                body.update(element)

        if remove_elements:
            for element in remove_elements:
                body.remove(element)

        return body

    def _merge_nGraphElement_payloads(self, payloads: List[RequestV2Patch]) -> "RequestV2Patch":
        """Merge multiple RequestV2Patch payloads into one RequestV2Patch payload.

        Args:
            payloads (List[RequestV2Patch]): List of RequestV2Patch payloads.

        Returns:
            RequestV2Patch: Merged RequestV2Patch payload.
        """
        body = RequestV2Patch()
        for payload in payloads:
            for action in payload.actions:
                if action.action == "add":
                    body.add(action)
                elif action.action == "update":
                    body.update(action)
                elif action.action == "remove":
                    body.remove(action)
        return body

    # --- Building the RequestRestV2Post object ---
    def _generate_validateTopologyUpdate_post_payload(
        self,
        added_elements: List[NGraphElement],
        removed_elements: List[NGraphElement],
    ) -> "RequestV2Post":
        """
        Generate a RequestRestV2Post object for validating topology updates (/rest/v2/actions/status/pathman/validateTopologyUpdate).

        Args:
            added_elements (List[]): List of elements which should be added or updated.
            removed_elements (List[]): List of elements which should be removed.

        Returns:
            RequestV2Post: RequestV2Post object for validating topology updates (/rest/v2/actions/status/pathman/validateTopologyUpdate).
        """
        body = RequestV2Post()

        data = ValidateTopologyUpdateData()
        data.added_elements(element_list=added_elements)
        data.removed_elements(element_list=removed_elements)

        body.data = data.model_dump(mode="json", by_alias=True)
        return body
