# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.msp.postgresql.v1alpha1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import grpc as grpc
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1alpha1 as v1alpha1_1
import nebius.api.nebius.common.v1alpha1.operation_pb2 as operation_pb2
import nebius.api.nebius.msp.postgresql.v1alpha1.backup_pb2 as backup_pb2
import nebius.api.nebius.msp.postgresql.v1alpha1.backup_service_pb2 as backup_service_pb2
import nebius.api.nebius.msp.postgresql.v1alpha1.cluster_pb2 as cluster_pb2
import nebius.api.nebius.msp.postgresql.v1alpha1.cluster_service_pb2 as cluster_service_pb2
import nebius.api.nebius.msp.postgresql.v1alpha1.config as config_1
import nebius.api.nebius.msp.postgresql.v1alpha1.config.postgresql_pb2 as postgresql_pb2
import nebius.api.nebius.msp.postgresql.v1alpha1.template_pb2 as template_pb2
import nebius.api.nebius.msp.v1alpha1 as v1alpha1_2
import nebius.api.nebius.msp.v1alpha1.cluster_pb2 as cluster_pb2_1
import nebius.api.nebius.msp.v1alpha1.resource as resource_1
import nebius.api.nebius.msp.v1alpha1.resource.template_pb2 as template_pb2_1
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
#@ local imports here @#

# file: nebius/msp/postgresql/v1alpha1/backup.proto
class Backup(pb_classes.Message):
    __PB2_CLASS__ = backup_pb2.Backup
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.Backup",backup_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "creation_start": well_known_1.ts_mask,
        "creation_finish": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        source_cluster_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        creation_start: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        creation_finish: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        source_cluster_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        source_cluster_visible: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        on_demand: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(source_cluster_id, unset.UnsetType):
            self.source_cluster_id = source_cluster_id
        if not isinstance(creation_start, unset.UnsetType):
            self.creation_start = creation_start
        if not isinstance(creation_finish, unset.UnsetType):
            self.creation_finish = creation_finish
        if not isinstance(source_cluster_name, unset.UnsetType):
            self.source_cluster_name = source_cluster_name
        if not isinstance(source_cluster_visible, unset.UnsetType):
            self.source_cluster_visible = source_cluster_visible
        if not isinstance(on_demand, unset.UnsetType):
            self.on_demand = on_demand
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "source_cluster_id",
            "creation_start",
            "creation_finish",
            "source_cluster_name",
            "source_cluster_visible",
            "on_demand",
            "size_bytes",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Required. ID of the backup.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def source_cluster_id(self) -> "builtins.str":
        """
        ID of the PostgreSQL cluster that the backup was created for.
        """
        
        return super()._get_field("source_cluster_id", explicit_presence=False,
        )
    @source_cluster_id.setter
    def source_cluster_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_cluster_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def creation_start(self) -> "datetime.datetime":
        """
        Creation start timestamp.
        """
        
        return super()._get_field("creation_start", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @creation_start.setter
    def creation_start(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("creation_start",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def creation_finish(self) -> "datetime.datetime":
        """
        Creation finish timestamp.
        """
        
        return super()._get_field("creation_finish", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @creation_finish.setter
    def creation_finish(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("creation_finish",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def source_cluster_name(self) -> "builtins.str":
        """
        Name of the PostgreSQL cluster that the backup was created for.
        """
        
        return super()._get_field("source_cluster_name", explicit_presence=False,
        )
    @source_cluster_name.setter
    def source_cluster_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_cluster_name",value,explicit_presence=False,
        )
    
    @builtins.property
    def source_cluster_visible(self) -> "builtins.bool":
        """
        Is PostgreSQL cluster that the backup was created for visible.
        """
        
        return super()._get_field("source_cluster_visible", explicit_presence=False,
        )
    @source_cluster_visible.setter
    def source_cluster_visible(self, value: "builtins.bool|None") -> None:
        return super()._set_field("source_cluster_visible",value,explicit_presence=False,
        )
    
    @builtins.property
    def on_demand(self) -> "builtins.bool":
        """
        Is the backup an on-demand manual backup.
        """
        
        return super()._get_field("on_demand", explicit_presence=False,
        )
    @on_demand.setter
    def on_demand(self, value: "builtins.bool|None") -> None:
        return super()._set_field("on_demand",value,explicit_presence=False,
        )
    
    @builtins.property
    def size_bytes(self) -> "builtins.int":
        """
        Size of the backup in bytes.
        """
        
        return super()._get_field("size_bytes", explicit_presence=False,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "source_cluster_id":"source_cluster_id",
        "creation_start":"creation_start",
        "creation_finish":"creation_finish",
        "source_cluster_name":"source_cluster_name",
        "source_cluster_visible":"source_cluster_visible",
        "on_demand":"on_demand",
        "size_bytes":"size_bytes",
    }
    
# file: nebius/msp/postgresql/v1alpha1/backup_service.proto
class GetBackupRequest(pb_classes.Message):
    __PB2_CLASS__ = backup_service_pb2.GetBackupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.GetBackupRequest",backup_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cluster_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        backup_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cluster_id, unset.UnsetType):
            self.cluster_id = cluster_id
        if not isinstance(backup_id, unset.UnsetType):
            self.backup_id = backup_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cluster_id",
            "backup_id",
        ]
    
    @builtins.property
    def cluster_id(self) -> "builtins.str":
        """
        ID of the PostgreSQL cluster that holds backup.
        """
        
        return super()._get_field("cluster_id", explicit_presence=False,
        )
    @cluster_id.setter
    def cluster_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("cluster_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def backup_id(self) -> "builtins.str":
        """
        ID of the designated backup.
        """
        
        return super()._get_field("backup_id", explicit_presence=False,
        )
    @backup_id.setter
    def backup_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("backup_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cluster_id":"cluster_id",
        "backup_id":"backup_id",
    }
    
class ListBackupsRequest(pb_classes.Message):
    __PB2_CLASS__ = backup_service_pb2.ListBackupsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.ListBackupsRequest",backup_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Identifier of IAM container to list backups from.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
    }
    
class ListBackupsByClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = backup_service_pb2.ListBackupsByClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.ListBackupsByClusterRequest",backup_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cluster_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cluster_id, unset.UnsetType):
            self.cluster_id = cluster_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cluster_id",
        ]
    
    @builtins.property
    def cluster_id(self) -> "builtins.str":
        """
        ID of the PostgreSQL cluster to list backups from.
        """
        
        return super()._get_field("cluster_id", explicit_presence=False,
        )
    @cluster_id.setter
    def cluster_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("cluster_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cluster_id":"cluster_id",
    }
    
class ListBackupsResponse(pb_classes.Message):
    __PB2_CLASS__ = backup_service_pb2.ListBackupsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.ListBackupsResponse",backup_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        backups: "abc.Iterable[Backup]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(backups, unset.UnsetType):
            self.backups = backups
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "backups",
        ]
    
    @builtins.property
    def backups(self) -> "abc.MutableSequence[Backup]":
        """
        List of backups.
        """
        
        return super()._get_field("backups", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Backup,None,None),
        )
    @backups.setter
    def backups(self, value: "abc.Iterable[Backup]|None") -> None:
        return super()._set_field("backups",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "backups":"backups",
    }
    
class CreateBackupRequest(pb_classes.Message):
    __PB2_CLASS__ = backup_service_pb2.CreateBackupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.CreateBackupRequest",backup_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cluster_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cluster_id, unset.UnsetType):
            self.cluster_id = cluster_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cluster_id",
        ]
    
    @builtins.property
    def cluster_id(self) -> "builtins.str":
        """
        ID of the PostgreSQL cluster that holds backup.
        """
        
        return super()._get_field("cluster_id", explicit_presence=False,
        )
    @cluster_id.setter
    def cluster_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("cluster_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cluster_id":"cluster_id",
    }
    
class DeleteBackupRequest(pb_classes.Message):
    __PB2_CLASS__ = backup_service_pb2.DeleteBackupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.DeleteBackupRequest",backup_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cluster_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        backup_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cluster_id, unset.UnsetType):
            self.cluster_id = cluster_id
        if not isinstance(backup_id, unset.UnsetType):
            self.backup_id = backup_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cluster_id",
            "backup_id",
        ]
    
    @builtins.property
    def cluster_id(self) -> "builtins.str":
        """
        ID of the PostgreSQL cluster that holds backup.
        """
        
        return super()._get_field("cluster_id", explicit_presence=False,
        )
    @cluster_id.setter
    def cluster_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("cluster_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def backup_id(self) -> "builtins.str":
        """
        ID of the designated backup.
        """
        
        return super()._get_field("backup_id", explicit_presence=False,
        )
    @backup_id.setter
    def backup_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("backup_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cluster_id":"cluster_id",
        "backup_id":"backup_id",
    }
    

class BackupServiceClient(client.ClientWithOperations[v1alpha1_1.Operation,v1alpha1_1.OperationServiceClient]):
    """
    A set of methods for managing PostgreSQL Cluster backups.
    
    This class provides the client methods for the ``.nebius.msp.postgresql.v1alpha1.BackupService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.msp.postgresql.v1alpha1.BackupService",backup_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.msp.postgresql.v1alpha1.BackupService"
    __operation_type__ = v1alpha1_1.Operation
    __operation_service_class__ = v1alpha1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetBackupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetBackupRequest","Backup"]:
        """
        Returns the specified PostgreSQL Cluster backup.
        To get the list of available PostgreSQL Cluster backups, make a [List] or [ListByCluster] request.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.GetBackupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.msp.postgresql.v1alpha1.Backup`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=backup_pb2.Backup,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Backup),
        )
    
    def list(self,
        request: "ListBackupsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListBackupsRequest","ListBackupsResponse"]:
        """
        Retrieves the list of PostgreSQL Cluster backups by project.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.ListBackupsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.msp.postgresql.v1alpha1.ListBackupsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=backup_service_pb2.ListBackupsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListBackupsResponse),
        )
    
    def list_by_cluster(self,
        request: "ListBackupsByClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListBackupsByClusterRequest","ListBackupsResponse"]:
        """
        Retrieves the list of PostgreSQL Cluster backups by cluster.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.ListBackupsByClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.msp.postgresql.v1alpha1.ListBackupsResponse`.
        """
        
        return super().request(
            method="ListByCluster",
            request=request,
            result_pb2_class=backup_service_pb2.ListBackupsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListBackupsResponse),
        )
    
    def create(self,
        request: "CreateBackupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateBackupRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        Creates a new on-demand backup.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.CreateBackupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteBackupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteBackupRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        Deletes an on-demand backup.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.DeleteBackupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    

# file: nebius/msp/postgresql/v1alpha1/template.proto
class TemplateSpec(pb_classes.Message):
    __PB2_CLASS__ = template_pb2.TemplateSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.TemplateSpec",template_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resources: "resource_1.ResourcesSpec|template_pb2_1.ResourcesSpec|None|unset.UnsetType" = unset.Unset,
        hosts: "resource_1.HostSpec|template_pb2_1.HostSpec|None|unset.UnsetType" = unset.Unset,
        disk: "resource_1.DiskSpec|template_pb2_1.DiskSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resources, unset.UnsetType):
            self.resources = resources
        if not isinstance(hosts, unset.UnsetType):
            self.hosts = hosts
        if not isinstance(disk, unset.UnsetType):
            self.disk = disk
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resources",
            "hosts",
            "disk",
        ]
    
    @builtins.property
    def resources(self) -> "resource_1.ResourcesSpec":
        """
        reduced msp.v1alpha1.resource.TemplateSpec
        """
        
        return super()._get_field("resources", explicit_presence=False,
        wrap=resource_1.ResourcesSpec,
        )
    @resources.setter
    def resources(self, value: "resource_1.ResourcesSpec|template_pb2_1.ResourcesSpec|None") -> None:
        return super()._set_field("resources",value,explicit_presence=False,
        )
    
    @builtins.property
    def hosts(self) -> "resource_1.HostSpec":
        return super()._get_field("hosts", explicit_presence=False,
        wrap=resource_1.HostSpec,
        )
    @hosts.setter
    def hosts(self, value: "resource_1.HostSpec|template_pb2_1.HostSpec|None") -> None:
        return super()._set_field("hosts",value,explicit_presence=False,
        )
    
    @builtins.property
    def disk(self) -> "resource_1.DiskSpec":
        return super()._get_field("disk", explicit_presence=False,
        wrap=resource_1.DiskSpec,
        )
    @disk.setter
    def disk(self, value: "resource_1.DiskSpec|template_pb2_1.DiskSpec|None") -> None:
        return super()._set_field("disk",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resources":"resources",
        "hosts":"hosts",
        "disk":"disk",
    }
    
# file: nebius/msp/postgresql/v1alpha1/cluster.proto
class Cluster(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.Cluster
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.Cluster",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
        status: "ClusterStatus|cluster_pb2.ClusterStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ClusterStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ClusterStatus,
        )
    @status.setter
    def status(self, value: "ClusterStatus|cluster_pb2.ClusterStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ConnectionPoolerConfig(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ConnectionPoolerConfig
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.ConnectionPoolerConfig",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class PoolingMode(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.msp.postgresql.v1alpha1.ConnectionPoolerConfig.PoolingMode",cluster_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        POOLING_MODE_UNSPECIFIED = 0
        SESSION = 1
        """
        Session pooling mode.
        """
        
        TRANSACTION = 2
        """
        Transaction pooling mode.
        """
        
    
    class __OneOfClass__max_pool_size__(pb_classes.OneOf):
        name: builtins.str= "_max_pool_size"
        
        def __init__(self, msg: "ConnectionPoolerConfig") -> None:
            super().__init__()
            self._message: "ConnectionPoolerConfig" = msg
    
    class __OneOfClass__max_pool_size_max_pool_size__(__OneOfClass__max_pool_size__):
        field: typing.Literal["max_pool_size"] = "max_pool_size"
        
        def __init__(self, msg: "ConnectionPoolerConfig") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.max_pool_size
    
    @builtins.property
    def _max_pool_size(self) -> __OneOfClass__max_pool_size_max_pool_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_max_pool_size")
        match field_name_1:
            case "max_pool_size":
                return self.__OneOfClass__max_pool_size_max_pool_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        pooling_mode: "ConnectionPoolerConfig.PoolingMode|cluster_pb2.ConnectionPoolerConfig.PoolingMode|None|unset.UnsetType" = unset.Unset,
        max_pool_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(pooling_mode, unset.UnsetType):
            self.pooling_mode = pooling_mode
        if not isinstance(max_pool_size, unset.UnsetType):
            self.max_pool_size = max_pool_size
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "pooling_mode",
            "max_pool_size",
            "_max_pool_size",
            "PoolingMode",
        ]
    
    @builtins.property
    def pooling_mode(self) -> "ConnectionPoolerConfig.PoolingMode":
        """
        Mode that the connection pooler is working in.
        """
        
        return super()._get_field("pooling_mode", explicit_presence=False,
        wrap=ConnectionPoolerConfig.PoolingMode,
        )
    @pooling_mode.setter
    def pooling_mode(self, value: "ConnectionPoolerConfig.PoolingMode|cluster_pb2.ConnectionPoolerConfig.PoolingMode|None") -> None:
        return super()._set_field("pooling_mode",value,explicit_presence=False,
        )
    
    @builtins.property
    def max_pool_size(self) -> "builtins.int|None":
        """
        Maximum number of connections in the pool for a single user/database pair.
        """
        
        return super()._get_field("max_pool_size", explicit_presence=True,
        )
    @max_pool_size.setter
    def max_pool_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("max_pool_size",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "pooling_mode":"pooling_mode",
        "max_pool_size":"max_pool_size",
        "_max_pool_size":"_max_pool_size",
        "PoolingMode":"PoolingMode",
    }
    
class ClusterSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ClusterSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.ClusterSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        network_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        config: "ConfigSpec|cluster_pb2.ConfigSpec|None|unset.UnsetType" = unset.Unset,
        bootstrap: "BootstrapSpec|cluster_pb2.BootstrapSpec|None|unset.UnsetType" = unset.Unset,
        backup: "BackupSpec|cluster_pb2.BackupSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(network_id, unset.UnsetType):
            self.network_id = network_id
        if not isinstance(config, unset.UnsetType):
            self.config = config
        if not isinstance(bootstrap, unset.UnsetType):
            self.bootstrap = bootstrap
        if not isinstance(backup, unset.UnsetType):
            self.backup = backup
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "description",
            "network_id",
            "config",
            "bootstrap",
            "backup",
        ]
    
    @builtins.property
    def description(self) -> "builtins.str":
        """
        Description of the PostgreSQL cluster.
        """
        
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def network_id(self) -> "builtins.str":
        """
        Network ID in which the cluster is created.
        """
        
        return super()._get_field("network_id", explicit_presence=False,
        )
    @network_id.setter
    def network_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("network_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def config(self) -> "ConfigSpec":
        return super()._get_field("config", explicit_presence=False,
        wrap=ConfigSpec,
        )
    @config.setter
    def config(self, value: "ConfigSpec|cluster_pb2.ConfigSpec|None") -> None:
        return super()._set_field("config",value,explicit_presence=False,
        )
    
    @builtins.property
    def bootstrap(self) -> "BootstrapSpec":
        return super()._get_field("bootstrap", explicit_presence=False,
        wrap=BootstrapSpec,
        )
    @bootstrap.setter
    def bootstrap(self, value: "BootstrapSpec|cluster_pb2.BootstrapSpec|None") -> None:
        return super()._set_field("bootstrap",value,explicit_presence=False,
        )
    
    @builtins.property
    def backup(self) -> "BackupSpec":
        return super()._get_field("backup", explicit_presence=False,
        wrap=BackupSpec,
        )
    @backup.setter
    def backup(self, value: "BackupSpec|cluster_pb2.BackupSpec|None") -> None:
        return super()._set_field("backup",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "description":"description",
        "network_id":"network_id",
        "config":"config",
        "bootstrap":"bootstrap",
        "backup":"backup",
    }
    
class ClusterStatus(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ClusterStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.ClusterStatus",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        phase: "v1alpha1_2.ClusterStatus.Phase|cluster_pb2_1.ClusterStatus.Phase|None|unset.UnsetType" = unset.Unset,
        state: "v1alpha1_2.ClusterStatus.State|cluster_pb2_1.ClusterStatus.State|None|unset.UnsetType" = unset.Unset,
        preset_details: "resource_1.PresetDetails|template_pb2_1.PresetDetails|None|unset.UnsetType" = unset.Unset,
        connection_endpoints: "Endpoints|cluster_pb2.Endpoints|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(phase, unset.UnsetType):
            self.phase = phase
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(preset_details, unset.UnsetType):
            self.preset_details = preset_details
        if not isinstance(connection_endpoints, unset.UnsetType):
            self.connection_endpoints = connection_endpoints
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "phase",
            "state",
            "preset_details",
            "connection_endpoints",
        ]
    
    @builtins.property
    def phase(self) -> "v1alpha1_2.ClusterStatus.Phase":
        """
        Current phase of the cluster.
        """
        
        return super()._get_field("phase", explicit_presence=False,
        wrap=v1alpha1_2.ClusterStatus.Phase,
        )
    @phase.setter
    def phase(self, value: "v1alpha1_2.ClusterStatus.Phase|cluster_pb2_1.ClusterStatus.Phase|None") -> None:
        return super()._set_field("phase",value,explicit_presence=False,
        )
    
    @builtins.property
    def state(self) -> "v1alpha1_2.ClusterStatus.State":
        """
        State reflects substatus of the phase to define whether it's healthy or not.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=v1alpha1_2.ClusterStatus.State,
        )
    @state.setter
    def state(self, value: "v1alpha1_2.ClusterStatus.State|cluster_pb2_1.ClusterStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def preset_details(self) -> "resource_1.PresetDetails":
        """
        Cluster resource preset details
        """
        
        return super()._get_field("preset_details", explicit_presence=False,
        wrap=resource_1.PresetDetails,
        )
    @preset_details.setter
    def preset_details(self, value: "resource_1.PresetDetails|template_pb2_1.PresetDetails|None") -> None:
        return super()._set_field("preset_details",value,explicit_presence=False,
        )
    
    @builtins.property
    def connection_endpoints(self) -> "Endpoints":
        """
        Connection endpoints of the PostgreSQL cluster.
        """
        
        return super()._get_field("connection_endpoints", explicit_presence=False,
        wrap=Endpoints,
        )
    @connection_endpoints.setter
    def connection_endpoints(self, value: "Endpoints|cluster_pb2.Endpoints|None") -> None:
        return super()._set_field("connection_endpoints",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "phase":"phase",
        "state":"state",
        "preset_details":"preset_details",
        "connection_endpoints":"connection_endpoints",
    }
    
class Endpoints(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.Endpoints
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.Endpoints",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        private_read_write: "builtins.str|None|unset.UnsetType" = unset.Unset,
        private_read_only: "builtins.str|None|unset.UnsetType" = unset.Unset,
        public_read_write: "builtins.str|None|unset.UnsetType" = unset.Unset,
        public_read_only: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(private_read_write, unset.UnsetType):
            self.private_read_write = private_read_write
        if not isinstance(private_read_only, unset.UnsetType):
            self.private_read_only = private_read_only
        if not isinstance(public_read_write, unset.UnsetType):
            self.public_read_write = public_read_write
        if not isinstance(public_read_only, unset.UnsetType):
            self.public_read_only = public_read_only
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "private_read_write",
            "private_read_only",
            "public_read_write",
            "public_read_only",
        ]
    
    @builtins.property
    def private_read_write(self) -> "builtins.str":
        """
        Read write endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        
        return super()._get_field("private_read_write", explicit_presence=False,
        )
    @private_read_write.setter
    def private_read_write(self, value: "builtins.str|None") -> None:
        return super()._set_field("private_read_write",value,explicit_presence=False,
        )
    
    @builtins.property
    def private_read_only(self) -> "builtins.str":
        """
        Read only endpoint of the PostgreSQL cluster accessible from the private VPC.
        """
        
        return super()._get_field("private_read_only", explicit_presence=False,
        )
    @private_read_only.setter
    def private_read_only(self, value: "builtins.str|None") -> None:
        return super()._set_field("private_read_only",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_read_write(self) -> "builtins.str":
        """
        Read write endpoint of the PostgreSQL cluster accessible from the internet.
        """
        
        return super()._get_field("public_read_write", explicit_presence=False,
        )
    @public_read_write.setter
    def public_read_write(self, value: "builtins.str|None") -> None:
        return super()._set_field("public_read_write",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_read_only(self) -> "builtins.str":
        """
        Read only endpoint of the PostgreSQL cluster accessible from the internet.
        """
        
        return super()._get_field("public_read_only", explicit_presence=False,
        )
    @public_read_only.setter
    def public_read_only(self, value: "builtins.str|None") -> None:
        return super()._set_field("public_read_only",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "private_read_write":"private_read_write",
        "private_read_only":"private_read_only",
        "public_read_write":"public_read_write",
        "public_read_only":"public_read_only",
    }
    
class ConfigSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ConfigSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.ConfigSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_config__(pb_classes.OneOf):
        name: builtins.str= "config"
        
        def __init__(self, msg: "ConfigSpec") -> None:
            super().__init__()
            self._message: "ConfigSpec" = msg
    
    class __OneOfClass_config_postgresql_config_16__(__OneOfClass_config__):
        field: typing.Literal["postgresql_config_16"] = "postgresql_config_16"
        
        def __init__(self, msg: "ConfigSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "config_1.PostgresqlConfig16":
            return self._message.postgresql_config_16
    
    @builtins.property
    def config(self) -> __OneOfClass_config_postgresql_config_16__|None:
        """
        Config of the PostgreSQL cluster.
        """
        
        field_name_1: str|None = super().which_field_in_oneof("config")
        match field_name_1:
            case "postgresql_config_16":
                return self.__OneOfClass_config_postgresql_config_16__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        pooler_config: "ConnectionPoolerConfig|cluster_pb2.ConnectionPoolerConfig|None|unset.UnsetType" = unset.Unset,
        postgresql_config_16: "config_1.PostgresqlConfig16|postgresql_pb2.PostgresqlConfig16|None|unset.UnsetType" = unset.Unset,
        public_access: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        template: "TemplateSpec|template_pb2.TemplateSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(pooler_config, unset.UnsetType):
            self.pooler_config = pooler_config
        if not isinstance(postgresql_config_16, unset.UnsetType):
            self.postgresql_config_16 = postgresql_config_16
        if not isinstance(public_access, unset.UnsetType):
            self.public_access = public_access
        if not isinstance(template, unset.UnsetType):
            self.template = template
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
            "pooler_config",
            "postgresql_config_16",
            "public_access",
            "template",
            "config",
        ]
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        Version of PostgreSQL used in the cluster.
        Possible values: ``16``
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def pooler_config(self) -> "ConnectionPoolerConfig":
        """
        Configuration of the connection pooler.
        """
        
        return super()._get_field("pooler_config", explicit_presence=False,
        wrap=ConnectionPoolerConfig,
        )
    @pooler_config.setter
    def pooler_config(self, value: "ConnectionPoolerConfig|cluster_pb2.ConnectionPoolerConfig|None") -> None:
        return super()._set_field("pooler_config",value,explicit_presence=False,
        )
    
    @builtins.property
    def postgresql_config_16(self) -> "config_1.PostgresqlConfig16|None":
        """
        Configuration parameters for postgres
        """
        
        return super()._get_field("postgresql_config_16", explicit_presence=True,
        wrap=config_1.PostgresqlConfig16,
        )
    @postgresql_config_16.setter
    def postgresql_config_16(self, value: "config_1.PostgresqlConfig16|postgresql_pb2.PostgresqlConfig16|None") -> None:
        return super()._set_field("postgresql_config_16",value,explicit_presence=True,
        )
    
    @builtins.property
    def public_access(self) -> "builtins.bool":
        """
        Either make cluster public accessible or accessible only via private VPC.
        """
        
        return super()._get_field("public_access", explicit_presence=False,
        )
    @public_access.setter
    def public_access(self, value: "builtins.bool|None") -> None:
        return super()._set_field("public_access",value,explicit_presence=False,
        )
    
    @builtins.property
    def template(self) -> "TemplateSpec":
        """
        Resources allocated to PostgreSQL hosts.
        """
        
        return super()._get_field("template", explicit_presence=False,
        wrap=TemplateSpec,
        )
    @template.setter
    def template(self, value: "TemplateSpec|template_pb2.TemplateSpec|None") -> None:
        return super()._set_field("template",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
        "pooler_config":"pooler_config",
        "postgresql_config_16":"postgresql_config_16",
        "public_access":"public_access",
        "template":"template",
        "config":"config",
    }
    
class BootstrapSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.BootstrapSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.BootstrapSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        user_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        user_password: "builtins.str|None|unset.UnsetType" = unset.Unset,
        db_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(user_name, unset.UnsetType):
            self.user_name = user_name
        if not isinstance(user_password, unset.UnsetType):
            self.user_password = user_password
        if not isinstance(db_name, unset.UnsetType):
            self.db_name = db_name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "user_name",
            "user_password",
            "db_name",
        ]
    
    @builtins.property
    def user_name(self) -> "builtins.str":
        """
        Name of the bootstrap PostgreSQL user.
        """
        
        return super()._get_field("user_name", explicit_presence=False,
        )
    @user_name.setter
    def user_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("user_name",value,explicit_presence=False,
        )
    
    @builtins.property
    def user_password(self) -> "builtins.str":
        """
        Password of the bootstrap PostgreSQL user.
        """
        
        return super()._get_field("user_password", explicit_presence=False,
        )
    @user_password.setter
    def user_password(self, value: "builtins.str|None") -> None:
        return super()._set_field("user_password",value,explicit_presence=False,
        )
    
    @builtins.property
    def db_name(self) -> "builtins.str":
        """
        Name of the PostgreSQL database. 1-63 characters long.
        """
        
        return super()._get_field("db_name", explicit_presence=False,
        )
    @db_name.setter
    def db_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("db_name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "user_name":"user_name",
        "user_password":"user_password",
        "db_name":"db_name",
    }
    
class BackupSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.BackupSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.BackupSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        backup_window_start: "builtins.str|None|unset.UnsetType" = unset.Unset,
        retention_policy: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(backup_window_start, unset.UnsetType):
            self.backup_window_start = backup_window_start
        if not isinstance(retention_policy, unset.UnsetType):
            self.retention_policy = retention_policy
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "backup_window_start",
            "retention_policy",
        ]
    
    @builtins.property
    def backup_window_start(self) -> "builtins.str":
        """
        Backup window start in "HH:MM:SS" format (UTC Time)
        """
        
        return super()._get_field("backup_window_start", explicit_presence=False,
        )
    @backup_window_start.setter
    def backup_window_start(self, value: "builtins.str|None") -> None:
        return super()._set_field("backup_window_start",value,explicit_presence=False,
        )
    
    @builtins.property
    def retention_policy(self) -> "builtins.str":
        """
        Retention policy to be used for backups and WALs (i.e. '7d')
        """
        
        return super()._get_field("retention_policy", explicit_presence=False,
        )
    @retention_policy.setter
    def retention_policy(self, value: "builtins.str|None") -> None:
        return super()._set_field("retention_policy",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "backup_window_start":"backup_window_start",
        "retention_policy":"retention_policy",
    }
    
# file: nebius/msp/postgresql/v1alpha1/cluster_service.proto
class GetClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.GetClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.GetClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of the PostgreSQL Cluster resource to return.
        To get the cluster ID use a [ClusterService.List] request.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetClusterForBackupRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.GetClusterForBackupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.GetClusterForBackupRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        backup_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(backup_id, unset.UnsetType):
            self.backup_id = backup_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "backup_id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of the PostgreSQL cluster that holds backup.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def backup_id(self) -> "builtins.str":
        """
        ID of the backup for which source cluster is requested.
        """
        
        return super()._get_field("backup_id", explicit_presence=False,
        )
    @backup_id.setter
    def backup_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("backup_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "backup_id":"backup_id",
    }
    
class ListClustersRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClustersRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.ListClustersRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Identifier of IAM container to list clusters from.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListClustersResponse(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClustersResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.ListClustersResponse",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        clusters: "abc.Iterable[Cluster]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(clusters, unset.UnsetType):
            self.clusters = clusters
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "clusters",
            "next_page_token",
        ]
    
    @builtins.property
    def clusters(self) -> "abc.MutableSequence[Cluster]":
        """
        List of PostgreSQL Cluster resources.
        """
        
        return super()._get_field("clusters", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Cluster,None,None),
        )
    @clusters.setter
    def clusters(self, value: "abc.Iterable[Cluster]|None") -> None:
        return super()._set_field("clusters",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        This token allows you to get the next page of results for list requests. If the number of results
        is larger than [ListClustersRequest.page_size], use the [next_page_token] as the value
        for the [ListClustersRequest.page_token] parameter in the next list request. Each subsequent
        list request will have its own [next_page_token] to continue paging through the results.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "clusters":"clusters",
        "next_page_token":"next_page_token",
    }
    
class CreateClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.CreateClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.CreateClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata associated with the new cluster.
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        """
        Specification for the new cluster.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class RestoreClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.RestoreClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.RestoreClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "recovery_time": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
        backup_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        source_cluster_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        recovery_time: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(backup_id, unset.UnsetType):
            self.backup_id = backup_id
        if not isinstance(source_cluster_id, unset.UnsetType):
            self.source_cluster_id = source_cluster_id
        if not isinstance(recovery_time, unset.UnsetType):
            self.recovery_time = recovery_time
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "backup_id",
            "source_cluster_id",
            "recovery_time",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata associated with the new cluster.
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        """
        Specification for the new cluster.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def backup_id(self) -> "builtins.str":
        """
        ID of the backup to restore from.
        """
        
        return super()._get_field("backup_id", explicit_presence=False,
        )
    @backup_id.setter
    def backup_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("backup_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def source_cluster_id(self) -> "builtins.str":
        """
        ID of the PostgreSQL cluster to restore from.
        """
        
        return super()._get_field("source_cluster_id", explicit_presence=False,
        )
    @source_cluster_id.setter
    def source_cluster_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_cluster_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def recovery_time(self) -> "datetime.datetime":
        """
        Timestamp for point in time recovery.
        """
        
        return super()._get_field("recovery_time", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @recovery_time.setter
    def recovery_time(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("recovery_time",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "backup_id":"backup_id",
        "source_cluster_id":"source_cluster_id",
        "recovery_time":"recovery_time",
    }
    
class DeleteClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.DeleteClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.DeleteClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of the PostgreSQL cluster to delete.
        To get the PostgreSQL cluster ID, use a [ClusterService.List] request.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UpdateClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.UpdateClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.UpdateClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata associated with the cluster. Must include id of the cluster we are going to update.
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        """
        Updated specification for the cluster.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class StopClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.StopClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.StopClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of the PostgreSQL Cluster resource to pause.
        To get the cluster ID use a [ClusterService.List] request.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class StartClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.StartClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.msp.postgresql.v1alpha1.StartClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of the PostgreSQL Cluster resource to resume.
        To get the cluster ID use a [ClusterService.List] request.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class ClusterServiceClient(client.ClientWithOperations[v1alpha1_1.Operation,v1alpha1_1.OperationServiceClient]):
    """
    A set of methods for managing PostgreSQL Cluster resources.
    
    This class provides the client methods for the ``.nebius.msp.postgresql.v1alpha1.ClusterService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.msp.postgresql.v1alpha1.ClusterService",cluster_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.msp.postgresql.v1alpha1.ClusterService"
    __operation_type__ = v1alpha1_1.Operation
    __operation_service_class__ = v1alpha1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetClusterRequest","Cluster"]:
        """
        Returns the specified PostgreSQL Cluster resource.
        To get the list of available PostgreSQL Cluster resources, make a [List] request.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.GetClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.msp.postgresql.v1alpha1.Cluster`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=cluster_pb2.Cluster,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Cluster),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Cluster"]:
        """
        Returns the specified PostgreSQL Cluster resource by name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.msp.postgresql.v1alpha1.Cluster`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=cluster_pb2.Cluster,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Cluster),
        )
    
    def get_for_backup(self,
        request: "GetClusterForBackupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetClusterForBackupRequest","Cluster"]:
        """
        Returns the specified PostgreSQL Cluster resource for backup.
        It should be used as a hint of cluster configuration in case of backup restoration.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.GetClusterForBackupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.msp.postgresql.v1alpha1.Cluster`.
        """
        
        return super().request(
            method="GetForBackup",
            request=request,
            result_pb2_class=cluster_pb2.Cluster,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Cluster),
        )
    
    def list(self,
        request: "ListClustersRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListClustersRequest","ListClustersResponse"]:
        """
        Retrieves the list of PostgreSQL Cluster resources that belong
        to the specified folder.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.ListClustersRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.msp.postgresql.v1alpha1.ListClustersResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=cluster_service_pb2.ListClustersResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListClustersResponse),
        )
    
    def create(self,
        request: "CreateClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        Creates a PostgreSQL cluster in the specified folder.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.CreateClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        Deletes the specified PostgreSQL cluster.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.DeleteClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        Updates the PostgreSQL cluster.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.UpdateClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def restore(self,
        request: "RestoreClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["RestoreClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        Creates a new PostgreSQL cluster from a previously created backup.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.RestoreClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Restore",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def stop(self,
        request: "StopClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["StopClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        Suspends the PostgreSQL cluster to save resources.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.StopClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Stop",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def start(self,
        request: "StartClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["StartClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        Wakes up suspended PostgreSQL cluster.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.msp.postgresql.v1alpha1.StartClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Start",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    

__all__ = [
    #@ local import names here @#
    "Backup",
    "GetBackupRequest",
    "ListBackupsRequest",
    "ListBackupsByClusterRequest",
    "ListBackupsResponse",
    "CreateBackupRequest",
    "DeleteBackupRequest",
    "BackupServiceClient",
    "TemplateSpec",
    "Cluster",
    "ConnectionPoolerConfig",
    "ClusterSpec",
    "ClusterStatus",
    "Endpoints",
    "ConfigSpec",
    "BootstrapSpec",
    "BackupSpec",
    "GetClusterRequest",
    "GetClusterForBackupRequest",
    "ListClustersRequest",
    "ListClustersResponse",
    "CreateClusterRequest",
    "RestoreClusterRequest",
    "DeleteClusterRequest",
    "UpdateClusterRequest",
    "StopClusterRequest",
    "StartClusterRequest",
    "ClusterServiceClient",
]
