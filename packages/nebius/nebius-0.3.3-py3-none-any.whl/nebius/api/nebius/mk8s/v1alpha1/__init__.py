# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.mk8s.v1alpha1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.duration_pb2 as duration_pb2
import google.protobuf.empty_pb2 as empty_pb2
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import grpc as grpc
import logging as logging
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1alpha1 as v1alpha1_1
import nebius.api.nebius.common.v1alpha1.operation_pb2 as operation_pb2
import nebius.api.nebius.mk8s.v1alpha1.cluster_pb2 as cluster_pb2
import nebius.api.nebius.mk8s.v1alpha1.cluster_service_pb2 as cluster_service_pb2
import nebius.api.nebius.mk8s.v1alpha1.condition_pb2 as condition_pb2
import nebius.api.nebius.mk8s.v1alpha1.instance_template_pb2 as instance_template_pb2
import nebius.api.nebius.mk8s.v1alpha1.node_group_pb2 as node_group_pb2
import nebius.api.nebius.mk8s.v1alpha1.node_group_service_pb2 as node_group_service_pb2
import nebius.api.nebius.mk8s.v1alpha1.progress_data_pb2 as progress_data_pb2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
#@ local imports here @#

# file: nebius/mk8s/v1alpha1/cluster.proto
class Cluster(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.Cluster
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.Cluster",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
        status: "ClusterStatus|cluster_pb2.ClusterStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ClusterStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ClusterStatus,
        )
    @status.setter
    def status(self, value: "ClusterStatus|cluster_pb2.ClusterStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ClusterSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ClusterSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ClusterSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        control_plane: "ControlPlaneSpec|cluster_pb2.ControlPlaneSpec|None|unset.UnsetType" = unset.Unset,
        kube_network: "KubeNetworkSpec|cluster_pb2.KubeNetworkSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(control_plane, unset.UnsetType):
            self.control_plane = control_plane
        if not isinstance(kube_network, unset.UnsetType):
            self.kube_network = kube_network
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "control_plane",
            "kube_network",
        ]
    
    @builtins.property
    def control_plane(self) -> "ControlPlaneSpec":
        return super()._get_field("control_plane", explicit_presence=False,
        wrap=ControlPlaneSpec,
        )
    @control_plane.setter
    def control_plane(self, value: "ControlPlaneSpec|cluster_pb2.ControlPlaneSpec|None") -> None:
        return super()._set_field("control_plane",value,explicit_presence=False,
        )
    
    @builtins.property
    def kube_network(self) -> "KubeNetworkSpec":
        """
        Defines kubernetes network configuration, like IP allocation.
        """
        
        return super()._get_field("kube_network", explicit_presence=False,
        wrap=KubeNetworkSpec,
        )
    @kube_network.setter
    def kube_network(self, value: "KubeNetworkSpec|cluster_pb2.KubeNetworkSpec|None") -> None:
        return super()._set_field("kube_network",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "control_plane":"control_plane",
        "kube_network":"kube_network",
    }
    
class ControlPlaneSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ControlPlaneSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ControlPlaneSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        subnet_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        endpoints: "ControlPlaneEndpointsSpec|cluster_pb2.ControlPlaneEndpointsSpec|None|unset.UnsetType" = unset.Unset,
        etcd_cluster_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(subnet_id, unset.UnsetType):
            self.subnet_id = subnet_id
        if not isinstance(endpoints, unset.UnsetType):
            self.endpoints = endpoints
        if not isinstance(etcd_cluster_size, unset.UnsetType):
            self.etcd_cluster_size = etcd_cluster_size
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
            "subnet_id",
            "endpoints",
            "etcd_cluster_size",
        ]
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        Version is desired Kubernetes version of the cluster. For now only acceptable format is
        ``MAJOR.MINOR`` like "1.31". Option for patch version update will be added later.
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def subnet_id(self) -> "builtins.str":
        """
        Subnet ID where control plane instances will be located.
        """
        
        return super()._get_field("subnet_id", explicit_presence=False,
        )
    @subnet_id.setter
    def subnet_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subnet_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def endpoints(self) -> "ControlPlaneEndpointsSpec":
        return super()._get_field("endpoints", explicit_presence=False,
        wrap=ControlPlaneEndpointsSpec,
        )
    @endpoints.setter
    def endpoints(self, value: "ControlPlaneEndpointsSpec|cluster_pb2.ControlPlaneEndpointsSpec|None") -> None:
        return super()._set_field("endpoints",value,explicit_presence=False,
        )
    
    @builtins.property
    def etcd_cluster_size(self) -> "builtins.int":
        """
        Number of instances in etcd cluster.
        3 by default.
        Control plane with ``etcd_cluster_size: 3`` called "Highly Available" ("HA"), because it's Kubernetes API
        will be available despite a failure of one control plane instance.
        """
        
        return super()._get_field("etcd_cluster_size", explicit_presence=False,
        )
    @etcd_cluster_size.setter
    def etcd_cluster_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("etcd_cluster_size",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
        "subnet_id":"subnet_id",
        "endpoints":"endpoints",
        "etcd_cluster_size":"etcd_cluster_size",
    }
    
class ControlPlaneEndpointsSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ControlPlaneEndpointsSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ControlPlaneEndpointsSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        public_endpoint: "PublicEndpointSpec|cluster_pb2.PublicEndpointSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(public_endpoint, unset.UnsetType):
            self.public_endpoint = public_endpoint
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "public_endpoint",
        ]
    
    @builtins.property
    def public_endpoint(self) -> "PublicEndpointSpec|None":
        """
        PublicEndpointSpec is a specification of public endpoint for control plane.
        """
        
        return super()._get_field("public_endpoint", explicit_presence=True,
        wrap=PublicEndpointSpec,
        )
    @public_endpoint.setter
    def public_endpoint(self, value: "PublicEndpointSpec|cluster_pb2.PublicEndpointSpec|None") -> None:
        return super()._set_field("public_endpoint",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "public_endpoint":"public_endpoint",
    }
    
class PublicEndpointSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.PublicEndpointSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.PublicEndpointSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class KubeNetworkSpec(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.KubeNetworkSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.KubeNetworkSpec",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        service_cidrs: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(service_cidrs, unset.UnsetType):
            self.service_cidrs = service_cidrs
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "service_cidrs",
        ]
    
    @builtins.property
    def service_cidrs(self) -> "abc.MutableSequence[builtins.str]":
        """
        CIDR blocks for Service ClusterIP allocation.
        For now, only one value is supported.
        Must be a valid CIDR block or prefix length.
        In case of prefix length, certain CIDR is auto allocated.
        Specified CIDR blocks will be reserved in Cluster.spec.control_plane.subnet_id to prevent address duplication.
        Allowed prefix length is from "/12" to "/28".
        Empty value treated as ["/16"].
        """
        
        return super()._get_field("service_cidrs", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @service_cidrs.setter
    def service_cidrs(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("service_cidrs",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "service_cidrs":"service_cidrs",
    }
    
class ClusterStatus(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ClusterStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ClusterStatus",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1alpha1.ClusterStatus.State",cluster_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        PROVISIONING = 1
        RUNNING = 2
        DELETING = 3
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "ClusterStatus.State|cluster_pb2.ClusterStatus.State|None|unset.UnsetType" = unset.Unset,
        control_plane: "ControlPlaneStatus|cluster_pb2.ControlPlaneStatus|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(control_plane, unset.UnsetType):
            self.control_plane = control_plane
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "control_plane",
            "reconciling",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "ClusterStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=ClusterStatus.State,
        )
    @state.setter
    def state(self, value: "ClusterStatus.State|cluster_pb2.ClusterStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def control_plane(self) -> "ControlPlaneStatus":
        return super()._get_field("control_plane", explicit_presence=False,
        wrap=ControlPlaneStatus,
        )
    @control_plane.setter
    def control_plane(self, value: "ControlPlaneStatus|cluster_pb2.ControlPlaneStatus|None") -> None:
        return super()._set_field("control_plane",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Show that changes are in flight
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "control_plane":"control_plane",
        "reconciling":"reconciling",
        "State":"State",
    }
    
class ControlPlaneStatus(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ControlPlaneStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ControlPlaneStatus",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        endpoints: "ControlPlaneStatusEndpoints|cluster_pb2.ControlPlaneStatusEndpoints|None|unset.UnsetType" = unset.Unset,
        etcd_cluster_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        auth: "ControlPlaneStatusAuth|cluster_pb2.ControlPlaneStatusAuth|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(endpoints, unset.UnsetType):
            self.endpoints = endpoints
        if not isinstance(etcd_cluster_size, unset.UnsetType):
            self.etcd_cluster_size = etcd_cluster_size
        if not isinstance(auth, unset.UnsetType):
            self.auth = auth
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
            "endpoints",
            "etcd_cluster_size",
            "auth",
        ]
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        Version have format ``major.minor.patch-nebius-cp.n`` like "1.30.0-nebius-cp.3".
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def endpoints(self) -> "ControlPlaneStatusEndpoints":
        return super()._get_field("endpoints", explicit_presence=False,
        wrap=ControlPlaneStatusEndpoints,
        )
    @endpoints.setter
    def endpoints(self, value: "ControlPlaneStatusEndpoints|cluster_pb2.ControlPlaneStatusEndpoints|None") -> None:
        return super()._set_field("endpoints",value,explicit_presence=False,
        )
    
    @builtins.property
    def etcd_cluster_size(self) -> "builtins.int":
        """
        Number of instances in etcd cluster.
        """
        
        return super()._get_field("etcd_cluster_size", explicit_presence=False,
        )
    @etcd_cluster_size.setter
    def etcd_cluster_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("etcd_cluster_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def auth(self) -> "ControlPlaneStatusAuth":
        return super()._get_field("auth", explicit_presence=False,
        wrap=ControlPlaneStatusAuth,
        )
    @auth.setter
    def auth(self, value: "ControlPlaneStatusAuth|cluster_pb2.ControlPlaneStatusAuth|None") -> None:
        return super()._set_field("auth",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
        "endpoints":"endpoints",
        "etcd_cluster_size":"etcd_cluster_size",
        "auth":"auth",
    }
    
class ControlPlaneStatusEndpoints(pb_classes.Message):
    """
    Endpoints of Kubernetes control plane. Kubernetes API can be accessed at ``https://endpoint/``.
    """
    
    __PB2_CLASS__ = cluster_pb2.ControlPlaneStatusEndpoints
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ControlPlaneStatusEndpoints",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        public_endpoint: "builtins.str|None|unset.UnsetType" = unset.Unset,
        private_endpoint: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(public_endpoint, unset.UnsetType):
            self.public_endpoint = public_endpoint
        if not isinstance(private_endpoint, unset.UnsetType):
            self.private_endpoint = private_endpoint
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "public_endpoint",
            "private_endpoint",
        ]
    
    @builtins.property
    def public_endpoint(self) -> "builtins.str":
        """
        DNS name or IP address accessible from the Internet.
        """
        
        return super()._get_field("public_endpoint", explicit_presence=False,
        )
    @public_endpoint.setter
    def public_endpoint(self, value: "builtins.str|None") -> None:
        return super()._set_field("public_endpoint",value,explicit_presence=False,
        )
    
    @builtins.property
    def private_endpoint(self) -> "builtins.str":
        """
        DNS name or IP address accessible from the user VPC.
        """
        
        return super()._get_field("private_endpoint", explicit_presence=False,
        )
    @private_endpoint.setter
    def private_endpoint(self, value: "builtins.str|None") -> None:
        return super()._set_field("private_endpoint",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "public_endpoint":"public_endpoint",
        "private_endpoint":"private_endpoint",
    }
    
class ControlPlaneStatusAuth(pb_classes.Message):
    __PB2_CLASS__ = cluster_pb2.ControlPlaneStatusAuth
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ControlPlaneStatusAuth",cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cluster_ca_certificate: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cluster_ca_certificate, unset.UnsetType):
            self.cluster_ca_certificate = cluster_ca_certificate
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cluster_ca_certificate",
        ]
    
    @builtins.property
    def cluster_ca_certificate(self) -> "builtins.str":
        return super()._get_field("cluster_ca_certificate", explicit_presence=False,
        )
    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: "builtins.str|None") -> None:
        return super()._set_field("cluster_ca_certificate",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cluster_ca_certificate":"cluster_ca_certificate",
    }
    
# file: nebius/mk8s/v1alpha1/cluster_service.proto
class CreateClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.CreateClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.CreateClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.GetClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.GetClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(resource_version, unset.UnsetType):
            self.resource_version = resource_version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "resource_version",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_version(self) -> "builtins.str":
        return super()._get_field("resource_version", explicit_presence=False,
        )
    @resource_version.setter
    def resource_version(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "resource_version":"resource_version",
    }
    
class GetClusterByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.GetClusterByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.GetClusterByNameRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListClustersRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClustersRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ListClustersRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        ID of the IAM container we are listing the resources in.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListClustersResponse(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClustersResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ListClustersResponse",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Cluster]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Cluster]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Cluster,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Cluster]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class UpdateClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.UpdateClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.UpdateClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ClusterSpec|cluster_pb2.ClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata associated with the instance.
        Includes ID of the instance to update.
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ClusterSpec":
        """
        Updated specifications for the instance.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=ClusterSpec,
        )
    @spec.setter
    def spec(self, value: "ClusterSpec|cluster_pb2.ClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.DeleteClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.DeleteClusterRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListClusterControlPlaneVersionsRequest(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClusterControlPlaneVersionsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ListClusterControlPlaneVersionsRequest",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class ListClusterControlPlaneVersionsResponse(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ListClusterControlPlaneVersionsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ListClusterControlPlaneVersionsResponse",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[ClusterControlPlaneVersion]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[ClusterControlPlaneVersion]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(ClusterControlPlaneVersion,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[ClusterControlPlaneVersion]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
    }
    
class ClusterControlPlaneVersion(pb_classes.Message):
    __PB2_CLASS__ = cluster_service_pb2.ClusterControlPlaneVersion
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ClusterControlPlaneVersion",cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
        ]
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        Format of the version includes only MAJOR.MINOR, the same as can be passed to cluster creation API. For example "1.31".
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
    }
    

class ClusterServiceClient(client.ClientWithOperations[v1alpha1_1.Operation,v1alpha1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.mk8s.v1alpha1.ClusterService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.mk8s.v1alpha1.ClusterService",cluster_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.mk8s.v1alpha1.ClusterService"
    __operation_type__ = v1alpha1_1.Operation
    __operation_service_class__ = v1alpha1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetClusterRequest","Cluster"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.GetClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1alpha1.Cluster`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=cluster_pb2.Cluster,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Cluster),
        )
    
    def get_by_name(self,
        request: "GetClusterByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetClusterByNameRequest","Cluster"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.GetClusterByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1alpha1.Cluster`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=cluster_pb2.Cluster,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Cluster),
        )
    
    def list(self,
        request: "ListClustersRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListClustersRequest","ListClustersResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.ListClustersRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1alpha1.ListClustersResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=cluster_service_pb2.ListClustersResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListClustersResponse),
        )
    
    def create(self,
        request: "CreateClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.CreateClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.UpdateClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.DeleteClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list_control_plane_versions(self,
        request: "ListClusterControlPlaneVersionsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListClusterControlPlaneVersionsRequest","ListClusterControlPlaneVersionsResponse"]:
        """
        ListControlPlaneVersions returns all k8s release versions available in Nebius API.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.ListClusterControlPlaneVersionsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1alpha1.ListClusterControlPlaneVersionsResponse`.
        """
        
        return super().request(
            method="ListControlPlaneVersions",
            request=request,
            result_pb2_class=cluster_service_pb2.ListClusterControlPlaneVersionsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListClusterControlPlaneVersionsResponse),
        )
    

# file: nebius/mk8s/v1alpha1/condition.proto
class Condition(pb_classes.Message):
    __PB2_CLASS__ = condition_pb2.Condition
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.Condition",condition_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "last_transition_at": well_known_1.ts_mask,
    }
    
    class TransitionError(pb_classes.Message):
        __PB2_CLASS__ = condition_pb2.Condition.TransitionError
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.Condition.TransitionError",condition_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            reason: "builtins.str|None|unset.UnsetType" = unset.Unset,
            description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(reason, unset.UnsetType):
                self.reason = reason
            if not isinstance(description, unset.UnsetType):
                self.description = description
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "reason",
                "description",
            ]
        
        @builtins.property
        def reason(self) -> "builtins.str":
            return super()._get_field("reason", explicit_presence=False,
            )
        @reason.setter
        def reason(self, value: "builtins.str|None") -> None:
            return super()._set_field("reason",value,explicit_presence=False,
            )
        
        @builtins.property
        def description(self) -> "builtins.str":
            return super()._get_field("description", explicit_presence=False,
            )
        @description.setter
        def description(self, value: "builtins.str|None") -> None:
            return super()._set_field("description",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "reason":"reason",
            "description":"description",
        }
        
    
    class Severity(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1alpha1.Condition.Severity",condition_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        NONE = 0
        """
        Should apply only if the condition is in state "True".
        """
        
        INFO = 1
        """
        Specifies that a failure of a condition type
        should be viewed as purely informational
        """
        
        ERROR = 2
        """
        Specifies that a failure of a condition type
        should be viewed as an error.
        """
        
    
    class Status(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1alpha1.Condition.Status",condition_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNKNOWN = 0
        TRUE = 1
        FALSE = 2
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        status: "Condition.Status|condition_pb2.Condition.Status|None|unset.UnsetType" = unset.Unset,
        last_transition_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        reason: "builtins.str|None|unset.UnsetType" = unset.Unset,
        severity: "Condition.Severity|condition_pb2.Condition.Severity|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        last_transition_error: "Condition.TransitionError|condition_pb2.Condition.TransitionError|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(type, unset.UnsetType):
            self.type = type
        if not isinstance(status, unset.UnsetType):
            self.status = status
        if not isinstance(last_transition_at, unset.UnsetType):
            self.last_transition_at = last_transition_at
        if not isinstance(reason, unset.UnsetType):
            self.reason = reason
        if not isinstance(severity, unset.UnsetType):
            self.severity = severity
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(last_transition_error, unset.UnsetType):
            self.last_transition_error = last_transition_error
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "type",
            "status",
            "last_transition_at",
            "reason",
            "severity",
            "description",
            "last_transition_error",
            "TransitionError",
            "Severity",
            "Status",
        ]
    
    @builtins.property
    def type(self) -> "builtins.str":
        """
        Type of condition. Should be CamelCase
        """
        
        return super()._get_field("type", explicit_presence=False,
        )
    @type.setter
    def type(self, value: "builtins.str|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "Condition.Status":
        """
        Status of the condition, one of TRUE, FALSE or UNKNOWN.
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=Condition.Status,
        )
    @status.setter
    def status(self, value: "Condition.Status|condition_pb2.Condition.Status|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    @builtins.property
    def last_transition_at(self) -> "datetime.datetime":
        """
        The last time the condition transitioned from one status to another.
        """
        
        return super()._get_field("last_transition_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @last_transition_at.setter
    def last_transition_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("last_transition_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def reason(self) -> "builtins.str":
        """
        The reason for the condition's last transition in CamelCase.
        The values are considered a guaranteed API.
        """
        
        return super()._get_field("reason", explicit_presence=False,
        )
    @reason.setter
    def reason(self, value: "builtins.str|None") -> None:
        return super()._set_field("reason",value,explicit_presence=False,
        )
    
    @builtins.property
    def severity(self) -> "Condition.Severity":
        """
        Explicit classification of Reason code, so the users or machines can immediately
        understand the current situation and act accordingly.
        """
        
        return super()._get_field("severity", explicit_presence=False,
        wrap=Condition.Severity,
        )
    @severity.setter
    def severity(self, value: "Condition.Severity|condition_pb2.Condition.Severity|None") -> None:
        return super()._set_field("severity",value,explicit_presence=False,
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        """
        A human readable description message of this detail.
        """
        
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def last_transition_error(self) -> "Condition.TransitionError":
        return super()._get_field("last_transition_error", explicit_presence=False,
        wrap=Condition.TransitionError,
        )
    @last_transition_error.setter
    def last_transition_error(self, value: "Condition.TransitionError|condition_pb2.Condition.TransitionError|None") -> None:
        return super()._set_field("last_transition_error",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "type":"type",
        "status":"status",
        "last_transition_at":"last_transition_at",
        "reason":"reason",
        "severity":"severity",
        "description":"description",
        "last_transition_error":"last_transition_error",
        "TransitionError":"TransitionError",
        "Severity":"Severity",
        "Status":"Status",
    }
    
# file: nebius/mk8s/v1alpha1/instance_template.proto
class DiskSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_template_pb2.DiskSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.DiskSpec",instance_template_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class DiskType(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1alpha1.DiskSpec.DiskType",instance_template_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        NETWORK_SSD = 1
        """
        the list of available types will be clarified later, it is not final version
        """
        
        NETWORK_HDD = 2
        NETWORK_SSD_IO_M3 = 3
        NETWORK_SSD_NON_REPLICATED = 4
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__()
            self._message: "DiskSpec" = msg
    
    class __OneOfClass_size_size_bytes__(__OneOfClass_size__):
        field: typing.Literal["size_bytes"] = "size_bytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_bytes
    
    class __OneOfClass_size_size_kibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_kibibytes"] = "size_kibibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_kibibytes
    
    class __OneOfClass_size_size_mebibytes__(__OneOfClass_size__):
        field: typing.Literal["size_mebibytes"] = "size_mebibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_mebibytes
    
    class __OneOfClass_size_size_gibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_gibibytes"] = "size_gibibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_gibibytes
    
    @builtins.property
    def size(self) -> __OneOfClass_size_size_bytes__|__OneOfClass_size_size_kibibytes__|__OneOfClass_size_size_mebibytes__|__OneOfClass_size_size_gibibytes__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "size_bytes":
                return self.__OneOfClass_size_size_bytes__(self)
            case "size_kibibytes":
                return self.__OneOfClass_size_size_kibibytes__(self)
            case "size_mebibytes":
                return self.__OneOfClass_size_size_mebibytes__(self)
            case "size_gibibytes":
                return self.__OneOfClass_size_size_gibibytes__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_kibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_mebibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_gibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        block_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        type: "DiskSpec.DiskType|instance_template_pb2.DiskSpec.DiskType|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(size_kibibytes, unset.UnsetType):
            self.size_kibibytes = size_kibibytes
        if not isinstance(size_mebibytes, unset.UnsetType):
            self.size_mebibytes = size_mebibytes
        if not isinstance(size_gibibytes, unset.UnsetType):
            self.size_gibibytes = size_gibibytes
        if not isinstance(block_size_bytes, unset.UnsetType):
            self.block_size_bytes = block_size_bytes
        if not isinstance(type, unset.UnsetType):
            self.type = type
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "size_bytes",
            "size_kibibytes",
            "size_mebibytes",
            "size_gibibytes",
            "block_size_bytes",
            "type",
            "size",
            "DiskType",
        ]
    
    @builtins.property
    def size_bytes(self) -> "builtins.int|None":
        return super()._get_field("size_bytes", explicit_presence=True,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_kibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_kibibytes", explicit_presence=True,
        )
    @size_kibibytes.setter
    def size_kibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_kibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_mebibytes(self) -> "builtins.int|None":
        return super()._get_field("size_mebibytes", explicit_presence=True,
        )
    @size_mebibytes.setter
    def size_mebibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_mebibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_gibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_gibibytes", explicit_presence=True,
        )
    @size_gibibytes.setter
    def size_gibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_gibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def block_size_bytes(self) -> "builtins.int":
        return super()._get_field("block_size_bytes", explicit_presence=False,
        )
    @block_size_bytes.setter
    def block_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("block_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def type(self) -> "DiskSpec.DiskType":
        return super()._get_field("type", explicit_presence=False,
        wrap=DiskSpec.DiskType,
        )
    @type.setter
    def type(self, value: "DiskSpec.DiskType|instance_template_pb2.DiskSpec.DiskType|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "size_bytes":"size_bytes",
        "size_kibibytes":"size_kibibytes",
        "size_mebibytes":"size_mebibytes",
        "size_gibibytes":"size_gibibytes",
        "block_size_bytes":"block_size_bytes",
        "type":"type",
        "size":"size",
        "DiskType":"DiskType",
    }
    
class ResourcesSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_template_pb2.ResourcesSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ResourcesSpec",instance_template_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "ResourcesSpec") -> None:
            super().__init__()
            self._message: "ResourcesSpec" = msg
    
    class __OneOfClass_size_preset__(__OneOfClass_size__):
        field: typing.Literal["preset"] = "preset"
        
        def __init__(self, msg: "ResourcesSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.preset
    
    @builtins.property
    def size(self) -> __OneOfClass_size_preset__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "preset":
                return self.__OneOfClass_size_preset__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        platform: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preset: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(platform, unset.UnsetType):
            self.platform = platform
        if not isinstance(preset, unset.UnsetType):
            self.preset = preset
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "platform",
            "preset",
            "size",
        ]
    
    @builtins.property
    def platform(self) -> "builtins.str":
        return super()._get_field("platform", explicit_presence=False,
        )
    @platform.setter
    def platform(self, value: "builtins.str|None") -> None:
        return super()._set_field("platform",value,explicit_presence=False,
        )
    
    @builtins.property
    def preset(self) -> "builtins.str|None":
        return super()._get_field("preset", explicit_presence=True,
        )
    @preset.setter
    def preset(self, value: "builtins.str|None") -> None:
        return super()._set_field("preset",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "platform":"platform",
        "preset":"preset",
        "size":"size",
    }
    
# file: nebius/mk8s/v1alpha1/node_group.proto
class NodeGroup(pb_classes.Message):
    """
    NodeGroup represents Kubernetes node pool
    """
    
    __PB2_CLASS__ = node_group_pb2.NodeGroup
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NodeGroup",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None|unset.UnsetType" = unset.Unset,
        status: "NodeGroupStatus|node_group_pb2.NodeGroupStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        the parent_id is an ID of Cluster
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "NodeGroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=NodeGroupSpec,
        )
    @spec.setter
    def spec(self, value: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "NodeGroupStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=NodeGroupStatus,
        )
    @status.setter
    def status(self, value: "NodeGroupStatus|node_group_pb2.NodeGroupStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class NodeGroupSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeGroupSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NodeGroupSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "NodeGroupSpec") -> None:
            super().__init__()
            self._message: "NodeGroupSpec" = msg
    
    class __OneOfClass_size_fixed_node_count__(__OneOfClass_size__):
        field: typing.Literal["fixed_node_count"] = "fixed_node_count"
        
        def __init__(self, msg: "NodeGroupSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.fixed_node_count
    
    class __OneOfClass_size_autoscaling__(__OneOfClass_size__):
        field: typing.Literal["autoscaling"] = "autoscaling"
        
        def __init__(self, msg: "NodeGroupSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "NodeGroupAutoscalingSpec":
            return self._message.autoscaling
    
    @builtins.property
    def size(self) -> __OneOfClass_size_fixed_node_count__|__OneOfClass_size_autoscaling__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "fixed_node_count":
                return self.__OneOfClass_size_fixed_node_count__(self)
            case "autoscaling":
                return self.__OneOfClass_size_autoscaling__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        fixed_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        autoscaling: "NodeGroupAutoscalingSpec|node_group_pb2.NodeGroupAutoscalingSpec|None|unset.UnsetType" = unset.Unset,
        template: "NodeTemplate|node_group_pb2.NodeTemplate|None|unset.UnsetType" = unset.Unset,
        strategy: "NodeGroupDeploymentStrategy|node_group_pb2.NodeGroupDeploymentStrategy|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(fixed_node_count, unset.UnsetType):
            self.fixed_node_count = fixed_node_count
        if not isinstance(autoscaling, unset.UnsetType):
            self.autoscaling = autoscaling
        if not isinstance(template, unset.UnsetType):
            self.template = template
        if not isinstance(strategy, unset.UnsetType):
            self.strategy = strategy
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
            "fixed_node_count",
            "autoscaling",
            "template",
            "strategy",
            "size",
        ]
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        Version is desired Kubernetes version of the cluster. For now only acceptable format is
        ``MAJOR.MINOR`` like "1.31". Option for patch version update will be added later.
        By default the cluster control plane MAJOR.MINOR version will be used.
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def fixed_node_count(self) -> "builtins.int|None":
        return super()._get_field("fixed_node_count", explicit_presence=True,
        )
    @fixed_node_count.setter
    def fixed_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("fixed_node_count",value,explicit_presence=True,
        )
    
    @builtins.property
    def autoscaling(self) -> "NodeGroupAutoscalingSpec|None":
        return super()._get_field("autoscaling", explicit_presence=True,
        wrap=NodeGroupAutoscalingSpec,
        )
    @autoscaling.setter
    def autoscaling(self, value: "NodeGroupAutoscalingSpec|node_group_pb2.NodeGroupAutoscalingSpec|None") -> None:
        return super()._set_field("autoscaling",value,explicit_presence=True,
        )
    
    @builtins.property
    def template(self) -> "NodeTemplate":
        return super()._get_field("template", explicit_presence=False,
        wrap=NodeTemplate,
        )
    @template.setter
    def template(self, value: "NodeTemplate|node_group_pb2.NodeTemplate|None") -> None:
        return super()._set_field("template",value,explicit_presence=False,
        )
    
    @builtins.property
    def strategy(self) -> "NodeGroupDeploymentStrategy":
        return super()._get_field("strategy", explicit_presence=False,
        wrap=NodeGroupDeploymentStrategy,
        )
    @strategy.setter
    def strategy(self, value: "NodeGroupDeploymentStrategy|node_group_pb2.NodeGroupDeploymentStrategy|None") -> None:
        return super()._set_field("strategy",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
        "fixed_node_count":"fixed_node_count",
        "autoscaling":"autoscaling",
        "template":"template",
        "strategy":"strategy",
        "size":"size",
    }
    
class NodeTemplate(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeTemplate
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NodeTemplate",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "NodeMetadataTemplate|node_group_pb2.NodeMetadataTemplate|None|unset.UnsetType" = unset.Unset,
        taints: "abc.Iterable[NodeTaint]|None|unset.UnsetType" = unset.Unset,
        resources: "ResourcesSpec|instance_template_pb2.ResourcesSpec|None|unset.UnsetType" = unset.Unset,
        boot_disk: "DiskSpec|instance_template_pb2.DiskSpec|None|unset.UnsetType" = unset.Unset,
        gpu_settings: "GpuSettings|node_group_pb2.GpuSettings|None|unset.UnsetType" = unset.Unset,
        os: "builtins.str|None|unset.UnsetType" = unset.Unset,
        gpu_cluster: "GpuClusterSpec|node_group_pb2.GpuClusterSpec|None|unset.UnsetType" = unset.Unset,
        network_interfaces: "abc.Iterable[NetworkInterfaceTemplate]|None|unset.UnsetType" = unset.Unset,
        filesystems: "abc.Iterable[AttachedFilesystemSpec]|None|unset.UnsetType" = unset.Unset,
        cloud_init_user_data: "builtins.str|None|unset.UnsetType" = unset.Unset,
        service_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preemptible: "PreemptibleSpec|node_group_pb2.PreemptibleSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(taints, unset.UnsetType):
            self.taints = taints
        if not isinstance(resources, unset.UnsetType):
            self.resources = resources
        if not isinstance(boot_disk, unset.UnsetType):
            self.boot_disk = boot_disk
        if not isinstance(gpu_settings, unset.UnsetType):
            self.gpu_settings = gpu_settings
        if not isinstance(os, unset.UnsetType):
            self.os = os
        if not isinstance(gpu_cluster, unset.UnsetType):
            self.gpu_cluster = gpu_cluster
        if not isinstance(network_interfaces, unset.UnsetType):
            self.network_interfaces = network_interfaces
        if not isinstance(filesystems, unset.UnsetType):
            self.filesystems = filesystems
        if not isinstance(cloud_init_user_data, unset.UnsetType):
            self.cloud_init_user_data = cloud_init_user_data
        if not isinstance(service_account_id, unset.UnsetType):
            self.service_account_id = service_account_id
        if not isinstance(preemptible, unset.UnsetType):
            self.preemptible = preemptible
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "taints",
            "resources",
            "boot_disk",
            "gpu_settings",
            "os",
            "gpu_cluster",
            "network_interfaces",
            "filesystems",
            "cloud_init_user_data",
            "service_account_id",
            "preemptible",
        ]
    
    @builtins.property
    def metadata(self) -> "NodeMetadataTemplate":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=NodeMetadataTemplate,
        )
    @metadata.setter
    def metadata(self, value: "NodeMetadataTemplate|node_group_pb2.NodeMetadataTemplate|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def taints(self) -> "abc.MutableSequence[NodeTaint]":
        return super()._get_field("taints", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NodeTaint,None,None),
        )
    @taints.setter
    def taints(self, value: "abc.Iterable[NodeTaint]|None") -> None:
        return super()._set_field("taints",value,explicit_presence=False,
        )
    
    @builtins.property
    def resources(self) -> "ResourcesSpec":
        return super()._get_field("resources", explicit_presence=False,
        wrap=ResourcesSpec,
        )
    @resources.setter
    def resources(self, value: "ResourcesSpec|instance_template_pb2.ResourcesSpec|None") -> None:
        return super()._set_field("resources",value,explicit_presence=False,
        )
    
    @builtins.property
    def boot_disk(self) -> "DiskSpec":
        return super()._get_field("boot_disk", explicit_presence=False,
        wrap=DiskSpec,
        )
    @boot_disk.setter
    def boot_disk(self, value: "DiskSpec|instance_template_pb2.DiskSpec|None") -> None:
        return super()._set_field("boot_disk",value,explicit_presence=False,
        )
    
    @builtins.property
    def gpu_settings(self) -> "GpuSettings":
        """
        GPU-related settings.
        """
        
        return super()._get_field("gpu_settings", explicit_presence=False,
        wrap=GpuSettings,
        )
    @gpu_settings.setter
    def gpu_settings(self, value: "GpuSettings|node_group_pb2.GpuSettings|None") -> None:
        return super()._set_field("gpu_settings",value,explicit_presence=False,
        )
    
    @builtins.property
    def os(self) -> "builtins.str":
        """
        OS version that will be used to create the boot disk of Compute Instances in the NodeGroup.
        Supported platform / k8s version /  OS / driver presets combinations
          gpu-l40s-a, gpu-l40s-d, gpu-h100-sxm, gpu-h200-sxm, cpu-e1, cpu-e2, cpu-d3:
            drivers_preset: ""
              k8s: 1.30 → "ubuntu22.04"
              k8s: 1.31 → "ubuntu22.04" (default), "ubuntu24.04"
          gpu-l40s-a, gpu-l40s-d, gpu-h100-sxm, gpu-h200-sxm:
            drivers_preset: "cuda12" (CUDA 12.4)
              k8s: 1.30, 1.31 → "ubuntu22.04"
            drivers_preset: "cuda12.4"
              k8s: 1.31 → "ubuntu22.04"
            drivers_preset: "cuda12.8"
              k8s: 1.31 → "ubuntu24.04"
          gpu-b200-sxm:
            drivers_preset: ""
              k8s: 1.30, 1.31 → "ubuntu24.04"
            drivers_preset: "cuda12" (CUDA 12.8)
              k8s: 1.30, 1.31 → "ubuntu24.04"
            drivers_preset: "cuda12.8"
              k8s: 1.31 → "ubuntu24.04"
          gpu-b200-sxm-a:
            drivers_preset: ""
              k8s: 1.31 → "ubuntu24.04"
            drivers_preset: "cuda12.8"
              k8s: 1.31 → "ubuntu24.04"
        """
        
        return super()._get_field("os", explicit_presence=False,
        )
    @os.setter
    def os(self, value: "builtins.str|None") -> None:
        return super()._set_field("os",value,explicit_presence=False,
        )
    
    @builtins.property
    def gpu_cluster(self) -> "GpuClusterSpec":
        return super()._get_field("gpu_cluster", explicit_presence=False,
        wrap=GpuClusterSpec,
        )
    @gpu_cluster.setter
    def gpu_cluster(self, value: "GpuClusterSpec|node_group_pb2.GpuClusterSpec|None") -> None:
        return super()._set_field("gpu_cluster",value,explicit_presence=False,
        )
    
    @builtins.property
    def network_interfaces(self) -> "abc.MutableSequence[NetworkInterfaceTemplate]":
        return super()._get_field("network_interfaces", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NetworkInterfaceTemplate,None,None),
        )
    @network_interfaces.setter
    def network_interfaces(self, value: "abc.Iterable[NetworkInterfaceTemplate]|None") -> None:
        return super()._set_field("network_interfaces",value,explicit_presence=False,
        )
    
    @builtins.property
    def filesystems(self) -> "abc.MutableSequence[AttachedFilesystemSpec]":
        return super()._get_field("filesystems", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AttachedFilesystemSpec,None,None),
        )
    @filesystems.setter
    def filesystems(self, value: "abc.Iterable[AttachedFilesystemSpec]|None") -> None:
        return super()._set_field("filesystems",value,explicit_presence=False,
        )
    
    @builtins.property
    def cloud_init_user_data(self) -> "builtins.str":
        """
        cloud-init user-data. Must contain at least one SSH key.
        """
        
        return super()._get_field("cloud_init_user_data", explicit_presence=False,
        )
    @cloud_init_user_data.setter
    def cloud_init_user_data(self, value: "builtins.str|None") -> None:
        return super()._set_field("cloud_init_user_data",value,explicit_presence=False,
        )
    
    @builtins.property
    def service_account_id(self) -> "builtins.str":
        """
        the Nebius service account whose credentials will be available on the nodes of the group.
        With these credentials, it is possible to make ``nebius`` CLI or public API requests from the nodes without the need for extra authentication.
        This service account is also used to make requests to container registry.
        
        ``resource.serviceaccount.issueAccessToken`` permission is required to use this field.
        """
        
        return super()._get_field("service_account_id", explicit_presence=False,
        )
    @service_account_id.setter
    def service_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("service_account_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def preemptible(self) -> "PreemptibleSpec|None":
        """
        Configures whether the nodes in the group are preemptible.
        Set to empty value to enable preemptible nodes.
        """
        
        return super()._get_field("preemptible", explicit_presence=True,
        wrap=PreemptibleSpec,
        )
    @preemptible.setter
    def preemptible(self, value: "PreemptibleSpec|node_group_pb2.PreemptibleSpec|None") -> None:
        return super()._set_field("preemptible",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "taints":"taints",
        "resources":"resources",
        "boot_disk":"boot_disk",
        "gpu_settings":"gpu_settings",
        "os":"os",
        "gpu_cluster":"gpu_cluster",
        "network_interfaces":"network_interfaces",
        "filesystems":"filesystems",
        "cloud_init_user_data":"cloud_init_user_data",
        "service_account_id":"service_account_id",
        "preemptible":"preemptible",
    }
    
class NodeMetadataTemplate(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeMetadataTemplate
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NodeMetadataTemplate",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class LabelsEntry(pb_classes.Message):
        __PB2_CLASS__ = node_group_pb2.NodeMetadataTemplate.LabelsEntry
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NodeMetadataTemplate.LabelsEntry",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            key: "builtins.str|None|unset.UnsetType" = unset.Unset,
            value: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(key, unset.UnsetType):
                self.key = key
            if not isinstance(value, unset.UnsetType):
                self.value = value
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "key",
                "value",
            ]
        
        @builtins.property
        def key(self) -> "builtins.str":
            return super()._get_field("key", explicit_presence=False,
            )
        @key.setter
        def key(self, value: "builtins.str|None") -> None:
            return super()._set_field("key",value,explicit_presence=False,
            )
        
        @builtins.property
        def value(self) -> "builtins.str":
            return super()._get_field("value", explicit_presence=False,
            )
        @value.setter
        def value(self, value: "builtins.str|None") -> None:
            return super()._set_field("value",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "key":"key",
            "value":"value",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        labels: "abc.Mapping[builtins.str,builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(labels, unset.UnsetType):
            self.labels = labels
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "labels",
            "LabelsEntry",
        ]
    
    @builtins.property
    def labels(self) -> "abc.MutableMapping[builtins.str,builtins.str]":
        """
        Labels will be propagated into nodes metadata.
        System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
        On update labels they will not be updated in nodes right away, only on node group update.
        """
        
        return super()._get_field("labels", explicit_presence=False,
        wrap=pb_classes.Map,
        )
    @labels.setter
    def labels(self, value: "abc.Mapping[builtins.str,builtins.str]|None") -> None:
        return super()._set_field("labels",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "labels":"labels",
        "LabelsEntry":"LabelsEntry",
    }
    
class GpuSettings(pb_classes.Message):
    """
    GPU-related settings.
    """
    
    __PB2_CLASS__ = node_group_pb2.GpuSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.GpuSettings",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        drivers_preset: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(drivers_preset, unset.UnsetType):
            self.drivers_preset = drivers_preset
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "drivers_preset",
        ]
    
    @builtins.property
    def drivers_preset(self) -> "builtins.str":
        """
        Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
        Supported presets for different platform / k8s version combinations:
          gpu-l40s-a, gpu-l40s-d, gpu-h100-sxm, gpu-h200-sxm:
            k8s: 1.30 → "cuda12" (CUDA 12.4)
            k8s: 1.31 → "cuda12" (CUDA 12.4), "cuda12.4", "cuda12.8"
          gpu-b200-sxm:
            k8s: 1.31 → "cuda12" (CUDA 12.8), "cuda12.8"
          gpu-b200-sxm-a:
            k8s: 1.31 → "cuda12.8"
        """
        
        return super()._get_field("drivers_preset", explicit_presence=False,
        )
    @drivers_preset.setter
    def drivers_preset(self, value: "builtins.str|None") -> None:
        return super()._set_field("drivers_preset",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "drivers_preset":"drivers_preset",
    }
    
class GpuClusterSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.GpuClusterSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.GpuClusterSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class NetworkInterfaceTemplate(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NetworkInterfaceTemplate
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NetworkInterfaceTemplate",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        public_ip_address: "PublicIPAddress|node_group_pb2.PublicIPAddress|None|unset.UnsetType" = unset.Unset,
        subnet_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(public_ip_address, unset.UnsetType):
            self.public_ip_address = public_ip_address
        if not isinstance(subnet_id, unset.UnsetType):
            self.subnet_id = subnet_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "public_ip_address",
            "subnet_id",
        ]
    
    @builtins.property
    def public_ip_address(self) -> "PublicIPAddress|None":
        """
        Public IPv4 address associated with the interface.
        """
        
        return super()._get_field("public_ip_address", explicit_presence=True,
        wrap=PublicIPAddress,
        )
    @public_ip_address.setter
    def public_ip_address(self, value: "PublicIPAddress|node_group_pb2.PublicIPAddress|None") -> None:
        return super()._set_field("public_ip_address",value,explicit_presence=True,
        )
    
    @builtins.property
    def subnet_id(self) -> "builtins.str":
        """
        Subnet ID that will be attached to a node cloud intstance network interface.
        By default control plane subnet_id used.
        Subnet should be located in the same network with control plane and have same parent ID as cluster.
        """
        
        return super()._get_field("subnet_id", explicit_presence=False,
        )
    @subnet_id.setter
    def subnet_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subnet_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "public_ip_address":"public_ip_address",
        "subnet_id":"subnet_id",
    }
    
class PublicIPAddress(pb_classes.Message):
    """
    Describes a public IP address.
    """
    
    __PB2_CLASS__ = node_group_pb2.PublicIPAddress
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.PublicIPAddress",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class AttachedFilesystemSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.AttachedFilesystemSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.AttachedFilesystemSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class AttachMode(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1alpha1.AttachedFilesystemSpec.AttachMode",node_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        READ_ONLY = 1
        READ_WRITE = 2
    
    class __OneOfClass_type__(pb_classes.OneOf):
        name: builtins.str= "type"
        
        def __init__(self, msg: "AttachedFilesystemSpec") -> None:
            super().__init__()
            self._message: "AttachedFilesystemSpec" = msg
    
    class __OneOfClass_type_existing_filesystem__(__OneOfClass_type__):
        field: typing.Literal["existing_filesystem"] = "existing_filesystem"
        
        def __init__(self, msg: "AttachedFilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ExistingFilesystem":
            return self._message.existing_filesystem
    
    @builtins.property
    def type(self) -> __OneOfClass_type_existing_filesystem__|None:
        field_name_1: str|None = super().which_field_in_oneof("type")
        match field_name_1:
            case "existing_filesystem":
                return self.__OneOfClass_type_existing_filesystem__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        attach_mode: "AttachedFilesystemSpec.AttachMode|node_group_pb2.AttachedFilesystemSpec.AttachMode|None|unset.UnsetType" = unset.Unset,
        device_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        existing_filesystem: "ExistingFilesystem|node_group_pb2.ExistingFilesystem|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(attach_mode, unset.UnsetType):
            self.attach_mode = attach_mode
        if not isinstance(device_name, unset.UnsetType):
            self.device_name = device_name
        if not isinstance(existing_filesystem, unset.UnsetType):
            self.existing_filesystem = existing_filesystem
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "attach_mode",
            "device_name",
            "existing_filesystem",
            "type",
            "AttachMode",
        ]
    
    @builtins.property
    def attach_mode(self) -> "AttachedFilesystemSpec.AttachMode":
        return super()._get_field("attach_mode", explicit_presence=False,
        wrap=AttachedFilesystemSpec.AttachMode,
        )
    @attach_mode.setter
    def attach_mode(self, value: "AttachedFilesystemSpec.AttachMode|node_group_pb2.AttachedFilesystemSpec.AttachMode|None") -> None:
        return super()._set_field("attach_mode",value,explicit_presence=False,
        )
    
    @builtins.property
    def device_name(self) -> "builtins.str":
        return super()._get_field("device_name", explicit_presence=False,
        )
    @device_name.setter
    def device_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("device_name",value,explicit_presence=False,
        )
    
    @builtins.property
    def existing_filesystem(self) -> "ExistingFilesystem|None":
        return super()._get_field("existing_filesystem", explicit_presence=True,
        wrap=ExistingFilesystem,
        )
    @existing_filesystem.setter
    def existing_filesystem(self, value: "ExistingFilesystem|node_group_pb2.ExistingFilesystem|None") -> None:
        return super()._set_field("existing_filesystem",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "attach_mode":"attach_mode",
        "device_name":"device_name",
        "existing_filesystem":"existing_filesystem",
        "type":"type",
        "AttachMode":"AttachMode",
    }
    
class ExistingFilesystem(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.ExistingFilesystem
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ExistingFilesystem",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class NodeGroupAutoscalingSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeGroupAutoscalingSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NodeGroupAutoscalingSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        min_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        max_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(min_node_count, unset.UnsetType):
            self.min_node_count = min_node_count
        if not isinstance(max_node_count, unset.UnsetType):
            self.max_node_count = max_node_count
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "min_node_count",
            "max_node_count",
        ]
    
    @builtins.property
    def min_node_count(self) -> "builtins.int":
        return super()._get_field("min_node_count", explicit_presence=False,
        )
    @min_node_count.setter
    def min_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("min_node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def max_node_count(self) -> "builtins.int":
        return super()._get_field("max_node_count", explicit_presence=False,
        )
    @max_node_count.setter
    def max_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("max_node_count",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "min_node_count":"min_node_count",
        "max_node_count":"max_node_count",
    }
    
class PreemptibleSpec(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.PreemptibleSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.PreemptibleSpec",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class NodeTaint(pb_classes.Message):
    """
    See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
    """
    
    __PB2_CLASS__ = node_group_pb2.NodeTaint
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NodeTaint",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class Effect(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1alpha1.NodeTaint.Effect",node_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        EFFECT_UNSPECIFIED = 0
        NO_EXECUTE = 1
        NO_SCHEDULE = 2
        PREFER_NO_SCHEDULE = 3
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        key: "builtins.str|None|unset.UnsetType" = unset.Unset,
        value: "builtins.str|None|unset.UnsetType" = unset.Unset,
        effect: "NodeTaint.Effect|node_group_pb2.NodeTaint.Effect|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(key, unset.UnsetType):
            self.key = key
        if not isinstance(value, unset.UnsetType):
            self.value = value
        if not isinstance(effect, unset.UnsetType):
            self.effect = effect
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "key",
            "value",
            "effect",
            "Effect",
        ]
    
    @builtins.property
    def key(self) -> "builtins.str":
        return super()._get_field("key", explicit_presence=False,
        )
    @key.setter
    def key(self, value: "builtins.str|None") -> None:
        return super()._set_field("key",value,explicit_presence=False,
        )
    
    @builtins.property
    def value(self) -> "builtins.str":
        return super()._get_field("value", explicit_presence=False,
        )
    @value.setter
    def value(self, value: "builtins.str|None") -> None:
        return super()._set_field("value",value,explicit_presence=False,
        )
    
    @builtins.property
    def effect(self) -> "NodeTaint.Effect":
        return super()._get_field("effect", explicit_presence=False,
        wrap=NodeTaint.Effect,
        )
    @effect.setter
    def effect(self, value: "NodeTaint.Effect|node_group_pb2.NodeTaint.Effect|None") -> None:
        return super()._set_field("effect",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "key":"key",
        "value":"value",
        "effect":"effect",
        "Effect":"Effect",
    }
    
class NodeGroupDeploymentStrategy(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeGroupDeploymentStrategy
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NodeGroupDeploymentStrategy",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "drain_timeout": well_known_1.duration_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        max_unavailable: "PercentOrCount|node_group_pb2.PercentOrCount|None|unset.UnsetType" = unset.Unset,
        max_surge: "PercentOrCount|node_group_pb2.PercentOrCount|None|unset.UnsetType" = unset.Unset,
        drain_timeout: "duration_pb2.Duration|datetime.timedelta|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(max_unavailable, unset.UnsetType):
            self.max_unavailable = max_unavailable
        if not isinstance(max_surge, unset.UnsetType):
            self.max_surge = max_surge
        if not isinstance(drain_timeout, unset.UnsetType):
            self.drain_timeout = drain_timeout
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "max_unavailable",
            "max_surge",
            "drain_timeout",
        ]
    
    @builtins.property
    def max_unavailable(self) -> "PercentOrCount":
        """
        The maximum number of machines that can be unavailable during the update.
        Value can be an absolute number (ex: 5) or a percentage of desired
        machines (ex: 10%).
        Absolute number is calculated from percentage by rounding down.
        This can not be 0 if MaxSurge is 0.
        Defaults to 0.
        Example: when this is set to 30%, the old MachineSet can be scaled
        down to 70% of desired machines immediately when the rolling update
        starts. Once new machines are ready, old MachineSet can be scaled
        down further, followed by scaling up the new MachineSet, ensuring
        that the total number of machines available at all times
        during the update is at least 70% of desired machines.
        """
        
        return super()._get_field("max_unavailable", explicit_presence=False,
        wrap=PercentOrCount,
        )
    @max_unavailable.setter
    def max_unavailable(self, value: "PercentOrCount|node_group_pb2.PercentOrCount|None") -> None:
        return super()._set_field("max_unavailable",value,explicit_presence=False,
        )
    
    @builtins.property
    def max_surge(self) -> "PercentOrCount":
        """
        The maximum number of machines that can be scheduled above the
        desired number of machines.
        Value can be an absolute number (ex: 5) or a percentage of
        desired machines (ex: 10%).
        This can not be 0 if MaxUnavailable is 0.
        Absolute number is calculated from percentage by rounding up.
        Defaults to 1.
        Example: when this is set to 30%, the new MachineSet can be scaled
        up immediately when the rolling update starts, such that the total
        number of old and new machines do not exceed 130% of desired
        machines. Once old machines have been killed, new MachineSet can
        be scaled up further, ensuring that total number of machines running
        at any time during the update is at most 130% of desired machines.
        """
        
        return super()._get_field("max_surge", explicit_presence=False,
        wrap=PercentOrCount,
        )
    @max_surge.setter
    def max_surge(self, value: "PercentOrCount|node_group_pb2.PercentOrCount|None") -> None:
        return super()._set_field("max_surge",value,explicit_presence=False,
        )
    
    @builtins.property
    def drain_timeout(self) -> "datetime.timedelta":
        """
        DrainTimeout is the total amount of time that the service will spend on draining a node.
        By default, node can be drained without any time limitations.
        NOTE: NodeDrainTimeout is different from ``kubectl drain --timeout``
        """
        
        return super()._get_field("drain_timeout", explicit_presence=False,
        wrap=well_known_1.from_duration
        )
    @drain_timeout.setter
    def drain_timeout(self, value: "duration_pb2.Duration|datetime.timedelta|None") -> None:
        return super()._set_field("drain_timeout",value,explicit_presence=False,
        unwrap=well_known_1.to_duration
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "max_unavailable":"max_unavailable",
        "max_surge":"max_surge",
        "drain_timeout":"drain_timeout",
    }
    
class PercentOrCount(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.PercentOrCount
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.PercentOrCount",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_value__(pb_classes.OneOf):
        name: builtins.str= "value"
        
        def __init__(self, msg: "PercentOrCount") -> None:
            super().__init__()
            self._message: "PercentOrCount" = msg
    
    class __OneOfClass_value_percent__(__OneOfClass_value__):
        field: typing.Literal["percent"] = "percent"
        
        def __init__(self, msg: "PercentOrCount") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.percent
    
    class __OneOfClass_value_count__(__OneOfClass_value__):
        field: typing.Literal["count"] = "count"
        
        def __init__(self, msg: "PercentOrCount") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.count
    
    @builtins.property
    def value(self) -> __OneOfClass_value_percent__|__OneOfClass_value_count__|None:
        field_name_1: str|None = super().which_field_in_oneof("value")
        match field_name_1:
            case "percent":
                return self.__OneOfClass_value_percent__(self)
            case "count":
                return self.__OneOfClass_value_count__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        percent: "builtins.int|None|unset.UnsetType" = unset.Unset,
        count: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(percent, unset.UnsetType):
            self.percent = percent
        if not isinstance(count, unset.UnsetType):
            self.count = count
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "percent",
            "count",
            "value",
        ]
    
    @builtins.property
    def percent(self) -> "builtins.int|None":
        return super()._get_field("percent", explicit_presence=True,
        )
    @percent.setter
    def percent(self, value: "builtins.int|None") -> None:
        return super()._set_field("percent",value,explicit_presence=True,
        )
    
    @builtins.property
    def count(self) -> "builtins.int|None":
        return super()._get_field("count", explicit_presence=True,
        )
    @count.setter
    def count(self, value: "builtins.int|None") -> None:
        return super()._set_field("count",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "percent":"percent",
        "count":"count",
        "value":"value",
    }
    
class NodeGroupStatus(pb_classes.Message):
    __PB2_CLASS__ = node_group_pb2.NodeGroupStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.NodeGroupStatus",node_group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.mk8s.v1alpha1.NodeGroupStatus.State",node_group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        PROVISIONING = 1
        RUNNING = 2
        DELETING = 3
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "NodeGroupStatus.State|node_group_pb2.NodeGroupStatus.State|None|unset.UnsetType" = unset.Unset,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        target_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        outdated_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        ready_node_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        conditions: "abc.Iterable[Condition]|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(target_node_count, unset.UnsetType):
            self.target_node_count = target_node_count
        if not isinstance(node_count, unset.UnsetType):
            self.node_count = node_count
        if not isinstance(outdated_node_count, unset.UnsetType):
            self.outdated_node_count = outdated_node_count
        if not isinstance(ready_node_count, unset.UnsetType):
            self.ready_node_count = ready_node_count
        if not isinstance(conditions, unset.UnsetType):
            self.conditions = conditions
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "version",
            "target_node_count",
            "node_count",
            "outdated_node_count",
            "ready_node_count",
            "conditions",
            "reconciling",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "NodeGroupStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=NodeGroupStatus.State,
        )
    @state.setter
    def state(self, value: "NodeGroupStatus.State|node_group_pb2.NodeGroupStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def version(self) -> "builtins.str":
        """
        Version have format ``MAJOR.MINOR.PATCH-nebius-node.n`` like "1.30.0-nebius-node.10".
        """
        
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def target_node_count(self) -> "builtins.int":
        """
        Desired total number of nodes that should be in the node group.
        It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
        """
        
        return super()._get_field("target_node_count", explicit_presence=False,
        )
    @target_node_count.setter
    def target_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("target_node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def node_count(self) -> "builtins.int":
        """
        Total number of nodes that are currently in the node group.
        Both ready and not ready nodes are counted.
        """
        
        return super()._get_field("node_count", explicit_presence=False,
        )
    @node_count.setter
    def node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def outdated_node_count(self) -> "builtins.int":
        """
        Total number of nodes that has outdated node configuration.
        These nodes will be replaced by new nodes with up-to-date configuration.
        """
        
        return super()._get_field("outdated_node_count", explicit_presence=False,
        )
    @outdated_node_count.setter
    def outdated_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("outdated_node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def ready_node_count(self) -> "builtins.int":
        """
        Total number of nodes that successfully joined the cluster and are ready to serve workloads.
        Both outdated and up-to-date nodes are counted.
        """
        
        return super()._get_field("ready_node_count", explicit_presence=False,
        )
    @ready_node_count.setter
    def ready_node_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("ready_node_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def conditions(self) -> "abc.MutableSequence[Condition]":
        """
        Supported until 08/01/25. It is not implemented well, messages should be used instead.
        """
        
        logging.getLogger("deprecation").warning(
        """Field .nebius.mk8s.v1alpha1.NodeGroupStatus.conditions is deprecated. Supported until 08/01/25. It is not implemented well, messages should be used instead."""
        , stack_info=True, stacklevel=2)
        
        return super()._get_field("conditions", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Condition,None,None),
        )
    @conditions.setter
    def conditions(self, value: "abc.Iterable[Condition]|None") -> None:
        logging.getLogger("deprecation").warning(
        """Field .nebius.mk8s.v1alpha1.NodeGroupStatus.conditions is deprecated. Supported until 08/01/25. It is not implemented well, messages should be used instead."""
        , stack_info=True, stacklevel=2)
        
        return super()._set_field("conditions",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Show that changes are in flight
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "version":"version",
        "target_node_count":"target_node_count",
        "node_count":"node_count",
        "outdated_node_count":"outdated_node_count",
        "ready_node_count":"ready_node_count",
        "conditions":"conditions",
        "reconciling":"reconciling",
        "State":"State",
    }
    
# file: nebius/mk8s/v1alpha1/node_group_service.proto
class CreateNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.CreateNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.CreateNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "NodeGroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=NodeGroupSpec,
        )
    @spec.setter
    def spec(self, value: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.GetNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.GetNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(resource_version, unset.UnsetType):
            self.resource_version = resource_version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "resource_version",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_version(self) -> "builtins.str":
        return super()._get_field("resource_version", explicit_presence=False,
        )
    @resource_version.setter
    def resource_version(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "resource_version":"resource_version",
    }
    
class GetNodeGroupByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.GetNodeGroupByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.GetNodeGroupByNameRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListNodeGroupsRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.ListNodeGroupsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ListNodeGroupsRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        ID of the parent Cluster.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListNodeGroupsResponse(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.ListNodeGroupsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ListNodeGroupsResponse",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[NodeGroup]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[NodeGroup]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NodeGroup,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[NodeGroup]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class UpdateNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.UpdateNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.UpdateNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "NodeGroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=NodeGroupSpec,
        )
    @spec.setter
    def spec(self, value: "NodeGroupSpec|node_group_pb2.NodeGroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.DeleteNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.DeleteNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UpgradeNodeGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = node_group_service_pb2.UpgradeNodeGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.UpgradeNodeGroupRequest",node_group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_upgrade_type__(pb_classes.OneOf):
        name: builtins.str= "upgrade_type"
        
        def __init__(self, msg: "UpgradeNodeGroupRequest") -> None:
            super().__init__()
            self._message: "UpgradeNodeGroupRequest" = msg
    
    class __OneOfClass_upgrade_type_latest_infra_version__(__OneOfClass_upgrade_type__):
        field: typing.Literal["latest_infra_version"] = "latest_infra_version"
        
        def __init__(self, msg: "UpgradeNodeGroupRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "empty_pb2.Empty":
            return self._message.latest_infra_version
    
    @builtins.property
    def upgrade_type(self) -> __OneOfClass_upgrade_type_latest_infra_version__|None:
        field_name_1: str|None = super().which_field_in_oneof("upgrade_type")
        match field_name_1:
            case "latest_infra_version":
                return self.__OneOfClass_upgrade_type_latest_infra_version__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        latest_infra_version: "empty_pb2.Empty|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(latest_infra_version, unset.UnsetType):
            self.latest_infra_version = latest_infra_version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "latest_infra_version",
            "upgrade_type",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def latest_infra_version(self) -> "empty_pb2.Empty|None":
        """
        Upgrades to the latest infra version, which includes latest supported kubernetes patch version. Kubernetes minor version remain the same.
        """
        
        return super()._get_field("latest_infra_version", explicit_presence=True,
        )
    @latest_infra_version.setter
    def latest_infra_version(self, value: "empty_pb2.Empty|None") -> None:
        return super()._set_field("latest_infra_version",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "latest_infra_version":"latest_infra_version",
        "upgrade_type":"upgrade_type",
    }
    

class NodeGroupServiceClient(client.ClientWithOperations[v1alpha1_1.Operation,v1alpha1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.mk8s.v1alpha1.NodeGroupService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.mk8s.v1alpha1.NodeGroupService",node_group_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.mk8s.v1alpha1.NodeGroupService"
    __operation_type__ = v1alpha1_1.Operation
    __operation_service_class__ = v1alpha1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetNodeGroupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetNodeGroupRequest","NodeGroup"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.GetNodeGroupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1alpha1.NodeGroup`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=node_group_pb2.NodeGroup,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(NodeGroup),
        )
    
    def get_by_name(self,
        request: "GetNodeGroupByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetNodeGroupByNameRequest","NodeGroup"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.GetNodeGroupByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1alpha1.NodeGroup`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=node_group_pb2.NodeGroup,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(NodeGroup),
        )
    
    def list(self,
        request: "ListNodeGroupsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListNodeGroupsRequest","ListNodeGroupsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.ListNodeGroupsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.mk8s.v1alpha1.ListNodeGroupsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=node_group_service_pb2.ListNodeGroupsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListNodeGroupsResponse),
        )
    
    def create(self,
        request: "CreateNodeGroupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateNodeGroupRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.CreateNodeGroupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateNodeGroupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateNodeGroupRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.UpdateNodeGroupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteNodeGroupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteNodeGroupRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.DeleteNodeGroupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def upgrade(self,
        request: "UpgradeNodeGroupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpgradeNodeGroupRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.mk8s.v1alpha1.UpgradeNodeGroupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Upgrade",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    

# file: nebius/mk8s/v1alpha1/progress_data.proto
class ProgressData(pb_classes.Message):
    __PB2_CLASS__ = progress_data_pb2.ProgressData
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.ProgressData",progress_data_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        problems: "abc.Iterable[Problem]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(problems, unset.UnsetType):
            self.problems = problems
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "problems",
        ]
    
    @builtins.property
    def problems(self) -> "abc.MutableSequence[Problem]":
        """
        Problems encountered during the operation execution.
        """
        
        return super()._get_field("problems", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Problem,None,None),
        )
    @problems.setter
    def problems(self, value: "abc.Iterable[Problem]|None") -> None:
        return super()._set_field("problems",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "problems":"problems",
    }
    
class Problem(pb_classes.Message):
    __PB2_CLASS__ = progress_data_pb2.Problem
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.mk8s.v1alpha1.Problem",progress_data_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        stage: "builtins.str|None|unset.UnsetType" = unset.Unset,
        message: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(stage, unset.UnsetType):
            self.stage = stage
        if not isinstance(message, unset.UnsetType):
            self.message = message
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "stage",
            "message",
        ]
    
    @builtins.property
    def stage(self) -> "builtins.str":
        """
        Stage on which the problem occurred.
        """
        
        return super()._get_field("stage", explicit_presence=False,
        )
    @stage.setter
    def stage(self, value: "builtins.str|None") -> None:
        return super()._set_field("stage",value,explicit_presence=False,
        )
    
    @builtins.property
    def message(self) -> "builtins.str":
        """
        Message describing the problem.
        """
        
        return super()._get_field("message", explicit_presence=False,
        )
    @message.setter
    def message(self, value: "builtins.str|None") -> None:
        return super()._set_field("message",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "stage":"stage",
        "message":"message",
    }
    
__all__ = [
    #@ local import names here @#
    "Cluster",
    "ClusterSpec",
    "ControlPlaneSpec",
    "ControlPlaneEndpointsSpec",
    "PublicEndpointSpec",
    "KubeNetworkSpec",
    "ClusterStatus",
    "ControlPlaneStatus",
    "ControlPlaneStatusEndpoints",
    "ControlPlaneStatusAuth",
    "CreateClusterRequest",
    "GetClusterRequest",
    "GetClusterByNameRequest",
    "ListClustersRequest",
    "ListClustersResponse",
    "UpdateClusterRequest",
    "DeleteClusterRequest",
    "ListClusterControlPlaneVersionsRequest",
    "ListClusterControlPlaneVersionsResponse",
    "ClusterControlPlaneVersion",
    "ClusterServiceClient",
    "Condition",
    "DiskSpec",
    "ResourcesSpec",
    "NodeGroup",
    "NodeGroupSpec",
    "NodeTemplate",
    "NodeMetadataTemplate",
    "GpuSettings",
    "GpuClusterSpec",
    "NetworkInterfaceTemplate",
    "PublicIPAddress",
    "AttachedFilesystemSpec",
    "ExistingFilesystem",
    "NodeGroupAutoscalingSpec",
    "PreemptibleSpec",
    "NodeTaint",
    "NodeGroupDeploymentStrategy",
    "PercentOrCount",
    "NodeGroupStatus",
    "CreateNodeGroupRequest",
    "GetNodeGroupRequest",
    "GetNodeGroupByNameRequest",
    "ListNodeGroupsRequest",
    "ListNodeGroupsResponse",
    "UpdateNodeGroupRequest",
    "DeleteNodeGroupRequest",
    "UpgradeNodeGroupRequest",
    "NodeGroupServiceClient",
    "ProgressData",
    "Problem",
]
