# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.compute.v1alpha1``"""

import builtins as builtins
import collections.abc as abc
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import grpc as grpc
import logging as logging
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1alpha1 as v1alpha1_1
import nebius.api.nebius.common.v1alpha1.operation_pb2 as operation_pb2
import nebius.api.nebius.common.v1alpha1.operation_service_pb2 as operation_service_pb2
import nebius.api.nebius.compute.v1alpha1.disk_pb2 as disk_pb2
import nebius.api.nebius.compute.v1alpha1.disk_service_pb2 as disk_service_pb2
import nebius.api.nebius.compute.v1alpha1.filesystem_pb2 as filesystem_pb2
import nebius.api.nebius.compute.v1alpha1.filesystem_service_pb2 as filesystem_service_pb2
import nebius.api.nebius.compute.v1alpha1.gpu_cluster_pb2 as gpu_cluster_pb2
import nebius.api.nebius.compute.v1alpha1.gpu_cluster_service_pb2 as gpu_cluster_service_pb2
import nebius.api.nebius.compute.v1alpha1.image_pb2 as image_pb2
import nebius.api.nebius.compute.v1alpha1.image_service_pb2 as image_service_pb2
import nebius.api.nebius.compute.v1alpha1.instance_pb2 as instance_pb2
import nebius.api.nebius.compute.v1alpha1.instance_service_pb2 as instance_service_pb2
import nebius.api.nebius.vpc.v1alpha1 as v1alpha1_2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import typing as typing
#@ local imports here @#

# file: nebius/compute/v1alpha1/disk.proto
class Disk(pb_classes.Message):
    __PB2_CLASS__ = disk_pb2.Disk
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.Disk",disk_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "DiskSpec|disk_pb2.DiskSpec|None|unset.UnsetType" = unset.Unset,
        status: "DiskStatus|disk_pb2.DiskStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "DiskSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=DiskSpec,
        )
    @spec.setter
    def spec(self, value: "DiskSpec|disk_pb2.DiskSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "DiskStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=DiskStatus,
        )
    @status.setter
    def status(self, value: "DiskStatus|disk_pb2.DiskStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class DiskSpec(pb_classes.Message):
    __PB2_CLASS__ = disk_pb2.DiskSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.DiskSpec",disk_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class DiskType(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1alpha1.DiskSpec.DiskType",disk_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        NETWORK_SSD = 1
        """
        the list of available types will be clarified later, it is not final version
        """
        
        NETWORK_HDD = 2
        NETWORK_SSD_NON_REPLICATED = 3
        NETWORK_SSD_IO_M3 = 4
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__()
            self._message: "DiskSpec" = msg
    
    class __OneOfClass_size_size_bytes__(__OneOfClass_size__):
        field: typing.Literal["size_bytes"] = "size_bytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_bytes
    
    class __OneOfClass_size_size_kibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_kibibytes"] = "size_kibibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_kibibytes
    
    class __OneOfClass_size_size_mebibytes__(__OneOfClass_size__):
        field: typing.Literal["size_mebibytes"] = "size_mebibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_mebibytes
    
    class __OneOfClass_size_size_gibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_gibibytes"] = "size_gibibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_gibibytes
    
    @builtins.property
    def size(self) -> __OneOfClass_size_size_bytes__|__OneOfClass_size_size_kibibytes__|__OneOfClass_size_size_mebibytes__|__OneOfClass_size_size_gibibytes__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "size_bytes":
                return self.__OneOfClass_size_size_bytes__(self)
            case "size_kibibytes":
                return self.__OneOfClass_size_size_kibibytes__(self)
            case "size_mebibytes":
                return self.__OneOfClass_size_size_mebibytes__(self)
            case "size_gibibytes":
                return self.__OneOfClass_size_size_gibibytes__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass_source__(pb_classes.OneOf):
        name: builtins.str= "source"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__()
            self._message: "DiskSpec" = msg
    
    class __OneOfClass_source_source_image_id__(__OneOfClass_source__):
        field: typing.Literal["source_image_id"] = "source_image_id"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.source_image_id
    
    class __OneOfClass_source_source_image_family__(__OneOfClass_source__):
        field: typing.Literal["source_image_family"] = "source_image_family"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.source_image_family
    
    @builtins.property
    def source(self) -> __OneOfClass_source_source_image_id__|__OneOfClass_source_source_image_family__|None:
        field_name_1: str|None = super().which_field_in_oneof("source")
        match field_name_1:
            case "source_image_id":
                return self.__OneOfClass_source_source_image_id__(self)
            case "source_image_family":
                return self.__OneOfClass_source_source_image_family__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_kibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_mebibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_gibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        block_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        type: "DiskSpec.DiskType|disk_pb2.DiskSpec.DiskType|None|unset.UnsetType" = unset.Unset,
        source_image_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        source_image_family: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(size_kibibytes, unset.UnsetType):
            self.size_kibibytes = size_kibibytes
        if not isinstance(size_mebibytes, unset.UnsetType):
            self.size_mebibytes = size_mebibytes
        if not isinstance(size_gibibytes, unset.UnsetType):
            self.size_gibibytes = size_gibibytes
        if not isinstance(block_size_bytes, unset.UnsetType):
            self.block_size_bytes = block_size_bytes
        if not isinstance(type, unset.UnsetType):
            self.type = type
        if not isinstance(source_image_id, unset.UnsetType):
            self.source_image_id = source_image_id
        if not isinstance(source_image_family, unset.UnsetType):
            self.source_image_family = source_image_family
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "size_bytes",
            "size_kibibytes",
            "size_mebibytes",
            "size_gibibytes",
            "block_size_bytes",
            "type",
            "source_image_id",
            "source_image_family",
            "size",
            "source",
            "DiskType",
        ]
    
    @builtins.property
    def size_bytes(self) -> "builtins.int|None":
        return super()._get_field("size_bytes", explicit_presence=True,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_kibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_kibibytes", explicit_presence=True,
        )
    @size_kibibytes.setter
    def size_kibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_kibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_mebibytes(self) -> "builtins.int|None":
        return super()._get_field("size_mebibytes", explicit_presence=True,
        )
    @size_mebibytes.setter
    def size_mebibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_mebibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_gibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_gibibytes", explicit_presence=True,
        )
    @size_gibibytes.setter
    def size_gibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_gibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def block_size_bytes(self) -> "builtins.int":
        return super()._get_field("block_size_bytes", explicit_presence=False,
        )
    @block_size_bytes.setter
    def block_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("block_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def type(self) -> "DiskSpec.DiskType":
        return super()._get_field("type", explicit_presence=False,
        wrap=DiskSpec.DiskType,
        )
    @type.setter
    def type(self, value: "DiskSpec.DiskType|disk_pb2.DiskSpec.DiskType|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    @builtins.property
    def source_image_id(self) -> "builtins.str|None":
        return super()._get_field("source_image_id", explicit_presence=True,
        )
    @source_image_id.setter
    def source_image_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_image_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def source_image_family(self) -> "builtins.str|None":
        return super()._get_field("source_image_family", explicit_presence=True,
        )
    @source_image_family.setter
    def source_image_family(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_image_family",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "size_bytes":"size_bytes",
        "size_kibibytes":"size_kibibytes",
        "size_mebibytes":"size_mebibytes",
        "size_gibibytes":"size_gibibytes",
        "block_size_bytes":"block_size_bytes",
        "type":"type",
        "source_image_id":"source_image_id",
        "source_image_family":"source_image_family",
        "size":"size",
        "source":"source",
        "DiskType":"DiskType",
    }
    
class DiskStatus(pb_classes.Message):
    __PB2_CLASS__ = disk_pb2.DiskStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.DiskStatus",disk_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1alpha1.DiskStatus.State",disk_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 1
        READY = 2
        UPDATING = 3
        DELETING = 4
        ERROR = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "DiskStatus.State|disk_pb2.DiskStatus.State|None|unset.UnsetType" = unset.Unset,
        state_description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        read_write_attachment: "builtins.str|None|unset.UnsetType" = unset.Unset,
        read_only_attachments: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        source_image_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(state_description, unset.UnsetType):
            self.state_description = state_description
        if not isinstance(read_write_attachment, unset.UnsetType):
            self.read_write_attachment = read_write_attachment
        if not isinstance(read_only_attachments, unset.UnsetType):
            self.read_only_attachments = read_only_attachments
        if not isinstance(source_image_id, unset.UnsetType):
            self.source_image_id = source_image_id
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "state_description",
            "read_write_attachment",
            "read_only_attachments",
            "source_image_id",
            "size_bytes",
            "reconciling",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "DiskStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=DiskStatus.State,
        )
    @state.setter
    def state(self, value: "DiskStatus.State|disk_pb2.DiskStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def state_description(self) -> "builtins.str":
        return super()._get_field("state_description", explicit_presence=False,
        )
    @state_description.setter
    def state_description(self, value: "builtins.str|None") -> None:
        return super()._set_field("state_description",value,explicit_presence=False,
        )
    
    @builtins.property
    def read_write_attachment(self) -> "builtins.str":
        return super()._get_field("read_write_attachment", explicit_presence=False,
        )
    @read_write_attachment.setter
    def read_write_attachment(self, value: "builtins.str|None") -> None:
        return super()._set_field("read_write_attachment",value,explicit_presence=False,
        )
    
    @builtins.property
    def read_only_attachments(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("read_only_attachments", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @read_only_attachments.setter
    def read_only_attachments(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("read_only_attachments",value,explicit_presence=False,
        )
    
    @builtins.property
    def source_image_id(self) -> "builtins.str":
        return super()._get_field("source_image_id", explicit_presence=False,
        )
    @source_image_id.setter
    def source_image_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_image_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def size_bytes(self) -> "builtins.int":
        return super()._get_field("size_bytes", explicit_presence=False,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "state_description":"state_description",
        "read_write_attachment":"read_write_attachment",
        "read_only_attachments":"read_only_attachments",
        "source_image_id":"source_image_id",
        "size_bytes":"size_bytes",
        "reconciling":"reconciling",
        "State":"State",
    }
    
# file: nebius/compute/v1alpha1/disk_service.proto
class GetDiskRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.GetDiskRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.GetDiskRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListDisksRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.ListDisksRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListDisksRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Supported until 06/16/25. It is not implemented, filtering could be done on client side.
        """
        
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1alpha1.ListDisksRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1alpha1.ListDisksRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class CreateDiskRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.CreateDiskRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.CreateDiskRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "DiskSpec|disk_pb2.DiskSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "DiskSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=DiskSpec,
        )
    @spec.setter
    def spec(self, value: "DiskSpec|disk_pb2.DiskSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateDiskRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.UpdateDiskRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.UpdateDiskRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "DiskSpec|disk_pb2.DiskSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "DiskSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=DiskSpec,
        )
    @spec.setter
    def spec(self, value: "DiskSpec|disk_pb2.DiskSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteDiskRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.DeleteDiskRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.DeleteDiskRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListDisksResponse(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.ListDisksResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListDisksResponse",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Disk]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Disk]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Disk,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Disk]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class DiskServiceClient(client.ClientWithOperations[v1alpha1_1.Operation,v1alpha1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.compute.v1alpha1.DiskService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1alpha1.DiskService",disk_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1alpha1.DiskService"
    __operation_type__ = v1alpha1_1.Operation
    __operation_service_class__ = v1alpha1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetDiskRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetDiskRequest","Disk"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.GetDiskRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.Disk`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=disk_pb2.Disk,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Disk),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Disk"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.Disk`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=disk_pb2.Disk,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Disk),
        )
    
    def list(self,
        request: "ListDisksRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListDisksRequest","ListDisksResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.ListDisksRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.ListDisksResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=disk_service_pb2.ListDisksResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListDisksResponse),
        )
    
    def create(self,
        request: "CreateDiskRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateDiskRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.CreateDiskRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateDiskRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateDiskRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.UpdateDiskRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteDiskRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteDiskRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.DeleteDiskRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list_operations_by_parent(self,
        request: "v1alpha1_1.ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1alpha1_1.ListOperationsByParentRequest","v1alpha1_1.ListOperationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1alpha1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1alpha1_1.ListOperationsResponse),
        )
    

# file: nebius/compute/v1alpha1/filesystem.proto
class Filesystem(pb_classes.Message):
    __PB2_CLASS__ = filesystem_pb2.Filesystem
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.Filesystem",filesystem_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None|unset.UnsetType" = unset.Unset,
        status: "FilesystemStatus|filesystem_pb2.FilesystemStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FilesystemSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FilesystemSpec,
        )
    @spec.setter
    def spec(self, value: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FilesystemStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FilesystemStatus,
        )
    @status.setter
    def status(self, value: "FilesystemStatus|filesystem_pb2.FilesystemStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class FilesystemSpec(pb_classes.Message):
    __PB2_CLASS__ = filesystem_pb2.FilesystemSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.FilesystemSpec",filesystem_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class FilesystemType(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1alpha1.FilesystemSpec.FilesystemType",filesystem_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        NETWORK_SSD = 1
        """
        the list of available types will be clarified later, it is not final version
        """
        
        NETWORK_HDD = 2
        WEKA = 3
        VAST = 4
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__()
            self._message: "FilesystemSpec" = msg
    
    class __OneOfClass_size_size_bytes__(__OneOfClass_size__):
        field: typing.Literal["size_bytes"] = "size_bytes"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_bytes
    
    class __OneOfClass_size_size_kibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_kibibytes"] = "size_kibibytes"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_kibibytes
    
    class __OneOfClass_size_size_mebibytes__(__OneOfClass_size__):
        field: typing.Literal["size_mebibytes"] = "size_mebibytes"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_mebibytes
    
    class __OneOfClass_size_size_gibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_gibibytes"] = "size_gibibytes"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_gibibytes
    
    @builtins.property
    def size(self) -> __OneOfClass_size_size_bytes__|__OneOfClass_size_size_kibibytes__|__OneOfClass_size_size_mebibytes__|__OneOfClass_size_size_gibibytes__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "size_bytes":
                return self.__OneOfClass_size_size_bytes__(self)
            case "size_kibibytes":
                return self.__OneOfClass_size_size_kibibytes__(self)
            case "size_mebibytes":
                return self.__OneOfClass_size_size_mebibytes__(self)
            case "size_gibibytes":
                return self.__OneOfClass_size_size_gibibytes__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_kibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_mebibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_gibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        block_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        type: "FilesystemSpec.FilesystemType|filesystem_pb2.FilesystemSpec.FilesystemType|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(size_kibibytes, unset.UnsetType):
            self.size_kibibytes = size_kibibytes
        if not isinstance(size_mebibytes, unset.UnsetType):
            self.size_mebibytes = size_mebibytes
        if not isinstance(size_gibibytes, unset.UnsetType):
            self.size_gibibytes = size_gibibytes
        if not isinstance(block_size_bytes, unset.UnsetType):
            self.block_size_bytes = block_size_bytes
        if not isinstance(type, unset.UnsetType):
            self.type = type
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "size_bytes",
            "size_kibibytes",
            "size_mebibytes",
            "size_gibibytes",
            "block_size_bytes",
            "type",
            "size",
            "FilesystemType",
        ]
    
    @builtins.property
    def size_bytes(self) -> "builtins.int|None":
        return super()._get_field("size_bytes", explicit_presence=True,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_kibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_kibibytes", explicit_presence=True,
        )
    @size_kibibytes.setter
    def size_kibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_kibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_mebibytes(self) -> "builtins.int|None":
        return super()._get_field("size_mebibytes", explicit_presence=True,
        )
    @size_mebibytes.setter
    def size_mebibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_mebibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_gibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_gibibytes", explicit_presence=True,
        )
    @size_gibibytes.setter
    def size_gibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_gibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def block_size_bytes(self) -> "builtins.int":
        return super()._get_field("block_size_bytes", explicit_presence=False,
        )
    @block_size_bytes.setter
    def block_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("block_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def type(self) -> "FilesystemSpec.FilesystemType":
        return super()._get_field("type", explicit_presence=False,
        wrap=FilesystemSpec.FilesystemType,
        )
    @type.setter
    def type(self, value: "FilesystemSpec.FilesystemType|filesystem_pb2.FilesystemSpec.FilesystemType|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "size_bytes":"size_bytes",
        "size_kibibytes":"size_kibibytes",
        "size_mebibytes":"size_mebibytes",
        "size_gibibytes":"size_gibibytes",
        "block_size_bytes":"block_size_bytes",
        "type":"type",
        "size":"size",
        "FilesystemType":"FilesystemType",
    }
    
class FilesystemStatus(pb_classes.Message):
    __PB2_CLASS__ = filesystem_pb2.FilesystemStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.FilesystemStatus",filesystem_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1alpha1.FilesystemStatus.State",filesystem_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 1
        READY = 2
        UPDATING = 3
        DELETING = 4
        ERROR = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "FilesystemStatus.State|filesystem_pb2.FilesystemStatus.State|None|unset.UnsetType" = unset.Unset,
        state_description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        read_write_attachments: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        read_only_attachments: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(state_description, unset.UnsetType):
            self.state_description = state_description
        if not isinstance(read_write_attachments, unset.UnsetType):
            self.read_write_attachments = read_write_attachments
        if not isinstance(read_only_attachments, unset.UnsetType):
            self.read_only_attachments = read_only_attachments
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "state_description",
            "read_write_attachments",
            "read_only_attachments",
            "size_bytes",
            "reconciling",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "FilesystemStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=FilesystemStatus.State,
        )
    @state.setter
    def state(self, value: "FilesystemStatus.State|filesystem_pb2.FilesystemStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def state_description(self) -> "builtins.str":
        return super()._get_field("state_description", explicit_presence=False,
        )
    @state_description.setter
    def state_description(self, value: "builtins.str|None") -> None:
        return super()._set_field("state_description",value,explicit_presence=False,
        )
    
    @builtins.property
    def read_write_attachments(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("read_write_attachments", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @read_write_attachments.setter
    def read_write_attachments(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("read_write_attachments",value,explicit_presence=False,
        )
    
    @builtins.property
    def read_only_attachments(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("read_only_attachments", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @read_only_attachments.setter
    def read_only_attachments(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("read_only_attachments",value,explicit_presence=False,
        )
    
    @builtins.property
    def size_bytes(self) -> "builtins.int":
        return super()._get_field("size_bytes", explicit_presence=False,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "state_description":"state_description",
        "read_write_attachments":"read_write_attachments",
        "read_only_attachments":"read_only_attachments",
        "size_bytes":"size_bytes",
        "reconciling":"reconciling",
        "State":"State",
    }
    
# file: nebius/compute/v1alpha1/filesystem_service.proto
class GetFilesystemRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.GetFilesystemRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.GetFilesystemRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFilesystemsRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.ListFilesystemsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListFilesystemsRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Supported until 06/16/25. It is not implemented, filtering could be done on client side.
        """
        
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1alpha1.ListFilesystemsRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1alpha1.ListFilesystemsRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class CreateFilesystemRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.CreateFilesystemRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.CreateFilesystemRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FilesystemSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FilesystemSpec,
        )
    @spec.setter
    def spec(self, value: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateFilesystemRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.UpdateFilesystemRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.UpdateFilesystemRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FilesystemSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FilesystemSpec,
        )
    @spec.setter
    def spec(self, value: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteFilesystemRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.DeleteFilesystemRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.DeleteFilesystemRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFilesystemsResponse(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.ListFilesystemsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListFilesystemsResponse",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Filesystem]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Filesystem]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Filesystem,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Filesystem]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class FilesystemServiceClient(client.ClientWithOperations[v1alpha1_1.Operation,v1alpha1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.compute.v1alpha1.FilesystemService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1alpha1.FilesystemService",filesystem_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1alpha1.FilesystemService"
    __operation_type__ = v1alpha1_1.Operation
    __operation_service_class__ = v1alpha1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetFilesystemRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetFilesystemRequest","Filesystem"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.GetFilesystemRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.Filesystem`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=filesystem_pb2.Filesystem,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Filesystem),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Filesystem"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.Filesystem`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=filesystem_pb2.Filesystem,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Filesystem),
        )
    
    def list(self,
        request: "ListFilesystemsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListFilesystemsRequest","ListFilesystemsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.ListFilesystemsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.ListFilesystemsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=filesystem_service_pb2.ListFilesystemsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListFilesystemsResponse),
        )
    
    def create(self,
        request: "CreateFilesystemRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateFilesystemRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.CreateFilesystemRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateFilesystemRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateFilesystemRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.UpdateFilesystemRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteFilesystemRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteFilesystemRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.DeleteFilesystemRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list_operations_by_parent(self,
        request: "v1alpha1_1.ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1alpha1_1.ListOperationsByParentRequest","v1alpha1_1.ListOperationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1alpha1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1alpha1_1.ListOperationsResponse),
        )
    

# file: nebius/compute/v1alpha1/gpu_cluster.proto
class GpuCluster(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_pb2.GpuCluster
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.GpuCluster",gpu_cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None|unset.UnsetType" = unset.Unset,
        status: "GpuClusterStatus|gpu_cluster_pb2.GpuClusterStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GpuClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GpuClusterSpec,
        )
    @spec.setter
    def spec(self, value: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "GpuClusterStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=GpuClusterStatus,
        )
    @status.setter
    def status(self, value: "GpuClusterStatus|gpu_cluster_pb2.GpuClusterStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class GpuClusterSpec(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_pb2.GpuClusterSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.GpuClusterSpec",gpu_cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        infiniband_fabric: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(infiniband_fabric, unset.UnsetType):
            self.infiniband_fabric = infiniband_fabric
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "infiniband_fabric",
        ]
    
    @builtins.property
    def infiniband_fabric(self) -> "builtins.str":
        return super()._get_field("infiniband_fabric", explicit_presence=False,
        )
    @infiniband_fabric.setter
    def infiniband_fabric(self, value: "builtins.str|None") -> None:
        return super()._set_field("infiniband_fabric",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "infiniband_fabric":"infiniband_fabric",
    }
    
class GpuClusterStatus(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_pb2.GpuClusterStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.GpuClusterStatus",gpu_cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        instances: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(instances, unset.UnsetType):
            self.instances = instances
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "instances",
            "reconciling",
        ]
    
    @builtins.property
    def instances(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("instances", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @instances.setter
    def instances(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("instances",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "instances":"instances",
        "reconciling":"reconciling",
    }
    
# file: nebius/compute/v1alpha1/gpu_cluster_service.proto
class GetGpuClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.GetGpuClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.GetGpuClusterRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListGpuClustersRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.ListGpuClustersRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListGpuClustersRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Supported until 06/16/25. It is not implemented, filtering could be done on client side.
        """
        
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1alpha1.ListGpuClustersRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1alpha1.ListGpuClustersRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class CreateGpuClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.CreateGpuClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.CreateGpuClusterRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GpuClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GpuClusterSpec,
        )
    @spec.setter
    def spec(self, value: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateGpuClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.UpdateGpuClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.UpdateGpuClusterRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GpuClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GpuClusterSpec,
        )
    @spec.setter
    def spec(self, value: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteGpuClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.DeleteGpuClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.DeleteGpuClusterRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListGpuClustersResponse(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.ListGpuClustersResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListGpuClustersResponse",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[GpuCluster]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[GpuCluster]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(GpuCluster,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[GpuCluster]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class GpuClusterServiceClient(client.ClientWithOperations[v1alpha1_1.Operation,v1alpha1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.compute.v1alpha1.GpuClusterService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1alpha1.GpuClusterService",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1alpha1.GpuClusterService"
    __operation_type__ = v1alpha1_1.Operation
    __operation_service_class__ = v1alpha1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetGpuClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetGpuClusterRequest","GpuCluster"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.GetGpuClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.GpuCluster`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=gpu_cluster_pb2.GpuCluster,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(GpuCluster),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","GpuCluster"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.GpuCluster`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=gpu_cluster_pb2.GpuCluster,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(GpuCluster),
        )
    
    def list(self,
        request: "ListGpuClustersRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListGpuClustersRequest","ListGpuClustersResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.ListGpuClustersRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.ListGpuClustersResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=gpu_cluster_service_pb2.ListGpuClustersResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListGpuClustersResponse),
        )
    
    def create(self,
        request: "CreateGpuClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateGpuClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.CreateGpuClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateGpuClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateGpuClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.UpdateGpuClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteGpuClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteGpuClusterRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.DeleteGpuClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list_operations_by_parent(self,
        request: "v1alpha1_1.ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1alpha1_1.ListOperationsByParentRequest","v1alpha1_1.ListOperationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1alpha1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1alpha1_1.ListOperationsResponse),
        )
    

# file: nebius/compute/v1alpha1/image.proto
class Image(pb_classes.Message):
    __PB2_CLASS__ = image_pb2.Image
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.Image",image_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ImageSpec|image_pb2.ImageSpec|None|unset.UnsetType" = unset.Unset,
        status: "ImageStatus|image_pb2.ImageStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ImageSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ImageSpec,
        )
    @spec.setter
    def spec(self, value: "ImageSpec|image_pb2.ImageSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ImageStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ImageStatus,
        )
    @status.setter
    def status(self, value: "ImageStatus|image_pb2.ImageStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ImageSpec(pb_classes.Message):
    __PB2_CLASS__ = image_pb2.ImageSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ImageSpec",image_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__description__(pb_classes.OneOf):
        name: builtins.str= "_description"
        
        def __init__(self, msg: "ImageSpec") -> None:
            super().__init__()
            self._message: "ImageSpec" = msg
    
    class __OneOfClass__description_description__(__OneOfClass__description__):
        field: typing.Literal["description"] = "description"
        
        def __init__(self, msg: "ImageSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.description
    
    @builtins.property
    def _description(self) -> __OneOfClass__description_description__|None:
        field_name_1: str|None = super().which_field_in_oneof("_description")
        match field_name_1:
            case "description":
                return self.__OneOfClass__description_description__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        image_family: "builtins.str|None|unset.UnsetType" = unset.Unset,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(image_family, unset.UnsetType):
            self.image_family = image_family
        if not isinstance(version, unset.UnsetType):
            self.version = version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "description",
            "image_family",
            "version",
            "_description",
        ]
    
    @builtins.property
    def description(self) -> "builtins.str|None":
        return super()._get_field("description", explicit_presence=True,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=True,
        )
    
    @builtins.property
    def image_family(self) -> "builtins.str":
        return super()._get_field("image_family", explicit_presence=False,
        )
    @image_family.setter
    def image_family(self, value: "builtins.str|None") -> None:
        return super()._set_field("image_family",value,explicit_presence=False,
        )
    
    @builtins.property
    def version(self) -> "builtins.str":
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "description":"description",
        "image_family":"image_family",
        "version":"version",
        "_description":"_description",
    }
    
class ImageStatus(pb_classes.Message):
    __PB2_CLASS__ = image_pb2.ImageStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ImageStatus",image_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1alpha1.ImageStatus.State",image_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 1
        READY = 2
        UPDATING = 3
        DELETING = 4
        ERROR = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "ImageStatus.State|image_pb2.ImageStatus.State|None|unset.UnsetType" = unset.Unset,
        state_description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        storage_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        min_disk_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(state_description, unset.UnsetType):
            self.state_description = state_description
        if not isinstance(storage_size_bytes, unset.UnsetType):
            self.storage_size_bytes = storage_size_bytes
        if not isinstance(min_disk_size_bytes, unset.UnsetType):
            self.min_disk_size_bytes = min_disk_size_bytes
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "state_description",
            "storage_size_bytes",
            "min_disk_size_bytes",
            "reconciling",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "ImageStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=ImageStatus.State,
        )
    @state.setter
    def state(self, value: "ImageStatus.State|image_pb2.ImageStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def state_description(self) -> "builtins.str":
        return super()._get_field("state_description", explicit_presence=False,
        )
    @state_description.setter
    def state_description(self, value: "builtins.str|None") -> None:
        return super()._set_field("state_description",value,explicit_presence=False,
        )
    
    @builtins.property
    def storage_size_bytes(self) -> "builtins.int":
        return super()._get_field("storage_size_bytes", explicit_presence=False,
        )
    @storage_size_bytes.setter
    def storage_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("storage_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def min_disk_size_bytes(self) -> "builtins.int":
        return super()._get_field("min_disk_size_bytes", explicit_presence=False,
        )
    @min_disk_size_bytes.setter
    def min_disk_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("min_disk_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "state_description":"state_description",
        "storage_size_bytes":"storage_size_bytes",
        "min_disk_size_bytes":"min_disk_size_bytes",
        "reconciling":"reconciling",
        "State":"State",
    }
    
# file: nebius/compute/v1alpha1/image_service.proto
class GetImageRequest(pb_classes.Message):
    __PB2_CLASS__ = image_service_pb2.GetImageRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.GetImageRequest",image_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetImageLatestByFamilyRequest(pb_classes.Message):
    __PB2_CLASS__ = image_service_pb2.GetImageLatestByFamilyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.GetImageLatestByFamilyRequest",image_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        image_family: "builtins.str|None|unset.UnsetType" = unset.Unset,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(image_family, unset.UnsetType):
            self.image_family = image_family
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "image_family",
            "parent_id",
        ]
    
    @builtins.property
    def image_family(self) -> "builtins.str":
        return super()._get_field("image_family", explicit_presence=False,
        )
    @image_family.setter
    def image_family(self, value: "builtins.str|None") -> None:
        return super()._set_field("image_family",value,explicit_presence=False,
        )
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        default 'project-{region}public-images'
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "image_family":"image_family",
        "parent_id":"parent_id",
    }
    
class ListImagesRequest(pb_classes.Message):
    __PB2_CLASS__ = image_service_pb2.ListImagesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListImagesRequest",image_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Supported until 06/16/25. It is not implemented, filtering could be done on client side.
        """
        
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1alpha1.ListImagesRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1alpha1.ListImagesRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListImagesResponse(pb_classes.Message):
    __PB2_CLASS__ = image_service_pb2.ListImagesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListImagesResponse",image_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Image]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Image]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Image,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Image]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class ImageServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.compute.v1alpha1.ImageService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1alpha1.ImageService",image_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1alpha1.ImageService"
    
    def get(self,
        request: "GetImageRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetImageRequest","Image"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.GetImageRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.Image`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=image_pb2.Image,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Image),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Image"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.Image`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=image_pb2.Image,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Image),
        )
    
    def get_latest_by_family(self,
        request: "GetImageLatestByFamilyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetImageLatestByFamilyRequest","Image"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.GetImageLatestByFamilyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.Image`.
        """
        
        return super().request(
            method="GetLatestByFamily",
            request=request,
            result_pb2_class=image_pb2.Image,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Image),
        )
    
    def list(self,
        request: "ListImagesRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListImagesRequest","ListImagesResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.ListImagesRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.ListImagesResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=image_service_pb2.ListImagesResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListImagesResponse),
        )
    
    def list_operations_by_parent(self,
        request: "v1alpha1_1.ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1alpha1_1.ListOperationsByParentRequest","v1alpha1_1.ListOperationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1alpha1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1alpha1_1.ListOperationsResponse),
        )
    

# file: nebius/compute/v1alpha1/instance.proto
class InstanceRecoveryPolicy(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1alpha1.InstanceRecoveryPolicy",instance_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    RECOVER = 0
    FAIL = 1

class Instance(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.Instance
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.Instance",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InstanceSpec|instance_pb2.InstanceSpec|None|unset.UnsetType" = unset.Unset,
        status: "InstanceStatus|instance_pb2.InstanceStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InstanceSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InstanceSpec,
        )
    @spec.setter
    def spec(self, value: "InstanceSpec|instance_pb2.InstanceSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "InstanceStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=InstanceStatus,
        )
    @status.setter
    def status(self, value: "InstanceStatus|instance_pb2.InstanceStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class InstanceSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.InstanceSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.InstanceSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        service_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resources: "ResourcesSpec|instance_pb2.ResourcesSpec|None|unset.UnsetType" = unset.Unset,
        gpu_cluster: "InstanceGpuClusterSpec|instance_pb2.InstanceGpuClusterSpec|None|unset.UnsetType" = unset.Unset,
        network_interfaces: "abc.Iterable[v1alpha1_2.NetworkInterfaceSpec]|None|unset.UnsetType" = unset.Unset,
        boot_disk: "AttachedDiskSpec|instance_pb2.AttachedDiskSpec|None|unset.UnsetType" = unset.Unset,
        secondary_disks: "abc.Iterable[AttachedDiskSpec]|None|unset.UnsetType" = unset.Unset,
        filesystems: "abc.Iterable[AttachedFilesystemSpec]|None|unset.UnsetType" = unset.Unset,
        cloud_init_user_data: "builtins.str|None|unset.UnsetType" = unset.Unset,
        stopped: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        recovery_policy: "InstanceRecoveryPolicy|instance_pb2.InstanceRecoveryPolicy|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(service_account_id, unset.UnsetType):
            self.service_account_id = service_account_id
        if not isinstance(resources, unset.UnsetType):
            self.resources = resources
        if not isinstance(gpu_cluster, unset.UnsetType):
            self.gpu_cluster = gpu_cluster
        if not isinstance(network_interfaces, unset.UnsetType):
            self.network_interfaces = network_interfaces
        if not isinstance(boot_disk, unset.UnsetType):
            self.boot_disk = boot_disk
        if not isinstance(secondary_disks, unset.UnsetType):
            self.secondary_disks = secondary_disks
        if not isinstance(filesystems, unset.UnsetType):
            self.filesystems = filesystems
        if not isinstance(cloud_init_user_data, unset.UnsetType):
            self.cloud_init_user_data = cloud_init_user_data
        if not isinstance(stopped, unset.UnsetType):
            self.stopped = stopped
        if not isinstance(recovery_policy, unset.UnsetType):
            self.recovery_policy = recovery_policy
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "service_account_id",
            "resources",
            "gpu_cluster",
            "network_interfaces",
            "boot_disk",
            "secondary_disks",
            "filesystems",
            "cloud_init_user_data",
            "stopped",
            "recovery_policy",
        ]
    
    @builtins.property
    def service_account_id(self) -> "builtins.str":
        return super()._get_field("service_account_id", explicit_presence=False,
        )
    @service_account_id.setter
    def service_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("service_account_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resources(self) -> "ResourcesSpec":
        return super()._get_field("resources", explicit_presence=False,
        wrap=ResourcesSpec,
        )
    @resources.setter
    def resources(self, value: "ResourcesSpec|instance_pb2.ResourcesSpec|None") -> None:
        return super()._set_field("resources",value,explicit_presence=False,
        )
    
    @builtins.property
    def gpu_cluster(self) -> "InstanceGpuClusterSpec":
        return super()._get_field("gpu_cluster", explicit_presence=False,
        wrap=InstanceGpuClusterSpec,
        )
    @gpu_cluster.setter
    def gpu_cluster(self, value: "InstanceGpuClusterSpec|instance_pb2.InstanceGpuClusterSpec|None") -> None:
        return super()._set_field("gpu_cluster",value,explicit_presence=False,
        )
    
    @builtins.property
    def network_interfaces(self) -> "abc.MutableSequence[v1alpha1_2.NetworkInterfaceSpec]":
        return super()._get_field("network_interfaces", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(v1alpha1_2.NetworkInterfaceSpec,None,None),
        )
    @network_interfaces.setter
    def network_interfaces(self, value: "abc.Iterable[v1alpha1_2.NetworkInterfaceSpec]|None") -> None:
        return super()._set_field("network_interfaces",value,explicit_presence=False,
        )
    
    @builtins.property
    def boot_disk(self) -> "AttachedDiskSpec":
        return super()._get_field("boot_disk", explicit_presence=False,
        wrap=AttachedDiskSpec,
        )
    @boot_disk.setter
    def boot_disk(self, value: "AttachedDiskSpec|instance_pb2.AttachedDiskSpec|None") -> None:
        return super()._set_field("boot_disk",value,explicit_presence=False,
        )
    
    @builtins.property
    def secondary_disks(self) -> "abc.MutableSequence[AttachedDiskSpec]":
        return super()._get_field("secondary_disks", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AttachedDiskSpec,None,None),
        )
    @secondary_disks.setter
    def secondary_disks(self, value: "abc.Iterable[AttachedDiskSpec]|None") -> None:
        return super()._set_field("secondary_disks",value,explicit_presence=False,
        )
    
    @builtins.property
    def filesystems(self) -> "abc.MutableSequence[AttachedFilesystemSpec]":
        return super()._get_field("filesystems", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AttachedFilesystemSpec,None,None),
        )
    @filesystems.setter
    def filesystems(self, value: "abc.Iterable[AttachedFilesystemSpec]|None") -> None:
        return super()._set_field("filesystems",value,explicit_presence=False,
        )
    
    @builtins.property
    def cloud_init_user_data(self) -> "builtins.str":
        return super()._get_field("cloud_init_user_data", explicit_presence=False,
        )
    @cloud_init_user_data.setter
    def cloud_init_user_data(self, value: "builtins.str|None") -> None:
        return super()._set_field("cloud_init_user_data",value,explicit_presence=False,
        )
    
    @builtins.property
    def stopped(self) -> "builtins.bool":
        return super()._get_field("stopped", explicit_presence=False,
        )
    @stopped.setter
    def stopped(self, value: "builtins.bool|None") -> None:
        return super()._set_field("stopped",value,explicit_presence=False,
        )
    
    @builtins.property
    def recovery_policy(self) -> "InstanceRecoveryPolicy":
        """
        Recovery policy defines how the instance will be treated in case of a failure. Common source of failure is a host failure, but it can be any other failure.
        Instance undergoing a guest shutdown (poweroff, etc.) will be subject to recovery policy, meaning that it could be restarted and billed accordingly. Stop instance via API or UI to stop it to avoid recovering.
        If set to RECOVER, instance will be restarted, if possible. It could be restarted on the same host or on another host.
        If set to FAIL, instance will be stopped and not restarted.
        """
        
        return super()._get_field("recovery_policy", explicit_presence=False,
        wrap=InstanceRecoveryPolicy,
        )
    @recovery_policy.setter
    def recovery_policy(self, value: "InstanceRecoveryPolicy|instance_pb2.InstanceRecoveryPolicy|None") -> None:
        return super()._set_field("recovery_policy",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "service_account_id":"service_account_id",
        "resources":"resources",
        "gpu_cluster":"gpu_cluster",
        "network_interfaces":"network_interfaces",
        "boot_disk":"boot_disk",
        "secondary_disks":"secondary_disks",
        "filesystems":"filesystems",
        "cloud_init_user_data":"cloud_init_user_data",
        "stopped":"stopped",
        "recovery_policy":"recovery_policy",
    }
    
class ResourcesSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.ResourcesSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ResourcesSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "ResourcesSpec") -> None:
            super().__init__()
            self._message: "ResourcesSpec" = msg
    
    class __OneOfClass_size_preset__(__OneOfClass_size__):
        field: typing.Literal["preset"] = "preset"
        
        def __init__(self, msg: "ResourcesSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.preset
    
    @builtins.property
    def size(self) -> __OneOfClass_size_preset__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "preset":
                return self.__OneOfClass_size_preset__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        platform: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preset: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(platform, unset.UnsetType):
            self.platform = platform
        if not isinstance(preset, unset.UnsetType):
            self.preset = preset
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "platform",
            "preset",
            "size",
        ]
    
    @builtins.property
    def platform(self) -> "builtins.str":
        return super()._get_field("platform", explicit_presence=False,
        )
    @platform.setter
    def platform(self, value: "builtins.str|None") -> None:
        return super()._set_field("platform",value,explicit_presence=False,
        )
    
    @builtins.property
    def preset(self) -> "builtins.str|None":
        return super()._get_field("preset", explicit_presence=True,
        )
    @preset.setter
    def preset(self, value: "builtins.str|None") -> None:
        return super()._set_field("preset",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "platform":"platform",
        "preset":"preset",
        "size":"size",
    }
    
class InstanceGpuClusterSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.InstanceGpuClusterSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.InstanceGpuClusterSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class AttachedDiskSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.AttachedDiskSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.AttachedDiskSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class AttachMode(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1alpha1.AttachedDiskSpec.AttachMode",instance_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        READ_ONLY = 1
        READ_WRITE = 2
    
    class __OneOfClass_type__(pb_classes.OneOf):
        name: builtins.str= "type"
        
        def __init__(self, msg: "AttachedDiskSpec") -> None:
            super().__init__()
            self._message: "AttachedDiskSpec" = msg
    
    class __OneOfClass_type_existing_disk__(__OneOfClass_type__):
        field: typing.Literal["existing_disk"] = "existing_disk"
        
        def __init__(self, msg: "AttachedDiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ExistingDisk":
            return self._message.existing_disk
    
    @builtins.property
    def type(self) -> __OneOfClass_type_existing_disk__|None:
        field_name_1: str|None = super().which_field_in_oneof("type")
        match field_name_1:
            case "existing_disk":
                return self.__OneOfClass_type_existing_disk__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        attach_mode: "AttachedDiskSpec.AttachMode|instance_pb2.AttachedDiskSpec.AttachMode|None|unset.UnsetType" = unset.Unset,
        existing_disk: "ExistingDisk|instance_pb2.ExistingDisk|None|unset.UnsetType" = unset.Unset,
        device_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(attach_mode, unset.UnsetType):
            self.attach_mode = attach_mode
        if not isinstance(existing_disk, unset.UnsetType):
            self.existing_disk = existing_disk
        if not isinstance(device_name, unset.UnsetType):
            self.device_name = device_name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "attach_mode",
            "existing_disk",
            "device_name",
            "type",
            "AttachMode",
        ]
    
    @builtins.property
    def attach_mode(self) -> "AttachedDiskSpec.AttachMode":
        return super()._get_field("attach_mode", explicit_presence=False,
        wrap=AttachedDiskSpec.AttachMode,
        )
    @attach_mode.setter
    def attach_mode(self, value: "AttachedDiskSpec.AttachMode|instance_pb2.AttachedDiskSpec.AttachMode|None") -> None:
        return super()._set_field("attach_mode",value,explicit_presence=False,
        )
    
    @builtins.property
    def existing_disk(self) -> "ExistingDisk|None":
        return super()._get_field("existing_disk", explicit_presence=True,
        wrap=ExistingDisk,
        )
    @existing_disk.setter
    def existing_disk(self, value: "ExistingDisk|instance_pb2.ExistingDisk|None") -> None:
        return super()._set_field("existing_disk",value,explicit_presence=True,
        )
    
    @builtins.property
    def device_name(self) -> "builtins.str":
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_name}' as a device path in mount command.
        """
        
        return super()._get_field("device_name", explicit_presence=False,
        )
    @device_name.setter
    def device_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("device_name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "attach_mode":"attach_mode",
        "existing_disk":"existing_disk",
        "device_name":"device_name",
        "type":"type",
        "AttachMode":"AttachMode",
    }
    
class ExistingDisk(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.ExistingDisk
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ExistingDisk",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ExistingFilesystem(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.ExistingFilesystem
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ExistingFilesystem",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class AttachedFilesystemSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.AttachedFilesystemSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.AttachedFilesystemSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class AttachMode(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1alpha1.AttachedFilesystemSpec.AttachMode",instance_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        READ_ONLY = 1
        READ_WRITE = 2
    
    class __OneOfClass_type__(pb_classes.OneOf):
        name: builtins.str= "type"
        
        def __init__(self, msg: "AttachedFilesystemSpec") -> None:
            super().__init__()
            self._message: "AttachedFilesystemSpec" = msg
    
    class __OneOfClass_type_existing_filesystem__(__OneOfClass_type__):
        field: typing.Literal["existing_filesystem"] = "existing_filesystem"
        
        def __init__(self, msg: "AttachedFilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ExistingFilesystem":
            return self._message.existing_filesystem
    
    @builtins.property
    def type(self) -> __OneOfClass_type_existing_filesystem__|None:
        field_name_1: str|None = super().which_field_in_oneof("type")
        match field_name_1:
            case "existing_filesystem":
                return self.__OneOfClass_type_existing_filesystem__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        attach_mode: "AttachedFilesystemSpec.AttachMode|instance_pb2.AttachedFilesystemSpec.AttachMode|None|unset.UnsetType" = unset.Unset,
        device_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        existing_filesystem: "ExistingFilesystem|instance_pb2.ExistingFilesystem|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(attach_mode, unset.UnsetType):
            self.attach_mode = attach_mode
        if not isinstance(device_name, unset.UnsetType):
            self.device_name = device_name
        if not isinstance(existing_filesystem, unset.UnsetType):
            self.existing_filesystem = existing_filesystem
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "attach_mode",
            "device_name",
            "existing_filesystem",
            "type",
            "AttachMode",
        ]
    
    @builtins.property
    def attach_mode(self) -> "AttachedFilesystemSpec.AttachMode":
        return super()._get_field("attach_mode", explicit_presence=False,
        wrap=AttachedFilesystemSpec.AttachMode,
        )
    @attach_mode.setter
    def attach_mode(self, value: "AttachedFilesystemSpec.AttachMode|instance_pb2.AttachedFilesystemSpec.AttachMode|None") -> None:
        return super()._set_field("attach_mode",value,explicit_presence=False,
        )
    
    @builtins.property
    def device_name(self) -> "builtins.str":
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        
        return super()._get_field("device_name", explicit_presence=False,
        )
    @device_name.setter
    def device_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("device_name",value,explicit_presence=False,
        )
    
    @builtins.property
    def existing_filesystem(self) -> "ExistingFilesystem|None":
        return super()._get_field("existing_filesystem", explicit_presence=True,
        wrap=ExistingFilesystem,
        )
    @existing_filesystem.setter
    def existing_filesystem(self, value: "ExistingFilesystem|instance_pb2.ExistingFilesystem|None") -> None:
        return super()._set_field("existing_filesystem",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "attach_mode":"attach_mode",
        "device_name":"device_name",
        "existing_filesystem":"existing_filesystem",
        "type":"type",
        "AttachMode":"AttachMode",
    }
    
class InstanceStatus(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.InstanceStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.InstanceStatus",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class InstanceState(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1alpha1.InstanceStatus.InstanceState",instance_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 1
        UPDATING = 2
        STARTING = 3
        RUNNING = 4
        STOPPING = 5
        STOPPED = 6
        DELETING = 7
        ERROR = 8
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "InstanceStatus.InstanceState|instance_pb2.InstanceStatus.InstanceState|None|unset.UnsetType" = unset.Unset,
        network_interfaces: "abc.Iterable[v1alpha1_2.NetworkInterfaceStatus]|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(network_interfaces, unset.UnsetType):
            self.network_interfaces = network_interfaces
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "network_interfaces",
            "reconciling",
            "InstanceState",
        ]
    
    @builtins.property
    def state(self) -> "InstanceStatus.InstanceState":
        return super()._get_field("state", explicit_presence=False,
        wrap=InstanceStatus.InstanceState,
        )
    @state.setter
    def state(self, value: "InstanceStatus.InstanceState|instance_pb2.InstanceStatus.InstanceState|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def network_interfaces(self) -> "abc.MutableSequence[v1alpha1_2.NetworkInterfaceStatus]":
        return super()._get_field("network_interfaces", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(v1alpha1_2.NetworkInterfaceStatus,None,None),
        )
    @network_interfaces.setter
    def network_interfaces(self, value: "abc.Iterable[v1alpha1_2.NetworkInterfaceStatus]|None") -> None:
        return super()._set_field("network_interfaces",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "network_interfaces":"network_interfaces",
        "reconciling":"reconciling",
        "InstanceState":"InstanceState",
    }
    
# file: nebius/compute/v1alpha1/instance_service.proto
class GetInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.GetInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.GetInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListInstancesRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.ListInstancesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListInstancesRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class CreateInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.CreateInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.CreateInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InstanceSpec|instance_pb2.InstanceSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InstanceSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InstanceSpec,
        )
    @spec.setter
    def spec(self, value: "InstanceSpec|instance_pb2.InstanceSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.UpdateInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.UpdateInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InstanceSpec|instance_pb2.InstanceSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InstanceSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InstanceSpec,
        )
    @spec.setter
    def spec(self, value: "InstanceSpec|instance_pb2.InstanceSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.DeleteInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.DeleteInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListInstancesResponse(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.ListInstancesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.ListInstancesResponse",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Instance]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Instance]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Instance,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Instance]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class StartInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.StartInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.StartInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class StopInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.StopInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1alpha1.StopInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class InstanceServiceClient(client.ClientWithOperations[v1alpha1_1.Operation,v1alpha1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.compute.v1alpha1.InstanceService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1alpha1.InstanceService",instance_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1alpha1.InstanceService"
    __operation_type__ = v1alpha1_1.Operation
    __operation_service_class__ = v1alpha1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetInstanceRequest","Instance"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.GetInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.Instance`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=instance_pb2.Instance,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Instance),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Instance"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.Instance`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=instance_pb2.Instance,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Instance),
        )
    
    def list(self,
        request: "ListInstancesRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListInstancesRequest","ListInstancesResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.ListInstancesRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1alpha1.ListInstancesResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=instance_service_pb2.ListInstancesResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListInstancesResponse),
        )
    
    def create(self,
        request: "CreateInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateInstanceRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.CreateInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateInstanceRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.UpdateInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteInstanceRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.DeleteInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def start(self,
        request: "StartInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["StartInstanceRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.StartInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Start",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def stop(self,
        request: "StopInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["StopInstanceRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1alpha1.StopInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Stop",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list_operations_by_parent(self,
        request: "v1alpha1_1.ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1alpha1_1.ListOperationsByParentRequest","v1alpha1_1.ListOperationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1alpha1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1alpha1_1.ListOperationsResponse),
        )
    

__all__ = [
    #@ local import names here @#
    "Disk",
    "DiskSpec",
    "DiskStatus",
    "GetDiskRequest",
    "ListDisksRequest",
    "CreateDiskRequest",
    "UpdateDiskRequest",
    "DeleteDiskRequest",
    "ListDisksResponse",
    "DiskServiceClient",
    "Filesystem",
    "FilesystemSpec",
    "FilesystemStatus",
    "GetFilesystemRequest",
    "ListFilesystemsRequest",
    "CreateFilesystemRequest",
    "UpdateFilesystemRequest",
    "DeleteFilesystemRequest",
    "ListFilesystemsResponse",
    "FilesystemServiceClient",
    "GpuCluster",
    "GpuClusterSpec",
    "GpuClusterStatus",
    "GetGpuClusterRequest",
    "ListGpuClustersRequest",
    "CreateGpuClusterRequest",
    "UpdateGpuClusterRequest",
    "DeleteGpuClusterRequest",
    "ListGpuClustersResponse",
    "GpuClusterServiceClient",
    "Image",
    "ImageSpec",
    "ImageStatus",
    "GetImageRequest",
    "GetImageLatestByFamilyRequest",
    "ListImagesRequest",
    "ListImagesResponse",
    "ImageServiceClient",
    "InstanceRecoveryPolicy",
    "Instance",
    "InstanceSpec",
    "ResourcesSpec",
    "InstanceGpuClusterSpec",
    "AttachedDiskSpec",
    "ExistingDisk",
    "ExistingFilesystem",
    "AttachedFilesystemSpec",
    "InstanceStatus",
    "GetInstanceRequest",
    "ListInstancesRequest",
    "CreateInstanceRequest",
    "UpdateInstanceRequest",
    "DeleteInstanceRequest",
    "ListInstancesResponse",
    "StartInstanceRequest",
    "StopInstanceRequest",
    "InstanceServiceClient",
]
