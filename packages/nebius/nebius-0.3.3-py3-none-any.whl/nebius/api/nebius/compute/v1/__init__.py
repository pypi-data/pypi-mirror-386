# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.compute.v1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import grpc as grpc
import logging as logging
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1.operation_pb2 as operation_pb2
import nebius.api.nebius.common.v1.operation_service_pb2 as operation_service_pb2_1
import nebius.api.nebius.compute.v1.disk_pb2 as disk_pb2
import nebius.api.nebius.compute.v1.disk_service_pb2 as disk_service_pb2
import nebius.api.nebius.compute.v1.filesystem_pb2 as filesystem_pb2
import nebius.api.nebius.compute.v1.filesystem_service_pb2 as filesystem_service_pb2
import nebius.api.nebius.compute.v1.gpu_cluster_pb2 as gpu_cluster_pb2
import nebius.api.nebius.compute.v1.gpu_cluster_service_pb2 as gpu_cluster_service_pb2
import nebius.api.nebius.compute.v1.image_pb2 as image_pb2
import nebius.api.nebius.compute.v1.image_service_pb2 as image_service_pb2
import nebius.api.nebius.compute.v1.instance_pb2 as instance_pb2
import nebius.api.nebius.compute.v1.instance_service_pb2 as instance_service_pb2
import nebius.api.nebius.compute.v1.maintenance_event_pb2 as maintenance_event_pb2
import nebius.api.nebius.compute.v1.maintenance_service_pb2 as maintenance_service_pb2
import nebius.api.nebius.compute.v1.network_interface_pb2 as network_interface_pb2
import nebius.api.nebius.compute.v1.node_service_pb2 as node_service_pb2
import nebius.api.nebius.compute.v1.operation_service_pb2 as operation_service_pb2
import nebius.api.nebius.compute.v1.platform_pb2 as platform_pb2
import nebius.api.nebius.compute.v1.platform_service_pb2 as platform_service_pb2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
#@ local imports here @#

# file: nebius/compute/v1/disk.proto
class Disk(pb_classes.Message):
    __PB2_CLASS__ = disk_pb2.Disk
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.Disk",disk_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "DiskSpec|disk_pb2.DiskSpec|None|unset.UnsetType" = unset.Unset,
        status: "DiskStatus|disk_pb2.DiskStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "DiskSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=DiskSpec,
        )
    @spec.setter
    def spec(self, value: "DiskSpec|disk_pb2.DiskSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "DiskStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=DiskStatus,
        )
    @status.setter
    def status(self, value: "DiskStatus|disk_pb2.DiskStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class DiskSpec(pb_classes.Message):
    __PB2_CLASS__ = disk_pb2.DiskSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.DiskSpec",disk_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class DiskType(pb_enum.Enum):
        """
        the list of available types will be clarified later, it is not final version
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.DiskSpec.DiskType",disk_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        NETWORK_SSD = 1
        NETWORK_HDD = 2
        NETWORK_SSD_NON_REPLICATED = 3
        NETWORK_SSD_IO_M3 = 4
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__()
            self._message: "DiskSpec" = msg
    
    class __OneOfClass_size_size_bytes__(__OneOfClass_size__):
        field: typing.Literal["size_bytes"] = "size_bytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_bytes
    
    class __OneOfClass_size_size_kibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_kibibytes"] = "size_kibibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_kibibytes
    
    class __OneOfClass_size_size_mebibytes__(__OneOfClass_size__):
        field: typing.Literal["size_mebibytes"] = "size_mebibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_mebibytes
    
    class __OneOfClass_size_size_gibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_gibibytes"] = "size_gibibytes"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_gibibytes
    
    @builtins.property
    def size(self) -> __OneOfClass_size_size_bytes__|__OneOfClass_size_size_kibibytes__|__OneOfClass_size_size_mebibytes__|__OneOfClass_size_size_gibibytes__|None:
        """
        Size of the disk. The size must be within the limits for the selected disk type.
        For current limits, see https://docs.nebius.com/compute/storage/types#disks-types-comparison
        """
        
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "size_bytes":
                return self.__OneOfClass_size_size_bytes__(self)
            case "size_kibibytes":
                return self.__OneOfClass_size_size_kibibytes__(self)
            case "size_mebibytes":
                return self.__OneOfClass_size_size_mebibytes__(self)
            case "size_gibibytes":
                return self.__OneOfClass_size_size_gibibytes__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass_source__(pb_classes.OneOf):
        name: builtins.str= "source"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__()
            self._message: "DiskSpec" = msg
    
    class __OneOfClass_source_source_image_id__(__OneOfClass_source__):
        field: typing.Literal["source_image_id"] = "source_image_id"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.source_image_id
    
    class __OneOfClass_source_source_image_family__(__OneOfClass_source__):
        field: typing.Literal["source_image_family"] = "source_image_family"
        
        def __init__(self, msg: "DiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "SourceImageFamily":
            return self._message.source_image_family
    
    @builtins.property
    def source(self) -> __OneOfClass_source_source_image_id__|__OneOfClass_source_source_image_family__|None:
        """
        Source for disk creation.
        Boot disk must be created from an image https://docs.nebius.com/compute/storage/manage#boot
        Additional disks can be created as an empty volume https://docs.nebius.com/compute/storage/manage#additional
        """
        
        field_name_1: str|None = super().which_field_in_oneof("source")
        match field_name_1:
            case "source_image_id":
                return self.__OneOfClass_source_source_image_id__(self)
            case "source_image_family":
                return self.__OneOfClass_source_source_image_family__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_kibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_mebibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_gibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        block_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        type: "DiskSpec.DiskType|disk_pb2.DiskSpec.DiskType|None|unset.UnsetType" = unset.Unset,
        source_image_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        source_image_family: "SourceImageFamily|disk_pb2.SourceImageFamily|None|unset.UnsetType" = unset.Unset,
        disk_encryption: "DiskEncryption|disk_pb2.DiskEncryption|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(size_kibibytes, unset.UnsetType):
            self.size_kibibytes = size_kibibytes
        if not isinstance(size_mebibytes, unset.UnsetType):
            self.size_mebibytes = size_mebibytes
        if not isinstance(size_gibibytes, unset.UnsetType):
            self.size_gibibytes = size_gibibytes
        if not isinstance(block_size_bytes, unset.UnsetType):
            self.block_size_bytes = block_size_bytes
        if not isinstance(type, unset.UnsetType):
            self.type = type
        if not isinstance(source_image_id, unset.UnsetType):
            self.source_image_id = source_image_id
        if not isinstance(source_image_family, unset.UnsetType):
            self.source_image_family = source_image_family
        if not isinstance(disk_encryption, unset.UnsetType):
            self.disk_encryption = disk_encryption
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "size_bytes",
            "size_kibibytes",
            "size_mebibytes",
            "size_gibibytes",
            "block_size_bytes",
            "type",
            "source_image_id",
            "source_image_family",
            "disk_encryption",
            "size",
            "source",
            "DiskType",
        ]
    
    @builtins.property
    def size_bytes(self) -> "builtins.int|None":
        return super()._get_field("size_bytes", explicit_presence=True,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_kibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_kibibytes", explicit_presence=True,
        )
    @size_kibibytes.setter
    def size_kibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_kibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_mebibytes(self) -> "builtins.int|None":
        return super()._get_field("size_mebibytes", explicit_presence=True,
        )
    @size_mebibytes.setter
    def size_mebibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_mebibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_gibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_gibibytes", explicit_presence=True,
        )
    @size_gibibytes.setter
    def size_gibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_gibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def block_size_bytes(self) -> "builtins.int":
        """
        Block size in bytes.
        The block size must be a power of two between 4096 bytes (4 KiB) and 131072 bytes (128 KiB).
        The default value is 4096 bytes (4 KiB).
        """
        
        return super()._get_field("block_size_bytes", explicit_presence=False,
        )
    @block_size_bytes.setter
    def block_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("block_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def type(self) -> "DiskSpec.DiskType":
        """
        The type of disk defines the performance and reliability characteristics of the block device.
        For details, see https://docs.nebius.com/compute/storage/types#disks-types
        """
        
        return super()._get_field("type", explicit_presence=False,
        wrap=DiskSpec.DiskType,
        )
    @type.setter
    def type(self, value: "DiskSpec.DiskType|disk_pb2.DiskSpec.DiskType|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    @builtins.property
    def source_image_id(self) -> "builtins.str|None":
        return super()._get_field("source_image_id", explicit_presence=True,
        )
    @source_image_id.setter
    def source_image_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_image_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def source_image_family(self) -> "SourceImageFamily|None":
        return super()._get_field("source_image_family", explicit_presence=True,
        wrap=SourceImageFamily,
        )
    @source_image_family.setter
    def source_image_family(self, value: "SourceImageFamily|disk_pb2.SourceImageFamily|None") -> None:
        return super()._set_field("source_image_family",value,explicit_presence=True,
        )
    
    @builtins.property
    def disk_encryption(self) -> "DiskEncryption":
        """
        Defines how data on the disk is encrypted. By default, no encryption is applied.
        """
        
        return super()._get_field("disk_encryption", explicit_presence=False,
        wrap=DiskEncryption,
        )
    @disk_encryption.setter
    def disk_encryption(self, value: "DiskEncryption|disk_pb2.DiskEncryption|None") -> None:
        return super()._set_field("disk_encryption",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "size_bytes":"size_bytes",
        "size_kibibytes":"size_kibibytes",
        "size_mebibytes":"size_mebibytes",
        "size_gibibytes":"size_gibibytes",
        "block_size_bytes":"block_size_bytes",
        "type":"type",
        "source_image_id":"source_image_id",
        "source_image_family":"source_image_family",
        "disk_encryption":"disk_encryption",
        "size":"size",
        "source":"source",
        "DiskType":"DiskType",
    }
    
class SourceImageFamily(pb_classes.Message):
    __PB2_CLASS__ = disk_pb2.SourceImageFamily
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.SourceImageFamily",disk_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        image_family: "builtins.str|None|unset.UnsetType" = unset.Unset,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(image_family, unset.UnsetType):
            self.image_family = image_family
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "image_family",
            "parent_id",
        ]
    
    @builtins.property
    def image_family(self) -> "builtins.str":
        return super()._get_field("image_family", explicit_presence=False,
        )
    @image_family.setter
    def image_family(self, value: "builtins.str|None") -> None:
        return super()._set_field("image_family",value,explicit_presence=False,
        )
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "image_family":"image_family",
        "parent_id":"parent_id",
    }
    
class DiskStatus(pb_classes.Message):
    __PB2_CLASS__ = disk_pb2.DiskStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.DiskStatus",disk_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.DiskStatus.State",disk_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 1
        READY = 2
        UPDATING = 3
        DELETING = 4
        ERROR = 5
        """
        Indicates that error happened during disk creation, and the disk cannot be recovered.
        """
        
        BROKEN = 6
        """
        Indicates that an error has occurred during the disk's life cycle, and the disk is broken or unhealthy, but can still be recovered.
        """
        
    
    class SourceImageCPUArchitecture(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.DiskStatus.SourceImageCPUArchitecture",disk_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        SOURCE_IMAGE_CPU_UNSPECIFIED = 0
        AMD64 = 1
        ARM64 = 2
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "DiskStatus.State|disk_pb2.DiskStatus.State|None|unset.UnsetType" = unset.Unset,
        state_description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        read_write_attachment: "builtins.str|None|unset.UnsetType" = unset.Unset,
        read_only_attachments: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        source_image_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        block_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        source_image_cpu_architecture: "DiskStatus.SourceImageCPUArchitecture|disk_pb2.DiskStatus.SourceImageCPUArchitecture|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(state_description, unset.UnsetType):
            self.state_description = state_description
        if not isinstance(read_write_attachment, unset.UnsetType):
            self.read_write_attachment = read_write_attachment
        if not isinstance(read_only_attachments, unset.UnsetType):
            self.read_only_attachments = read_only_attachments
        if not isinstance(source_image_id, unset.UnsetType):
            self.source_image_id = source_image_id
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
        if not isinstance(block_size_bytes, unset.UnsetType):
            self.block_size_bytes = block_size_bytes
        if not isinstance(source_image_cpu_architecture, unset.UnsetType):
            self.source_image_cpu_architecture = source_image_cpu_architecture
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "state_description",
            "read_write_attachment",
            "read_only_attachments",
            "source_image_id",
            "size_bytes",
            "reconciling",
            "block_size_bytes",
            "source_image_cpu_architecture",
            "State",
            "SourceImageCPUArchitecture",
        ]
    
    @builtins.property
    def state(self) -> "DiskStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=DiskStatus.State,
        )
    @state.setter
    def state(self, value: "DiskStatus.State|disk_pb2.DiskStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def state_description(self) -> "builtins.str":
        return super()._get_field("state_description", explicit_presence=False,
        )
    @state_description.setter
    def state_description(self, value: "builtins.str|None") -> None:
        return super()._set_field("state_description",value,explicit_presence=False,
        )
    
    @builtins.property
    def read_write_attachment(self) -> "builtins.str":
        return super()._get_field("read_write_attachment", explicit_presence=False,
        )
    @read_write_attachment.setter
    def read_write_attachment(self, value: "builtins.str|None") -> None:
        return super()._set_field("read_write_attachment",value,explicit_presence=False,
        )
    
    @builtins.property
    def read_only_attachments(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("read_only_attachments", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @read_only_attachments.setter
    def read_only_attachments(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("read_only_attachments",value,explicit_presence=False,
        )
    
    @builtins.property
    def source_image_id(self) -> "builtins.str":
        return super()._get_field("source_image_id", explicit_presence=False,
        )
    @source_image_id.setter
    def source_image_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_image_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def size_bytes(self) -> "builtins.int":
        return super()._get_field("size_bytes", explicit_presence=False,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    @builtins.property
    def block_size_bytes(self) -> "builtins.int":
        return super()._get_field("block_size_bytes", explicit_presence=False,
        )
    @block_size_bytes.setter
    def block_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("block_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def source_image_cpu_architecture(self) -> "DiskStatus.SourceImageCPUArchitecture":
        return super()._get_field("source_image_cpu_architecture", explicit_presence=False,
        wrap=DiskStatus.SourceImageCPUArchitecture,
        )
    @source_image_cpu_architecture.setter
    def source_image_cpu_architecture(self, value: "DiskStatus.SourceImageCPUArchitecture|disk_pb2.DiskStatus.SourceImageCPUArchitecture|None") -> None:
        return super()._set_field("source_image_cpu_architecture",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "state_description":"state_description",
        "read_write_attachment":"read_write_attachment",
        "read_only_attachments":"read_only_attachments",
        "source_image_id":"source_image_id",
        "size_bytes":"size_bytes",
        "reconciling":"reconciling",
        "block_size_bytes":"block_size_bytes",
        "source_image_cpu_architecture":"source_image_cpu_architecture",
        "State":"State",
        "SourceImageCPUArchitecture":"SourceImageCPUArchitecture",
    }
    
class DiskEncryption(pb_classes.Message):
    __PB2_CLASS__ = disk_pb2.DiskEncryption
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.DiskEncryption",disk_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class DiskEncryptionType(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.DiskEncryption.DiskEncryptionType",disk_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        DISK_ENCRYPTION_UNSPECIFIED = 0
        """
        No encryption is applied unless explicitly specified.
        """
        
        DISK_ENCRYPTION_MANAGED = 1
        """
        Enables encryption using the platform's default root key from KMS.
        Available for blank disks only.
        Available for disks with NETWORK_SSD_NON_REPLICATED and NETWORK_SSD_IO_M3 types only.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        type: "DiskEncryption.DiskEncryptionType|disk_pb2.DiskEncryption.DiskEncryptionType|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(type, unset.UnsetType):
            self.type = type
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "type",
            "DiskEncryptionType",
        ]
    
    @builtins.property
    def type(self) -> "DiskEncryption.DiskEncryptionType":
        return super()._get_field("type", explicit_presence=False,
        wrap=DiskEncryption.DiskEncryptionType,
        )
    @type.setter
    def type(self, value: "DiskEncryption.DiskEncryptionType|disk_pb2.DiskEncryption.DiskEncryptionType|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "type":"type",
        "DiskEncryptionType":"DiskEncryptionType",
    }
    
# file: nebius/compute/v1/operation_service.proto
class ListOperationsByParentRequest(pb_classes.Message):
    __PB2_CLASS__ = operation_service_pb2.ListOperationsByParentRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListOperationsByParentRequest",operation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        ID of the parent to list operations for resource type at.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Page size. [1...1000]. Optional, if not specified, a reasonable default will be chosen by the service.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Listing continuation token. Empty to start listing from the first page.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
# file: nebius/compute/v1/disk_service.proto
class GetDiskRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.GetDiskRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GetDiskRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListDisksRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.ListDisksRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListDisksRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Supported until 06/16/25. It is not implemented, filtering could be done on client side.
        """
        
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1.ListDisksRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1.ListDisksRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class CreateDiskRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.CreateDiskRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.CreateDiskRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "DiskSpec|disk_pb2.DiskSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "DiskSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=DiskSpec,
        )
    @spec.setter
    def spec(self, value: "DiskSpec|disk_pb2.DiskSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateDiskRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.UpdateDiskRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.UpdateDiskRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "DiskSpec|disk_pb2.DiskSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "DiskSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=DiskSpec,
        )
    @spec.setter
    def spec(self, value: "DiskSpec|disk_pb2.DiskSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteDiskRequest(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.DeleteDiskRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.DeleteDiskRequest",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListDisksResponse(pb_classes.Message):
    __PB2_CLASS__ = disk_service_pb2.ListDisksResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListDisksResponse",disk_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Disk]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Disk]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Disk,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Disk]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class DiskServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.compute.v1.DiskService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1.DiskService",disk_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1.DiskService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetDiskRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetDiskRequest","Disk"]:
        """
        Retrieves information about a disk by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.GetDiskRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Disk`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=disk_pb2.Disk,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Disk),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Disk"]:
        """
        Retrieves information about a disk by its parent and name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Disk`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=disk_pb2.Disk,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Disk),
        )
    
    def list(self,
        request: "ListDisksRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListDisksRequest","ListDisksResponse"]:
        """
        Lists all disks within a specified parent.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListDisksRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.ListDisksResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=disk_service_pb2.ListDisksResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListDisksResponse),
        )
    
    def create(self,
        request: "CreateDiskRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateDiskRequest","operation.Operation[v1_1.Operation]"]:
        """
        Creates a new disk with the specified configuration.
        For details, see https://docs.nebius.com/compute/storage/manage
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.CreateDiskRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateDiskRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateDiskRequest","operation.Operation[v1_1.Operation]"]:
        """
        Updates an existing disk with new configuration parameters.
        For details, see https://docs.nebius.com/compute/storage/manage#parameters
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.UpdateDiskRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteDiskRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteDiskRequest","operation.Operation[v1_1.Operation]"]:
        """
        Deletes a disk by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.DeleteDiskRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list_operations_by_parent(self,
        request: "ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListOperationsByParentRequest","v1_1.ListOperationsResponse"]:
        """
        Lists all operations that were performed within a specific parent resource.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2_1.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1_1.ListOperationsResponse),
        )
    

# file: nebius/compute/v1/filesystem.proto
class Filesystem(pb_classes.Message):
    __PB2_CLASS__ = filesystem_pb2.Filesystem
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.Filesystem",filesystem_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None|unset.UnsetType" = unset.Unset,
        status: "FilesystemStatus|filesystem_pb2.FilesystemStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FilesystemSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FilesystemSpec,
        )
    @spec.setter
    def spec(self, value: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FilesystemStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FilesystemStatus,
        )
    @status.setter
    def status(self, value: "FilesystemStatus|filesystem_pb2.FilesystemStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class FilesystemSpec(pb_classes.Message):
    __PB2_CLASS__ = filesystem_pb2.FilesystemSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.FilesystemSpec",filesystem_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class FilesystemType(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.FilesystemSpec.FilesystemType",filesystem_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        NETWORK_SSD = 1
        """
        the list of available types will be clarified later, it is not final version
        """
        
        NETWORK_HDD = 2
        WEKA = 3
        VAST = 4
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__()
            self._message: "FilesystemSpec" = msg
    
    class __OneOfClass_size_size_bytes__(__OneOfClass_size__):
        field: typing.Literal["size_bytes"] = "size_bytes"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_bytes
    
    class __OneOfClass_size_size_kibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_kibibytes"] = "size_kibibytes"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_kibibytes
    
    class __OneOfClass_size_size_mebibytes__(__OneOfClass_size__):
        field: typing.Literal["size_mebibytes"] = "size_mebibytes"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_mebibytes
    
    class __OneOfClass_size_size_gibibytes__(__OneOfClass_size__):
        field: typing.Literal["size_gibibytes"] = "size_gibibytes"
        
        def __init__(self, msg: "FilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.size_gibibytes
    
    @builtins.property
    def size(self) -> __OneOfClass_size_size_bytes__|__OneOfClass_size_size_kibibytes__|__OneOfClass_size_size_mebibytes__|__OneOfClass_size_size_gibibytes__|None:
        """
        Size of the disk. Only one size unit can be specified.
        The size must be within the limits for the selected disk type.
        For current limits, see https://docs.nebius.com/compute/storage/types#disks-types-comparison
        """
        
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "size_bytes":
                return self.__OneOfClass_size_size_bytes__(self)
            case "size_kibibytes":
                return self.__OneOfClass_size_size_kibibytes__(self)
            case "size_mebibytes":
                return self.__OneOfClass_size_size_mebibytes__(self)
            case "size_gibibytes":
                return self.__OneOfClass_size_size_gibibytes__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_kibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_mebibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        size_gibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        block_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        type: "FilesystemSpec.FilesystemType|filesystem_pb2.FilesystemSpec.FilesystemType|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(size_kibibytes, unset.UnsetType):
            self.size_kibibytes = size_kibibytes
        if not isinstance(size_mebibytes, unset.UnsetType):
            self.size_mebibytes = size_mebibytes
        if not isinstance(size_gibibytes, unset.UnsetType):
            self.size_gibibytes = size_gibibytes
        if not isinstance(block_size_bytes, unset.UnsetType):
            self.block_size_bytes = block_size_bytes
        if not isinstance(type, unset.UnsetType):
            self.type = type
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "size_bytes",
            "size_kibibytes",
            "size_mebibytes",
            "size_gibibytes",
            "block_size_bytes",
            "type",
            "size",
            "FilesystemType",
        ]
    
    @builtins.property
    def size_bytes(self) -> "builtins.int|None":
        return super()._get_field("size_bytes", explicit_presence=True,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_kibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_kibibytes", explicit_presence=True,
        )
    @size_kibibytes.setter
    def size_kibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_kibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_mebibytes(self) -> "builtins.int|None":
        return super()._get_field("size_mebibytes", explicit_presence=True,
        )
    @size_mebibytes.setter
    def size_mebibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_mebibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def size_gibibytes(self) -> "builtins.int|None":
        return super()._get_field("size_gibibytes", explicit_presence=True,
        )
    @size_gibibytes.setter
    def size_gibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_gibibytes",value,explicit_presence=True,
        )
    
    @builtins.property
    def block_size_bytes(self) -> "builtins.int":
        """
        Block size in bytes.
        The block size must be a power of two between 4096 bytes (4 KiB) and 131072 bytes (128 KiB).
        The default value is 4096 bytes (4 KiB).
        """
        
        return super()._get_field("block_size_bytes", explicit_presence=False,
        )
    @block_size_bytes.setter
    def block_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("block_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def type(self) -> "FilesystemSpec.FilesystemType":
        """
        The Shared Filesystem type determines its limits and performance characteristics.
        For details, see https://docs.nebius.com/compute/storage/types#filesystems-types
        """
        
        return super()._get_field("type", explicit_presence=False,
        wrap=FilesystemSpec.FilesystemType,
        )
    @type.setter
    def type(self, value: "FilesystemSpec.FilesystemType|filesystem_pb2.FilesystemSpec.FilesystemType|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "size_bytes":"size_bytes",
        "size_kibibytes":"size_kibibytes",
        "size_mebibytes":"size_mebibytes",
        "size_gibibytes":"size_gibibytes",
        "block_size_bytes":"block_size_bytes",
        "type":"type",
        "size":"size",
        "FilesystemType":"FilesystemType",
    }
    
class FilesystemStatus(pb_classes.Message):
    __PB2_CLASS__ = filesystem_pb2.FilesystemStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.FilesystemStatus",filesystem_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.FilesystemStatus.State",filesystem_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 1
        READY = 2
        UPDATING = 3
        DELETING = 4
        ERROR = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "FilesystemStatus.State|filesystem_pb2.FilesystemStatus.State|None|unset.UnsetType" = unset.Unset,
        state_description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        read_write_attachments: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        read_only_attachments: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        block_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(state_description, unset.UnsetType):
            self.state_description = state_description
        if not isinstance(read_write_attachments, unset.UnsetType):
            self.read_write_attachments = read_write_attachments
        if not isinstance(read_only_attachments, unset.UnsetType):
            self.read_only_attachments = read_only_attachments
        if not isinstance(size_bytes, unset.UnsetType):
            self.size_bytes = size_bytes
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
        if not isinstance(block_size_bytes, unset.UnsetType):
            self.block_size_bytes = block_size_bytes
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "state_description",
            "read_write_attachments",
            "read_only_attachments",
            "size_bytes",
            "reconciling",
            "block_size_bytes",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "FilesystemStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=FilesystemStatus.State,
        )
    @state.setter
    def state(self, value: "FilesystemStatus.State|filesystem_pb2.FilesystemStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def state_description(self) -> "builtins.str":
        return super()._get_field("state_description", explicit_presence=False,
        )
    @state_description.setter
    def state_description(self, value: "builtins.str|None") -> None:
        return super()._set_field("state_description",value,explicit_presence=False,
        )
    
    @builtins.property
    def read_write_attachments(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("read_write_attachments", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @read_write_attachments.setter
    def read_write_attachments(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("read_write_attachments",value,explicit_presence=False,
        )
    
    @builtins.property
    def read_only_attachments(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("read_only_attachments", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @read_only_attachments.setter
    def read_only_attachments(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("read_only_attachments",value,explicit_presence=False,
        )
    
    @builtins.property
    def size_bytes(self) -> "builtins.int":
        return super()._get_field("size_bytes", explicit_presence=False,
        )
    @size_bytes.setter
    def size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    @builtins.property
    def block_size_bytes(self) -> "builtins.int":
        return super()._get_field("block_size_bytes", explicit_presence=False,
        )
    @block_size_bytes.setter
    def block_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("block_size_bytes",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "state_description":"state_description",
        "read_write_attachments":"read_write_attachments",
        "read_only_attachments":"read_only_attachments",
        "size_bytes":"size_bytes",
        "reconciling":"reconciling",
        "block_size_bytes":"block_size_bytes",
        "State":"State",
    }
    
# file: nebius/compute/v1/filesystem_service.proto
class GetFilesystemRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.GetFilesystemRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GetFilesystemRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFilesystemsRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.ListFilesystemsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListFilesystemsRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Supported until 06/16/25. It is not implemented, filtering could be done on client side.
        """
        
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1.ListFilesystemsRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1.ListFilesystemsRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class CreateFilesystemRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.CreateFilesystemRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.CreateFilesystemRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FilesystemSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FilesystemSpec,
        )
    @spec.setter
    def spec(self, value: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateFilesystemRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.UpdateFilesystemRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.UpdateFilesystemRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FilesystemSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FilesystemSpec,
        )
    @spec.setter
    def spec(self, value: "FilesystemSpec|filesystem_pb2.FilesystemSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteFilesystemRequest(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.DeleteFilesystemRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.DeleteFilesystemRequest",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFilesystemsResponse(pb_classes.Message):
    __PB2_CLASS__ = filesystem_service_pb2.ListFilesystemsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListFilesystemsResponse",filesystem_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Filesystem]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Filesystem]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Filesystem,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Filesystem]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class FilesystemServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.compute.v1.FilesystemService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1.FilesystemService",filesystem_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1.FilesystemService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetFilesystemRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetFilesystemRequest","Filesystem"]:
        """
        Retrieves information about a filesystem by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.GetFilesystemRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Filesystem`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=filesystem_pb2.Filesystem,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Filesystem),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Filesystem"]:
        """
        Retrieves information about a filesystem by its parent and name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Filesystem`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=filesystem_pb2.Filesystem,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Filesystem),
        )
    
    def list(self,
        request: "ListFilesystemsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListFilesystemsRequest","ListFilesystemsResponse"]:
        """
        Lists all filesystems within a specified parent.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListFilesystemsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.ListFilesystemsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=filesystem_service_pb2.ListFilesystemsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListFilesystemsResponse),
        )
    
    def create(self,
        request: "CreateFilesystemRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateFilesystemRequest","operation.Operation[v1_1.Operation]"]:
        """
        Creates a new filesystem with the specified configuration.
        For details, see https://docs.nebius.com/compute/storage/manage
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.CreateFilesystemRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateFilesystemRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateFilesystemRequest","operation.Operation[v1_1.Operation]"]:
        """
        Updates an existing filesystem with new configuration parameters.
        For details, see https://docs.nebius.com/compute/storage/manage#parameters
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.UpdateFilesystemRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteFilesystemRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteFilesystemRequest","operation.Operation[v1_1.Operation]"]:
        """
        Deletes a disk by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.DeleteFilesystemRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list_operations_by_parent(self,
        request: "ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListOperationsByParentRequest","v1_1.ListOperationsResponse"]:
        """
        Lists all operations that were performed within a specific parent resource.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2_1.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1_1.ListOperationsResponse),
        )
    

# file: nebius/compute/v1/gpu_cluster.proto
class GpuCluster(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_pb2.GpuCluster
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GpuCluster",gpu_cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None|unset.UnsetType" = unset.Unset,
        status: "GpuClusterStatus|gpu_cluster_pb2.GpuClusterStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GpuClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GpuClusterSpec,
        )
    @spec.setter
    def spec(self, value: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "GpuClusterStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=GpuClusterStatus,
        )
    @status.setter
    def status(self, value: "GpuClusterStatus|gpu_cluster_pb2.GpuClusterStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class GpuClusterSpec(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_pb2.GpuClusterSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GpuClusterSpec",gpu_cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        infiniband_fabric: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(infiniband_fabric, unset.UnsetType):
            self.infiniband_fabric = infiniband_fabric
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "infiniband_fabric",
        ]
    
    @builtins.property
    def infiniband_fabric(self) -> "builtins.str":
        """
        The identifier of the physical InfiniBand fabric to connect GPU instances to.
        For details, see https://docs.nebius.com/compute/clusters/gpu#fabrics
        """
        
        return super()._get_field("infiniband_fabric", explicit_presence=False,
        )
    @infiniband_fabric.setter
    def infiniband_fabric(self, value: "builtins.str|None") -> None:
        return super()._set_field("infiniband_fabric",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "infiniband_fabric":"infiniband_fabric",
    }
    
class GpuClusterStatus(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_pb2.GpuClusterStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GpuClusterStatus",gpu_cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_topology__(pb_classes.OneOf):
        name: builtins.str= "topology"
        
        def __init__(self, msg: "GpuClusterStatus") -> None:
            super().__init__()
            self._message: "GpuClusterStatus" = msg
    
    class __OneOfClass_topology_infiniband_topology_path__(__OneOfClass_topology__):
        field: typing.Literal["infiniband_topology_path"] = "infiniband_topology_path"
        
        def __init__(self, msg: "GpuClusterStatus") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "GpuClusterStatusInfinibandTopologyPath":
            return self._message.infiniband_topology_path
    
    @builtins.property
    def topology(self) -> __OneOfClass_topology_infiniband_topology_path__|None:
        field_name_1: str|None = super().which_field_in_oneof("topology")
        match field_name_1:
            case "infiniband_topology_path":
                return self.__OneOfClass_topology_infiniband_topology_path__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        instances: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        infiniband_topology_path: "GpuClusterStatusInfinibandTopologyPath|gpu_cluster_pb2.GpuClusterStatusInfinibandTopologyPath|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(instances, unset.UnsetType):
            self.instances = instances
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
        if not isinstance(infiniband_topology_path, unset.UnsetType):
            self.infiniband_topology_path = infiniband_topology_path
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "instances",
            "reconciling",
            "infiniband_topology_path",
            "topology",
        ]
    
    @builtins.property
    def instances(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("instances", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @instances.setter
    def instances(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("instances",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    @builtins.property
    def infiniband_topology_path(self) -> "GpuClusterStatusInfinibandTopologyPath|None":
        return super()._get_field("infiniband_topology_path", explicit_presence=True,
        wrap=GpuClusterStatusInfinibandTopologyPath,
        )
    @infiniband_topology_path.setter
    def infiniband_topology_path(self, value: "GpuClusterStatusInfinibandTopologyPath|gpu_cluster_pb2.GpuClusterStatusInfinibandTopologyPath|None") -> None:
        return super()._set_field("infiniband_topology_path",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "instances":"instances",
        "reconciling":"reconciling",
        "infiniband_topology_path":"infiniband_topology_path",
        "topology":"topology",
    }
    
class GpuClusterStatusInfinibandTopologyPath(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_pb2.GpuClusterStatusInfinibandTopologyPath
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GpuClusterStatusInfinibandTopologyPath",gpu_cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        instances: "abc.Iterable[GpuClusterStatusInfinibandTopologyPathInstance]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(instances, unset.UnsetType):
            self.instances = instances
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "instances",
        ]
    
    @builtins.property
    def instances(self) -> "abc.MutableSequence[GpuClusterStatusInfinibandTopologyPathInstance]":
        return super()._get_field("instances", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(GpuClusterStatusInfinibandTopologyPathInstance,None,None),
        )
    @instances.setter
    def instances(self, value: "abc.Iterable[GpuClusterStatusInfinibandTopologyPathInstance]|None") -> None:
        return super()._set_field("instances",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "instances":"instances",
    }
    
class GpuClusterStatusInfinibandTopologyPathInstance(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_pb2.GpuClusterStatusInfinibandTopologyPathInstance
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GpuClusterStatusInfinibandTopologyPathInstance",gpu_cluster_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        instance_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        path: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(instance_id, unset.UnsetType):
            self.instance_id = instance_id
        if not isinstance(path, unset.UnsetType):
            self.path = path
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "instance_id",
            "path",
        ]
    
    @builtins.property
    def instance_id(self) -> "builtins.str":
        return super()._get_field("instance_id", explicit_presence=False,
        )
    @instance_id.setter
    def instance_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("instance_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def path(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("path", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @path.setter
    def path(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("path",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "instance_id":"instance_id",
        "path":"path",
    }
    
# file: nebius/compute/v1/gpu_cluster_service.proto
class GetGpuClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.GetGpuClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GetGpuClusterRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListGpuClustersRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.ListGpuClustersRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListGpuClustersRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Supported until 06/16/25. It is not implemented, filtering could be done on client side.
        """
        
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1.ListGpuClustersRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1.ListGpuClustersRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class CreateGpuClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.CreateGpuClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.CreateGpuClusterRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GpuClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GpuClusterSpec,
        )
    @spec.setter
    def spec(self, value: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateGpuClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.UpdateGpuClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.UpdateGpuClusterRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GpuClusterSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GpuClusterSpec,
        )
    @spec.setter
    def spec(self, value: "GpuClusterSpec|gpu_cluster_pb2.GpuClusterSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteGpuClusterRequest(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.DeleteGpuClusterRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.DeleteGpuClusterRequest",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListGpuClustersResponse(pb_classes.Message):
    __PB2_CLASS__ = gpu_cluster_service_pb2.ListGpuClustersResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListGpuClustersResponse",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[GpuCluster]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[GpuCluster]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(GpuCluster,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[GpuCluster]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class GpuClusterServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.compute.v1.GpuClusterService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1.GpuClusterService",gpu_cluster_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1.GpuClusterService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetGpuClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetGpuClusterRequest","GpuCluster"]:
        """
        Retrieves the specified GPU Cluster by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.GetGpuClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.GpuCluster`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=gpu_cluster_pb2.GpuCluster,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(GpuCluster),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","GpuCluster"]:
        """
        Retrieves the specified GPU Cluster by its parent and name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.GpuCluster`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=gpu_cluster_pb2.GpuCluster,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(GpuCluster),
        )
    
    def list(self,
        request: "ListGpuClustersRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListGpuClustersRequest","ListGpuClustersResponse"]:
        """
        Lists GPU Clusters in the specified parent.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListGpuClustersRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.ListGpuClustersResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=gpu_cluster_service_pb2.ListGpuClustersResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListGpuClustersResponse),
        )
    
    def create(self,
        request: "CreateGpuClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateGpuClusterRequest","operation.Operation[v1_1.Operation]"]:
        """
        Creates a new GPU Cluster.
        For details, see https://docs.nebius.com/compute/clusters/gpu#create-cluster
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.CreateGpuClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateGpuClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateGpuClusterRequest","operation.Operation[v1_1.Operation]"]:
        """
        Modifies the configuration of an existing GPU Cluster.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.UpdateGpuClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteGpuClusterRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteGpuClusterRequest","operation.Operation[v1_1.Operation]"]:
        """
        Deletes a GPU Cluster by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.DeleteGpuClusterRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list_operations_by_parent(self,
        request: "ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListOperationsByParentRequest","v1_1.ListOperationsResponse"]:
        """
        Lists all operations that were performed within a specific parent resource.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2_1.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1_1.ListOperationsResponse),
        )
    

# file: nebius/compute/v1/image.proto
class Image(pb_classes.Message):
    __PB2_CLASS__ = image_pb2.Image
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.Image",image_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ImageSpec|image_pb2.ImageSpec|None|unset.UnsetType" = unset.Unset,
        status: "ImageStatus|image_pb2.ImageStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ImageSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ImageSpec,
        )
    @spec.setter
    def spec(self, value: "ImageSpec|image_pb2.ImageSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ImageStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ImageStatus,
        )
    @status.setter
    def status(self, value: "ImageStatus|image_pb2.ImageStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ImageSpec(pb_classes.Message):
    __PB2_CLASS__ = image_pb2.ImageSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ImageSpec",image_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class CPUArchitecture(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.ImageSpec.CPUArchitecture",image_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        AMD64 = 1
        ARM64 = 2
    
    class __OneOfClass__description__(pb_classes.OneOf):
        name: builtins.str= "_description"
        
        def __init__(self, msg: "ImageSpec") -> None:
            super().__init__()
            self._message: "ImageSpec" = msg
    
    class __OneOfClass__description_description__(__OneOfClass__description__):
        field: typing.Literal["description"] = "description"
        
        def __init__(self, msg: "ImageSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.description
    
    @builtins.property
    def _description(self) -> __OneOfClass__description_description__|None:
        field_name_1: str|None = super().which_field_in_oneof("_description")
        match field_name_1:
            case "description":
                return self.__OneOfClass__description_description__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        image_family: "builtins.str|None|unset.UnsetType" = unset.Unset,
        version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        cpu_architecture: "ImageSpec.CPUArchitecture|image_pb2.ImageSpec.CPUArchitecture|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(image_family, unset.UnsetType):
            self.image_family = image_family
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(cpu_architecture, unset.UnsetType):
            self.cpu_architecture = cpu_architecture
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "description",
            "image_family",
            "version",
            "cpu_architecture",
            "_description",
            "CPUArchitecture",
        ]
    
    @builtins.property
    def description(self) -> "builtins.str|None":
        return super()._get_field("description", explicit_presence=True,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=True,
        )
    
    @builtins.property
    def image_family(self) -> "builtins.str":
        return super()._get_field("image_family", explicit_presence=False,
        )
    @image_family.setter
    def image_family(self, value: "builtins.str|None") -> None:
        return super()._set_field("image_family",value,explicit_presence=False,
        )
    
    @builtins.property
    def version(self) -> "builtins.str":
        return super()._get_field("version", explicit_presence=False,
        )
    @version.setter
    def version(self, value: "builtins.str|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def cpu_architecture(self) -> "ImageSpec.CPUArchitecture":
        return super()._get_field("cpu_architecture", explicit_presence=False,
        wrap=ImageSpec.CPUArchitecture,
        )
    @cpu_architecture.setter
    def cpu_architecture(self, value: "ImageSpec.CPUArchitecture|image_pb2.ImageSpec.CPUArchitecture|None") -> None:
        return super()._set_field("cpu_architecture",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "description":"description",
        "image_family":"image_family",
        "version":"version",
        "cpu_architecture":"cpu_architecture",
        "_description":"_description",
        "CPUArchitecture":"CPUArchitecture",
    }
    
class ImageStatus(pb_classes.Message):
    __PB2_CLASS__ = image_pb2.ImageStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ImageStatus",image_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.ImageStatus.State",image_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 1
        READY = 2
        UPDATING = 3
        DELETING = 4
        ERROR = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "ImageStatus.State|image_pb2.ImageStatus.State|None|unset.UnsetType" = unset.Unset,
        state_description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        storage_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        min_disk_size_bytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(state_description, unset.UnsetType):
            self.state_description = state_description
        if not isinstance(storage_size_bytes, unset.UnsetType):
            self.storage_size_bytes = storage_size_bytes
        if not isinstance(min_disk_size_bytes, unset.UnsetType):
            self.min_disk_size_bytes = min_disk_size_bytes
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "state_description",
            "storage_size_bytes",
            "min_disk_size_bytes",
            "reconciling",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "ImageStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=ImageStatus.State,
        )
    @state.setter
    def state(self, value: "ImageStatus.State|image_pb2.ImageStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def state_description(self) -> "builtins.str":
        return super()._get_field("state_description", explicit_presence=False,
        )
    @state_description.setter
    def state_description(self, value: "builtins.str|None") -> None:
        return super()._set_field("state_description",value,explicit_presence=False,
        )
    
    @builtins.property
    def storage_size_bytes(self) -> "builtins.int":
        return super()._get_field("storage_size_bytes", explicit_presence=False,
        )
    @storage_size_bytes.setter
    def storage_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("storage_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def min_disk_size_bytes(self) -> "builtins.int":
        return super()._get_field("min_disk_size_bytes", explicit_presence=False,
        )
    @min_disk_size_bytes.setter
    def min_disk_size_bytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("min_disk_size_bytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "state_description":"state_description",
        "storage_size_bytes":"storage_size_bytes",
        "min_disk_size_bytes":"min_disk_size_bytes",
        "reconciling":"reconciling",
        "State":"State",
    }
    
# file: nebius/compute/v1/image_service.proto
class GetImageRequest(pb_classes.Message):
    __PB2_CLASS__ = image_service_pb2.GetImageRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GetImageRequest",image_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetImageLatestByFamilyRequest(pb_classes.Message):
    __PB2_CLASS__ = image_service_pb2.GetImageLatestByFamilyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GetImageLatestByFamilyRequest",image_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        image_family: "builtins.str|None|unset.UnsetType" = unset.Unset,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(image_family, unset.UnsetType):
            self.image_family = image_family
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "image_family",
            "parent_id",
        ]
    
    @builtins.property
    def image_family(self) -> "builtins.str":
        return super()._get_field("image_family", explicit_presence=False,
        )
    @image_family.setter
    def image_family(self, value: "builtins.str|None") -> None:
        return super()._set_field("image_family",value,explicit_presence=False,
        )
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        default 'project-{region}public-images'
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "image_family":"image_family",
        "parent_id":"parent_id",
    }
    
class ListImagesRequest(pb_classes.Message):
    __PB2_CLASS__ = image_service_pb2.ListImagesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListImagesRequest",image_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Supported until 06/16/25. It is not implemented, filtering could be done on client side.
        """
        
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1.ListImagesRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        logging.getLogger("deprecation").warning(
        """Field .nebius.compute.v1.ListImagesRequest.filter is deprecated. Supported until 06/16/25. It is not implemented, filtering could be done on client side."""
        , stack_info=True, stacklevel=2)
        
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListImagesResponse(pb_classes.Message):
    __PB2_CLASS__ = image_service_pb2.ListImagesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListImagesResponse",image_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Image]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Image]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Image,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Image]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class ImageServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.compute.v1.ImageService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1.ImageService",image_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1.ImageService"
    
    def get(self,
        request: "GetImageRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetImageRequest","Image"]:
        """
        Retrieves detailed information about a specific image by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.GetImageRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Image`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=image_pb2.Image,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Image),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Image"]:
        """
        Retrieves detailed information about a specific image by its parent and name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Image`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=image_pb2.Image,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Image),
        )
    
    def get_latest_by_family(self,
        request: "GetImageLatestByFamilyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetImageLatestByFamilyRequest","Image"]:
        """
        Retrieves the most recent image from a specified family.
        Image families are used to organize related images and ensure easy access to the latest version.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.GetImageLatestByFamilyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Image`.
        """
        
        return super().request(
            method="GetLatestByFamily",
            request=request,
            result_pb2_class=image_pb2.Image,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Image),
        )
    
    def list(self,
        request: "ListImagesRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListImagesRequest","ListImagesResponse"]:
        """
        Lists all images in a specific parent resource.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListImagesRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.ListImagesResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=image_service_pb2.ListImagesResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListImagesResponse),
        )
    
    def list_operations_by_parent(self,
        request: "ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListOperationsByParentRequest","v1_1.ListOperationsResponse"]:
        """
        Lists all operations that were performed within a specific parent resource.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2_1.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1_1.ListOperationsResponse),
        )
    

# file: nebius/compute/v1/network_interface.proto
class NetworkInterfaceSpec(pb_classes.Message):
    """
    Describes the specification of a network interface.
    """
    
    __PB2_CLASS__ = network_interface_pb2.NetworkInterfaceSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.NetworkInterfaceSpec",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        subnet_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ip_address: "IPAddress|network_interface_pb2.IPAddress|None|unset.UnsetType" = unset.Unset,
        public_ip_address: "PublicIPAddress|network_interface_pb2.PublicIPAddress|None|unset.UnsetType" = unset.Unset,
        aliases: "abc.Iterable[IPAlias]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(subnet_id, unset.UnsetType):
            self.subnet_id = subnet_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(ip_address, unset.UnsetType):
            self.ip_address = ip_address
        if not isinstance(public_ip_address, unset.UnsetType):
            self.public_ip_address = public_ip_address
        if not isinstance(aliases, unset.UnsetType):
            self.aliases = aliases
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "subnet_id",
            "name",
            "ip_address",
            "public_ip_address",
            "aliases",
        ]
    
    @builtins.property
    def subnet_id(self) -> "builtins.str":
        """
        Subnet ID
        """
        
        return super()._get_field("subnet_id", explicit_presence=False,
        )
    @subnet_id.setter
    def subnet_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subnet_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Interface name
        Value of this field configures the name of the network interface inside VM's OS.
        Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    @builtins.property
    def ip_address(self) -> "IPAddress|None":
        """
        Private IPv4 address associated with the interface.
        """
        
        return super()._get_field("ip_address", explicit_presence=True,
        wrap=IPAddress,
        )
    @ip_address.setter
    def ip_address(self, value: "IPAddress|network_interface_pb2.IPAddress|None") -> None:
        return super()._set_field("ip_address",value,explicit_presence=True,
        )
    
    @builtins.property
    def public_ip_address(self) -> "PublicIPAddress|None":
        """
        Public IPv4 address associated with the interface.
        """
        
        return super()._get_field("public_ip_address", explicit_presence=True,
        wrap=PublicIPAddress,
        )
    @public_ip_address.setter
    def public_ip_address(self, value: "PublicIPAddress|network_interface_pb2.PublicIPAddress|None") -> None:
        return super()._set_field("public_ip_address",value,explicit_presence=True,
        )
    
    @builtins.property
    def aliases(self) -> "abc.MutableSequence[IPAlias]":
        """
        Assign ranges of IP addresses as aliases
        """
        
        return super()._get_field("aliases", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(IPAlias,None,None),
        )
    @aliases.setter
    def aliases(self, value: "abc.Iterable[IPAlias]|None") -> None:
        return super()._set_field("aliases",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "subnet_id":"subnet_id",
        "name":"name",
        "ip_address":"ip_address",
        "public_ip_address":"public_ip_address",
        "aliases":"aliases",
    }
    
class IPAddress(pb_classes.Message):
    """
    Describes an IPv4 address.
    """
    
    __PB2_CLASS__ = network_interface_pb2.IPAddress
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.IPAddress",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "allocation_id",
        ]
    
    @builtins.property
    def allocation_id(self) -> "builtins.str":
        """
        Allocation identifier if it was created before.
        """
        
        return super()._get_field("allocation_id", explicit_presence=False,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "allocation_id":"allocation_id",
    }
    
class PublicIPAddress(pb_classes.Message):
    """
    Describes a public IP address.
    """
    
    __PB2_CLASS__ = network_interface_pb2.PublicIPAddress
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.PublicIPAddress",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_allocation__(pb_classes.OneOf):
        name: builtins.str= "allocation"
        
        def __init__(self, msg: "PublicIPAddress") -> None:
            super().__init__()
            self._message: "PublicIPAddress" = msg
    
    class __OneOfClass_allocation_allocation_id__(__OneOfClass_allocation__):
        field: typing.Literal["allocation_id"] = "allocation_id"
        
        def __init__(self, msg: "PublicIPAddress") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.allocation_id
    
    @builtins.property
    def allocation(self) -> __OneOfClass_allocation_allocation_id__|None:
        """
        Describes different methods of public IP address allocation.
        """
        
        field_name_1: str|None = super().which_field_in_oneof("allocation")
        match field_name_1:
            case "allocation_id":
                return self.__OneOfClass_allocation_allocation_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        static: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
        if not isinstance(static, unset.UnsetType):
            self.static = static
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "allocation_id",
            "static",
            "allocation",
        ]
    
    @builtins.property
    def allocation_id(self) -> "builtins.str|None":
        """
        Allocation identifier if it was created before.
        """
        
        return super()._get_field("allocation_id", explicit_presence=True,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def static(self) -> "builtins.bool":
        """
        If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        
        return super()._get_field("static", explicit_presence=False,
        )
    @static.setter
    def static(self, value: "builtins.bool|None") -> None:
        return super()._set_field("static",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "allocation_id":"allocation_id",
        "static":"static",
        "allocation":"allocation",
    }
    
class IPAlias(pb_classes.Message):
    __PB2_CLASS__ = network_interface_pb2.IPAlias
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.IPAlias",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "allocation_id",
        ]
    
    @builtins.property
    def allocation_id(self) -> "builtins.str":
        """
        ID of allocation
        """
        
        return super()._get_field("allocation_id", explicit_presence=False,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "allocation_id":"allocation_id",
    }
    
class NetworkInterfaceStatus(pb_classes.Message):
    """
    Describes the status of a network interface.
    """
    
    __PB2_CLASS__ = network_interface_pb2.NetworkInterfaceStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.NetworkInterfaceStatus",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        index: "builtins.int|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ip_address: "IPAddressStatus|network_interface_pb2.IPAddressStatus|None|unset.UnsetType" = unset.Unset,
        public_ip_address: "PublicIPAddressStatus|network_interface_pb2.PublicIPAddressStatus|None|unset.UnsetType" = unset.Unset,
        aliases: "IPAliasesStatus|network_interface_pb2.IPAliasesStatus|None|unset.UnsetType" = unset.Unset,
        mac_address: "builtins.str|None|unset.UnsetType" = unset.Unset,
        fqdn: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(index, unset.UnsetType):
            self.index = index
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(ip_address, unset.UnsetType):
            self.ip_address = ip_address
        if not isinstance(public_ip_address, unset.UnsetType):
            self.public_ip_address = public_ip_address
        if not isinstance(aliases, unset.UnsetType):
            self.aliases = aliases
        if not isinstance(mac_address, unset.UnsetType):
            self.mac_address = mac_address
        if not isinstance(fqdn, unset.UnsetType):
            self.fqdn = fqdn
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "index",
            "name",
            "ip_address",
            "public_ip_address",
            "aliases",
            "mac_address",
            "fqdn",
        ]
    
    @builtins.property
    def index(self) -> "builtins.int":
        """
        The index of the network interface
        """
        
        return super()._get_field("index", explicit_presence=False,
        )
    @index.setter
    def index(self, value: "builtins.int|None") -> None:
        return super()._set_field("index",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    @builtins.property
    def ip_address(self) -> "IPAddressStatus":
        """
        Effective Private IPv4 address
        """
        
        return super()._get_field("ip_address", explicit_presence=False,
        wrap=IPAddressStatus,
        )
    @ip_address.setter
    def ip_address(self, value: "IPAddressStatus|network_interface_pb2.IPAddressStatus|None") -> None:
        return super()._set_field("ip_address",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_ip_address(self) -> "PublicIPAddressStatus":
        """
        Effective Public IPv4 address
        """
        
        return super()._get_field("public_ip_address", explicit_presence=False,
        wrap=PublicIPAddressStatus,
        )
    @public_ip_address.setter
    def public_ip_address(self, value: "PublicIPAddressStatus|network_interface_pb2.PublicIPAddressStatus|None") -> None:
        return super()._set_field("public_ip_address",value,explicit_presence=False,
        )
    
    @builtins.property
    def aliases(self) -> "IPAliasesStatus":
        """
        Effective IP Aliases
        """
        
        return super()._get_field("aliases", explicit_presence=False,
        wrap=IPAliasesStatus,
        )
    @aliases.setter
    def aliases(self, value: "IPAliasesStatus|network_interface_pb2.IPAliasesStatus|None") -> None:
        return super()._set_field("aliases",value,explicit_presence=False,
        )
    
    @builtins.property
    def mac_address(self) -> "builtins.str":
        """
        MAC address
        """
        
        return super()._get_field("mac_address", explicit_presence=False,
        )
    @mac_address.setter
    def mac_address(self, value: "builtins.str|None") -> None:
        return super()._set_field("mac_address",value,explicit_presence=False,
        )
    
    @builtins.property
    def fqdn(self) -> "builtins.str":
        """
        FQDN of the interface
        """
        
        return super()._get_field("fqdn", explicit_presence=False,
        )
    @fqdn.setter
    def fqdn(self, value: "builtins.str|None") -> None:
        return super()._set_field("fqdn",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "index":"index",
        "name":"name",
        "ip_address":"ip_address",
        "public_ip_address":"public_ip_address",
        "aliases":"aliases",
        "mac_address":"mac_address",
        "fqdn":"fqdn",
    }
    
class IPAddressStatus(pb_classes.Message):
    __PB2_CLASS__ = network_interface_pb2.IPAddressStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.IPAddressStatus",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        address: "builtins.str|None|unset.UnsetType" = unset.Unset,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(address, unset.UnsetType):
            self.address = address
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "address",
            "allocation_id",
        ]
    
    @builtins.property
    def address(self) -> "builtins.str":
        """
        Effective private IPv4 address assigned to the interface.
        """
        
        return super()._get_field("address", explicit_presence=False,
        )
    @address.setter
    def address(self, value: "builtins.str|None") -> None:
        return super()._set_field("address",value,explicit_presence=False,
        )
    
    @builtins.property
    def allocation_id(self) -> "builtins.str":
        """
        Allocation identifier.
        """
        
        return super()._get_field("allocation_id", explicit_presence=False,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "address":"address",
        "allocation_id":"allocation_id",
    }
    
class PublicIPAddressStatus(pb_classes.Message):
    __PB2_CLASS__ = network_interface_pb2.PublicIPAddressStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.PublicIPAddressStatus",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        address: "builtins.str|None|unset.UnsetType" = unset.Unset,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        static: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(address, unset.UnsetType):
            self.address = address
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
        if not isinstance(static, unset.UnsetType):
            self.static = static
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "address",
            "allocation_id",
            "static",
        ]
    
    @builtins.property
    def address(self) -> "builtins.str":
        """
        Effective public IPv4 address assigned to the interface.
        """
        
        return super()._get_field("address", explicit_presence=False,
        )
    @address.setter
    def address(self, value: "builtins.str|None") -> None:
        return super()._set_field("address",value,explicit_presence=False,
        )
    
    @builtins.property
    def allocation_id(self) -> "builtins.str":
        """
        Allocation identifier.
        """
        
        return super()._get_field("allocation_id", explicit_presence=False,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def static(self) -> "builtins.bool":
        """
        If false - Allocation will be created/deleted during NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Allocation will be created/deleted during NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        
        return super()._get_field("static", explicit_presence=False,
        )
    @static.setter
    def static(self, value: "builtins.bool|None") -> None:
        return super()._set_field("static",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "address":"address",
        "allocation_id":"allocation_id",
        "static":"static",
    }
    
class IPAliasesStatus(pb_classes.Message):
    __PB2_CLASS__ = network_interface_pb2.IPAliasesStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.IPAliasesStatus",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cidrs: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cidrs, unset.UnsetType):
            self.cidrs = cidrs
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cidrs",
        ]
    
    @builtins.property
    def cidrs(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("cidrs", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @cidrs.setter
    def cidrs(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("cidrs",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cidrs":"cidrs",
    }
    
# file: nebius/compute/v1/instance.proto
class InstanceRecoveryPolicy(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.InstanceRecoveryPolicy",instance_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    RECOVER = 0
    FAIL = 1

class Instance(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.Instance
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.Instance",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InstanceSpec|instance_pb2.InstanceSpec|None|unset.UnsetType" = unset.Unset,
        status: "InstanceStatus|instance_pb2.InstanceStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InstanceSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InstanceSpec,
        )
    @spec.setter
    def spec(self, value: "InstanceSpec|instance_pb2.InstanceSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "InstanceStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=InstanceStatus,
        )
    @status.setter
    def status(self, value: "InstanceStatus|instance_pb2.InstanceStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class InstanceSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.InstanceSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.InstanceSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        service_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resources: "ResourcesSpec|instance_pb2.ResourcesSpec|None|unset.UnsetType" = unset.Unset,
        gpu_cluster: "InstanceGpuClusterSpec|instance_pb2.InstanceGpuClusterSpec|None|unset.UnsetType" = unset.Unset,
        network_interfaces: "abc.Iterable[NetworkInterfaceSpec]|None|unset.UnsetType" = unset.Unset,
        boot_disk: "AttachedDiskSpec|instance_pb2.AttachedDiskSpec|None|unset.UnsetType" = unset.Unset,
        secondary_disks: "abc.Iterable[AttachedDiskSpec]|None|unset.UnsetType" = unset.Unset,
        filesystems: "abc.Iterable[AttachedFilesystemSpec]|None|unset.UnsetType" = unset.Unset,
        cloud_init_user_data: "builtins.str|None|unset.UnsetType" = unset.Unset,
        stopped: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        recovery_policy: "InstanceRecoveryPolicy|instance_pb2.InstanceRecoveryPolicy|None|unset.UnsetType" = unset.Unset,
        preemptible: "PreemptibleSpec|instance_pb2.PreemptibleSpec|None|unset.UnsetType" = unset.Unset,
        hostname: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(service_account_id, unset.UnsetType):
            self.service_account_id = service_account_id
        if not isinstance(resources, unset.UnsetType):
            self.resources = resources
        if not isinstance(gpu_cluster, unset.UnsetType):
            self.gpu_cluster = gpu_cluster
        if not isinstance(network_interfaces, unset.UnsetType):
            self.network_interfaces = network_interfaces
        if not isinstance(boot_disk, unset.UnsetType):
            self.boot_disk = boot_disk
        if not isinstance(secondary_disks, unset.UnsetType):
            self.secondary_disks = secondary_disks
        if not isinstance(filesystems, unset.UnsetType):
            self.filesystems = filesystems
        if not isinstance(cloud_init_user_data, unset.UnsetType):
            self.cloud_init_user_data = cloud_init_user_data
        if not isinstance(stopped, unset.UnsetType):
            self.stopped = stopped
        if not isinstance(recovery_policy, unset.UnsetType):
            self.recovery_policy = recovery_policy
        if not isinstance(preemptible, unset.UnsetType):
            self.preemptible = preemptible
        if not isinstance(hostname, unset.UnsetType):
            self.hostname = hostname
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "service_account_id",
            "resources",
            "gpu_cluster",
            "network_interfaces",
            "boot_disk",
            "secondary_disks",
            "filesystems",
            "cloud_init_user_data",
            "stopped",
            "recovery_policy",
            "preemptible",
            "hostname",
        ]
    
    @builtins.property
    def service_account_id(self) -> "builtins.str":
        """
        Unique identifier of the service account associated with this instance.
        For details, see https://docs.nebius.dev/en/iam/about-iam/concepts/service-accounts
        """
        
        return super()._get_field("service_account_id", explicit_presence=False,
        )
    @service_account_id.setter
    def service_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("service_account_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resources(self) -> "ResourcesSpec":
        """
        Specification of compute resources allocated to the instance.
        For details, see https://docs.nebius.com/compute/virtual-machines/types
        """
        
        return super()._get_field("resources", explicit_presence=False,
        wrap=ResourcesSpec,
        )
    @resources.setter
    def resources(self, value: "ResourcesSpec|instance_pb2.ResourcesSpec|None") -> None:
        return super()._set_field("resources",value,explicit_presence=False,
        )
    
    @builtins.property
    def gpu_cluster(self) -> "InstanceGpuClusterSpec":
        """
        If you want to interconnect several instances in a GPU cluster via NVIDIA InfiniBand,
        set the ID of an existing GPU cluster.
        You can only add the VM to the cluster when creating the VM.
        For details, see https://docs.nebius.com/compute/clusters/gpu
        """
        
        return super()._get_field("gpu_cluster", explicit_presence=False,
        wrap=InstanceGpuClusterSpec,
        )
    @gpu_cluster.setter
    def gpu_cluster(self, value: "InstanceGpuClusterSpec|instance_pb2.InstanceGpuClusterSpec|None") -> None:
        return super()._set_field("gpu_cluster",value,explicit_presence=False,
        )
    
    @builtins.property
    def network_interfaces(self) -> "abc.MutableSequence[NetworkInterfaceSpec]":
        """
        List of network interfaces attached to the instance.
        """
        
        return super()._get_field("network_interfaces", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NetworkInterfaceSpec,None,None),
        )
    @network_interfaces.setter
    def network_interfaces(self, value: "abc.Iterable[NetworkInterfaceSpec]|None") -> None:
        return super()._set_field("network_interfaces",value,explicit_presence=False,
        )
    
    @builtins.property
    def boot_disk(self) -> "AttachedDiskSpec":
        """
        Specified boot disk attached to the instance.
        """
        
        return super()._get_field("boot_disk", explicit_presence=False,
        wrap=AttachedDiskSpec,
        )
    @boot_disk.setter
    def boot_disk(self, value: "AttachedDiskSpec|instance_pb2.AttachedDiskSpec|None") -> None:
        return super()._set_field("boot_disk",value,explicit_presence=False,
        )
    
    @builtins.property
    def secondary_disks(self) -> "abc.MutableSequence[AttachedDiskSpec]":
        """
        List of additional data disks attached to the instance beyond the boot disk.
        """
        
        return super()._get_field("secondary_disks", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AttachedDiskSpec,None,None),
        )
    @secondary_disks.setter
    def secondary_disks(self, value: "abc.Iterable[AttachedDiskSpec]|None") -> None:
        return super()._set_field("secondary_disks",value,explicit_presence=False,
        )
    
    @builtins.property
    def filesystems(self) -> "abc.MutableSequence[AttachedFilesystemSpec]":
        """
        List of Shared Filesystems attached to the instance.
        """
        
        return super()._get_field("filesystems", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AttachedFilesystemSpec,None,None),
        )
    @filesystems.setter
    def filesystems(self, value: "abc.Iterable[AttachedFilesystemSpec]|None") -> None:
        return super()._set_field("filesystems",value,explicit_presence=False,
        )
    
    @builtins.property
    def cloud_init_user_data(self) -> "builtins.str":
        """
        Data in cloud-init format for customizing instance initialization.
        For details, see https://docs.nebius.com/compute/virtual-machines/manage#user-data
        """
        
        return super()._get_field("cloud_init_user_data", explicit_presence=False,
        )
    @cloud_init_user_data.setter
    def cloud_init_user_data(self, value: "builtins.str|None") -> None:
        return super()._set_field("cloud_init_user_data",value,explicit_presence=False,
        )
    
    @builtins.property
    def stopped(self) -> "builtins.bool":
        """
        Indicates whether the instance should be stopped.
        """
        
        return super()._get_field("stopped", explicit_presence=False,
        )
    @stopped.setter
    def stopped(self, value: "builtins.bool|None") -> None:
        return super()._set_field("stopped",value,explicit_presence=False,
        )
    
    @builtins.property
    def recovery_policy(self) -> "InstanceRecoveryPolicy":
        """
        Recovery policy defines how the instance will be treated in case of a failure. Common source of failure is a host failure, but it can be any other failure.
        Instance undergoing a guest shutdown (poweroff, etc.) will be subject to recovery policy, meaning that it could be restarted and billed accordingly. Stop instance via API or UI to stop it to avoid recovering.
        If set to RECOVER, instance will be restarted, if possible. It could be restarted on the same host or on another host.
        If set to FAIL, instance will be stopped and not restarted.
        """
        
        return super()._get_field("recovery_policy", explicit_presence=False,
        wrap=InstanceRecoveryPolicy,
        )
    @recovery_policy.setter
    def recovery_policy(self, value: "InstanceRecoveryPolicy|instance_pb2.InstanceRecoveryPolicy|None") -> None:
        return super()._set_field("recovery_policy",value,explicit_presence=False,
        )
    
    @builtins.property
    def preemptible(self) -> "PreemptibleSpec":
        """
        Include these parameters to create a Preemptible VM and omit them to create a Regular VM
        For details, see https://docs.nebius.com/compute/virtual-machines/preemptible
        """
        
        return super()._get_field("preemptible", explicit_presence=False,
        wrap=PreemptibleSpec,
        )
    @preemptible.setter
    def preemptible(self, value: "PreemptibleSpec|instance_pb2.PreemptibleSpec|None") -> None:
        return super()._set_field("preemptible",value,explicit_presence=False,
        )
    
    @builtins.property
    def hostname(self) -> "builtins.str":
        """
        Instance's hostname. Used to generate default DNS record in format ``<hostname>.<network_id>.compute.internal.``
        or ``<instance_id>.<network_id>.compute.internal.`` if hostname is not specified.
        """
        
        return super()._get_field("hostname", explicit_presence=False,
        )
    @hostname.setter
    def hostname(self, value: "builtins.str|None") -> None:
        return super()._set_field("hostname",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "service_account_id":"service_account_id",
        "resources":"resources",
        "gpu_cluster":"gpu_cluster",
        "network_interfaces":"network_interfaces",
        "boot_disk":"boot_disk",
        "secondary_disks":"secondary_disks",
        "filesystems":"filesystems",
        "cloud_init_user_data":"cloud_init_user_data",
        "stopped":"stopped",
        "recovery_policy":"recovery_policy",
        "preemptible":"preemptible",
        "hostname":"hostname",
    }
    
class PreemptibleSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.PreemptibleSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.PreemptibleSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class PreemptionPolicy(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.PreemptibleSpec.PreemptionPolicy",instance_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        STOP = 1
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        on_preemption: "PreemptibleSpec.PreemptionPolicy|instance_pb2.PreemptibleSpec.PreemptionPolicy|None|unset.UnsetType" = unset.Unset,
        priority: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(on_preemption, unset.UnsetType):
            self.on_preemption = on_preemption
        if not isinstance(priority, unset.UnsetType):
            self.priority = priority
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "on_preemption",
            "priority",
            "PreemptionPolicy",
        ]
    
    @builtins.property
    def on_preemption(self) -> "PreemptibleSpec.PreemptionPolicy":
        """
        Specifies what happens when the VM is preempted. The only supported value is STOP:
        Compute stops the VM without deleting or restarting it.
        """
        
        return super()._get_field("on_preemption", explicit_presence=False,
        wrap=PreemptibleSpec.PreemptionPolicy,
        )
    @on_preemption.setter
    def on_preemption(self, value: "PreemptibleSpec.PreemptionPolicy|instance_pb2.PreemptibleSpec.PreemptionPolicy|None") -> None:
        return super()._set_field("on_preemption",value,explicit_presence=False,
        )
    
    @builtins.property
    def priority(self) -> "builtins.int":
        """
        The value can range from 1 to 5, where 5 indicates the highest priority.
        Affects the order in which Compute tries to preempt VMs, but does not guarantee the exact order.
        """
        
        return super()._get_field("priority", explicit_presence=False,
        )
    @priority.setter
    def priority(self, value: "builtins.int|None") -> None:
        return super()._set_field("priority",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "on_preemption":"on_preemption",
        "priority":"priority",
        "PreemptionPolicy":"PreemptionPolicy",
    }
    
class ResourcesSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.ResourcesSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ResourcesSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_size__(pb_classes.OneOf):
        name: builtins.str= "size"
        
        def __init__(self, msg: "ResourcesSpec") -> None:
            super().__init__()
            self._message: "ResourcesSpec" = msg
    
    class __OneOfClass_size_preset__(__OneOfClass_size__):
        field: typing.Literal["preset"] = "preset"
        
        def __init__(self, msg: "ResourcesSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.preset
    
    @builtins.property
    def size(self) -> __OneOfClass_size_preset__|None:
        field_name_1: str|None = super().which_field_in_oneof("size")
        match field_name_1:
            case "preset":
                return self.__OneOfClass_size_preset__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        platform: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preset: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(platform, unset.UnsetType):
            self.platform = platform
        if not isinstance(preset, unset.UnsetType):
            self.preset = preset
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "platform",
            "preset",
            "size",
        ]
    
    @builtins.property
    def platform(self) -> "builtins.str":
        return super()._get_field("platform", explicit_presence=False,
        )
    @platform.setter
    def platform(self, value: "builtins.str|None") -> None:
        return super()._set_field("platform",value,explicit_presence=False,
        )
    
    @builtins.property
    def preset(self) -> "builtins.str|None":
        return super()._get_field("preset", explicit_presence=True,
        )
    @preset.setter
    def preset(self, value: "builtins.str|None") -> None:
        return super()._set_field("preset",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "platform":"platform",
        "preset":"preset",
        "size":"size",
    }
    
class InstanceGpuClusterSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.InstanceGpuClusterSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.InstanceGpuClusterSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        If you want to interconnect several instances in a GPU cluster via NVIDIA InfiniBand,
        set the ID of an existing GPU cluster.
        You can only add the VM to the cluster when creating the VM.
        For details, see https://docs.nebius.com/compute/clusters/gpu
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class AttachedDiskSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.AttachedDiskSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.AttachedDiskSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class AttachMode(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.AttachedDiskSpec.AttachMode",instance_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        READ_ONLY = 1
        READ_WRITE = 2
    
    class __OneOfClass_type__(pb_classes.OneOf):
        name: builtins.str= "type"
        
        def __init__(self, msg: "AttachedDiskSpec") -> None:
            super().__init__()
            self._message: "AttachedDiskSpec" = msg
    
    class __OneOfClass_type_existing_disk__(__OneOfClass_type__):
        field: typing.Literal["existing_disk"] = "existing_disk"
        
        def __init__(self, msg: "AttachedDiskSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ExistingDisk":
            return self._message.existing_disk
    
    @builtins.property
    def type(self) -> __OneOfClass_type_existing_disk__|None:
        field_name_1: str|None = super().which_field_in_oneof("type")
        match field_name_1:
            case "existing_disk":
                return self.__OneOfClass_type_existing_disk__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        attach_mode: "AttachedDiskSpec.AttachMode|instance_pb2.AttachedDiskSpec.AttachMode|None|unset.UnsetType" = unset.Unset,
        existing_disk: "ExistingDisk|instance_pb2.ExistingDisk|None|unset.UnsetType" = unset.Unset,
        device_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(attach_mode, unset.UnsetType):
            self.attach_mode = attach_mode
        if not isinstance(existing_disk, unset.UnsetType):
            self.existing_disk = existing_disk
        if not isinstance(device_id, unset.UnsetType):
            self.device_id = device_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "attach_mode",
            "existing_disk",
            "device_id",
            "type",
            "AttachMode",
        ]
    
    @builtins.property
    def attach_mode(self) -> "AttachedDiskSpec.AttachMode":
        return super()._get_field("attach_mode", explicit_presence=False,
        wrap=AttachedDiskSpec.AttachMode,
        )
    @attach_mode.setter
    def attach_mode(self, value: "AttachedDiskSpec.AttachMode|instance_pb2.AttachedDiskSpec.AttachMode|None") -> None:
        return super()._set_field("attach_mode",value,explicit_presence=False,
        )
    
    @builtins.property
    def existing_disk(self) -> "ExistingDisk|None":
        return super()._get_field("existing_disk", explicit_presence=True,
        wrap=ExistingDisk,
        )
    @existing_disk.setter
    def existing_disk(self, value: "ExistingDisk|instance_pb2.ExistingDisk|None") -> None:
        return super()._set_field("existing_disk",value,explicit_presence=True,
        )
    
    @builtins.property
    def device_id(self) -> "builtins.str":
        """
        Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
        """
        
        return super()._get_field("device_id", explicit_presence=False,
        )
    @device_id.setter
    def device_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("device_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "attach_mode":"attach_mode",
        "existing_disk":"existing_disk",
        "device_id":"device_id",
        "type":"type",
        "AttachMode":"AttachMode",
    }
    
class ExistingDisk(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.ExistingDisk
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ExistingDisk",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ExistingFilesystem(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.ExistingFilesystem
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ExistingFilesystem",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class AttachedFilesystemSpec(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.AttachedFilesystemSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.AttachedFilesystemSpec",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class AttachMode(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.AttachedFilesystemSpec.AttachMode",instance_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        READ_ONLY = 1
        READ_WRITE = 2
    
    class __OneOfClass_type__(pb_classes.OneOf):
        name: builtins.str= "type"
        
        def __init__(self, msg: "AttachedFilesystemSpec") -> None:
            super().__init__()
            self._message: "AttachedFilesystemSpec" = msg
    
    class __OneOfClass_type_existing_filesystem__(__OneOfClass_type__):
        field: typing.Literal["existing_filesystem"] = "existing_filesystem"
        
        def __init__(self, msg: "AttachedFilesystemSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ExistingFilesystem":
            return self._message.existing_filesystem
    
    @builtins.property
    def type(self) -> __OneOfClass_type_existing_filesystem__|None:
        field_name_1: str|None = super().which_field_in_oneof("type")
        match field_name_1:
            case "existing_filesystem":
                return self.__OneOfClass_type_existing_filesystem__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        attach_mode: "AttachedFilesystemSpec.AttachMode|instance_pb2.AttachedFilesystemSpec.AttachMode|None|unset.UnsetType" = unset.Unset,
        mount_tag: "builtins.str|None|unset.UnsetType" = unset.Unset,
        existing_filesystem: "ExistingFilesystem|instance_pb2.ExistingFilesystem|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(attach_mode, unset.UnsetType):
            self.attach_mode = attach_mode
        if not isinstance(mount_tag, unset.UnsetType):
            self.mount_tag = mount_tag
        if not isinstance(existing_filesystem, unset.UnsetType):
            self.existing_filesystem = existing_filesystem
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "attach_mode",
            "mount_tag",
            "existing_filesystem",
            "type",
            "AttachMode",
        ]
    
    @builtins.property
    def attach_mode(self) -> "AttachedFilesystemSpec.AttachMode":
        return super()._get_field("attach_mode", explicit_presence=False,
        wrap=AttachedFilesystemSpec.AttachMode,
        )
    @attach_mode.setter
    def attach_mode(self, value: "AttachedFilesystemSpec.AttachMode|instance_pb2.AttachedFilesystemSpec.AttachMode|None") -> None:
        return super()._set_field("attach_mode",value,explicit_presence=False,
        )
    
    @builtins.property
    def mount_tag(self) -> "builtins.str":
        """
        Specifies the user-defined identifier, allowing to use it as a device in mount command.
        """
        
        return super()._get_field("mount_tag", explicit_presence=False,
        )
    @mount_tag.setter
    def mount_tag(self, value: "builtins.str|None") -> None:
        return super()._set_field("mount_tag",value,explicit_presence=False,
        )
    
    @builtins.property
    def existing_filesystem(self) -> "ExistingFilesystem|None":
        return super()._get_field("existing_filesystem", explicit_presence=True,
        wrap=ExistingFilesystem,
        )
    @existing_filesystem.setter
    def existing_filesystem(self, value: "ExistingFilesystem|instance_pb2.ExistingFilesystem|None") -> None:
        return super()._set_field("existing_filesystem",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "attach_mode":"attach_mode",
        "mount_tag":"mount_tag",
        "existing_filesystem":"existing_filesystem",
        "type":"type",
        "AttachMode":"AttachMode",
    }
    
class InstanceStatus(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.InstanceStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.InstanceStatus",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class InstanceState(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.compute.v1.InstanceStatus.InstanceState",instance_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 1
        UPDATING = 2
        STARTING = 3
        RUNNING = 4
        STOPPING = 5
        STOPPED = 6
        DELETING = 7
        ERROR = 8
    
    class __OneOfClass_gpu_cluster_topology__(pb_classes.OneOf):
        name: builtins.str= "gpu_cluster_topology"
        
        def __init__(self, msg: "InstanceStatus") -> None:
            super().__init__()
            self._message: "InstanceStatus" = msg
    
    class __OneOfClass_gpu_cluster_topology_infiniband_topology_path__(__OneOfClass_gpu_cluster_topology__):
        field: typing.Literal["infiniband_topology_path"] = "infiniband_topology_path"
        
        def __init__(self, msg: "InstanceStatus") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "InstanceStatusInfinibandTopologyPath":
            return self._message.infiniband_topology_path
    
    @builtins.property
    def gpu_cluster_topology(self) -> __OneOfClass_gpu_cluster_topology_infiniband_topology_path__|None:
        field_name_1: str|None = super().which_field_in_oneof("gpu_cluster_topology")
        match field_name_1:
            case "infiniband_topology_path":
                return self.__OneOfClass_gpu_cluster_topology_infiniband_topology_path__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "InstanceStatus.InstanceState|instance_pb2.InstanceStatus.InstanceState|None|unset.UnsetType" = unset.Unset,
        network_interfaces: "abc.Iterable[NetworkInterfaceStatus]|None|unset.UnsetType" = unset.Unset,
        reconciling: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        maintenance_event_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        infiniband_topology_path: "InstanceStatusInfinibandTopologyPath|instance_pb2.InstanceStatusInfinibandTopologyPath|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(network_interfaces, unset.UnsetType):
            self.network_interfaces = network_interfaces
        if not isinstance(reconciling, unset.UnsetType):
            self.reconciling = reconciling
        if not isinstance(maintenance_event_id, unset.UnsetType):
            self.maintenance_event_id = maintenance_event_id
        if not isinstance(infiniband_topology_path, unset.UnsetType):
            self.infiniband_topology_path = infiniband_topology_path
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "network_interfaces",
            "reconciling",
            "maintenance_event_id",
            "infiniband_topology_path",
            "gpu_cluster_topology",
            "InstanceState",
        ]
    
    @builtins.property
    def state(self) -> "InstanceStatus.InstanceState":
        return super()._get_field("state", explicit_presence=False,
        wrap=InstanceStatus.InstanceState,
        )
    @state.setter
    def state(self, value: "InstanceStatus.InstanceState|instance_pb2.InstanceStatus.InstanceState|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def network_interfaces(self) -> "abc.MutableSequence[NetworkInterfaceStatus]":
        return super()._get_field("network_interfaces", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NetworkInterfaceStatus,None,None),
        )
    @network_interfaces.setter
    def network_interfaces(self, value: "abc.Iterable[NetworkInterfaceStatus]|None") -> None:
        return super()._set_field("network_interfaces",value,explicit_presence=False,
        )
    
    @builtins.property
    def reconciling(self) -> "builtins.bool":
        """
        Indicates whether there is an ongoing operation
        """
        
        return super()._get_field("reconciling", explicit_presence=False,
        )
    @reconciling.setter
    def reconciling(self, value: "builtins.bool|None") -> None:
        return super()._set_field("reconciling",value,explicit_presence=False,
        )
    
    @builtins.property
    def maintenance_event_id(self) -> "builtins.str":
        return super()._get_field("maintenance_event_id", explicit_presence=False,
        )
    @maintenance_event_id.setter
    def maintenance_event_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("maintenance_event_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def infiniband_topology_path(self) -> "InstanceStatusInfinibandTopologyPath|None":
        return super()._get_field("infiniband_topology_path", explicit_presence=True,
        wrap=InstanceStatusInfinibandTopologyPath,
        )
    @infiniband_topology_path.setter
    def infiniband_topology_path(self, value: "InstanceStatusInfinibandTopologyPath|instance_pb2.InstanceStatusInfinibandTopologyPath|None") -> None:
        return super()._set_field("infiniband_topology_path",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "network_interfaces":"network_interfaces",
        "reconciling":"reconciling",
        "maintenance_event_id":"maintenance_event_id",
        "infiniband_topology_path":"infiniband_topology_path",
        "gpu_cluster_topology":"gpu_cluster_topology",
        "InstanceState":"InstanceState",
    }
    
class InstanceStatusInfinibandTopologyPath(pb_classes.Message):
    __PB2_CLASS__ = instance_pb2.InstanceStatusInfinibandTopologyPath
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.InstanceStatusInfinibandTopologyPath",instance_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        path: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(path, unset.UnsetType):
            self.path = path
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "path",
        ]
    
    @builtins.property
    def path(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("path", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @path.setter
    def path(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("path",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "path":"path",
    }
    
# file: nebius/compute/v1/instance_service.proto
class GetInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.GetInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GetInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListInstancesRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.ListInstancesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListInstancesRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class CreateInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.CreateInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.CreateInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InstanceSpec|instance_pb2.InstanceSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InstanceSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InstanceSpec,
        )
    @spec.setter
    def spec(self, value: "InstanceSpec|instance_pb2.InstanceSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.UpdateInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.UpdateInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InstanceSpec|instance_pb2.InstanceSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InstanceSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InstanceSpec,
        )
    @spec.setter
    def spec(self, value: "InstanceSpec|instance_pb2.InstanceSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.DeleteInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.DeleteInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListInstancesResponse(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.ListInstancesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListInstancesResponse",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Instance]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Instance]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Instance,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Instance]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class StartInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.StartInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.StartInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class StopInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = instance_service_pb2.StopInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.StopInstanceRequest",instance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class InstanceServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.compute.v1.InstanceService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1.InstanceService",instance_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1.InstanceService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetInstanceRequest","Instance"]:
        """
        Retrieves detailed information about a specific VM instance by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.GetInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Instance`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=instance_pb2.Instance,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Instance),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Instance"]:
        """
        Retrieves detailed information about a specific VM instance by its parent and name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Instance`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=instance_pb2.Instance,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Instance),
        )
    
    def list(self,
        request: "ListInstancesRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListInstancesRequest","ListInstancesResponse"]:
        """
        Lists all VM instances within a specified parent.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListInstancesRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.ListInstancesResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=instance_service_pb2.ListInstancesResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListInstancesResponse),
        )
    
    def create(self,
        request: "CreateInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateInstanceRequest","operation.Operation[v1_1.Operation]"]:
        """
        Creates a new VM instance based on the provided specification.
        For details, see https://docs.nebius.com/compute/virtual-machines/manage
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.CreateInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateInstanceRequest","operation.Operation[v1_1.Operation]"]:
        """
        Updates an existing VM instance with new configuration parameters.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.UpdateInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteInstanceRequest","operation.Operation[v1_1.Operation]"]:
        """
        Deletes a VM instance by its ID.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.DeleteInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def start(self,
        request: "StartInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["StartInstanceRequest","operation.Operation[v1_1.Operation]"]:
        """
        Starts a stopped VM instance.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.StartInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Start",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def stop(self,
        request: "StopInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["StopInstanceRequest","operation.Operation[v1_1.Operation]"]:
        """
        Stops a running VM instance.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.StopInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Stop",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list_operations_by_parent(self,
        request: "ListOperationsByParentRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListOperationsByParentRequest","v1_1.ListOperationsResponse"]:
        """
        Lists all operations that were performed within a specific parent resource.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListOperationsByParentRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.ListOperationsResponse`.
        """
        
        return super().request(
            method="ListOperationsByParent",
            request=request,
            result_pb2_class=operation_service_pb2_1.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(v1_1.ListOperationsResponse),
        )
    

# file: nebius/compute/v1/maintenance_event.proto
class MaintenanceEvent(pb_classes.Message):
    __PB2_CLASS__ = maintenance_event_pb2.MaintenanceEvent
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.MaintenanceEvent",maintenance_event_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        spec: "MaintenanceEventSpec|maintenance_event_pb2.MaintenanceEventSpec|None|unset.UnsetType" = unset.Unset,
        status: "MaintenanceEventStatus|maintenance_event_pb2.MaintenanceEventStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "spec",
            "status",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "MaintenanceEventSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=MaintenanceEventSpec,
        )
    @spec.setter
    def spec(self, value: "MaintenanceEventSpec|maintenance_event_pb2.MaintenanceEventSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "MaintenanceEventStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=MaintenanceEventStatus,
        )
    @status.setter
    def status(self, value: "MaintenanceEventStatus|maintenance_event_pb2.MaintenanceEventStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "spec":"spec",
        "status":"status",
    }
    
class MaintenanceEventSpec(pb_classes.Message):
    __PB2_CLASS__ = maintenance_event_pb2.MaintenanceEventSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.MaintenanceEventSpec",maintenance_event_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        is_planned: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(is_planned, unset.UnsetType):
            self.is_planned = is_planned
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "is_planned",
        ]
    
    @builtins.property
    def is_planned(self) -> "builtins.bool":
        """
        If the maintenance event is planned or not
        """
        
        return super()._get_field("is_planned", explicit_presence=False,
        )
    @is_planned.setter
    def is_planned(self, value: "builtins.bool|None") -> None:
        return super()._set_field("is_planned",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "is_planned":"is_planned",
    }
    
class MaintenanceEventStatus(pb_classes.Message):
    __PB2_CLASS__ = maintenance_event_pb2.MaintenanceEventStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.MaintenanceEventStatus",maintenance_event_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "created_at": well_known_1.ts_mask,
        "finished_at": well_known_1.ts_mask,
        "sla_deadline_ts": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        maintenance_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        created_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        finished_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        sla_deadline_ts: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        support_center_ticket_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(maintenance_id, unset.UnsetType):
            self.maintenance_id = maintenance_id
        if not isinstance(created_at, unset.UnsetType):
            self.created_at = created_at
        if not isinstance(finished_at, unset.UnsetType):
            self.finished_at = finished_at
        if not isinstance(sla_deadline_ts, unset.UnsetType):
            self.sla_deadline_ts = sla_deadline_ts
        if not isinstance(support_center_ticket_id, unset.UnsetType):
            self.support_center_ticket_id = support_center_ticket_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "maintenance_id",
            "created_at",
            "finished_at",
            "sla_deadline_ts",
            "support_center_ticket_id",
        ]
    
    @builtins.property
    def maintenance_id(self) -> "builtins.str":
        return super()._get_field("maintenance_id", explicit_presence=False,
        )
    @maintenance_id.setter
    def maintenance_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("maintenance_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def created_at(self) -> "datetime.datetime":
        """
        Time when the maintenance event is created
        """
        
        return super()._get_field("created_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @created_at.setter
    def created_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("created_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def finished_at(self) -> "datetime.datetime":
        """
        Time when the maintenance event is finished
        """
        
        return super()._get_field("finished_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @finished_at.setter
    def finished_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("finished_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def sla_deadline_ts(self) -> "datetime.datetime":
        """
        Time when the instance will be force stopped
        """
        
        return super()._get_field("sla_deadline_ts", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @sla_deadline_ts.setter
    def sla_deadline_ts(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("sla_deadline_ts",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def support_center_ticket_id(self) -> "builtins.str":
        """
        Ticket key, can be transformed into url where support is talking with the client
        """
        
        return super()._get_field("support_center_ticket_id", explicit_presence=False,
        )
    @support_center_ticket_id.setter
    def support_center_ticket_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("support_center_ticket_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "maintenance_id":"maintenance_id",
        "created_at":"created_at",
        "finished_at":"finished_at",
        "sla_deadline_ts":"sla_deadline_ts",
        "support_center_ticket_id":"support_center_ticket_id",
    }
    
# file: nebius/compute/v1/maintenance_service.proto
class GetMaintenanceEventByInstanceRequest(pb_classes.Message):
    __PB2_CLASS__ = maintenance_service_pb2.GetMaintenanceEventByInstanceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.GetMaintenanceEventByInstanceRequest",maintenance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        instance_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(instance_id, unset.UnsetType):
            self.instance_id = instance_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "instance_id",
        ]
    
    @builtins.property
    def instance_id(self) -> "builtins.str":
        return super()._get_field("instance_id", explicit_presence=False,
        )
    @instance_id.setter
    def instance_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("instance_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "instance_id":"instance_id",
    }
    
class ListMaintenanceEventsRequest(pb_classes.Message):
    __PB2_CLASS__ = maintenance_service_pb2.ListMaintenanceEventsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListMaintenanceEventsRequest",maintenance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListMaintenanceEventsResponse(pb_classes.Message):
    __PB2_CLASS__ = maintenance_service_pb2.ListMaintenanceEventsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListMaintenanceEventsResponse",maintenance_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[MaintenanceEvent]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[MaintenanceEvent]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(MaintenanceEvent,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[MaintenanceEvent]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class MaintenanceServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.compute.v1.MaintenanceService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1.MaintenanceService",maintenance_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1.MaintenanceService"
    
    def get_by_instance(self,
        request: "GetMaintenanceEventByInstanceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetMaintenanceEventByInstanceRequest","MaintenanceEvent"]:
        """
        Returns only active maintenance event for the instance
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.GetMaintenanceEventByInstanceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.MaintenanceEvent`.
        """
        
        return super().request(
            method="GetByInstance",
            request=request,
            result_pb2_class=maintenance_event_pb2.MaintenanceEvent,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(MaintenanceEvent),
        )
    
    def list_active(self,
        request: "ListMaintenanceEventsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListMaintenanceEventsRequest","ListMaintenanceEventsResponse"]:
        """
        Returns all unfinished maintenance events for the parent
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListMaintenanceEventsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.ListMaintenanceEventsResponse`.
        """
        
        return super().request(
            method="ListActive",
            request=request,
            result_pb2_class=maintenance_service_pb2.ListMaintenanceEventsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListMaintenanceEventsResponse),
        )
    

# file: nebius/compute/v1/node_service.proto
class NodeSetUnhealthyRequest(pb_classes.Message):
    __PB2_CLASS__ = node_service_pb2.NodeSetUnhealthyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.NodeSetUnhealthyRequest",node_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class HealthCheckInfo(pb_classes.Message):
        __PB2_CLASS__ = node_service_pb2.NodeSetUnhealthyRequest.HealthCheckInfo
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.NodeSetUnhealthyRequest.HealthCheckInfo",node_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
            "observed_at": well_known_1.ts_mask,
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            observed_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
            check_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
            description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(observed_at, unset.UnsetType):
                self.observed_at = observed_at
            if not isinstance(check_id, unset.UnsetType):
                self.check_id = check_id
            if not isinstance(description, unset.UnsetType):
                self.description = description
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "observed_at",
                "check_id",
                "description",
            ]
        
        @builtins.property
        def observed_at(self) -> "datetime.datetime":
            """
            Time when the unhealthy node was observed
            """
            
            return super()._get_field("observed_at", explicit_presence=False,
            wrap=well_known_1.from_timestamp
            )
        @observed_at.setter
        def observed_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
            return super()._set_field("observed_at",value,explicit_presence=False,
            unwrap=well_known_1.to_timestamp
            )
        
        @builtins.property
        def check_id(self) -> "builtins.str":
            """
            Identifies specific GPU check that failed in soperator (key for observability)
            """
            
            return super()._get_field("check_id", explicit_presence=False,
            )
        @check_id.setter
        def check_id(self, value: "builtins.str|None") -> None:
            return super()._set_field("check_id",value,explicit_presence=False,
            )
        
        @builtins.property
        def description(self) -> "builtins.str":
            """
            Human-readable description of the error for further investigation
            """
            
            return super()._get_field("description", explicit_presence=False,
            )
        @description.setter
        def description(self, value: "builtins.str|None") -> None:
            return super()._set_field("description",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "observed_at":"observed_at",
            "check_id":"check_id",
            "description":"description",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        instance_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        health_check_info: "NodeSetUnhealthyRequest.HealthCheckInfo|node_service_pb2.NodeSetUnhealthyRequest.HealthCheckInfo|None|unset.UnsetType" = unset.Unset,
        dry_run: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(instance_id, unset.UnsetType):
            self.instance_id = instance_id
        if not isinstance(health_check_info, unset.UnsetType):
            self.health_check_info = health_check_info
        if not isinstance(dry_run, unset.UnsetType):
            self.dry_run = dry_run
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "instance_id",
            "health_check_info",
            "dry_run",
            "HealthCheckInfo",
        ]
    
    @builtins.property
    def instance_id(self) -> "builtins.str":
        return super()._get_field("instance_id", explicit_presence=False,
        )
    @instance_id.setter
    def instance_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("instance_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def health_check_info(self) -> "NodeSetUnhealthyRequest.HealthCheckInfo":
        return super()._get_field("health_check_info", explicit_presence=False,
        wrap=NodeSetUnhealthyRequest.HealthCheckInfo,
        )
    @health_check_info.setter
    def health_check_info(self, value: "NodeSetUnhealthyRequest.HealthCheckInfo|node_service_pb2.NodeSetUnhealthyRequest.HealthCheckInfo|None") -> None:
        return super()._set_field("health_check_info",value,explicit_presence=False,
        )
    
    @builtins.property
    def dry_run(self) -> "builtins.bool":
        """
        If set to true, the call performs the authorization and limit checks, but does not mark node unhealthy.
        False by default
        """
        
        return super()._get_field("dry_run", explicit_presence=False,
        )
    @dry_run.setter
    def dry_run(self, value: "builtins.bool|None") -> None:
        return super()._set_field("dry_run",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "instance_id":"instance_id",
        "health_check_info":"health_check_info",
        "dry_run":"dry_run",
        "HealthCheckInfo":"HealthCheckInfo",
    }
    
class NodeSetUnhealthyResponse(pb_classes.Message):
    __PB2_CLASS__ = node_service_pb2.NodeSetUnhealthyResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.NodeSetUnhealthyResponse",node_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    

class NodeServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.compute.v1.NodeService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1.NodeService",node_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1.NodeService"
    
    def set_unhealthy(self,
        request: "NodeSetUnhealthyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["NodeSetUnhealthyRequest","NodeSetUnhealthyResponse"]:
        """
        SetUnhealthy marks the node underlying the Compute VM as unhealthy, which has the following effect:
        
        
        #. Scheduler makes the best effort not to assign new VMs to the unhealthy node,
           but in case of no capacity, the VM can be assigned to an unhealthy node.
        #. The existing VMs continue to work on the node, but after stop/start via
           Compute API they most probably will be assigned to a different node.
        
        To use this rpc one needs to obtain ``compute.node.setUnhealthy`` permission
        for the VM's parent container. The permission is granted to the TSA inside the VM.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.NodeSetUnhealthyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.NodeSetUnhealthyResponse`.
        """
        
        return super().request(
            method="SetUnhealthy",
            request=request,
            result_pb2_class=node_service_pb2.NodeSetUnhealthyResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(NodeSetUnhealthyResponse),
        )
    

# file: nebius/compute/v1/platform.proto
class Platform(pb_classes.Message):
    __PB2_CLASS__ = platform_pb2.Platform
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.Platform",platform_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "PlatformSpec|platform_pb2.PlatformSpec|None|unset.UnsetType" = unset.Unset,
        status: "PlatformStatus|platform_pb2.PlatformStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "PlatformSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=PlatformSpec,
        )
    @spec.setter
    def spec(self, value: "PlatformSpec|platform_pb2.PlatformSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "PlatformStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=PlatformStatus,
        )
    @status.setter
    def status(self, value: "PlatformStatus|platform_pb2.PlatformStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class PlatformSpec(pb_classes.Message):
    __PB2_CLASS__ = platform_pb2.PlatformSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.PlatformSpec",platform_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        presets: "abc.Iterable[Preset]|None|unset.UnsetType" = unset.Unset,
        gpu_count_quota_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        human_readable_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        allow_preset_change: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        short_human_readable_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(presets, unset.UnsetType):
            self.presets = presets
        if not isinstance(gpu_count_quota_type, unset.UnsetType):
            self.gpu_count_quota_type = gpu_count_quota_type
        if not isinstance(human_readable_name, unset.UnsetType):
            self.human_readable_name = human_readable_name
        if not isinstance(allow_preset_change, unset.UnsetType):
            self.allow_preset_change = allow_preset_change
        if not isinstance(short_human_readable_name, unset.UnsetType):
            self.short_human_readable_name = short_human_readable_name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "presets",
            "gpu_count_quota_type",
            "human_readable_name",
            "allow_preset_change",
            "short_human_readable_name",
        ]
    
    @builtins.property
    def presets(self) -> "abc.MutableSequence[Preset]":
        return super()._get_field("presets", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Preset,None,None),
        )
    @presets.setter
    def presets(self, value: "abc.Iterable[Preset]|None") -> None:
        return super()._set_field("presets",value,explicit_presence=False,
        )
    
    @builtins.property
    def gpu_count_quota_type(self) -> "builtins.str":
        return super()._get_field("gpu_count_quota_type", explicit_presence=False,
        )
    @gpu_count_quota_type.setter
    def gpu_count_quota_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("gpu_count_quota_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def human_readable_name(self) -> "builtins.str":
        return super()._get_field("human_readable_name", explicit_presence=False,
        )
    @human_readable_name.setter
    def human_readable_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("human_readable_name",value,explicit_presence=False,
        )
    
    @builtins.property
    def allow_preset_change(self) -> "builtins.bool":
        return super()._get_field("allow_preset_change", explicit_presence=False,
        )
    @allow_preset_change.setter
    def allow_preset_change(self, value: "builtins.bool|None") -> None:
        return super()._set_field("allow_preset_change",value,explicit_presence=False,
        )
    
    @builtins.property
    def short_human_readable_name(self) -> "builtins.str":
        return super()._get_field("short_human_readable_name", explicit_presence=False,
        )
    @short_human_readable_name.setter
    def short_human_readable_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("short_human_readable_name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "presets":"presets",
        "gpu_count_quota_type":"gpu_count_quota_type",
        "human_readable_name":"human_readable_name",
        "allow_preset_change":"allow_preset_change",
        "short_human_readable_name":"short_human_readable_name",
    }
    
class Preset(pb_classes.Message):
    __PB2_CLASS__ = platform_pb2.Preset
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.Preset",platform_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resources: "PresetResources|platform_pb2.PresetResources|None|unset.UnsetType" = unset.Unset,
        allow_gpu_clustering: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(resources, unset.UnsetType):
            self.resources = resources
        if not isinstance(allow_gpu_clustering, unset.UnsetType):
            self.allow_gpu_clustering = allow_gpu_clustering
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
            "resources",
            "allow_gpu_clustering",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    @builtins.property
    def resources(self) -> "PresetResources":
        return super()._get_field("resources", explicit_presence=False,
        wrap=PresetResources,
        )
    @resources.setter
    def resources(self, value: "PresetResources|platform_pb2.PresetResources|None") -> None:
        return super()._set_field("resources",value,explicit_presence=False,
        )
    
    @builtins.property
    def allow_gpu_clustering(self) -> "builtins.bool":
        return super()._get_field("allow_gpu_clustering", explicit_presence=False,
        )
    @allow_gpu_clustering.setter
    def allow_gpu_clustering(self, value: "builtins.bool|None") -> None:
        return super()._set_field("allow_gpu_clustering",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
        "resources":"resources",
        "allow_gpu_clustering":"allow_gpu_clustering",
    }
    
class PresetResources(pb_classes.Message):
    __PB2_CLASS__ = platform_pb2.PresetResources
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.PresetResources",platform_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        vcpu_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        memory_gibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
        gpu_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        gpu_memory_gibibytes: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(vcpu_count, unset.UnsetType):
            self.vcpu_count = vcpu_count
        if not isinstance(memory_gibibytes, unset.UnsetType):
            self.memory_gibibytes = memory_gibibytes
        if not isinstance(gpu_count, unset.UnsetType):
            self.gpu_count = gpu_count
        if not isinstance(gpu_memory_gibibytes, unset.UnsetType):
            self.gpu_memory_gibibytes = gpu_memory_gibibytes
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "vcpu_count",
            "memory_gibibytes",
            "gpu_count",
            "gpu_memory_gibibytes",
        ]
    
    @builtins.property
    def vcpu_count(self) -> "builtins.int":
        return super()._get_field("vcpu_count", explicit_presence=False,
        )
    @vcpu_count.setter
    def vcpu_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("vcpu_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def memory_gibibytes(self) -> "builtins.int":
        return super()._get_field("memory_gibibytes", explicit_presence=False,
        )
    @memory_gibibytes.setter
    def memory_gibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("memory_gibibytes",value,explicit_presence=False,
        )
    
    @builtins.property
    def gpu_count(self) -> "builtins.int":
        return super()._get_field("gpu_count", explicit_presence=False,
        )
    @gpu_count.setter
    def gpu_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("gpu_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def gpu_memory_gibibytes(self) -> "builtins.int":
        return super()._get_field("gpu_memory_gibibytes", explicit_presence=False,
        )
    @gpu_memory_gibibytes.setter
    def gpu_memory_gibibytes(self, value: "builtins.int|None") -> None:
        return super()._set_field("gpu_memory_gibibytes",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "vcpu_count":"vcpu_count",
        "memory_gibibytes":"memory_gibibytes",
        "gpu_count":"gpu_count",
        "gpu_memory_gibibytes":"gpu_memory_gibibytes",
    }
    
class PlatformStatus(pb_classes.Message):
    __PB2_CLASS__ = platform_pb2.PlatformStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.PlatformStatus",platform_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        allowed_for_preemptibles: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(allowed_for_preemptibles, unset.UnsetType):
            self.allowed_for_preemptibles = allowed_for_preemptibles
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "allowed_for_preemptibles",
        ]
    
    @builtins.property
    def allowed_for_preemptibles(self) -> "builtins.bool":
        return super()._get_field("allowed_for_preemptibles", explicit_presence=False,
        )
    @allowed_for_preemptibles.setter
    def allowed_for_preemptibles(self, value: "builtins.bool|None") -> None:
        return super()._set_field("allowed_for_preemptibles",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "allowed_for_preemptibles":"allowed_for_preemptibles",
    }
    
# file: nebius/compute/v1/platform_service.proto
class ListPlatformsRequest(pb_classes.Message):
    __PB2_CLASS__ = platform_service_pb2.ListPlatformsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListPlatformsRequest",platform_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "page_size",
            "page_token",
            "parent_id",
        ]
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "page_size":"page_size",
        "page_token":"page_token",
        "parent_id":"parent_id",
    }
    
class ListPlatformsResponse(pb_classes.Message):
    __PB2_CLASS__ = platform_service_pb2.ListPlatformsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.compute.v1.ListPlatformsResponse",platform_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Platform]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Platform]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Platform,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Platform]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class PlatformServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.compute.v1.PlatformService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.compute.v1.PlatformService",platform_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.compute.v1.PlatformService"
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Platform"]:
        """
        Retrieves detailed information about a specific compute platform by its parent and name.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.Platform`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=platform_pb2.Platform,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Platform),
        )
    
    def list(self,
        request: "ListPlatformsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListPlatformsRequest","ListPlatformsResponse"]:
        """
        Lists all compute platforms within a specified parent.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.compute.v1.ListPlatformsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.compute.v1.ListPlatformsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=platform_service_pb2.ListPlatformsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListPlatformsResponse),
        )
    

__all__ = [
    #@ local import names here @#
    "Disk",
    "DiskSpec",
    "SourceImageFamily",
    "DiskStatus",
    "DiskEncryption",
    "ListOperationsByParentRequest",
    "GetDiskRequest",
    "ListDisksRequest",
    "CreateDiskRequest",
    "UpdateDiskRequest",
    "DeleteDiskRequest",
    "ListDisksResponse",
    "DiskServiceClient",
    "Filesystem",
    "FilesystemSpec",
    "FilesystemStatus",
    "GetFilesystemRequest",
    "ListFilesystemsRequest",
    "CreateFilesystemRequest",
    "UpdateFilesystemRequest",
    "DeleteFilesystemRequest",
    "ListFilesystemsResponse",
    "FilesystemServiceClient",
    "GpuCluster",
    "GpuClusterSpec",
    "GpuClusterStatus",
    "GpuClusterStatusInfinibandTopologyPath",
    "GpuClusterStatusInfinibandTopologyPathInstance",
    "GetGpuClusterRequest",
    "ListGpuClustersRequest",
    "CreateGpuClusterRequest",
    "UpdateGpuClusterRequest",
    "DeleteGpuClusterRequest",
    "ListGpuClustersResponse",
    "GpuClusterServiceClient",
    "Image",
    "ImageSpec",
    "ImageStatus",
    "GetImageRequest",
    "GetImageLatestByFamilyRequest",
    "ListImagesRequest",
    "ListImagesResponse",
    "ImageServiceClient",
    "NetworkInterfaceSpec",
    "IPAddress",
    "PublicIPAddress",
    "IPAlias",
    "NetworkInterfaceStatus",
    "IPAddressStatus",
    "PublicIPAddressStatus",
    "IPAliasesStatus",
    "InstanceRecoveryPolicy",
    "Instance",
    "InstanceSpec",
    "PreemptibleSpec",
    "ResourcesSpec",
    "InstanceGpuClusterSpec",
    "AttachedDiskSpec",
    "ExistingDisk",
    "ExistingFilesystem",
    "AttachedFilesystemSpec",
    "InstanceStatus",
    "InstanceStatusInfinibandTopologyPath",
    "GetInstanceRequest",
    "ListInstancesRequest",
    "CreateInstanceRequest",
    "UpdateInstanceRequest",
    "DeleteInstanceRequest",
    "ListInstancesResponse",
    "StartInstanceRequest",
    "StopInstanceRequest",
    "InstanceServiceClient",
    "MaintenanceEvent",
    "MaintenanceEventSpec",
    "MaintenanceEventStatus",
    "GetMaintenanceEventByInstanceRequest",
    "ListMaintenanceEventsRequest",
    "ListMaintenanceEventsResponse",
    "MaintenanceServiceClient",
    "NodeSetUnhealthyRequest",
    "NodeSetUnhealthyResponse",
    "NodeServiceClient",
    "Platform",
    "PlatformSpec",
    "Preset",
    "PresetResources",
    "PlatformStatus",
    "ListPlatformsRequest",
    "ListPlatformsResponse",
    "PlatformServiceClient",
]
