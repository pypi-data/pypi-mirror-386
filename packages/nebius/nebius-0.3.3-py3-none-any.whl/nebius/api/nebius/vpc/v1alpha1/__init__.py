# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.vpc.v1alpha1``"""

import builtins as builtins
import collections.abc as abc
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import grpc as grpc
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1alpha1 as v1alpha1_1
import nebius.api.nebius.common.v1alpha1.operation_pb2 as operation_pb2
import nebius.api.nebius.vpc.v1alpha1.allocation_pb2 as allocation_pb2
import nebius.api.nebius.vpc.v1alpha1.allocation_service_pb2 as allocation_service_pb2
import nebius.api.nebius.vpc.v1alpha1.network_interface_pb2 as network_interface_pb2
import nebius.api.nebius.vpc.v1alpha1.network_pb2 as network_pb2
import nebius.api.nebius.vpc.v1alpha1.network_service_pb2 as network_service_pb2
import nebius.api.nebius.vpc.v1alpha1.pool_pb2 as pool_pb2
import nebius.api.nebius.vpc.v1alpha1.pool_service_pb2 as pool_service_pb2
import nebius.api.nebius.vpc.v1alpha1.scope_pb2 as scope_pb2
import nebius.api.nebius.vpc.v1alpha1.scope_service_pb2 as scope_service_pb2
import nebius.api.nebius.vpc.v1alpha1.subnet_pb2 as subnet_pb2
import nebius.api.nebius.vpc.v1alpha1.subnet_service_pb2 as subnet_service_pb2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import typing as typing
#@ local imports here @#

# file: nebius/vpc/v1alpha1/pool.proto
class PoolCidrState(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.vpc.v1alpha1.PoolCidrState",pool_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    STATE_UNSPECIFIED = 0
    """
    Default, unspecified state.
    """
    
    AVAILABLE = 1
    """
    Allocation from range is available.
    """
    
    DISABLED = 2
    """
    New allocation would not be created.
    """
    

class IpVersion(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.vpc.v1alpha1.IpVersion",pool_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    IP_VERSION_UNSPECIFIED = 0
    """
    Default, unspecified IP version.
    """
    
    IPV4 = 1
    """
    IPv4 address.
    """
    
    IPV6 = 2
    """
    IPv6 address.
    """
    

class Pool(pb_classes.Message):
    __PB2_CLASS__ = pool_pb2.Pool
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.Pool",pool_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "PoolSpec|pool_pb2.PoolSpec|None|unset.UnsetType" = unset.Unset,
        status: "PoolStatus|pool_pb2.PoolStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata associated with the Pool.
        ``metadata.parent_id`` represents the Project.
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "PoolSpec":
        """
        Specification of the Pool.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=PoolSpec,
        )
    @spec.setter
    def spec(self, value: "PoolSpec|pool_pb2.PoolSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "PoolStatus":
        """
        Status information for the Pool.
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=PoolStatus,
        )
    @status.setter
    def status(self, value: "PoolStatus|pool_pb2.PoolStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class PoolSpec(pb_classes.Message):
    __PB2_CLASS__ = pool_pb2.PoolSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.PoolSpec",pool_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_source__(pb_classes.OneOf):
        name: builtins.str= "source"
        
        def __init__(self, msg: "PoolSpec") -> None:
            super().__init__()
            self._message: "PoolSpec" = msg
    
    class __OneOfClass_source_source_pool_id__(__OneOfClass_source__):
        field: typing.Literal["source_pool_id"] = "source_pool_id"
        
        def __init__(self, msg: "PoolSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.source_pool_id
    
    class __OneOfClass_source_source_scope_id__(__OneOfClass_source__):
        field: typing.Literal["source_scope_id"] = "source_scope_id"
        
        def __init__(self, msg: "PoolSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.source_scope_id
    
    @builtins.property
    def source(self) -> __OneOfClass_source_source_pool_id__|__OneOfClass_source_source_scope_id__|None:
        field_name_1: str|None = super().which_field_in_oneof("source")
        match field_name_1:
            case "source_pool_id":
                return self.__OneOfClass_source_source_pool_id__(self)
            case "source_scope_id":
                return self.__OneOfClass_source_source_scope_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        source_pool_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        source_scope_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        version: "IpVersion|pool_pb2.IpVersion|None|unset.UnsetType" = unset.Unset,
        cidrs: "abc.Iterable[PoolCidr]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(source_pool_id, unset.UnsetType):
            self.source_pool_id = source_pool_id
        if not isinstance(source_scope_id, unset.UnsetType):
            self.source_scope_id = source_scope_id
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(cidrs, unset.UnsetType):
            self.cidrs = cidrs
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "source_pool_id",
            "source_scope_id",
            "version",
            "cidrs",
            "source",
        ]
    
    @builtins.property
    def source_pool_id(self) -> "builtins.str|None":
        """
        ID of source pool. Current pool will be created with the same scope.
        """
        
        return super()._get_field("source_pool_id", explicit_presence=True,
        )
    @source_pool_id.setter
    def source_pool_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_pool_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def source_scope_id(self) -> "builtins.str|None":
        """
        ID of the scope. Pool will be considered as top-level pool within scope.
        """
        
        return super()._get_field("source_scope_id", explicit_presence=True,
        )
    @source_scope_id.setter
    def source_scope_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("source_scope_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def version(self) -> "IpVersion":
        """
        IP version for the Pool.
        """
        
        return super()._get_field("version", explicit_presence=False,
        wrap=IpVersion,
        )
    @version.setter
    def version(self, value: "IpVersion|pool_pb2.IpVersion|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def cidrs(self) -> "abc.MutableSequence[PoolCidr]":
        """
        CIDR blocks.
        """
        
        return super()._get_field("cidrs", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(PoolCidr,None,None),
        )
    @cidrs.setter
    def cidrs(self, value: "abc.Iterable[PoolCidr]|None") -> None:
        return super()._set_field("cidrs",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "source_pool_id":"source_pool_id",
        "source_scope_id":"source_scope_id",
        "version":"version",
        "cidrs":"cidrs",
        "source":"source",
    }
    
class PoolCidr(pb_classes.Message):
    __PB2_CLASS__ = pool_pb2.PoolCidr
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.PoolCidr",pool_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cidr: "builtins.str|None|unset.UnsetType" = unset.Unset,
        state: "PoolCidrState|pool_pb2.PoolCidrState|None|unset.UnsetType" = unset.Unset,
        allowed_mask: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cidr, unset.UnsetType):
            self.cidr = cidr
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(allowed_mask, unset.UnsetType):
            self.allowed_mask = allowed_mask
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cidr",
            "state",
            "allowed_mask",
        ]
    
    @builtins.property
    def cidr(self) -> "builtins.str":
        """
        CIDR block.
        May be a prefix length (such as /24) for non-top-level pools
        or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        
        return super()._get_field("cidr", explicit_presence=False,
        )
    @cidr.setter
    def cidr(self, value: "builtins.str|None") -> None:
        return super()._set_field("cidr",value,explicit_presence=False,
        )
    
    @builtins.property
    def state(self) -> "PoolCidrState":
        """
        State of the Cidr.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=PoolCidrState,
        )
    @state.setter
    def state(self, value: "PoolCidrState|pool_pb2.PoolCidrState|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def allowed_mask(self) -> "builtins.int":
        """
        Maximum mask length for allocation from this IP pool including creation of sub-pools
        """
        
        return super()._get_field("allowed_mask", explicit_presence=False,
        )
    @allowed_mask.setter
    def allowed_mask(self, value: "builtins.int|None") -> None:
        return super()._set_field("allowed_mask",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cidr":"cidr",
        "state":"state",
        "allowed_mask":"allowed_mask",
    }
    
class PoolStatus(pb_classes.Message):
    __PB2_CLASS__ = pool_pb2.PoolStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.PoolStatus",pool_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        """
        Possible states of the Pool.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.vpc.v1alpha1.PoolStatus.State",pool_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        """
        Default, unspecified state.
        """
        
        CREATING = 1
        """
        Pool is being created.
        """
        
        READY = 2
        """
        Pool is ready for use.
        """
        
        DELETING = 3
        """
        Pool is being deleted.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "PoolStatus.State|pool_pb2.PoolStatus.State|None|unset.UnsetType" = unset.Unset,
        cidrs: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        scope_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(cidrs, unset.UnsetType):
            self.cidrs = cidrs
        if not isinstance(scope_id, unset.UnsetType):
            self.scope_id = scope_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "cidrs",
            "scope_id",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "PoolStatus.State":
        """
        Current state of the Pool.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=PoolStatus.State,
        )
    @state.setter
    def state(self, value: "PoolStatus.State|pool_pb2.PoolStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def cidrs(self) -> "abc.MutableSequence[builtins.str]":
        """
        CIDR blocks.
        """
        
        return super()._get_field("cidrs", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @cidrs.setter
    def cidrs(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("cidrs",value,explicit_presence=False,
        )
    
    @builtins.property
    def scope_id(self) -> "builtins.str":
        """
        ID of the scope
        """
        
        return super()._get_field("scope_id", explicit_presence=False,
        )
    @scope_id.setter
    def scope_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("scope_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "cidrs":"cidrs",
        "scope_id":"scope_id",
        "State":"State",
    }
    
# file: nebius/vpc/v1alpha1/allocation.proto
class Allocation(pb_classes.Message):
    __PB2_CLASS__ = allocation_pb2.Allocation
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.Allocation",allocation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AllocationSpec|allocation_pb2.AllocationSpec|None|unset.UnsetType" = unset.Unset,
        status: "AllocationStatus|allocation_pb2.AllocationStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata for the Allocation.
        ``metadata.parent_id`` represents IAM Container.
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AllocationSpec":
        """
        Specifications for the allocation, detailing its name and IP configuration.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=AllocationSpec,
        )
    @spec.setter
    def spec(self, value: "AllocationSpec|allocation_pb2.AllocationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "AllocationStatus":
        """
        Contains the current status of the allocation, indicating its state and any additional details.
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=AllocationStatus,
        )
    @status.setter
    def status(self, value: "AllocationStatus|allocation_pb2.AllocationStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class AllocationSpec(pb_classes.Message):
    __PB2_CLASS__ = allocation_pb2.AllocationSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.AllocationSpec",allocation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_ip_spec__(pb_classes.OneOf):
        name: builtins.str= "ip_spec"
        
        def __init__(self, msg: "AllocationSpec") -> None:
            super().__init__()
            self._message: "AllocationSpec" = msg
    
    class __OneOfClass_ip_spec_ipv4_private__(__OneOfClass_ip_spec__):
        field: typing.Literal["ipv4_private"] = "ipv4_private"
        
        def __init__(self, msg: "AllocationSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "IPv4PrivateAllocationSpec":
            return self._message.ipv4_private
    
    class __OneOfClass_ip_spec_ipv4_public__(__OneOfClass_ip_spec__):
        field: typing.Literal["ipv4_public"] = "ipv4_public"
        
        def __init__(self, msg: "AllocationSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "IPv4PublicAllocationSpec":
            return self._message.ipv4_public
    
    @builtins.property
    def ip_spec(self) -> __OneOfClass_ip_spec_ipv4_private__|__OneOfClass_ip_spec_ipv4_public__|None:
        """
        Holds the IP specifications for the allocation, including the type of IP (IPv4 or IPv6) and its corresponding configuration.
        """
        
        field_name_1: str|None = super().which_field_in_oneof("ip_spec")
        match field_name_1:
            case "ipv4_private":
                return self.__OneOfClass_ip_spec_ipv4_private__(self)
            case "ipv4_public":
                return self.__OneOfClass_ip_spec_ipv4_public__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        ipv4_private: "IPv4PrivateAllocationSpec|allocation_pb2.IPv4PrivateAllocationSpec|None|unset.UnsetType" = unset.Unset,
        ipv4_public: "IPv4PublicAllocationSpec|allocation_pb2.IPv4PublicAllocationSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(ipv4_private, unset.UnsetType):
            self.ipv4_private = ipv4_private
        if not isinstance(ipv4_public, unset.UnsetType):
            self.ipv4_public = ipv4_public
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "ipv4_private",
            "ipv4_public",
            "ip_spec",
        ]
    
    @builtins.property
    def ipv4_private(self) -> "IPv4PrivateAllocationSpec|None":
        return super()._get_field("ipv4_private", explicit_presence=True,
        wrap=IPv4PrivateAllocationSpec,
        )
    @ipv4_private.setter
    def ipv4_private(self, value: "IPv4PrivateAllocationSpec|allocation_pb2.IPv4PrivateAllocationSpec|None") -> None:
        return super()._set_field("ipv4_private",value,explicit_presence=True,
        )
    
    @builtins.property
    def ipv4_public(self) -> "IPv4PublicAllocationSpec|None":
        return super()._get_field("ipv4_public", explicit_presence=True,
        wrap=IPv4PublicAllocationSpec,
        )
    @ipv4_public.setter
    def ipv4_public(self, value: "IPv4PublicAllocationSpec|allocation_pb2.IPv4PublicAllocationSpec|None") -> None:
        return super()._set_field("ipv4_public",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "ipv4_private":"ipv4_private",
        "ipv4_public":"ipv4_public",
        "ip_spec":"ip_spec",
    }
    
class IPv4PrivateAllocationSpec(pb_classes.Message):
    __PB2_CLASS__ = allocation_pb2.IPv4PrivateAllocationSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.IPv4PrivateAllocationSpec",allocation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_pool__(pb_classes.OneOf):
        name: builtins.str= "pool"
        
        def __init__(self, msg: "IPv4PrivateAllocationSpec") -> None:
            super().__init__()
            self._message: "IPv4PrivateAllocationSpec" = msg
    
    class __OneOfClass_pool_subnet_id__(__OneOfClass_pool__):
        field: typing.Literal["subnet_id"] = "subnet_id"
        
        def __init__(self, msg: "IPv4PrivateAllocationSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.subnet_id
    
    class __OneOfClass_pool_pool_id__(__OneOfClass_pool__):
        field: typing.Literal["pool_id"] = "pool_id"
        
        def __init__(self, msg: "IPv4PrivateAllocationSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.pool_id
    
    @builtins.property
    def pool(self) -> __OneOfClass_pool_subnet_id__|__OneOfClass_pool_pool_id__|None:
        field_name_1: str|None = super().which_field_in_oneof("pool")
        match field_name_1:
            case "subnet_id":
                return self.__OneOfClass_pool_subnet_id__(self)
            case "pool_id":
                return self.__OneOfClass_pool_pool_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cidr: "builtins.str|None|unset.UnsetType" = unset.Unset,
        subnet_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        pool_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cidr, unset.UnsetType):
            self.cidr = cidr
        if not isinstance(subnet_id, unset.UnsetType):
            self.subnet_id = subnet_id
        if not isinstance(pool_id, unset.UnsetType):
            self.pool_id = pool_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cidr",
            "subnet_id",
            "pool_id",
            "pool",
        ]
    
    @builtins.property
    def cidr(self) -> "builtins.str":
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        
        return super()._get_field("cidr", explicit_presence=False,
        )
    @cidr.setter
    def cidr(self, value: "builtins.str|None") -> None:
        return super()._set_field("cidr",value,explicit_presence=False,
        )
    
    @builtins.property
    def subnet_id(self) -> "builtins.str|None":
        """
        Subnet ID.
        Required same subnet to use allocation in subnet-resources (e.g. Network Interface)
        """
        
        return super()._get_field("subnet_id", explicit_presence=True,
        )
    @subnet_id.setter
    def subnet_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subnet_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def pool_id(self) -> "builtins.str|None":
        """
        Pool for the IPv4 private allocation.
        """
        
        return super()._get_field("pool_id", explicit_presence=True,
        )
    @pool_id.setter
    def pool_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("pool_id",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cidr":"cidr",
        "subnet_id":"subnet_id",
        "pool_id":"pool_id",
        "pool":"pool",
    }
    
class IPv4PublicAllocationSpec(pb_classes.Message):
    __PB2_CLASS__ = allocation_pb2.IPv4PublicAllocationSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.IPv4PublicAllocationSpec",allocation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cidr: "builtins.str|None|unset.UnsetType" = unset.Unset,
        pool_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cidr, unset.UnsetType):
            self.cidr = cidr
        if not isinstance(pool_id, unset.UnsetType):
            self.pool_id = pool_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cidr",
            "pool_id",
        ]
    
    @builtins.property
    def cidr(self) -> "builtins.str":
        """
        CIDR block for IPv4 Allocation.
        May be a single IP address (such as 10.2.3.4),
        a prefix length (such as /32) or a CIDR-formatted string (such as 10.1.2.0/32).
        Random address (/32) from pool would be allocated if field is omitted.
        """
        
        return super()._get_field("cidr", explicit_presence=False,
        )
    @cidr.setter
    def cidr(self, value: "builtins.str|None") -> None:
        return super()._set_field("cidr",value,explicit_presence=False,
        )
    
    @builtins.property
    def pool_id(self) -> "builtins.str":
        """
        Pool for the IPv4 public allocation.
        """
        
        return super()._get_field("pool_id", explicit_presence=False,
        )
    @pool_id.setter
    def pool_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("pool_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cidr":"cidr",
        "pool_id":"pool_id",
    }
    
class AllocationStatus(pb_classes.Message):
    __PB2_CLASS__ = allocation_pb2.AllocationStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.AllocationStatus",allocation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        """
        Enumeration of possible states of the Allocation.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.vpc.v1alpha1.AllocationStatus.State",allocation_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        """
        Default state, unspecified.
        """
        
        CREATING = 1
        """
        Allocation is being created.
        """
        
        ALLOCATED = 2
        """
        Allocation is ready for use.
        """
        
        ASSIGNED = 3
        """
        Allocation is used.
        """
        
        DELETING = 4
        """
        Allocation is being deleted.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "AllocationStatus.State|allocation_pb2.AllocationStatus.State|None|unset.UnsetType" = unset.Unset,
        details: "AllocationDetails|allocation_pb2.AllocationDetails|None|unset.UnsetType" = unset.Unset,
        assignment: "Assignment|allocation_pb2.Assignment|None|unset.UnsetType" = unset.Unset,
        static: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(details, unset.UnsetType):
            self.details = details
        if not isinstance(assignment, unset.UnsetType):
            self.assignment = assignment
        if not isinstance(static, unset.UnsetType):
            self.static = static
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "details",
            "assignment",
            "static",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "AllocationStatus.State":
        """
        This field represents the current state of the allocation.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=AllocationStatus.State,
        )
    @state.setter
    def state(self, value: "AllocationStatus.State|allocation_pb2.AllocationStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def details(self) -> "AllocationDetails":
        """
        Detailed information about the allocation status,
        including the allocated CIDR, pool ID, scope type, and IP version.
        """
        
        return super()._get_field("details", explicit_presence=False,
        wrap=AllocationDetails,
        )
    @details.setter
    def details(self, value: "AllocationDetails|allocation_pb2.AllocationDetails|None") -> None:
        return super()._set_field("details",value,explicit_presence=False,
        )
    
    @builtins.property
    def assignment(self) -> "Assignment":
        """
        Information about the assignment associated with the allocation,
        such as network interface or load balancer assignment.
        """
        
        return super()._get_field("assignment", explicit_presence=False,
        wrap=Assignment,
        )
    @assignment.setter
    def assignment(self, value: "Assignment|allocation_pb2.Assignment|None") -> None:
        return super()._set_field("assignment",value,explicit_presence=False,
        )
    
    @builtins.property
    def static(self) -> "builtins.bool":
        """
        If false - Lifecycle of allocation depends on resource that using it.
        """
        
        return super()._get_field("static", explicit_presence=False,
        )
    @static.setter
    def static(self, value: "builtins.bool|None") -> None:
        return super()._set_field("static",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "details":"details",
        "assignment":"assignment",
        "static":"static",
        "State":"State",
    }
    
class AllocationDetails(pb_classes.Message):
    __PB2_CLASS__ = allocation_pb2.AllocationDetails
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.AllocationDetails",allocation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        allocated_cidr: "builtins.str|None|unset.UnsetType" = unset.Unset,
        pool_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        version: "IpVersion|pool_pb2.IpVersion|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(allocated_cidr, unset.UnsetType):
            self.allocated_cidr = allocated_cidr
        if not isinstance(pool_id, unset.UnsetType):
            self.pool_id = pool_id
        if not isinstance(version, unset.UnsetType):
            self.version = version
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "allocated_cidr",
            "pool_id",
            "version",
        ]
    
    @builtins.property
    def allocated_cidr(self) -> "builtins.str":
        return super()._get_field("allocated_cidr", explicit_presence=False,
        )
    @allocated_cidr.setter
    def allocated_cidr(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocated_cidr",value,explicit_presence=False,
        )
    
    @builtins.property
    def pool_id(self) -> "builtins.str":
        return super()._get_field("pool_id", explicit_presence=False,
        )
    @pool_id.setter
    def pool_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("pool_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def version(self) -> "IpVersion":
        return super()._get_field("version", explicit_presence=False,
        wrap=IpVersion,
        )
    @version.setter
    def version(self, value: "IpVersion|pool_pb2.IpVersion|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "allocated_cidr":"allocated_cidr",
        "pool_id":"pool_id",
        "version":"version",
    }
    
class Assignment(pb_classes.Message):
    __PB2_CLASS__ = allocation_pb2.Assignment
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.Assignment",allocation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_type__(pb_classes.OneOf):
        name: builtins.str= "type"
        
        def __init__(self, msg: "Assignment") -> None:
            super().__init__()
            self._message: "Assignment" = msg
    
    class __OneOfClass_type_network_interface__(__OneOfClass_type__):
        field: typing.Literal["network_interface"] = "network_interface"
        
        def __init__(self, msg: "Assignment") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "NetworkInterfaceAssignment":
            return self._message.network_interface
    
    class __OneOfClass_type_load_balancer__(__OneOfClass_type__):
        field: typing.Literal["load_balancer"] = "load_balancer"
        
        def __init__(self, msg: "Assignment") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "LoadBalancerAssignment":
            return self._message.load_balancer
    
    @builtins.property
    def type(self) -> __OneOfClass_type_network_interface__|__OneOfClass_type_load_balancer__|None:
        """
        This field specifies the type of assignment associated with the allocation,
        which could be a network interface or load balancer assignment.
        """
        
        field_name_1: str|None = super().which_field_in_oneof("type")
        match field_name_1:
            case "network_interface":
                return self.__OneOfClass_type_network_interface__(self)
            case "load_balancer":
                return self.__OneOfClass_type_load_balancer__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        network_interface: "NetworkInterfaceAssignment|allocation_pb2.NetworkInterfaceAssignment|None|unset.UnsetType" = unset.Unset,
        load_balancer: "LoadBalancerAssignment|allocation_pb2.LoadBalancerAssignment|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(network_interface, unset.UnsetType):
            self.network_interface = network_interface
        if not isinstance(load_balancer, unset.UnsetType):
            self.load_balancer = load_balancer
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "network_interface",
            "load_balancer",
            "type",
        ]
    
    @builtins.property
    def network_interface(self) -> "NetworkInterfaceAssignment|None":
        return super()._get_field("network_interface", explicit_presence=True,
        wrap=NetworkInterfaceAssignment,
        )
    @network_interface.setter
    def network_interface(self, value: "NetworkInterfaceAssignment|allocation_pb2.NetworkInterfaceAssignment|None") -> None:
        return super()._set_field("network_interface",value,explicit_presence=True,
        )
    
    @builtins.property
    def load_balancer(self) -> "LoadBalancerAssignment|None":
        return super()._get_field("load_balancer", explicit_presence=True,
        wrap=LoadBalancerAssignment,
        )
    @load_balancer.setter
    def load_balancer(self, value: "LoadBalancerAssignment|allocation_pb2.LoadBalancerAssignment|None") -> None:
        return super()._set_field("load_balancer",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "network_interface":"network_interface",
        "load_balancer":"load_balancer",
        "type":"type",
    }
    
class NetworkInterfaceAssignment(pb_classes.Message):
    __PB2_CLASS__ = allocation_pb2.NetworkInterfaceAssignment
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.NetworkInterfaceAssignment",allocation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        instance_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(instance_id, unset.UnsetType):
            self.instance_id = instance_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "instance_id",
            "name",
        ]
    
    @builtins.property
    def instance_id(self) -> "builtins.str":
        """
        ID of the Compute instance network interface belongs to.
        """
        
        return super()._get_field("instance_id", explicit_presence=False,
        )
    @instance_id.setter
    def instance_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("instance_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Network interface name
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "instance_id":"instance_id",
        "name":"name",
    }
    
class LoadBalancerAssignment(pb_classes.Message):
    __PB2_CLASS__ = allocation_pb2.LoadBalancerAssignment
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.LoadBalancerAssignment",allocation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of the Load Balancer.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
# file: nebius/vpc/v1alpha1/allocation_service.proto
class GetAllocationRequest(pb_classes.Message):
    __PB2_CLASS__ = allocation_service_pb2.GetAllocationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetAllocationRequest",allocation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAllocationByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = allocation_service_pb2.GetAllocationByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetAllocationByNameRequest",allocation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListAllocationsRequest(pb_classes.Message):
    __PB2_CLASS__ = allocation_service_pb2.ListAllocationsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListAllocationsRequest",allocation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListAllocationsResponse(pb_classes.Message):
    __PB2_CLASS__ = allocation_service_pb2.ListAllocationsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListAllocationsResponse",allocation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Allocation]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Allocation]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Allocation,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Allocation]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class CreateAllocationRequest(pb_classes.Message):
    __PB2_CLASS__ = allocation_service_pb2.CreateAllocationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.CreateAllocationRequest",allocation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AllocationSpec|allocation_pb2.AllocationSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AllocationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AllocationSpec,
        )
    @spec.setter
    def spec(self, value: "AllocationSpec|allocation_pb2.AllocationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateAllocationRequest(pb_classes.Message):
    __PB2_CLASS__ = allocation_service_pb2.UpdateAllocationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.UpdateAllocationRequest",allocation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AllocationSpec|allocation_pb2.AllocationSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AllocationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AllocationSpec,
        )
    @spec.setter
    def spec(self, value: "AllocationSpec|allocation_pb2.AllocationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteAllocationRequest(pb_classes.Message):
    __PB2_CLASS__ = allocation_service_pb2.DeleteAllocationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.DeleteAllocationRequest",allocation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class AllocationServiceClient(client.ClientWithOperations[v1alpha1_1.Operation,v1alpha1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.vpc.v1alpha1.AllocationService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.vpc.v1alpha1.AllocationService",allocation_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.vpc.v1alpha1.AllocationService"
    __operation_type__ = v1alpha1_1.Operation
    __operation_service_class__ = v1alpha1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetAllocationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetAllocationRequest","Allocation"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetAllocationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Allocation`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=allocation_pb2.Allocation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Allocation),
        )
    
    def get_by_name(self,
        request: "GetAllocationByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetAllocationByNameRequest","Allocation"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetAllocationByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Allocation`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=allocation_pb2.Allocation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Allocation),
        )
    
    def list(self,
        request: "ListAllocationsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListAllocationsRequest","ListAllocationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.ListAllocationsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.ListAllocationsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=allocation_service_pb2.ListAllocationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListAllocationsResponse),
        )
    
    def create(self,
        request: "CreateAllocationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateAllocationRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.CreateAllocationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def update(self,
        request: "UpdateAllocationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateAllocationRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.UpdateAllocationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def delete(self,
        request: "DeleteAllocationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteAllocationRequest","operation.Operation[v1alpha1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.DeleteAllocationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    

# file: nebius/vpc/v1alpha1/network.proto
class Network(pb_classes.Message):
    """
    Defines a Network, which serves as a virtual representation of a traditional LAN
    within a cloud environment.
    Networks facilitate communication between subnets.
    """
    
    __PB2_CLASS__ = network_pb2.Network
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.Network",network_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "NetworkSpec|network_pb2.NetworkSpec|None|unset.UnsetType" = unset.Unset,
        status: "NetworkStatus|network_pb2.NetworkStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata for the network resource.
        ``metadata.parent_id`` represents IAM container
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "NetworkSpec":
        """
        Specification of the network.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=NetworkSpec,
        )
    @spec.setter
    def spec(self, value: "NetworkSpec|network_pb2.NetworkSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "NetworkStatus":
        """
        Status of the network.
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=NetworkStatus,
        )
    @status.setter
    def status(self, value: "NetworkStatus|network_pb2.NetworkStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class NetworkSpec(pb_classes.Message):
    __PB2_CLASS__ = network_pb2.NetworkSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.NetworkSpec",network_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        pools: "abc.Iterable[NetworkPool]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(pools, unset.UnsetType):
            self.pools = pools
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "pools",
        ]
    
    @builtins.property
    def pools(self) -> "abc.MutableSequence[NetworkPool]":
        """
        Pools for addresses
        """
        
        return super()._get_field("pools", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NetworkPool,None,None),
        )
    @pools.setter
    def pools(self, value: "abc.Iterable[NetworkPool]|None") -> None:
        return super()._set_field("pools",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "pools":"pools",
    }
    
class NetworkPool(pb_classes.Message):
    __PB2_CLASS__ = network_pb2.NetworkPool
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.NetworkPool",network_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        pool_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(pool_id, unset.UnsetType):
            self.pool_id = pool_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "pool_id",
        ]
    
    @builtins.property
    def pool_id(self) -> "builtins.str":
        return super()._get_field("pool_id", explicit_presence=False,
        )
    @pool_id.setter
    def pool_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("pool_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "pool_id":"pool_id",
    }
    
class NetworkStatus(pb_classes.Message):
    __PB2_CLASS__ = network_pb2.NetworkStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.NetworkStatus",network_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        """
        Enumeration of possible states of the network.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.vpc.v1alpha1.NetworkStatus.State",network_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        """
        Default state, unspecified.
        """
        
        CREATING = 1
        """
        Network is being created.
        """
        
        READY = 2
        """
        Network is ready for use.
        """
        
        DELETING = 3
        """
        Network is being deleted.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "NetworkStatus.State|network_pb2.NetworkStatus.State|None|unset.UnsetType" = unset.Unset,
        scope_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(scope_id, unset.UnsetType):
            self.scope_id = scope_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "scope_id",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "NetworkStatus.State":
        """
        Current state of the network.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=NetworkStatus.State,
        )
    @state.setter
    def state(self, value: "NetworkStatus.State|network_pb2.NetworkStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def scope_id(self) -> "builtins.str":
        """
        Scope ID of all pools
        """
        
        return super()._get_field("scope_id", explicit_presence=False,
        )
    @scope_id.setter
    def scope_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("scope_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "scope_id":"scope_id",
        "State":"State",
    }
    
# file: nebius/vpc/v1alpha1/network_interface.proto
class NetworkInterfaceSpec(pb_classes.Message):
    """
    Describes the specification of a network interface.
    """
    
    __PB2_CLASS__ = network_interface_pb2.NetworkInterfaceSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.NetworkInterfaceSpec",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        subnet_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ip_address: "IPAddress|network_interface_pb2.IPAddress|None|unset.UnsetType" = unset.Unset,
        public_ip_address: "PublicIPAddress|network_interface_pb2.PublicIPAddress|None|unset.UnsetType" = unset.Unset,
        aliases: "abc.Iterable[IPAlias]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(subnet_id, unset.UnsetType):
            self.subnet_id = subnet_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(ip_address, unset.UnsetType):
            self.ip_address = ip_address
        if not isinstance(public_ip_address, unset.UnsetType):
            self.public_ip_address = public_ip_address
        if not isinstance(aliases, unset.UnsetType):
            self.aliases = aliases
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "subnet_id",
            "name",
            "ip_address",
            "public_ip_address",
            "aliases",
        ]
    
    @builtins.property
    def subnet_id(self) -> "builtins.str":
        """
        Subnet ID
        """
        
        return super()._get_field("subnet_id", explicit_presence=False,
        )
    @subnet_id.setter
    def subnet_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subnet_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Interface name
        Value of this field configures the name of the network interface inside VM's OS.
        Longer values will persist in the specification but will be truncated to 15 symbols before being passed to VM configuration.
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    @builtins.property
    def ip_address(self) -> "IPAddress|None":
        """
        Private IPv4 address associated with the interface.
        """
        
        return super()._get_field("ip_address", explicit_presence=True,
        wrap=IPAddress,
        )
    @ip_address.setter
    def ip_address(self, value: "IPAddress|network_interface_pb2.IPAddress|None") -> None:
        return super()._set_field("ip_address",value,explicit_presence=True,
        )
    
    @builtins.property
    def public_ip_address(self) -> "PublicIPAddress|None":
        """
        Public IPv4 address associated with the interface.
        """
        
        return super()._get_field("public_ip_address", explicit_presence=True,
        wrap=PublicIPAddress,
        )
    @public_ip_address.setter
    def public_ip_address(self, value: "PublicIPAddress|network_interface_pb2.PublicIPAddress|None") -> None:
        return super()._set_field("public_ip_address",value,explicit_presence=True,
        )
    
    @builtins.property
    def aliases(self) -> "abc.MutableSequence[IPAlias]":
        """
        Assign ranges of IP addresses as aliases
        """
        
        return super()._get_field("aliases", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(IPAlias,None,None),
        )
    @aliases.setter
    def aliases(self, value: "abc.Iterable[IPAlias]|None") -> None:
        return super()._set_field("aliases",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "subnet_id":"subnet_id",
        "name":"name",
        "ip_address":"ip_address",
        "public_ip_address":"public_ip_address",
        "aliases":"aliases",
    }
    
class IPAddress(pb_classes.Message):
    """
    Describes an IPv4 address.
    """
    
    __PB2_CLASS__ = network_interface_pb2.IPAddress
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.IPAddress",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "allocation_id",
        ]
    
    @builtins.property
    def allocation_id(self) -> "builtins.str":
        """
        Allocation identifier if it was created before.
        """
        
        return super()._get_field("allocation_id", explicit_presence=False,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "allocation_id":"allocation_id",
    }
    
class PublicIPAddress(pb_classes.Message):
    """
    Describes a public IP address.
    """
    
    __PB2_CLASS__ = network_interface_pb2.PublicIPAddress
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.PublicIPAddress",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_allocation__(pb_classes.OneOf):
        name: builtins.str= "allocation"
        
        def __init__(self, msg: "PublicIPAddress") -> None:
            super().__init__()
            self._message: "PublicIPAddress" = msg
    
    class __OneOfClass_allocation_allocation_id__(__OneOfClass_allocation__):
        field: typing.Literal["allocation_id"] = "allocation_id"
        
        def __init__(self, msg: "PublicIPAddress") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.allocation_id
    
    @builtins.property
    def allocation(self) -> __OneOfClass_allocation_allocation_id__|None:
        """
        Describes different methods of public IP address allocation.
        """
        
        field_name_1: str|None = super().which_field_in_oneof("allocation")
        match field_name_1:
            case "allocation_id":
                return self.__OneOfClass_allocation_allocation_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        static: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
        if not isinstance(static, unset.UnsetType):
            self.static = static
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "allocation_id",
            "static",
            "allocation",
        ]
    
    @builtins.property
    def allocation_id(self) -> "builtins.str|None":
        """
        Allocation identifier if it was created before.
        """
        
        return super()._get_field("allocation_id", explicit_presence=True,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def static(self) -> "builtins.bool":
        """
        If false - Lifecycle of allocation depends on NetworkInterface.Allocate/NetworkInterface.Deallocate
        If true  - Lifecycle of allocation depends on NetworkInterface.Create/NetworkInterface.Delete
        False by default
        """
        
        return super()._get_field("static", explicit_presence=False,
        )
    @static.setter
    def static(self, value: "builtins.bool|None") -> None:
        return super()._set_field("static",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "allocation_id":"allocation_id",
        "static":"static",
        "allocation":"allocation",
    }
    
class IPAlias(pb_classes.Message):
    __PB2_CLASS__ = network_interface_pb2.IPAlias
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.IPAlias",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "allocation_id",
        ]
    
    @builtins.property
    def allocation_id(self) -> "builtins.str":
        """
        ID of allocation
        """
        
        return super()._get_field("allocation_id", explicit_presence=False,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "allocation_id":"allocation_id",
    }
    
class NetworkInterfaceStatus(pb_classes.Message):
    """
    Describes the status of a network interface.
    """
    
    __PB2_CLASS__ = network_interface_pb2.NetworkInterfaceStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.NetworkInterfaceStatus",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        index: "builtins.int|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ip_address: "IPAddressStatus|network_interface_pb2.IPAddressStatus|None|unset.UnsetType" = unset.Unset,
        public_ip_address: "PublicIPAddressStatus|network_interface_pb2.PublicIPAddressStatus|None|unset.UnsetType" = unset.Unset,
        aliases: "IPAliasesStatus|network_interface_pb2.IPAliasesStatus|None|unset.UnsetType" = unset.Unset,
        mac_address: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(index, unset.UnsetType):
            self.index = index
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(ip_address, unset.UnsetType):
            self.ip_address = ip_address
        if not isinstance(public_ip_address, unset.UnsetType):
            self.public_ip_address = public_ip_address
        if not isinstance(aliases, unset.UnsetType):
            self.aliases = aliases
        if not isinstance(mac_address, unset.UnsetType):
            self.mac_address = mac_address
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "index",
            "name",
            "ip_address",
            "public_ip_address",
            "aliases",
            "mac_address",
        ]
    
    @builtins.property
    def index(self) -> "builtins.int":
        """
        The index of the network interface
        """
        
        return super()._get_field("index", explicit_presence=False,
        )
    @index.setter
    def index(self, value: "builtins.int|None") -> None:
        return super()._set_field("index",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Name for interface.
        Unique within instance's network interfaces
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    @builtins.property
    def ip_address(self) -> "IPAddressStatus":
        """
        Effective Private IPv4 address
        """
        
        return super()._get_field("ip_address", explicit_presence=False,
        wrap=IPAddressStatus,
        )
    @ip_address.setter
    def ip_address(self, value: "IPAddressStatus|network_interface_pb2.IPAddressStatus|None") -> None:
        return super()._set_field("ip_address",value,explicit_presence=False,
        )
    
    @builtins.property
    def public_ip_address(self) -> "PublicIPAddressStatus":
        """
        Effective Public IPv4 address
        """
        
        return super()._get_field("public_ip_address", explicit_presence=False,
        wrap=PublicIPAddressStatus,
        )
    @public_ip_address.setter
    def public_ip_address(self, value: "PublicIPAddressStatus|network_interface_pb2.PublicIPAddressStatus|None") -> None:
        return super()._set_field("public_ip_address",value,explicit_presence=False,
        )
    
    @builtins.property
    def aliases(self) -> "IPAliasesStatus":
        """
        Effective IP Aliases
        """
        
        return super()._get_field("aliases", explicit_presence=False,
        wrap=IPAliasesStatus,
        )
    @aliases.setter
    def aliases(self, value: "IPAliasesStatus|network_interface_pb2.IPAliasesStatus|None") -> None:
        return super()._set_field("aliases",value,explicit_presence=False,
        )
    
    @builtins.property
    def mac_address(self) -> "builtins.str":
        """
        MAC address
        """
        
        return super()._get_field("mac_address", explicit_presence=False,
        )
    @mac_address.setter
    def mac_address(self, value: "builtins.str|None") -> None:
        return super()._set_field("mac_address",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "index":"index",
        "name":"name",
        "ip_address":"ip_address",
        "public_ip_address":"public_ip_address",
        "aliases":"aliases",
        "mac_address":"mac_address",
    }
    
class IPAddressStatus(pb_classes.Message):
    __PB2_CLASS__ = network_interface_pb2.IPAddressStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.IPAddressStatus",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        address: "builtins.str|None|unset.UnsetType" = unset.Unset,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(address, unset.UnsetType):
            self.address = address
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "address",
            "allocation_id",
        ]
    
    @builtins.property
    def address(self) -> "builtins.str":
        """
        Effective private IPv4 address assigned to the interface.
        """
        
        return super()._get_field("address", explicit_presence=False,
        )
    @address.setter
    def address(self, value: "builtins.str|None") -> None:
        return super()._set_field("address",value,explicit_presence=False,
        )
    
    @builtins.property
    def allocation_id(self) -> "builtins.str":
        """
        Allocation identifier.
        """
        
        return super()._get_field("allocation_id", explicit_presence=False,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "address":"address",
        "allocation_id":"allocation_id",
    }
    
class PublicIPAddressStatus(pb_classes.Message):
    __PB2_CLASS__ = network_interface_pb2.PublicIPAddressStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.PublicIPAddressStatus",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        address: "builtins.str|None|unset.UnsetType" = unset.Unset,
        allocation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(address, unset.UnsetType):
            self.address = address
        if not isinstance(allocation_id, unset.UnsetType):
            self.allocation_id = allocation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "address",
            "allocation_id",
        ]
    
    @builtins.property
    def address(self) -> "builtins.str":
        """
        Effective public IPv4 address assigned to the interface.
        """
        
        return super()._get_field("address", explicit_presence=False,
        )
    @address.setter
    def address(self, value: "builtins.str|None") -> None:
        return super()._set_field("address",value,explicit_presence=False,
        )
    
    @builtins.property
    def allocation_id(self) -> "builtins.str":
        """
        Allocation identifier.
        """
        
        return super()._get_field("allocation_id", explicit_presence=False,
        )
    @allocation_id.setter
    def allocation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("allocation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "address":"address",
        "allocation_id":"allocation_id",
    }
    
class IPAliasesStatus(pb_classes.Message):
    __PB2_CLASS__ = network_interface_pb2.IPAliasesStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.IPAliasesStatus",network_interface_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cidrs: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cidrs, unset.UnsetType):
            self.cidrs = cidrs
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cidrs",
        ]
    
    @builtins.property
    def cidrs(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("cidrs", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @cidrs.setter
    def cidrs(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("cidrs",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cidrs":"cidrs",
    }
    
# file: nebius/vpc/v1alpha1/network_service.proto
class GetNetworkRequest(pb_classes.Message):
    __PB2_CLASS__ = network_service_pb2.GetNetworkRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetNetworkRequest",network_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetNetworkByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = network_service_pb2.GetNetworkByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetNetworkByNameRequest",network_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListNetworksRequest(pb_classes.Message):
    __PB2_CLASS__ = network_service_pb2.ListNetworksRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListNetworksRequest",network_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListNetworksResponse(pb_classes.Message):
    __PB2_CLASS__ = network_service_pb2.ListNetworksResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListNetworksResponse",network_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Network]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Network]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Network,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Network]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class NetworkServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.vpc.v1alpha1.NetworkService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.vpc.v1alpha1.NetworkService",network_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.vpc.v1alpha1.NetworkService"
    
    def get(self,
        request: "GetNetworkRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetNetworkRequest","Network"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetNetworkRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Network`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=network_pb2.Network,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Network),
        )
    
    def get_by_name(self,
        request: "GetNetworkByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetNetworkByNameRequest","Network"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetNetworkByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Network`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=network_pb2.Network,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Network),
        )
    
    def list(self,
        request: "ListNetworksRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListNetworksRequest","ListNetworksResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.ListNetworksRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.ListNetworksResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=network_service_pb2.ListNetworksResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListNetworksResponse),
        )
    

# file: nebius/vpc/v1alpha1/pool_service.proto
class GetPoolRequest(pb_classes.Message):
    __PB2_CLASS__ = pool_service_pb2.GetPoolRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetPoolRequest",pool_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetPoolByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = pool_service_pb2.GetPoolByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetPoolByNameRequest",pool_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListPoolsRequest(pb_classes.Message):
    __PB2_CLASS__ = pool_service_pb2.ListPoolsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListPoolsRequest",pool_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListPoolsResponse(pb_classes.Message):
    __PB2_CLASS__ = pool_service_pb2.ListPoolsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListPoolsResponse",pool_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Pool]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Pool]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Pool,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Pool]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class PoolServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.vpc.v1alpha1.PoolService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.vpc.v1alpha1.PoolService",pool_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.vpc.v1alpha1.PoolService"
    
    def get(self,
        request: "GetPoolRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetPoolRequest","Pool"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetPoolRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Pool`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=pool_pb2.Pool,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Pool),
        )
    
    def get_by_name(self,
        request: "GetPoolByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetPoolByNameRequest","Pool"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetPoolByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Pool`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=pool_pb2.Pool,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Pool),
        )
    
    def list(self,
        request: "ListPoolsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListPoolsRequest","ListPoolsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.ListPoolsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.ListPoolsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=pool_service_pb2.ListPoolsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListPoolsResponse),
        )
    

# file: nebius/vpc/v1alpha1/scope.proto
class Scope(pb_classes.Message):
    __PB2_CLASS__ = scope_pb2.Scope
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.Scope",scope_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ScopeSpec|scope_pb2.ScopeSpec|None|unset.UnsetType" = unset.Unset,
        status: "ScopeStatus|scope_pb2.ScopeStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata associated with the Scope.
        ``metadata.parent_id`` represents the parent IAM container.
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ScopeSpec":
        """
        Specification of the Scope.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=ScopeSpec,
        )
    @spec.setter
    def spec(self, value: "ScopeSpec|scope_pb2.ScopeSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ScopeStatus":
        """
        Status information for the Scope.
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=ScopeStatus,
        )
    @status.setter
    def status(self, value: "ScopeStatus|scope_pb2.ScopeStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ScopeSpec(pb_classes.Message):
    __PB2_CLASS__ = scope_pb2.ScopeSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ScopeSpec",scope_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class Type(pb_enum.Enum):
        """
        Type of scope.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.vpc.v1alpha1.ScopeSpec.Type",scope_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        SCOPE_TYPE_UNSPECIFIED = 0
        """
        Default, unspecified scope type.
        """
        
        PUBLIC = 1
        """
        Public scope.
        """
        
        PRIVATE = 2
        """
        Private scope.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        type: "ScopeSpec.Type|scope_pb2.ScopeSpec.Type|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(type, unset.UnsetType):
            self.type = type
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "type",
            "Type",
        ]
    
    @builtins.property
    def type(self) -> "ScopeSpec.Type":
        """
        Type of the Scope (Private or Public).
        """
        
        return super()._get_field("type", explicit_presence=False,
        wrap=ScopeSpec.Type,
        )
    @type.setter
    def type(self, value: "ScopeSpec.Type|scope_pb2.ScopeSpec.Type|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "type":"type",
        "Type":"Type",
    }
    
class ScopeStatus(pb_classes.Message):
    __PB2_CLASS__ = scope_pb2.ScopeStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ScopeStatus",scope_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        """
        Possible states of the Scope.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.vpc.v1alpha1.ScopeStatus.State",scope_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        """
        Default, unspecified state.
        """
        
        CREATING = 1
        """
        Scope is being created.
        """
        
        READY = 2
        """
        Scope is ready for use.
        """
        
        DELETING = 3
        """
        Scope is being deleted.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "ScopeStatus.State|scope_pb2.ScopeStatus.State|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "ScopeStatus.State":
        """
        Current state of the Scope.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=ScopeStatus.State,
        )
    @state.setter
    def state(self, value: "ScopeStatus.State|scope_pb2.ScopeStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "State":"State",
    }
    
# file: nebius/vpc/v1alpha1/scope_service.proto
class GetScopeRequest(pb_classes.Message):
    __PB2_CLASS__ = scope_service_pb2.GetScopeRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetScopeRequest",scope_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetScopeByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = scope_service_pb2.GetScopeByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetScopeByNameRequest",scope_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListScopesRequest(pb_classes.Message):
    __PB2_CLASS__ = scope_service_pb2.ListScopesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListScopesRequest",scope_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListScopesResponse(pb_classes.Message):
    __PB2_CLASS__ = scope_service_pb2.ListScopesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListScopesResponse",scope_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Scope]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Scope]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Scope,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Scope]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class ScopeServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.vpc.v1alpha1.ScopeService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.vpc.v1alpha1.ScopeService",scope_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.vpc.v1alpha1.ScopeService"
    
    def get(self,
        request: "GetScopeRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetScopeRequest","Scope"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetScopeRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Scope`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=scope_pb2.Scope,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Scope),
        )
    
    def get_by_name(self,
        request: "GetScopeByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetScopeByNameRequest","Scope"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetScopeByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Scope`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=scope_pb2.Scope,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Scope),
        )
    
    def list(self,
        request: "ListScopesRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListScopesRequest","ListScopesResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.ListScopesRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.ListScopesResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=scope_service_pb2.ListScopesResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListScopesResponse),
        )
    

# file: nebius/vpc/v1alpha1/subnet.proto
class Subnet(pb_classes.Message):
    """
    Defines a Subnet, a segment of a network used for more granular control and management.
    Subnet uses pools to organize address space.
    """
    
    __PB2_CLASS__ = subnet_pb2.Subnet
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.Subnet",subnet_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "SubnetSpec|subnet_pb2.SubnetSpec|None|unset.UnsetType" = unset.Unset,
        status: "SubnetStatus|subnet_pb2.SubnetStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        """
        Metadata for the subnet resource.
        ``metadata.parent_id`` represents IAM container
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "SubnetSpec":
        """
        Specification of the subnet.
        """
        
        return super()._get_field("spec", explicit_presence=False,
        wrap=SubnetSpec,
        )
    @spec.setter
    def spec(self, value: "SubnetSpec|subnet_pb2.SubnetSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "SubnetStatus":
        """
        Status of the subnet.
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=SubnetStatus,
        )
    @status.setter
    def status(self, value: "SubnetStatus|subnet_pb2.SubnetStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class SubnetSpec(pb_classes.Message):
    __PB2_CLASS__ = subnet_pb2.SubnetSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.SubnetSpec",subnet_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        network_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        pools: "abc.Iterable[SubnetPool]|None|unset.UnsetType" = unset.Unset,
        enable_egress_nat: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(network_id, unset.UnsetType):
            self.network_id = network_id
        if not isinstance(pools, unset.UnsetType):
            self.pools = pools
        if not isinstance(enable_egress_nat, unset.UnsetType):
            self.enable_egress_nat = enable_egress_nat
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "network_id",
            "pools",
            "enable_egress_nat",
        ]
    
    @builtins.property
    def network_id(self) -> "builtins.str":
        """
        Network ID.
        """
        
        return super()._get_field("network_id", explicit_presence=False,
        )
    @network_id.setter
    def network_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("network_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def pools(self) -> "abc.MutableSequence[SubnetPool]":
        """
        Pool for addresses
        """
        
        return super()._get_field("pools", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(SubnetPool,None,None),
        )
    @pools.setter
    def pools(self, value: "abc.Iterable[SubnetPool]|None") -> None:
        return super()._set_field("pools",value,explicit_presence=False,
        )
    
    @builtins.property
    def enable_egress_nat(self) -> "builtins.bool":
        """
        Enable egress NAT gateway
        """
        
        return super()._get_field("enable_egress_nat", explicit_presence=False,
        )
    @enable_egress_nat.setter
    def enable_egress_nat(self, value: "builtins.bool|None") -> None:
        return super()._set_field("enable_egress_nat",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "network_id":"network_id",
        "pools":"pools",
        "enable_egress_nat":"enable_egress_nat",
    }
    
class SubnetPool(pb_classes.Message):
    __PB2_CLASS__ = subnet_pb2.SubnetPool
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.SubnetPool",subnet_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_pool__(pb_classes.OneOf):
        name: builtins.str= "pool"
        
        def __init__(self, msg: "SubnetPool") -> None:
            super().__init__()
            self._message: "SubnetPool" = msg
    
    class __OneOfClass_pool_spec__(__OneOfClass_pool__):
        field: typing.Literal["spec"] = "spec"
        
        def __init__(self, msg: "SubnetPool") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "SubnetPoolSpec":
            return self._message.spec
    
    class __OneOfClass_pool_pool_id__(__OneOfClass_pool__):
        field: typing.Literal["pool_id"] = "pool_id"
        
        def __init__(self, msg: "SubnetPool") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.pool_id
    
    @builtins.property
    def pool(self) -> __OneOfClass_pool_spec__|__OneOfClass_pool_pool_id__|None:
        field_name_1: str|None = super().which_field_in_oneof("pool")
        match field_name_1:
            case "spec":
                return self.__OneOfClass_pool_spec__(self)
            case "pool_id":
                return self.__OneOfClass_pool_pool_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        spec: "SubnetPoolSpec|subnet_pb2.SubnetPoolSpec|None|unset.UnsetType" = unset.Unset,
        pool_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(pool_id, unset.UnsetType):
            self.pool_id = pool_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "spec",
            "pool_id",
            "pool",
        ]
    
    @builtins.property
    def spec(self) -> "SubnetPoolSpec|None":
        return super()._get_field("spec", explicit_presence=True,
        wrap=SubnetPoolSpec,
        )
    @spec.setter
    def spec(self, value: "SubnetPoolSpec|subnet_pb2.SubnetPoolSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=True,
        )
    
    @builtins.property
    def pool_id(self) -> "builtins.str|None":
        return super()._get_field("pool_id", explicit_presence=True,
        )
    @pool_id.setter
    def pool_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("pool_id",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "spec":"spec",
        "pool_id":"pool_id",
        "pool":"pool",
    }
    
class SubnetPoolSpec(pb_classes.Message):
    __PB2_CLASS__ = subnet_pb2.SubnetPoolSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.SubnetPoolSpec",subnet_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        version: "IpVersion|pool_pb2.IpVersion|None|unset.UnsetType" = unset.Unset,
        cidrs: "abc.Iterable[SubnetCidr]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(version, unset.UnsetType):
            self.version = version
        if not isinstance(cidrs, unset.UnsetType):
            self.cidrs = cidrs
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "version",
            "cidrs",
        ]
    
    @builtins.property
    def version(self) -> "IpVersion":
        return super()._get_field("version", explicit_presence=False,
        wrap=IpVersion,
        )
    @version.setter
    def version(self, value: "IpVersion|pool_pb2.IpVersion|None") -> None:
        return super()._set_field("version",value,explicit_presence=False,
        )
    
    @builtins.property
    def cidrs(self) -> "abc.MutableSequence[SubnetCidr]":
        return super()._get_field("cidrs", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(SubnetCidr,None,None),
        )
    @cidrs.setter
    def cidrs(self, value: "abc.Iterable[SubnetCidr]|None") -> None:
        return super()._set_field("cidrs",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "version":"version",
        "cidrs":"cidrs",
    }
    
class SubnetCidr(pb_classes.Message):
    __PB2_CLASS__ = subnet_pb2.SubnetCidr
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.SubnetCidr",subnet_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        cidr: "builtins.str|None|unset.UnsetType" = unset.Unset,
        state: "PoolCidrState|pool_pb2.PoolCidrState|None|unset.UnsetType" = unset.Unset,
        allowed_mask: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(cidr, unset.UnsetType):
            self.cidr = cidr
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(allowed_mask, unset.UnsetType):
            self.allowed_mask = allowed_mask
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "cidr",
            "state",
            "allowed_mask",
        ]
    
    @builtins.property
    def cidr(self) -> "builtins.str":
        """
        CIDR block.
        May be a prefix length (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
        """
        
        return super()._get_field("cidr", explicit_presence=False,
        )
    @cidr.setter
    def cidr(self, value: "builtins.str|None") -> None:
        return super()._set_field("cidr",value,explicit_presence=False,
        )
    
    @builtins.property
    def state(self) -> "PoolCidrState":
        """
        State of the Cidr.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=PoolCidrState,
        )
    @state.setter
    def state(self, value: "PoolCidrState|pool_pb2.PoolCidrState|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def allowed_mask(self) -> "builtins.int":
        """
        Maximum mask length for allocation from this cidr
        """
        
        return super()._get_field("allowed_mask", explicit_presence=False,
        )
    @allowed_mask.setter
    def allowed_mask(self, value: "builtins.int|None") -> None:
        return super()._set_field("allowed_mask",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "cidr":"cidr",
        "state":"state",
        "allowed_mask":"allowed_mask",
    }
    
class SubnetStatus(pb_classes.Message):
    __PB2_CLASS__ = subnet_pb2.SubnetStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.SubnetStatus",subnet_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        """
        Enumeration of possible states of the subnet.
        """
        
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.vpc.v1alpha1.SubnetStatus.State",subnet_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        """
        Default state, unspecified.
        """
        
        CREATING = 1
        """
        Subnet is being created.
        """
        
        READY = 2
        """
        Subnet is ready for use.
        """
        
        DELETING = 3
        """
        Subnet is being deleted.
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "SubnetStatus.State|subnet_pb2.SubnetStatus.State|None|unset.UnsetType" = unset.Unset,
        ipv4_cidrs: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(ipv4_cidrs, unset.UnsetType):
            self.ipv4_cidrs = ipv4_cidrs
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "ipv4_cidrs",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "SubnetStatus.State":
        """
        Current state of the subnet.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=SubnetStatus.State,
        )
    @state.setter
    def state(self, value: "SubnetStatus.State|subnet_pb2.SubnetStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def ipv4_cidrs(self) -> "abc.MutableSequence[builtins.str]":
        """
        CIDR blocks.
        """
        
        return super()._get_field("ipv4_cidrs", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @ipv4_cidrs.setter
    def ipv4_cidrs(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("ipv4_cidrs",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "ipv4_cidrs":"ipv4_cidrs",
        "State":"State",
    }
    
# file: nebius/vpc/v1alpha1/subnet_service.proto
class GetSubnetRequest(pb_classes.Message):
    __PB2_CLASS__ = subnet_service_pb2.GetSubnetRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetSubnetRequest",subnet_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetSubnetByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = subnet_service_pb2.GetSubnetByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.GetSubnetByNameRequest",subnet_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListSubnetsRequest(pb_classes.Message):
    __PB2_CLASS__ = subnet_service_pb2.ListSubnetsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListSubnetsRequest",subnet_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListSubnetsByNetworkRequest(pb_classes.Message):
    __PB2_CLASS__ = subnet_service_pb2.ListSubnetsByNetworkRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListSubnetsByNetworkRequest",subnet_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        network_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(network_id, unset.UnsetType):
            self.network_id = network_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "network_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def network_id(self) -> "builtins.str":
        return super()._get_field("network_id", explicit_presence=False,
        )
    @network_id.setter
    def network_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("network_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "network_id":"network_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListSubnetsResponse(pb_classes.Message):
    __PB2_CLASS__ = subnet_service_pb2.ListSubnetsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.vpc.v1alpha1.ListSubnetsResponse",subnet_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Subnet]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Subnet]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Subnet,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Subnet]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class SubnetServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.vpc.v1alpha1.SubnetService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.vpc.v1alpha1.SubnetService",subnet_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.vpc.v1alpha1.SubnetService"
    
    def get(self,
        request: "GetSubnetRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetSubnetRequest","Subnet"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetSubnetRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Subnet`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=subnet_pb2.Subnet,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Subnet),
        )
    
    def get_by_name(self,
        request: "GetSubnetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetSubnetByNameRequest","Subnet"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.GetSubnetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.Subnet`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=subnet_pb2.Subnet,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Subnet),
        )
    
    def list(self,
        request: "ListSubnetsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListSubnetsRequest","ListSubnetsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.ListSubnetsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.ListSubnetsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=subnet_service_pb2.ListSubnetsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListSubnetsResponse),
        )
    
    def list_by_network(self,
        request: "ListSubnetsByNetworkRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListSubnetsByNetworkRequest","ListSubnetsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.vpc.v1alpha1.ListSubnetsByNetworkRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.vpc.v1alpha1.ListSubnetsResponse`.
        """
        
        return super().request(
            method="ListByNetwork",
            request=request,
            result_pb2_class=subnet_service_pb2.ListSubnetsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListSubnetsResponse),
        )
    

__all__ = [
    #@ local import names here @#
    "PoolCidrState",
    "IpVersion",
    "Pool",
    "PoolSpec",
    "PoolCidr",
    "PoolStatus",
    "Allocation",
    "AllocationSpec",
    "IPv4PrivateAllocationSpec",
    "IPv4PublicAllocationSpec",
    "AllocationStatus",
    "AllocationDetails",
    "Assignment",
    "NetworkInterfaceAssignment",
    "LoadBalancerAssignment",
    "GetAllocationRequest",
    "GetAllocationByNameRequest",
    "ListAllocationsRequest",
    "ListAllocationsResponse",
    "CreateAllocationRequest",
    "UpdateAllocationRequest",
    "DeleteAllocationRequest",
    "AllocationServiceClient",
    "Network",
    "NetworkSpec",
    "NetworkPool",
    "NetworkStatus",
    "NetworkInterfaceSpec",
    "IPAddress",
    "PublicIPAddress",
    "IPAlias",
    "NetworkInterfaceStatus",
    "IPAddressStatus",
    "PublicIPAddressStatus",
    "IPAliasesStatus",
    "GetNetworkRequest",
    "GetNetworkByNameRequest",
    "ListNetworksRequest",
    "ListNetworksResponse",
    "NetworkServiceClient",
    "GetPoolRequest",
    "GetPoolByNameRequest",
    "ListPoolsRequest",
    "ListPoolsResponse",
    "PoolServiceClient",
    "Scope",
    "ScopeSpec",
    "ScopeStatus",
    "GetScopeRequest",
    "GetScopeByNameRequest",
    "ListScopesRequest",
    "ListScopesResponse",
    "ScopeServiceClient",
    "Subnet",
    "SubnetSpec",
    "SubnetPool",
    "SubnetPoolSpec",
    "SubnetCidr",
    "SubnetStatus",
    "GetSubnetRequest",
    "GetSubnetByNameRequest",
    "ListSubnetsRequest",
    "ListSubnetsByNetworkRequest",
    "ListSubnetsResponse",
    "SubnetServiceClient",
]
