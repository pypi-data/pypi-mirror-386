# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.iam.v1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import grpc as grpc
import nebius.aio.client as client
import nebius.aio.operation as operation_1
import nebius.aio.request as request_1
import nebius.api.nebius.common.v1 as v1_1
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1.operation_pb2 as operation_pb2
import nebius.api.nebius.iam.v1.access_key_pb2 as access_key_pb2
import nebius.api.nebius.iam.v1.access_key_service_pb2 as access_key_service_pb2
import nebius.api.nebius.iam.v1.access_pb2 as access_pb2
import nebius.api.nebius.iam.v1.access_permit_pb2 as access_permit_pb2
import nebius.api.nebius.iam.v1.access_permit_service_pb2 as access_permit_service_pb2
import nebius.api.nebius.iam.v1.auth_public_key_pb2 as auth_public_key_pb2
import nebius.api.nebius.iam.v1.auth_public_key_service_pb2 as auth_public_key_service_pb2
import nebius.api.nebius.iam.v1.container_pb2 as container_pb2
import nebius.api.nebius.iam.v1.federated_credentials_pb2 as federated_credentials_pb2
import nebius.api.nebius.iam.v1.federated_credentials_service_pb2 as federated_credentials_service_pb2
import nebius.api.nebius.iam.v1.federation_certificate_pb2 as federation_certificate_pb2
import nebius.api.nebius.iam.v1.federation_certificate_service_pb2 as federation_certificate_service_pb2
import nebius.api.nebius.iam.v1.federation_pb2 as federation_pb2
import nebius.api.nebius.iam.v1.federation_service_pb2 as federation_service_pb2
import nebius.api.nebius.iam.v1.group_membership_pb2 as group_membership_pb2
import nebius.api.nebius.iam.v1.group_membership_service_pb2 as group_membership_service_pb2
import nebius.api.nebius.iam.v1.group_pb2 as group_pb2
import nebius.api.nebius.iam.v1.group_service_pb2 as group_service_pb2
import nebius.api.nebius.iam.v1.invitation_pb2 as invitation_pb2
import nebius.api.nebius.iam.v1.invitation_service_pb2 as invitation_service_pb2
import nebius.api.nebius.iam.v1.profile_service_pb2 as profile_service_pb2
import nebius.api.nebius.iam.v1.project_service_pb2 as project_service_pb2
import nebius.api.nebius.iam.v1.service_account_pb2 as service_account_pb2
import nebius.api.nebius.iam.v1.service_account_service_pb2 as service_account_service_pb2
import nebius.api.nebius.iam.v1.session_management_service_pb2 as session_management_service_pb2
import nebius.api.nebius.iam.v1.state_pb2 as state_pb2
import nebius.api.nebius.iam.v1.static_key_pb2 as static_key_pb2
import nebius.api.nebius.iam.v1.static_key_service_pb2 as static_key_service_pb2
import nebius.api.nebius.iam.v1.suspension_state_pb2 as suspension_state_pb2
import nebius.api.nebius.iam.v1.tenant_service_pb2 as tenant_service_pb2
import nebius.api.nebius.iam.v1.tenant_user_account_pb2 as tenant_user_account_pb2
import nebius.api.nebius.iam.v1.tenant_user_account_service_pb2 as tenant_user_account_service_pb2
import nebius.api.nebius.iam.v1.tenant_user_account_with_attributes_service_pb2 as tenant_user_account_with_attributes_service_pb2
import nebius.api.nebius.iam.v1.token_exchange_service_pb2 as token_exchange_service_pb2
import nebius.api.nebius.iam.v1.token_service_pb2 as token_service_pb2
import nebius.api.nebius.iam.v1.user_account_pb2 as user_account_pb2
import nebius.base.fieldmask_protobuf as fieldmask_protobuf
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
#@ local imports here @#

# file: nebius/iam/v1/access.proto
class Account(pb_classes.Message):
    __PB2_CLASS__ = access_pb2.Account
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Account",access_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class UserAccount(pb_classes.Message):
        __PB2_CLASS__ = access_pb2.Account.UserAccount
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Account.UserAccount",access_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(id, unset.UnsetType):
                self.id = id
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "id",
            ]
        
        @builtins.property
        def id(self) -> "builtins.str":
            return super()._get_field("id", explicit_presence=False,
            )
        @id.setter
        def id(self, value: "builtins.str|None") -> None:
            return super()._set_field("id",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "id":"id",
        }
        
    
    class ServiceAccount(pb_classes.Message):
        __PB2_CLASS__ = access_pb2.Account.ServiceAccount
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Account.ServiceAccount",access_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(id, unset.UnsetType):
                self.id = id
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "id",
            ]
        
        @builtins.property
        def id(self) -> "builtins.str":
            return super()._get_field("id", explicit_presence=False,
            )
        @id.setter
        def id(self, value: "builtins.str|None") -> None:
            return super()._set_field("id",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "id":"id",
        }
        
    
    class AnonymousAccount(pb_classes.Message):
        __PB2_CLASS__ = access_pb2.Account.AnonymousAccount
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Account.AnonymousAccount",access_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
        ) -> None:
            super().__init__(initial_message)
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
            ]
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        }
        
    
    class __OneOfClass_type__(pb_classes.OneOf):
        name: builtins.str= "type"
        
        def __init__(self, msg: "Account") -> None:
            super().__init__()
            self._message: "Account" = msg
    
    class __OneOfClass_type_user_account__(__OneOfClass_type__):
        field: typing.Literal["user_account"] = "user_account"
        
        def __init__(self, msg: "Account") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Account.UserAccount":
            return self._message.user_account
    
    class __OneOfClass_type_service_account__(__OneOfClass_type__):
        field: typing.Literal["service_account"] = "service_account"
        
        def __init__(self, msg: "Account") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Account.ServiceAccount":
            return self._message.service_account
    
    class __OneOfClass_type_anonymous_account__(__OneOfClass_type__):
        field: typing.Literal["anonymous_account"] = "anonymous_account"
        
        def __init__(self, msg: "Account") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Account.AnonymousAccount":
            return self._message.anonymous_account
    
    @builtins.property
    def type(self) -> __OneOfClass_type_user_account__|__OneOfClass_type_service_account__|__OneOfClass_type_anonymous_account__|None:
        field_name_1: str|None = super().which_field_in_oneof("type")
        match field_name_1:
            case "user_account":
                return self.__OneOfClass_type_user_account__(self)
            case "service_account":
                return self.__OneOfClass_type_service_account__(self)
            case "anonymous_account":
                return self.__OneOfClass_type_anonymous_account__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        user_account: "Account.UserAccount|access_pb2.Account.UserAccount|None|unset.UnsetType" = unset.Unset,
        service_account: "Account.ServiceAccount|access_pb2.Account.ServiceAccount|None|unset.UnsetType" = unset.Unset,
        anonymous_account: "Account.AnonymousAccount|access_pb2.Account.AnonymousAccount|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(user_account, unset.UnsetType):
            self.user_account = user_account
        if not isinstance(service_account, unset.UnsetType):
            self.service_account = service_account
        if not isinstance(anonymous_account, unset.UnsetType):
            self.anonymous_account = anonymous_account
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "user_account",
            "service_account",
            "anonymous_account",
            "UserAccount",
            "ServiceAccount",
            "AnonymousAccount",
            "type",
        ]
    
    @builtins.property
    def user_account(self) -> "Account.UserAccount|None":
        return super()._get_field("user_account", explicit_presence=True,
        wrap=Account.UserAccount,
        )
    @user_account.setter
    def user_account(self, value: "Account.UserAccount|access_pb2.Account.UserAccount|None") -> None:
        return super()._set_field("user_account",value,explicit_presence=True,
        )
    
    @builtins.property
    def service_account(self) -> "Account.ServiceAccount|None":
        return super()._get_field("service_account", explicit_presence=True,
        wrap=Account.ServiceAccount,
        )
    @service_account.setter
    def service_account(self, value: "Account.ServiceAccount|access_pb2.Account.ServiceAccount|None") -> None:
        return super()._set_field("service_account",value,explicit_presence=True,
        )
    
    @builtins.property
    def anonymous_account(self) -> "Account.AnonymousAccount|None":
        return super()._get_field("anonymous_account", explicit_presence=True,
        wrap=Account.AnonymousAccount,
        )
    @anonymous_account.setter
    def anonymous_account(self, value: "Account.AnonymousAccount|access_pb2.Account.AnonymousAccount|None") -> None:
        return super()._set_field("anonymous_account",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "user_account":"user_account",
        "service_account":"service_account",
        "anonymous_account":"anonymous_account",
        "UserAccount":"UserAccount",
        "ServiceAccount":"ServiceAccount",
        "AnonymousAccount":"AnonymousAccount",
        "type":"type",
    }
    
# file: nebius/iam/v1/access_key.proto
class AccessKey(pb_classes.Message):
    __PB2_CLASS__ = access_key_pb2.AccessKey
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessKey",access_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessKeySpec|access_key_pb2.AccessKeySpec|None|unset.UnsetType" = unset.Unset,
        status: "AccessKeyStatus|access_key_pb2.AccessKeyStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessKeySpec,
        )
    @spec.setter
    def spec(self, value: "AccessKeySpec|access_key_pb2.AccessKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "AccessKeyStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=AccessKeyStatus,
        )
    @status.setter
    def status(self, value: "AccessKeyStatus|access_key_pb2.AccessKeyStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class AccessKeySpec(pb_classes.Message):
    __PB2_CLASS__ = access_key_pb2.AccessKeySpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessKeySpec",access_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "expires_at": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        expires_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(expires_at, unset.UnsetType):
            self.expires_at = expires_at
        if not isinstance(description, unset.UnsetType):
            self.description = description
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "expires_at",
            "description",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def expires_at(self) -> "datetime.datetime":
        return super()._get_field("expires_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @expires_at.setter
    def expires_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("expires_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "expires_at":"expires_at",
        "description":"description",
    }
    
class AccessKeyStatus(pb_classes.Message):
    __PB2_CLASS__ = access_key_pb2.AccessKeyStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessKeyStatus",access_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.AccessKeyStatus.State",access_key_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        INACTIVE = 2
        EXPIRED = 3
        DELETING = 4
        DELETED = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "AccessKeyStatus.State|access_key_pb2.AccessKeyStatus.State|None|unset.UnsetType" = unset.Unset,
        fingerprint: "builtins.str|None|unset.UnsetType" = unset.Unset,
        algorithm: "builtins.str|None|unset.UnsetType" = unset.Unset,
        key_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        secret: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(fingerprint, unset.UnsetType):
            self.fingerprint = fingerprint
        if not isinstance(algorithm, unset.UnsetType):
            self.algorithm = algorithm
        if not isinstance(key_size, unset.UnsetType):
            self.key_size = key_size
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
        if not isinstance(secret, unset.UnsetType):
            self.secret = secret
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "fingerprint",
            "algorithm",
            "key_size",
            "aws_access_key_id",
            "secret",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "AccessKeyStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=AccessKeyStatus.State,
        )
    @state.setter
    def state(self, value: "AccessKeyStatus.State|access_key_pb2.AccessKeyStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def fingerprint(self) -> "builtins.str":
        return super()._get_field("fingerprint", explicit_presence=False,
        )
    @fingerprint.setter
    def fingerprint(self, value: "builtins.str|None") -> None:
        return super()._set_field("fingerprint",value,explicit_presence=False,
        )
    
    @builtins.property
    def algorithm(self) -> "builtins.str":
        return super()._get_field("algorithm", explicit_presence=False,
        )
    @algorithm.setter
    def algorithm(self, value: "builtins.str|None") -> None:
        return super()._set_field("algorithm",value,explicit_presence=False,
        )
    
    @builtins.property
    def key_size(self) -> "builtins.int":
        return super()._get_field("key_size", explicit_presence=False,
        )
    @key_size.setter
    def key_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("key_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def secret(self) -> "builtins.str":
        return super()._get_field("secret", explicit_presence=False,
        )
    @secret.setter
    def secret(self, value: "builtins.str|None") -> None:
        return super()._set_field("secret",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "fingerprint":"fingerprint",
        "algorithm":"algorithm",
        "key_size":"key_size",
        "aws_access_key_id":"aws_access_key_id",
        "secret":"secret",
        "State":"State",
    }
    
# file: nebius/iam/v1/access_key_service.proto
class CreateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.CreateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessKeySpec|access_key_pb2.AccessKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessKeySpec,
        )
    @spec.setter
    def spec(self, value: "AccessKeySpec|access_key_pb2.AccessKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class KeyIdentity(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.KeyIdentity
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.KeyIdentity",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_identity__(pb_classes.OneOf):
        name: builtins.str= "identity"
        
        def __init__(self, msg: "KeyIdentity") -> None:
            super().__init__()
            self._message: "KeyIdentity" = msg
    
    class __OneOfClass_identity_id__(__OneOfClass_identity__):
        field: typing.Literal["id"] = "id"
        
        def __init__(self, msg: "KeyIdentity") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.id
    
    class __OneOfClass_identity_aws_access_key_id__(__OneOfClass_identity__):
        field: typing.Literal["aws_access_key_id"] = "aws_access_key_id"
        
        def __init__(self, msg: "KeyIdentity") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.aws_access_key_id
    
    @builtins.property
    def identity(self) -> __OneOfClass_identity_id__|__OneOfClass_identity_aws_access_key_id__|None:
        field_name_1: str|None = super().which_field_in_oneof("identity")
        match field_name_1:
            case "id":
                return self.__OneOfClass_identity_id__(self)
            case "aws_access_key_id":
                return self.__OneOfClass_identity_aws_access_key_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "aws_access_key_id",
            "identity",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str|None":
        return super()._get_field("id", explicit_presence=True,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=True,
        )
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str|None":
        return super()._get_field("aws_access_key_id", explicit_presence=True,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "aws_access_key_id":"aws_access_key_id",
        "identity":"identity",
    }
    
class GetAccessKeySecretOnceRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeySecretOnceRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessKeySecretOnceRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessKeyByIdRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeyByIdRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessKeyByIdRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessKeyByAwsIdRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeyByAwsIdRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessKeyByAwsIdRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        aws_access_key_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(aws_access_key_id, unset.UnsetType):
            self.aws_access_key_id = aws_access_key_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "aws_access_key_id",
        ]
    
    @builtins.property
    def aws_access_key_id(self) -> "builtins.str":
        return super()._get_field("aws_access_key_id", explicit_presence=False,
        )
    @aws_access_key_id.setter
    def aws_access_key_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aws_access_key_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "aws_access_key_id":"aws_access_key_id",
    }
    
class ListAccessKeysRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ListAccessKeysRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessKeysRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListAccessKeysRequest") -> None:
            super().__init__()
            self._message: "ListAccessKeysRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListAccessKeysRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class ListAccessKeysByAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ListAccessKeysByAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessKeysByAccountRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        """
        Represents the parent account ID.
        """
        
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class UpdateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.UpdateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessKeySpec|access_key_pb2.AccessKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessKeySpec,
        )
    @spec.setter
    def spec(self, value: "AccessKeySpec|access_key_pb2.AccessKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ActivateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ActivateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ActivateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "KeyIdentity|access_key_service_pb2.KeyIdentity|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "KeyIdentity":
        return super()._get_field("id", explicit_presence=False,
        wrap=KeyIdentity,
        )
    @id.setter
    def id(self, value: "KeyIdentity|access_key_service_pb2.KeyIdentity|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeactivateAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.DeactivateAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeactivateAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "KeyIdentity|access_key_service_pb2.KeyIdentity|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "KeyIdentity":
        return super()._get_field("id", explicit_presence=False,
        wrap=KeyIdentity,
        )
    @id.setter
    def id(self, value: "KeyIdentity|access_key_service_pb2.KeyIdentity|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeleteAccessKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.DeleteAccessKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteAccessKeyRequest",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "KeyIdentity|access_key_service_pb2.KeyIdentity|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "KeyIdentity":
        return super()._get_field("id", explicit_presence=False,
        wrap=KeyIdentity,
        )
    @id.setter
    def id(self, value: "KeyIdentity|access_key_service_pb2.KeyIdentity|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessKeySecretOnceResponse(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.GetAccessKeySecretOnceResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessKeySecretOnceResponse",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        secret: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(secret, unset.UnsetType):
            self.secret = secret
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "secret",
        ]
    
    @builtins.property
    def secret(self) -> "builtins.str":
        return super()._get_field("secret", explicit_presence=False,
        )
    @secret.setter
    def secret(self, value: "builtins.str|None") -> None:
        return super()._set_field("secret",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "secret":"secret",
    }
    
class ListAccessKeysResponse(pb_classes.Message):
    __PB2_CLASS__ = access_key_service_pb2.ListAccessKeysResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessKeysResponse",access_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[AccessKey]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[AccessKey]":
        """
        List of access keys returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AccessKey,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[AccessKey]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class AccessKeyServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    Access keys API v1 is depricated. It's known to malfunction under certain conditions.
    Use Access keys API v2 instead. Access keys create by API v1 are available using Access keys API v2.
    
    Supported until 09/01/26. Access keys API v1 is deprecated, use the v2 version instead. Keys produced by API v1 are available using v2.
    
    This class provides the client methods for the ``.nebius.iam.v1.AccessKeyService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.AccessKeyService",access_key_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.AccessKeyService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    __service_deprecation_details__ = (
    """Service .nebius.iam.v1.AccessKeyService is deprecated. Supported until 09/01/26. Access keys API v1 is deprecated, use the v2 version instead. Keys produced by API v1 are available using v2."""
    )
    
    def create(self,
        request: "CreateAccessKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateAccessKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def list(self,
        request: "ListAccessKeysRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListAccessKeysRequest","ListAccessKeysResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAccessKeysRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAccessKeysResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=access_key_service_pb2.ListAccessKeysResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListAccessKeysResponse),
        )
    
    def list_by_account(self,
        request: "ListAccessKeysByAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListAccessKeysByAccountRequest","ListAccessKeysResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAccessKeysByAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAccessKeysResponse`.
        """
        
        return super().request(
            method="ListByAccount",
            request=request,
            result_pb2_class=access_key_service_pb2.ListAccessKeysResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListAccessKeysResponse),
        )
    
    def update(self,
        request: "UpdateAccessKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateAccessKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get_by_id(self,
        request: "GetAccessKeyByIdRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetAccessKeyByIdRequest","AccessKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAccessKeyByIdRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.AccessKey`.
        """
        
        return super().request(
            method="GetById",
            request=request,
            result_pb2_class=access_key_pb2.AccessKey,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(AccessKey),
        )
    
    def get_by_aws_id(self,
        request: "GetAccessKeyByAwsIdRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetAccessKeyByAwsIdRequest","AccessKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAccessKeyByAwsIdRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.AccessKey`.
        """
        
        return super().request(
            method="GetByAwsId",
            request=request,
            result_pb2_class=access_key_pb2.AccessKey,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(AccessKey),
        )
    
    def get_secret_once(self,
        request: "GetAccessKeySecretOnceRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetAccessKeySecretOnceRequest","GetAccessKeySecretOnceResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAccessKeySecretOnceRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.GetAccessKeySecretOnceResponse`.
        """
        
        return super().request(
            method="GetSecretOnce",
            request=request,
            result_pb2_class=access_key_service_pb2.GetAccessKeySecretOnceResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(GetAccessKeySecretOnceResponse),
        )
    
    def activate(self,
        request: "ActivateAccessKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ActivateAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ActivateAccessKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Activate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def deactivate(self,
        request: "DeactivateAccessKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeactivateAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeactivateAccessKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Deactivate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def delete(self,
        request: "DeleteAccessKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteAccessKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteAccessKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/access_permit.proto
class AccessPermit(pb_classes.Message):
    __PB2_CLASS__ = access_permit_pb2.AccessPermit
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessPermit",access_permit_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessPermitSpec|access_permit_pb2.AccessPermitSpec|None|unset.UnsetType" = unset.Unset,
        status: "AccessPermitStatus|access_permit_pb2.AccessPermitStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessPermitSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessPermitSpec,
        )
    @spec.setter
    def spec(self, value: "AccessPermitSpec|access_permit_pb2.AccessPermitSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "AccessPermitStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=AccessPermitStatus,
        )
    @status.setter
    def status(self, value: "AccessPermitStatus|access_permit_pb2.AccessPermitStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class AccessPermitSpec(pb_classes.Message):
    __PB2_CLASS__ = access_permit_pb2.AccessPermitSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessPermitSpec",access_permit_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        role: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
        if not isinstance(role, unset.UnsetType):
            self.role = role
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_id",
            "role",
        ]
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        Resource for granting access permit.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def role(self) -> "builtins.str":
        """
        Role for granting access permit.
        """
        
        return super()._get_field("role", explicit_presence=False,
        )
    @role.setter
    def role(self, value: "builtins.str|None") -> None:
        return super()._set_field("role",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_id":"resource_id",
        "role":"role",
    }
    
class AccessPermitStatus(pb_classes.Message):
    __PB2_CLASS__ = access_permit_pb2.AccessPermitStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AccessPermitStatus",access_permit_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
# file: nebius/iam/v1/access_permit_service.proto
class CreateAccessPermitRequest(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.CreateAccessPermitRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateAccessPermitRequest",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AccessPermitSpec|access_permit_pb2.AccessPermitSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AccessPermitSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AccessPermitSpec,
        )
    @spec.setter
    def spec(self, value: "AccessPermitSpec|access_permit_pb2.AccessPermitSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ListAccessPermitRequest(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.ListAccessPermitRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessPermitRequest",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class DeleteAccessPermitRequest(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.DeleteAccessPermitRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteAccessPermitRequest",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetAccessPermitRequest(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.GetAccessPermitRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAccessPermitRequest",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListAccessPermitResponse(pb_classes.Message):
    __PB2_CLASS__ = access_permit_service_pb2.ListAccessPermitResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAccessPermitResponse",access_permit_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[AccessPermit]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[AccessPermit]":
        """
        List of access bindings returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AccessPermit,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[AccessPermit]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class AccessPermitServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.AccessPermitService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.AccessPermitService",access_permit_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.AccessPermitService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateAccessPermitRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateAccessPermitRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        Creates access permit for provided resource with provided role.
        Subject of access permit is also a parent of access permit.
        If resource is unknown - NOT_FOUND will be thrown.
        If parent of subject is not from resource's hierarchy - NOT_FOUND will be thrown.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateAccessPermitRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def list(self,
        request: "ListAccessPermitRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListAccessPermitRequest","ListAccessPermitResponse"]:
        """
        Lists access permits for provided parent
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAccessPermitRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAccessPermitResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=access_permit_service_pb2.ListAccessPermitResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListAccessPermitResponse),
        )
    
    def delete(self,
        request: "DeleteAccessPermitRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteAccessPermitRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        Delete access permit by id
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteAccessPermitRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get(self,
        request: "GetAccessPermitRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetAccessPermitRequest","AccessPermit"]:
        """
        Gets access permit by id
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAccessPermitRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.AccessPermit`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=access_permit_pb2.AccessPermit,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(AccessPermit),
        )
    

# file: nebius/iam/v1/auth_public_key.proto
class AuthPublicKey(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_pb2.AuthPublicKey
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AuthPublicKey",auth_public_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None|unset.UnsetType" = unset.Unset,
        status: "AuthPublicKeyStatus|auth_public_key_pb2.AuthPublicKeyStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AuthPublicKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AuthPublicKeySpec,
        )
    @spec.setter
    def spec(self, value: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "AuthPublicKeyStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=AuthPublicKeyStatus,
        )
    @status.setter
    def status(self, value: "AuthPublicKeyStatus|auth_public_key_pb2.AuthPublicKeyStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class AuthPublicKeySpec(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_pb2.AuthPublicKeySpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AuthPublicKeySpec",auth_public_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "expires_at": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        expires_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        data: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(expires_at, unset.UnsetType):
            self.expires_at = expires_at
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(data, unset.UnsetType):
            self.data = data
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "expires_at",
            "description",
            "data",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def expires_at(self) -> "datetime.datetime":
        return super()._get_field("expires_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @expires_at.setter
    def expires_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("expires_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def data(self) -> "builtins.str":
        return super()._get_field("data", explicit_presence=False,
        )
    @data.setter
    def data(self, value: "builtins.str|None") -> None:
        return super()._set_field("data",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "expires_at":"expires_at",
        "description":"description",
        "data":"data",
    }
    
class AuthPublicKeyStatus(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_pb2.AuthPublicKeyStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AuthPublicKeyStatus",auth_public_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.AuthPublicKeyStatus.State",auth_public_key_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        INACTIVE = 2
        EXPIRED = 3
        DELETING = 4
        DELETED = 5
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "AuthPublicKeyStatus.State|auth_public_key_pb2.AuthPublicKeyStatus.State|None|unset.UnsetType" = unset.Unset,
        fingerprint: "builtins.str|None|unset.UnsetType" = unset.Unset,
        algorithm: "builtins.str|None|unset.UnsetType" = unset.Unset,
        key_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(fingerprint, unset.UnsetType):
            self.fingerprint = fingerprint
        if not isinstance(algorithm, unset.UnsetType):
            self.algorithm = algorithm
        if not isinstance(key_size, unset.UnsetType):
            self.key_size = key_size
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "fingerprint",
            "algorithm",
            "key_size",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "AuthPublicKeyStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=AuthPublicKeyStatus.State,
        )
    @state.setter
    def state(self, value: "AuthPublicKeyStatus.State|auth_public_key_pb2.AuthPublicKeyStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def fingerprint(self) -> "builtins.str":
        return super()._get_field("fingerprint", explicit_presence=False,
        )
    @fingerprint.setter
    def fingerprint(self, value: "builtins.str|None") -> None:
        return super()._set_field("fingerprint",value,explicit_presence=False,
        )
    
    @builtins.property
    def algorithm(self) -> "builtins.str":
        return super()._get_field("algorithm", explicit_presence=False,
        )
    @algorithm.setter
    def algorithm(self, value: "builtins.str|None") -> None:
        return super()._set_field("algorithm",value,explicit_presence=False,
        )
    
    @builtins.property
    def key_size(self) -> "builtins.int":
        return super()._get_field("key_size", explicit_presence=False,
        )
    @key_size.setter
    def key_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("key_size",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "fingerprint":"fingerprint",
        "algorithm":"algorithm",
        "key_size":"key_size",
        "State":"State",
    }
    
# file: nebius/iam/v1/auth_public_key_service.proto
class CreateAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.CreateAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AuthPublicKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AuthPublicKeySpec,
        )
    @spec.setter
    def spec(self, value: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.GetAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.ListAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListAuthPublicKeyRequest") -> None:
            super().__init__()
            self._message: "ListAuthPublicKeyRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListAuthPublicKeyRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class ListAuthPublicKeyByAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.ListAuthPublicKeyByAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAuthPublicKeyByAccountRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        """
        Represents the parent account ID.
        """
        
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class UpdateAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.UpdateAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "AuthPublicKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=AuthPublicKeySpec,
        )
    @spec.setter
    def spec(self, value: "AuthPublicKeySpec|auth_public_key_pb2.AuthPublicKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ActivateAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.ActivateAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ActivateAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeactivateAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.DeactivateAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeactivateAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class DeleteAuthPublicKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.DeleteAuthPublicKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteAuthPublicKeyRequest",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListAuthPublicKeyResponse(pb_classes.Message):
    __PB2_CLASS__ = auth_public_key_service_pb2.ListAuthPublicKeyResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListAuthPublicKeyResponse",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[AuthPublicKey]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[AuthPublicKey]":
        """
        List of auth public keys returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AuthPublicKey,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[AuthPublicKey]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class AuthPublicKeyServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.AuthPublicKeyService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.AuthPublicKeyService",auth_public_key_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.AuthPublicKeyService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateAuthPublicKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateAuthPublicKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get(self,
        request: "GetAuthPublicKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetAuthPublicKeyRequest","AuthPublicKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetAuthPublicKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.AuthPublicKey`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=auth_public_key_pb2.AuthPublicKey,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(AuthPublicKey),
        )
    
    def list(self,
        request: "ListAuthPublicKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListAuthPublicKeyRequest","ListAuthPublicKeyResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAuthPublicKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAuthPublicKeyResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=auth_public_key_service_pb2.ListAuthPublicKeyResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListAuthPublicKeyResponse),
        )
    
    def list_by_account(self,
        request: "ListAuthPublicKeyByAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListAuthPublicKeyByAccountRequest","ListAuthPublicKeyResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListAuthPublicKeyByAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListAuthPublicKeyResponse`.
        """
        
        return super().request(
            method="ListByAccount",
            request=request,
            result_pb2_class=auth_public_key_service_pb2.ListAuthPublicKeyResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListAuthPublicKeyResponse),
        )
    
    def update(self,
        request: "UpdateAuthPublicKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateAuthPublicKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def activate(self,
        request: "ActivateAuthPublicKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ActivateAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ActivateAuthPublicKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Activate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def deactivate(self,
        request: "DeactivateAuthPublicKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeactivateAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeactivateAuthPublicKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Deactivate",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def delete(self,
        request: "DeleteAuthPublicKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteAuthPublicKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteAuthPublicKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/state.proto
class State(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.State",state_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    STATE_UNSPECIFIED = 0
    ACTIVE = 1
    SCHEDULING_FOR_DELETION = 2
    SCHEDULED_FOR_DELETION = 3
    SCHEDULING_FOR_DELETION_BY_PARENT = 4
    SCHEDULED_FOR_DELETION_BY_PARENT = 5
    UNDELETING = 6
    PURGING = 7
    PURGED = 8
    CREATING = 1001
    """
    DRAFT = 1000;
    """
    

# file: nebius/iam/v1/suspension_state.proto
class SuspensionState(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.SuspensionState",suspension_state_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    SUSPENSION_STATE_UNSPECIFIED = 0
    NONE = 1
    SUSPENDING = 2
    SUSPENDED = 3
    RESUMING = 4

# file: nebius/iam/v1/container.proto
class Container(pb_classes.Message):
    __PB2_CLASS__ = container_pb2.Container
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Container",container_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ContainerSpec|container_pb2.ContainerSpec|None|unset.UnsetType" = unset.Unset,
        status: "ContainerStatus|container_pb2.ContainerStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ContainerSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ContainerSpec,
        )
    @spec.setter
    def spec(self, value: "ContainerSpec|container_pb2.ContainerSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ContainerStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ContainerStatus,
        )
    @status.setter
    def status(self, value: "ContainerStatus|container_pb2.ContainerStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ContainerSpec(pb_classes.Message):
    __PB2_CLASS__ = container_pb2.ContainerSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ContainerSpec",container_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        region: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(region, unset.UnsetType):
            self.region = region
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "region",
        ]
    
    @builtins.property
    def region(self) -> "builtins.str":
        return super()._get_field("region", explicit_presence=False,
        )
    @region.setter
    def region(self, value: "builtins.str|None") -> None:
        return super()._set_field("region",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "region":"region",
    }
    
class ContainerStatus(pb_classes.Message):
    __PB2_CLASS__ = container_pb2.ContainerStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ContainerStatus",container_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        suspension_state: "SuspensionState|suspension_state_pb2.SuspensionState|None|unset.UnsetType" = unset.Unset,
        container_state: "State|state_pb2.State|None|unset.UnsetType" = unset.Unset,
        region: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(suspension_state, unset.UnsetType):
            self.suspension_state = suspension_state
        if not isinstance(container_state, unset.UnsetType):
            self.container_state = container_state
        if not isinstance(region, unset.UnsetType):
            self.region = region
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "suspension_state",
            "container_state",
            "region",
        ]
    
    @builtins.property
    def suspension_state(self) -> "SuspensionState":
        return super()._get_field("suspension_state", explicit_presence=False,
        wrap=SuspensionState,
        )
    @suspension_state.setter
    def suspension_state(self, value: "SuspensionState|suspension_state_pb2.SuspensionState|None") -> None:
        return super()._set_field("suspension_state",value,explicit_presence=False,
        )
    
    @builtins.property
    def container_state(self) -> "State":
        return super()._get_field("container_state", explicit_presence=False,
        wrap=State,
        )
    @container_state.setter
    def container_state(self, value: "State|state_pb2.State|None") -> None:
        return super()._set_field("container_state",value,explicit_presence=False,
        )
    
    @builtins.property
    def region(self) -> "builtins.str":
        return super()._get_field("region", explicit_presence=False,
        )
    @region.setter
    def region(self, value: "builtins.str|None") -> None:
        return super()._set_field("region",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "suspension_state":"suspension_state",
        "container_state":"container_state",
        "region":"region",
    }
    
# file: nebius/iam/v1/federated_credentials.proto
class FederatedCredentials(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_pb2.FederatedCredentials
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederatedCredentials",federated_credentials_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None|unset.UnsetType" = unset.Unset,
        status: "FederatedCredentialsStatus|federated_credentials_pb2.FederatedCredentialsStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederatedCredentialsSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederatedCredentialsSpec,
        )
    @spec.setter
    def spec(self, value: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FederatedCredentialsStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FederatedCredentialsStatus,
        )
    @status.setter
    def status(self, value: "FederatedCredentialsStatus|federated_credentials_pb2.FederatedCredentialsStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class FederatedCredentialsSpec(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_pb2.FederatedCredentialsSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederatedCredentialsSpec",federated_credentials_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_credentials_provider__(pb_classes.OneOf):
        name: builtins.str= "credentials_provider"
        
        def __init__(self, msg: "FederatedCredentialsSpec") -> None:
            super().__init__()
            self._message: "FederatedCredentialsSpec" = msg
    
    class __OneOfClass_credentials_provider_oidc_provider__(__OneOfClass_credentials_provider__):
        field: typing.Literal["oidc_provider"] = "oidc_provider"
        
        def __init__(self, msg: "FederatedCredentialsSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "OidcCredentialsProvider":
            return self._message.oidc_provider
    
    @builtins.property
    def credentials_provider(self) -> __OneOfClass_credentials_provider_oidc_provider__|None:
        """
        provider of federated credentials used for federated subject authentication
        """
        
        field_name_1: str|None = super().which_field_in_oneof("credentials_provider")
        match field_name_1:
            case "oidc_provider":
                return self.__OneOfClass_credentials_provider_oidc_provider__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        oidc_provider: "OidcCredentialsProvider|federated_credentials_pb2.OidcCredentialsProvider|None|unset.UnsetType" = unset.Unset,
        federated_subject_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        subject_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(oidc_provider, unset.UnsetType):
            self.oidc_provider = oidc_provider
        if not isinstance(federated_subject_id, unset.UnsetType):
            self.federated_subject_id = federated_subject_id
        if not isinstance(subject_id, unset.UnsetType):
            self.subject_id = subject_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "oidc_provider",
            "federated_subject_id",
            "subject_id",
            "credentials_provider",
        ]
    
    @builtins.property
    def oidc_provider(self) -> "OidcCredentialsProvider|None":
        return super()._get_field("oidc_provider", explicit_presence=True,
        wrap=OidcCredentialsProvider,
        )
    @oidc_provider.setter
    def oidc_provider(self, value: "OidcCredentialsProvider|federated_credentials_pb2.OidcCredentialsProvider|None") -> None:
        return super()._set_field("oidc_provider",value,explicit_presence=True,
        )
    
    @builtins.property
    def federated_subject_id(self) -> "builtins.str":
        """
        Federated subject ID.For oidc_provider subject will be calculated based on the “sub” claim of the JWT federation token.
        """
        
        return super()._get_field("federated_subject_id", explicit_presence=False,
        )
    @federated_subject_id.setter
    def federated_subject_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federated_subject_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def subject_id(self) -> "builtins.str":
        """
        IAM subject, in which federated subject will be impersonated to. E.g. for workload identities it will be IAM service account.
        """
        
        return super()._get_field("subject_id", explicit_presence=False,
        )
    @subject_id.setter
    def subject_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subject_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "oidc_provider":"oidc_provider",
        "federated_subject_id":"federated_subject_id",
        "subject_id":"subject_id",
        "credentials_provider":"credentials_provider",
    }
    
class OidcCredentialsProvider(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_pb2.OidcCredentialsProvider
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.OidcCredentialsProvider",federated_credentials_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        issuer_url: "builtins.str|None|unset.UnsetType" = unset.Unset,
        jwk_set_json: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(issuer_url, unset.UnsetType):
            self.issuer_url = issuer_url
        if not isinstance(jwk_set_json, unset.UnsetType):
            self.jwk_set_json = jwk_set_json
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "issuer_url",
            "jwk_set_json",
        ]
    
    @builtins.property
    def issuer_url(self) -> "builtins.str":
        """
        *
        It's not required provider OIDC issuer should be real OIDC provider, but should expose OIDC configuration
        with "/.well-known/openid-configuration" endpoint. Configuration should contains the "jwks_uri" endpoint
        where the JSON Web Key Set (JWKS) can be found; this set contains public keys used to verify
        JSON Web Tokens (JWTs) issued by an identity provider.
        
        Limitations for external OIDC providers:
        
        
        * token service limits the number of handled keys by 50. If your JWKS return more than 50,
          the only first 50  will be used for signature verifying.
        * response size for jwks_uri and "/.well-known/openid-configuration limited by 100KB.
        """
        
        return super()._get_field("issuer_url", explicit_presence=False,
        )
    @issuer_url.setter
    def issuer_url(self, value: "builtins.str|None") -> None:
        return super()._set_field("issuer_url",value,explicit_presence=False,
        )
    
    @builtins.property
    def jwk_set_json(self) -> "builtins.str":
        """
        *
        Literally json, which represents JWKS with public keys for JWT verification.
        It worth mentioned that in a case of adding/rotating keys the jwk_set_json also should be updated here.
        Besides, the "issuer" parameter should be set even if the JWKS will be resolved locally.
        """
        
        return super()._get_field("jwk_set_json", explicit_presence=False,
        )
    @jwk_set_json.setter
    def jwk_set_json(self, value: "builtins.str|None") -> None:
        return super()._set_field("jwk_set_json",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "issuer_url":"issuer_url",
        "jwk_set_json":"jwk_set_json",
    }
    
class FederatedCredentialsStatus(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_pb2.FederatedCredentialsStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederatedCredentialsStatus",federated_credentials_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
# file: nebius/iam/v1/federated_credentials_service.proto
class GetFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.GetFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetByNameFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.GetByNameFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetByNameFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Container (project), which contains desired credentials.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Federated credentials name.
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class CreateFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.CreateFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederatedCredentialsSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederatedCredentialsSpec,
        )
    @spec.setter
    def spec(self, value: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class UpdateFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.UpdateFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederatedCredentialsSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederatedCredentialsSpec,
        )
    @spec.setter
    def spec(self, value: "FederatedCredentialsSpec|federated_credentials_pb2.FederatedCredentialsSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ListFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.ListFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the parent NID
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response. Default is 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListFederatedCredentialsResponse(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.ListFederatedCredentialsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederatedCredentialsResponse",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[FederatedCredentials]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[FederatedCredentials]":
        """
        List of user accounts returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(FederatedCredentials,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[FederatedCredentials]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class DeleteFederatedCredentialsRequest(pb_classes.Message):
    __PB2_CLASS__ = federated_credentials_service_pb2.DeleteFederatedCredentialsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteFederatedCredentialsRequest",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class FederatedCredentialsServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.FederatedCredentialsService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.FederatedCredentialsService",federated_credentials_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.FederatedCredentialsService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetFederatedCredentialsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetFederatedCredentialsRequest","FederatedCredentials"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetFederatedCredentialsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.FederatedCredentials`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=federated_credentials_pb2.FederatedCredentials,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(FederatedCredentials),
        )
    
    def get_by_name(self,
        request: "GetByNameFederatedCredentialsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetByNameFederatedCredentialsRequest","FederatedCredentials"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetByNameFederatedCredentialsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.FederatedCredentials`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=federated_credentials_pb2.FederatedCredentials,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(FederatedCredentials),
        )
    
    def list(self,
        request: "ListFederatedCredentialsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListFederatedCredentialsRequest","ListFederatedCredentialsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListFederatedCredentialsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListFederatedCredentialsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=federated_credentials_service_pb2.ListFederatedCredentialsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListFederatedCredentialsResponse),
        )
    
    def create(self,
        request: "CreateFederatedCredentialsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateFederatedCredentialsRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateFederatedCredentialsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def update(self,
        request: "UpdateFederatedCredentialsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateFederatedCredentialsRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateFederatedCredentialsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def delete(self,
        request: "DeleteFederatedCredentialsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteFederatedCredentialsRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteFederatedCredentialsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/federation.proto
class Federation(pb_classes.Message):
    __PB2_CLASS__ = federation_pb2.Federation
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Federation",federation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationSpec|federation_pb2.FederationSpec|None|unset.UnsetType" = unset.Unset,
        status: "FederationStatus|federation_pb2.FederationStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationSpec,
        )
    @spec.setter
    def spec(self, value: "FederationSpec|federation_pb2.FederationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FederationStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FederationStatus,
        )
    @status.setter
    def status(self, value: "FederationStatus|federation_pb2.FederationStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class FederationSpec(pb_classes.Message):
    __PB2_CLASS__ = federation_pb2.FederationSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationSpec",federation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_settings__(pb_classes.OneOf):
        name: builtins.str= "settings"
        
        def __init__(self, msg: "FederationSpec") -> None:
            super().__init__()
            self._message: "FederationSpec" = msg
    
    class __OneOfClass_settings_saml_settings__(__OneOfClass_settings__):
        field: typing.Literal["saml_settings"] = "saml_settings"
        
        def __init__(self, msg: "FederationSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "SamlSettings":
            return self._message.saml_settings
    
    @builtins.property
    def settings(self) -> __OneOfClass_settings_saml_settings__|None:
        field_name_1: str|None = super().which_field_in_oneof("settings")
        match field_name_1:
            case "saml_settings":
                return self.__OneOfClass_settings_saml_settings__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        user_account_auto_creation: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        active: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        saml_settings: "SamlSettings|federation_pb2.SamlSettings|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(user_account_auto_creation, unset.UnsetType):
            self.user_account_auto_creation = user_account_auto_creation
        if not isinstance(active, unset.UnsetType):
            self.active = active
        if not isinstance(saml_settings, unset.UnsetType):
            self.saml_settings = saml_settings
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "user_account_auto_creation",
            "active",
            "saml_settings",
            "settings",
        ]
    
    @builtins.property
    def user_account_auto_creation(self) -> "builtins.bool":
        return super()._get_field("user_account_auto_creation", explicit_presence=False,
        )
    @user_account_auto_creation.setter
    def user_account_auto_creation(self, value: "builtins.bool|None") -> None:
        return super()._set_field("user_account_auto_creation",value,explicit_presence=False,
        )
    
    @builtins.property
    def active(self) -> "builtins.bool":
        return super()._get_field("active", explicit_presence=False,
        )
    @active.setter
    def active(self, value: "builtins.bool|None") -> None:
        return super()._set_field("active",value,explicit_presence=False,
        )
    
    @builtins.property
    def saml_settings(self) -> "SamlSettings|None":
        return super()._get_field("saml_settings", explicit_presence=True,
        wrap=SamlSettings,
        )
    @saml_settings.setter
    def saml_settings(self, value: "SamlSettings|federation_pb2.SamlSettings|None") -> None:
        return super()._set_field("saml_settings",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "user_account_auto_creation":"user_account_auto_creation",
        "active":"active",
        "saml_settings":"saml_settings",
        "settings":"settings",
    }
    
class SamlSettings(pb_classes.Message):
    __PB2_CLASS__ = federation_pb2.SamlSettings
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.SamlSettings",federation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        idp_issuer: "builtins.str|None|unset.UnsetType" = unset.Unset,
        sso_url: "builtins.str|None|unset.UnsetType" = unset.Unset,
        force_authn: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(idp_issuer, unset.UnsetType):
            self.idp_issuer = idp_issuer
        if not isinstance(sso_url, unset.UnsetType):
            self.sso_url = sso_url
        if not isinstance(force_authn, unset.UnsetType):
            self.force_authn = force_authn
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "idp_issuer",
            "sso_url",
            "force_authn",
        ]
    
    @builtins.property
    def idp_issuer(self) -> "builtins.str":
        return super()._get_field("idp_issuer", explicit_presence=False,
        )
    @idp_issuer.setter
    def idp_issuer(self, value: "builtins.str|None") -> None:
        return super()._set_field("idp_issuer",value,explicit_presence=False,
        )
    
    @builtins.property
    def sso_url(self) -> "builtins.str":
        return super()._get_field("sso_url", explicit_presence=False,
        )
    @sso_url.setter
    def sso_url(self, value: "builtins.str|None") -> None:
        return super()._set_field("sso_url",value,explicit_presence=False,
        )
    
    @builtins.property
    def force_authn(self) -> "builtins.bool":
        """
        if "true", the identity provider MUST authenticate the presenter directly rather than rely on a previous security context.
        """
        
        return super()._get_field("force_authn", explicit_presence=False,
        )
    @force_authn.setter
    def force_authn(self, value: "builtins.bool|None") -> None:
        return super()._set_field("force_authn",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "idp_issuer":"idp_issuer",
        "sso_url":"sso_url",
        "force_authn":"force_authn",
    }
    
class FederationStatus(pb_classes.Message):
    __PB2_CLASS__ = federation_pb2.FederationStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationStatus",federation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
# file: nebius/iam/v1/federation_certificate.proto
class FederationCertificate(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_pb2.FederationCertificate
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationCertificate",federation_certificate_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None|unset.UnsetType" = unset.Unset,
        status: "FederationCertificateStatus|federation_certificate_pb2.FederationCertificateStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationCertificateSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationCertificateSpec,
        )
    @spec.setter
    def spec(self, value: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FederationCertificateStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FederationCertificateStatus,
        )
    @status.setter
    def status(self, value: "FederationCertificateStatus|federation_certificate_pb2.FederationCertificateStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class FederationCertificateSpec(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_pb2.FederationCertificateSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationCertificateSpec",federation_certificate_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        data: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(data, unset.UnsetType):
            self.data = data
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "description",
            "data",
        ]
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def data(self) -> "builtins.str":
        return super()._get_field("data", explicit_presence=False,
        )
    @data.setter
    def data(self, value: "builtins.str|None") -> None:
        return super()._set_field("data",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "description":"description",
        "data":"data",
    }
    
class FederationCertificateStatus(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_pb2.FederationCertificateStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FederationCertificateStatus",federation_certificate_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "not_before": well_known_1.ts_mask,
        "not_after": well_known_1.ts_mask,
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.FederationCertificateStatus.State",federation_certificate_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        EXPIRED = 2
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "FederationCertificateStatus.State|federation_certificate_pb2.FederationCertificateStatus.State|None|unset.UnsetType" = unset.Unset,
        algorithm: "builtins.str|None|unset.UnsetType" = unset.Unset,
        key_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        not_before: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        not_after: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(algorithm, unset.UnsetType):
            self.algorithm = algorithm
        if not isinstance(key_size, unset.UnsetType):
            self.key_size = key_size
        if not isinstance(not_before, unset.UnsetType):
            self.not_before = not_before
        if not isinstance(not_after, unset.UnsetType):
            self.not_after = not_after
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "algorithm",
            "key_size",
            "not_before",
            "not_after",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "FederationCertificateStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=FederationCertificateStatus.State,
        )
    @state.setter
    def state(self, value: "FederationCertificateStatus.State|federation_certificate_pb2.FederationCertificateStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def algorithm(self) -> "builtins.str":
        return super()._get_field("algorithm", explicit_presence=False,
        )
    @algorithm.setter
    def algorithm(self, value: "builtins.str|None") -> None:
        return super()._set_field("algorithm",value,explicit_presence=False,
        )
    
    @builtins.property
    def key_size(self) -> "builtins.int":
        return super()._get_field("key_size", explicit_presence=False,
        )
    @key_size.setter
    def key_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("key_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def not_before(self) -> "datetime.datetime":
        return super()._get_field("not_before", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @not_before.setter
    def not_before(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("not_before",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def not_after(self) -> "datetime.datetime":
        return super()._get_field("not_after", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @not_after.setter
    def not_after(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("not_after",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "algorithm":"algorithm",
        "key_size":"key_size",
        "not_before":"not_before",
        "not_after":"not_after",
        "State":"State",
    }
    
# file: nebius/iam/v1/federation_certificate_service.proto
class CreateFederationCertificateRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.CreateFederationCertificateRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateFederationCertificateRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationCertificateSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationCertificateSpec,
        )
    @spec.setter
    def spec(self, value: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetFederationCertificateRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.GetFederationCertificateRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetFederationCertificateRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFederationCertificateByFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.ListFederationCertificateByFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederationCertificateByFederationRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        federation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(federation_id, unset.UnsetType):
            self.federation_id = federation_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "federation_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def federation_id(self) -> "builtins.str":
        """
        Represents the parent federation ID. Corresponds to the parent_id value.
        """
        
        return super()._get_field("federation_id", explicit_presence=False,
        )
    @federation_id.setter
    def federation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "federation_id":"federation_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class UpdateFederationCertificateRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.UpdateFederationCertificateRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateFederationCertificateRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationCertificateSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationCertificateSpec,
        )
    @spec.setter
    def spec(self, value: "FederationCertificateSpec|federation_certificate_pb2.FederationCertificateSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteFederationCertificateRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.DeleteFederationCertificateRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteFederationCertificateRequest",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFederationCertificateResponse(pb_classes.Message):
    __PB2_CLASS__ = federation_certificate_service_pb2.ListFederationCertificateResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederationCertificateResponse",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[FederationCertificate]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[FederationCertificate]":
        """
        List of public keys returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(FederationCertificate,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[FederationCertificate]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class FederationCertificateServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.FederationCertificateService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.FederationCertificateService",federation_certificate_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.FederationCertificateService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateFederationCertificateRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateFederationCertificateRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateFederationCertificateRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get(self,
        request: "GetFederationCertificateRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetFederationCertificateRequest","FederationCertificate"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetFederationCertificateRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.FederationCertificate`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=federation_certificate_pb2.FederationCertificate,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(FederationCertificate),
        )
    
    def list_by_federation(self,
        request: "ListFederationCertificateByFederationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListFederationCertificateByFederationRequest","ListFederationCertificateResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListFederationCertificateByFederationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListFederationCertificateResponse`.
        """
        
        return super().request(
            method="ListByFederation",
            request=request,
            result_pb2_class=federation_certificate_service_pb2.ListFederationCertificateResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListFederationCertificateResponse),
        )
    
    def update(self,
        request: "UpdateFederationCertificateRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateFederationCertificateRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateFederationCertificateRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def delete(self,
        request: "DeleteFederationCertificateRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteFederationCertificateRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteFederationCertificateRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/federation_service.proto
class CreateFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.CreateFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationSpec|federation_pb2.FederationSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationSpec,
        )
    @spec.setter
    def spec(self, value: "FederationSpec|federation_pb2.FederationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.GetFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListFederationsRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.ListFederationsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederationsRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListFederationsResponse(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.ListFederationsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListFederationsResponse",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Federation]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Federation]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Federation,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Federation]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class UpdateFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.UpdateFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "FederationSpec|federation_pb2.FederationSpec|None|unset.UnsetType" = unset.Unset,
        status: "FederationStatus|federation_pb2.FederationStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "FederationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=FederationSpec,
        )
    @spec.setter
    def spec(self, value: "FederationSpec|federation_pb2.FederationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "FederationStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=FederationStatus,
        )
    @status.setter
    def status(self, value: "FederationStatus|federation_pb2.FederationStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class DeleteFederationRequest(pb_classes.Message):
    __PB2_CLASS__ = federation_service_pb2.DeleteFederationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteFederationRequest",federation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class FederationServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.FederationService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.FederationService",federation_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.FederationService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateFederationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateFederationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateFederationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get(self,
        request: "GetFederationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetFederationRequest","Federation"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetFederationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Federation`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=federation_pb2.Federation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Federation),
        )
    
    def get_by_name(self,
        request: "v1_1.GetByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["v1_1.GetByNameRequest","Federation"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Federation`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=federation_pb2.Federation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Federation),
        )
    
    def list(self,
        request: "ListFederationsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListFederationsRequest","ListFederationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListFederationsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListFederationsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=federation_service_pb2.ListFederationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListFederationsResponse),
        )
    
    def update(self,
        request: "UpdateFederationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateFederationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateFederationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def delete(self,
        request: "DeleteFederationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteFederationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteFederationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/group.proto
class Group(pb_classes.Message):
    __PB2_CLASS__ = group_pb2.Group
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Group",group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupSpec|group_pb2.GroupSpec|None|unset.UnsetType" = unset.Unset,
        status: "GroupStatus|group_pb2.GroupStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupSpec,
        )
    @spec.setter
    def spec(self, value: "GroupSpec|group_pb2.GroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "GroupStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=GroupStatus,
        )
    @status.setter
    def status(self, value: "GroupStatus|group_pb2.GroupStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class GroupSpec(pb_classes.Message):
    __PB2_CLASS__ = group_pb2.GroupSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupSpec",group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class GroupStatus(pb_classes.Message):
    __PB2_CLASS__ = group_pb2.GroupStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupStatus",group_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.GroupStatus.State",group_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        ACTIVE = 1
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "GroupStatus.State|group_pb2.GroupStatus.State|None|unset.UnsetType" = unset.Unset,
        members_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        service_accounts_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
        tenant_user_accounts_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(members_count, unset.UnsetType):
            self.members_count = members_count
        if not isinstance(service_accounts_count, unset.UnsetType):
            self.service_accounts_count = service_accounts_count
        if not isinstance(tenant_user_accounts_count, unset.UnsetType):
            self.tenant_user_accounts_count = tenant_user_accounts_count
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "members_count",
            "service_accounts_count",
            "tenant_user_accounts_count",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "GroupStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=GroupStatus.State,
        )
    @state.setter
    def state(self, value: "GroupStatus.State|group_pb2.GroupStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def members_count(self) -> "builtins.int":
        return super()._get_field("members_count", explicit_presence=False,
        )
    @members_count.setter
    def members_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("members_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def service_accounts_count(self) -> "builtins.int":
        return super()._get_field("service_accounts_count", explicit_presence=False,
        )
    @service_accounts_count.setter
    def service_accounts_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("service_accounts_count",value,explicit_presence=False,
        )
    
    @builtins.property
    def tenant_user_accounts_count(self) -> "builtins.int":
        return super()._get_field("tenant_user_accounts_count", explicit_presence=False,
        )
    @tenant_user_accounts_count.setter
    def tenant_user_accounts_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("tenant_user_accounts_count",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "members_count":"members_count",
        "service_accounts_count":"service_accounts_count",
        "tenant_user_accounts_count":"tenant_user_accounts_count",
        "State":"State",
    }
    
# file: nebius/iam/v1/service_account.proto
class ServiceAccount(pb_classes.Message):
    __PB2_CLASS__ = service_account_pb2.ServiceAccount
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccount",service_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None|unset.UnsetType" = unset.Unset,
        status: "ServiceAccountStatus|service_account_pb2.ServiceAccountStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ServiceAccountSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ServiceAccountSpec,
        )
    @spec.setter
    def spec(self, value: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "ServiceAccountStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=ServiceAccountStatus,
        )
    @status.setter
    def status(self, value: "ServiceAccountStatus|service_account_pb2.ServiceAccountStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class ServiceAccountSpec(pb_classes.Message):
    __PB2_CLASS__ = service_account_pb2.ServiceAccountSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccountSpec",service_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(description, unset.UnsetType):
            self.description = description
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "description",
        ]
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "description":"description",
    }
    
class ServiceAccountStatus(pb_classes.Message):
    __PB2_CLASS__ = service_account_pb2.ServiceAccountStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccountStatus",service_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        active: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(active, unset.UnsetType):
            self.active = active
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "active",
        ]
    
    @builtins.property
    def active(self) -> "builtins.bool":
        return super()._get_field("active", explicit_presence=False,
        )
    @active.setter
    def active(self, value: "builtins.bool|None") -> None:
        return super()._set_field("active",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "active":"active",
    }
    
class ServiceAccountAttributes(pb_classes.Message):
    """
    see also nebius/iam/v1/tenant_user_account.proto/UserAttributes
    """
    
    __PB2_CLASS__ = service_account_pb2.ServiceAccountAttributes
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccountAttributes",service_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(description, unset.UnsetType):
            self.description = description
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
            "description",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
        "description":"description",
    }
    
# file: nebius/iam/v1/user_account.proto
class UserAccountExternalId(pb_classes.Message):
    __PB2_CLASS__ = user_account_pb2.UserAccountExternalId
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserAccountExternalId",user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        federation_user_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        federation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(federation_user_account_id, unset.UnsetType):
            self.federation_user_account_id = federation_user_account_id
        if not isinstance(federation_id, unset.UnsetType):
            self.federation_id = federation_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "federation_user_account_id",
            "federation_id",
        ]
    
    @builtins.property
    def federation_user_account_id(self) -> "builtins.str":
        return super()._get_field("federation_user_account_id", explicit_presence=False,
        )
    @federation_user_account_id.setter
    def federation_user_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_user_account_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def federation_id(self) -> "builtins.str":
        return super()._get_field("federation_id", explicit_presence=False,
        )
    @federation_id.setter
    def federation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "federation_user_account_id":"federation_user_account_id",
        "federation_id":"federation_id",
    }
    
class UserAccountStatus(pb_classes.Message):
    __PB2_CLASS__ = user_account_pb2.UserAccountStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserAccountStatus",user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.UserAccountStatus.State",user_account_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        """
        usual state when federated user can log into the system and view/manage granted resources in one or more tenants
        """
        
        INACTIVE = 2
        """
        federated user can be blocked (manually or by any specific automated process), in this state user cannot log into the system
        """
        
        DELETING = 3
        """
        federated user can be deleted/forgot, in this state user cannot log into the system and various internal removal interactions are in progress
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "UserAccountStatus.State|user_account_pb2.UserAccountStatus.State|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "UserAccountStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=UserAccountStatus.State,
        )
    @state.setter
    def state(self, value: "UserAccountStatus.State|user_account_pb2.UserAccountStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "State":"State",
    }
    
# file: nebius/iam/v1/tenant_user_account.proto
class TenantUserAccount(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccount
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccount",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "TenantUserAccountSpec|tenant_user_account_pb2.TenantUserAccountSpec|None|unset.UnsetType" = unset.Unset,
        status: "TenantUserAccountStatus|tenant_user_account_pb2.TenantUserAccountStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "TenantUserAccountSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=TenantUserAccountSpec,
        )
    @spec.setter
    def spec(self, value: "TenantUserAccountSpec|tenant_user_account_pb2.TenantUserAccountSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "TenantUserAccountStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=TenantUserAccountStatus,
        )
    @status.setter
    def status(self, value: "TenantUserAccountStatus|tenant_user_account_pb2.TenantUserAccountStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class TenantUserAccountWithAttributes(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccountWithAttributes
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccountWithAttributes",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_attributesOptional__(pb_classes.OneOf):
        name: builtins.str= "attributesOptional"
        
        def __init__(self, msg: "TenantUserAccountWithAttributes") -> None:
            super().__init__()
            self._message: "TenantUserAccountWithAttributes" = msg
    
    class __OneOfClass_attributesOptional_attributes__(__OneOfClass_attributesOptional__):
        field: typing.Literal["attributes"] = "attributes"
        
        def __init__(self, msg: "TenantUserAccountWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "UserAttributes":
            return self._message.attributes
    
    class __OneOfClass_attributesOptional_error__(__OneOfClass_attributesOptional__):
        field: typing.Literal["error"] = "error"
        
        def __init__(self, msg: "TenantUserAccountWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Error":
            return self._message.error
    
    @builtins.property
    def attributesOptional(self) -> __OneOfClass_attributesOptional_attributes__|__OneOfClass_attributesOptional_error__|None:
        field_name_1: str|None = super().which_field_in_oneof("attributesOptional")
        match field_name_1:
            case "attributes":
                return self.__OneOfClass_attributesOptional_attributes__(self)
            case "error":
                return self.__OneOfClass_attributesOptional_error__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        tenant_user_account: "TenantUserAccount|tenant_user_account_pb2.TenantUserAccount|None|unset.UnsetType" = unset.Unset,
        attributes: "UserAttributes|tenant_user_account_pb2.UserAttributes|None|unset.UnsetType" = unset.Unset,
        error: "Error|tenant_user_account_pb2.Error|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(tenant_user_account, unset.UnsetType):
            self.tenant_user_account = tenant_user_account
        if not isinstance(attributes, unset.UnsetType):
            self.attributes = attributes
        if not isinstance(error, unset.UnsetType):
            self.error = error
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "tenant_user_account",
            "attributes",
            "error",
            "attributesOptional",
        ]
    
    @builtins.property
    def tenant_user_account(self) -> "TenantUserAccount":
        return super()._get_field("tenant_user_account", explicit_presence=False,
        wrap=TenantUserAccount,
        )
    @tenant_user_account.setter
    def tenant_user_account(self, value: "TenantUserAccount|tenant_user_account_pb2.TenantUserAccount|None") -> None:
        return super()._set_field("tenant_user_account",value,explicit_presence=False,
        )
    
    @builtins.property
    def attributes(self) -> "UserAttributes|None":
        return super()._get_field("attributes", explicit_presence=True,
        wrap=UserAttributes,
        )
    @attributes.setter
    def attributes(self, value: "UserAttributes|tenant_user_account_pb2.UserAttributes|None") -> None:
        return super()._set_field("attributes",value,explicit_presence=True,
        )
    
    @builtins.property
    def error(self) -> "Error|None":
        """
        in a case of issues of getting attributes from pds service, we can still return some data from cpl
        """
        
        return super()._get_field("error", explicit_presence=True,
        wrap=Error,
        )
    @error.setter
    def error(self, value: "Error|tenant_user_account_pb2.Error|None") -> None:
        return super()._set_field("error",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "tenant_user_account":"tenant_user_account",
        "attributes":"attributes",
        "error":"error",
        "attributesOptional":"attributesOptional",
    }
    
class UserAttributes(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.UserAttributes
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserAttributes",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__sub__(pb_classes.OneOf):
        name: builtins.str= "_sub"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__sub_sub__(__OneOfClass__sub__):
        field: typing.Literal["sub"] = "sub"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.sub
    
    @builtins.property
    def _sub(self) -> __OneOfClass__sub_sub__|None:
        field_name_1: str|None = super().which_field_in_oneof("_sub")
        match field_name_1:
            case "sub":
                return self.__OneOfClass__sub_sub__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__name__(pb_classes.OneOf):
        name: builtins.str= "_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__name_name__(__OneOfClass__name__):
        field: typing.Literal["name"] = "name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.name
    
    @builtins.property
    def _name(self) -> __OneOfClass__name_name__|None:
        field_name_1: str|None = super().which_field_in_oneof("_name")
        match field_name_1:
            case "name":
                return self.__OneOfClass__name_name__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__given_name__(pb_classes.OneOf):
        name: builtins.str= "_given_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__given_name_given_name__(__OneOfClass__given_name__):
        field: typing.Literal["given_name"] = "given_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.given_name
    
    @builtins.property
    def _given_name(self) -> __OneOfClass__given_name_given_name__|None:
        field_name_1: str|None = super().which_field_in_oneof("_given_name")
        match field_name_1:
            case "given_name":
                return self.__OneOfClass__given_name_given_name__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__family_name__(pb_classes.OneOf):
        name: builtins.str= "_family_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__family_name_family_name__(__OneOfClass__family_name__):
        field: typing.Literal["family_name"] = "family_name"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.family_name
    
    @builtins.property
    def _family_name(self) -> __OneOfClass__family_name_family_name__|None:
        field_name_1: str|None = super().which_field_in_oneof("_family_name")
        match field_name_1:
            case "family_name":
                return self.__OneOfClass__family_name_family_name__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__preferred_username__(pb_classes.OneOf):
        name: builtins.str= "_preferred_username"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__preferred_username_preferred_username__(__OneOfClass__preferred_username__):
        field: typing.Literal["preferred_username"] = "preferred_username"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.preferred_username
    
    @builtins.property
    def _preferred_username(self) -> __OneOfClass__preferred_username_preferred_username__|None:
        field_name_1: str|None = super().which_field_in_oneof("_preferred_username")
        match field_name_1:
            case "preferred_username":
                return self.__OneOfClass__preferred_username_preferred_username__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__picture__(pb_classes.OneOf):
        name: builtins.str= "_picture"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__picture_picture__(__OneOfClass__picture__):
        field: typing.Literal["picture"] = "picture"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.picture
    
    @builtins.property
    def _picture(self) -> __OneOfClass__picture_picture__|None:
        field_name_1: str|None = super().which_field_in_oneof("_picture")
        match field_name_1:
            case "picture":
                return self.__OneOfClass__picture_picture__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__email__(pb_classes.OneOf):
        name: builtins.str= "_email"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__email_email__(__OneOfClass__email__):
        field: typing.Literal["email"] = "email"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.email
    
    @builtins.property
    def _email(self) -> __OneOfClass__email_email__|None:
        field_name_1: str|None = super().which_field_in_oneof("_email")
        match field_name_1:
            case "email":
                return self.__OneOfClass__email_email__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__email_verified__(pb_classes.OneOf):
        name: builtins.str= "_email_verified"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__email_verified_email_verified__(__OneOfClass__email_verified__):
        field: typing.Literal["email_verified"] = "email_verified"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.bool":
            return self._message.email_verified
    
    @builtins.property
    def _email_verified(self) -> __OneOfClass__email_verified_email_verified__|None:
        field_name_1: str|None = super().which_field_in_oneof("_email_verified")
        match field_name_1:
            case "email_verified":
                return self.__OneOfClass__email_verified_email_verified__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__zoneinfo__(pb_classes.OneOf):
        name: builtins.str= "_zoneinfo"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__zoneinfo_zoneinfo__(__OneOfClass__zoneinfo__):
        field: typing.Literal["zoneinfo"] = "zoneinfo"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.zoneinfo
    
    @builtins.property
    def _zoneinfo(self) -> __OneOfClass__zoneinfo_zoneinfo__|None:
        field_name_1: str|None = super().which_field_in_oneof("_zoneinfo")
        match field_name_1:
            case "zoneinfo":
                return self.__OneOfClass__zoneinfo_zoneinfo__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__locale__(pb_classes.OneOf):
        name: builtins.str= "_locale"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__locale_locale__(__OneOfClass__locale__):
        field: typing.Literal["locale"] = "locale"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.locale
    
    @builtins.property
    def _locale(self) -> __OneOfClass__locale_locale__|None:
        field_name_1: str|None = super().which_field_in_oneof("_locale")
        match field_name_1:
            case "locale":
                return self.__OneOfClass__locale_locale__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__phone_number__(pb_classes.OneOf):
        name: builtins.str= "_phone_number"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__phone_number_phone_number__(__OneOfClass__phone_number__):
        field: typing.Literal["phone_number"] = "phone_number"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.phone_number
    
    @builtins.property
    def _phone_number(self) -> __OneOfClass__phone_number_phone_number__|None:
        field_name_1: str|None = super().which_field_in_oneof("_phone_number")
        match field_name_1:
            case "phone_number":
                return self.__OneOfClass__phone_number_phone_number__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    class __OneOfClass__phone_number_verified__(pb_classes.OneOf):
        name: builtins.str= "_phone_number_verified"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__()
            self._message: "UserAttributes" = msg
    
    class __OneOfClass__phone_number_verified_phone_number_verified__(__OneOfClass__phone_number_verified__):
        field: typing.Literal["phone_number_verified"] = "phone_number_verified"
        
        def __init__(self, msg: "UserAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.bool":
            return self._message.phone_number_verified
    
    @builtins.property
    def _phone_number_verified(self) -> __OneOfClass__phone_number_verified_phone_number_verified__|None:
        field_name_1: str|None = super().which_field_in_oneof("_phone_number_verified")
        match field_name_1:
            case "phone_number_verified":
                return self.__OneOfClass__phone_number_verified_phone_number_verified__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        sub: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        given_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        family_name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        preferred_username: "builtins.str|None|unset.UnsetType" = unset.Unset,
        picture: "builtins.str|None|unset.UnsetType" = unset.Unset,
        email: "builtins.str|None|unset.UnsetType" = unset.Unset,
        email_verified: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        zoneinfo: "builtins.str|None|unset.UnsetType" = unset.Unset,
        locale: "builtins.str|None|unset.UnsetType" = unset.Unset,
        phone_number: "builtins.str|None|unset.UnsetType" = unset.Unset,
        phone_number_verified: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(sub, unset.UnsetType):
            self.sub = sub
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(given_name, unset.UnsetType):
            self.given_name = given_name
        if not isinstance(family_name, unset.UnsetType):
            self.family_name = family_name
        if not isinstance(preferred_username, unset.UnsetType):
            self.preferred_username = preferred_username
        if not isinstance(picture, unset.UnsetType):
            self.picture = picture
        if not isinstance(email, unset.UnsetType):
            self.email = email
        if not isinstance(email_verified, unset.UnsetType):
            self.email_verified = email_verified
        if not isinstance(zoneinfo, unset.UnsetType):
            self.zoneinfo = zoneinfo
        if not isinstance(locale, unset.UnsetType):
            self.locale = locale
        if not isinstance(phone_number, unset.UnsetType):
            self.phone_number = phone_number
        if not isinstance(phone_number_verified, unset.UnsetType):
            self.phone_number_verified = phone_number_verified
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "sub",
            "name",
            "given_name",
            "family_name",
            "preferred_username",
            "picture",
            "email",
            "email_verified",
            "zoneinfo",
            "locale",
            "phone_number",
            "phone_number_verified",
            "_sub",
            "_name",
            "_given_name",
            "_family_name",
            "_preferred_username",
            "_picture",
            "_email",
            "_email_verified",
            "_zoneinfo",
            "_locale",
            "_phone_number",
            "_phone_number_verified",
        ]
    
    @builtins.property
    def sub(self) -> "builtins.str|None":
        return super()._get_field("sub", explicit_presence=True,
        )
    @sub.setter
    def sub(self, value: "builtins.str|None") -> None:
        return super()._set_field("sub",value,explicit_presence=True,
        )
    
    @builtins.property
    def name(self) -> "builtins.str|None":
        return super()._get_field("name", explicit_presence=True,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=True,
        )
    
    @builtins.property
    def given_name(self) -> "builtins.str|None":
        return super()._get_field("given_name", explicit_presence=True,
        )
    @given_name.setter
    def given_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("given_name",value,explicit_presence=True,
        )
    
    @builtins.property
    def family_name(self) -> "builtins.str|None":
        return super()._get_field("family_name", explicit_presence=True,
        )
    @family_name.setter
    def family_name(self, value: "builtins.str|None") -> None:
        return super()._set_field("family_name",value,explicit_presence=True,
        )
    
    @builtins.property
    def preferred_username(self) -> "builtins.str|None":
        return super()._get_field("preferred_username", explicit_presence=True,
        )
    @preferred_username.setter
    def preferred_username(self, value: "builtins.str|None") -> None:
        return super()._set_field("preferred_username",value,explicit_presence=True,
        )
    
    @builtins.property
    def picture(self) -> "builtins.str|None":
        return super()._get_field("picture", explicit_presence=True,
        )
    @picture.setter
    def picture(self, value: "builtins.str|None") -> None:
        return super()._set_field("picture",value,explicit_presence=True,
        )
    
    @builtins.property
    def email(self) -> "builtins.str|None":
        return super()._get_field("email", explicit_presence=True,
        )
    @email.setter
    def email(self, value: "builtins.str|None") -> None:
        return super()._set_field("email",value,explicit_presence=True,
        )
    
    @builtins.property
    def email_verified(self) -> "builtins.bool|None":
        return super()._get_field("email_verified", explicit_presence=True,
        )
    @email_verified.setter
    def email_verified(self, value: "builtins.bool|None") -> None:
        return super()._set_field("email_verified",value,explicit_presence=True,
        )
    
    @builtins.property
    def zoneinfo(self) -> "builtins.str|None":
        return super()._get_field("zoneinfo", explicit_presence=True,
        )
    @zoneinfo.setter
    def zoneinfo(self, value: "builtins.str|None") -> None:
        return super()._set_field("zoneinfo",value,explicit_presence=True,
        )
    
    @builtins.property
    def locale(self) -> "builtins.str|None":
        return super()._get_field("locale", explicit_presence=True,
        )
    @locale.setter
    def locale(self, value: "builtins.str|None") -> None:
        return super()._set_field("locale",value,explicit_presence=True,
        )
    
    @builtins.property
    def phone_number(self) -> "builtins.str|None":
        return super()._get_field("phone_number", explicit_presence=True,
        )
    @phone_number.setter
    def phone_number(self, value: "builtins.str|None") -> None:
        return super()._set_field("phone_number",value,explicit_presence=True,
        )
    
    @builtins.property
    def phone_number_verified(self) -> "builtins.bool|None":
        return super()._get_field("phone_number_verified", explicit_presence=True,
        )
    @phone_number_verified.setter
    def phone_number_verified(self, value: "builtins.bool|None") -> None:
        return super()._set_field("phone_number_verified",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "sub":"sub",
        "name":"name",
        "given_name":"given_name",
        "family_name":"family_name",
        "preferred_username":"preferred_username",
        "picture":"picture",
        "email":"email",
        "email_verified":"email_verified",
        "zoneinfo":"zoneinfo",
        "locale":"locale",
        "phone_number":"phone_number",
        "phone_number_verified":"phone_number_verified",
        "_sub":"_sub",
        "_name":"_name",
        "_given_name":"_given_name",
        "_family_name":"_family_name",
        "_preferred_username":"_preferred_username",
        "_picture":"_picture",
        "_email":"_email",
        "_email_verified":"_email_verified",
        "_zoneinfo":"_zoneinfo",
        "_locale":"_locale",
        "_phone_number":"_phone_number",
        "_phone_number_verified":"_phone_number_verified",
    }
    
class Error(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.Error
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Error",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        message: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(message, unset.UnsetType):
            self.message = message
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "message",
        ]
    
    @builtins.property
    def message(self) -> "builtins.str":
        return super()._get_field("message", explicit_presence=False,
        )
    @message.setter
    def message(self, value: "builtins.str|None") -> None:
        return super()._set_field("message",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "message":"message",
    }
    
class TenantUserAccountSpec(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccountSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccountSpec",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class VisibleAttributes(pb_classes.Message):
        """
        when a global user account is projected to a specific tenant
        they can give consent for that tenant's owner to view specific personal data
        by listing explicitly visible PDS attributes
        complete list of PDS attributes is described in ../../pds/inner/v1alpha1/iam_identifier.proto
        """
        
        __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccountSpec.VisibleAttributes
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccountSpec.VisibleAttributes",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            attribute: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(attribute, unset.UnsetType):
                self.attribute = attribute
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "attribute",
            ]
        
        @builtins.property
        def attribute(self) -> "abc.MutableSequence[builtins.str]":
            return super()._get_field("attribute", explicit_presence=False,
            wrap=pb_classes.Repeated,
            )
        @attribute.setter
        def attribute(self, value: "abc.Iterable[builtins.str]|None") -> None:
            return super()._set_field("attribute",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "attribute":"attribute",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        visible_attributes: "TenantUserAccountSpec.VisibleAttributes|tenant_user_account_pb2.TenantUserAccountSpec.VisibleAttributes|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(visible_attributes, unset.UnsetType):
            self.visible_attributes = visible_attributes
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "visible_attributes",
            "VisibleAttributes",
        ]
    
    @builtins.property
    def visible_attributes(self) -> "TenantUserAccountSpec.VisibleAttributes":
        return super()._get_field("visible_attributes", explicit_presence=False,
        wrap=TenantUserAccountSpec.VisibleAttributes,
        )
    @visible_attributes.setter
    def visible_attributes(self, value: "TenantUserAccountSpec.VisibleAttributes|tenant_user_account_pb2.TenantUserAccountSpec.VisibleAttributes|None") -> None:
        return super()._set_field("visible_attributes",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "visible_attributes":"visible_attributes",
        "VisibleAttributes":"VisibleAttributes",
    }
    
class TenantUserAccountStatus(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_pb2.TenantUserAccountStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.TenantUserAccountStatus",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.TenantUserAccountStatus.State",tenant_user_account_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        STATE_UNSPECIFIED = 0
        ACTIVE = 1
        """
        in case of ordinary tenant user account a corresponding user can log into the system and use granted tenant resources
        in case of invited tenant user account once the invitation is accepted a corresponding user can start using granted resources immediately
        """
        
        INACTIVE = 2
        """
        unused
        """
        
        BLOCKED = 3
        """
        in case of ordinary tenant user account a corresponding user can log into the system but cannot be authorized to use tenant resources
        in case of invited tenant user account once the invitation is accepted a corresponding user cannot start using granted resources until is unblocked
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        state: "TenantUserAccountStatus.State|tenant_user_account_pb2.TenantUserAccountStatus.State|None|unset.UnsetType" = unset.Unset,
        invitation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        federation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        user_account_state: "UserAccountStatus.State|user_account_pb2.UserAccountStatus.State|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(invitation_id, unset.UnsetType):
            self.invitation_id = invitation_id
        if not isinstance(federation_id, unset.UnsetType):
            self.federation_id = federation_id
        if not isinstance(user_account_state, unset.UnsetType):
            self.user_account_state = user_account_state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "state",
            "invitation_id",
            "federation_id",
            "user_account_state",
            "State",
        ]
    
    @builtins.property
    def state(self) -> "TenantUserAccountStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=TenantUserAccountStatus.State,
        )
    @state.setter
    def state(self, value: "TenantUserAccountStatus.State|tenant_user_account_pb2.TenantUserAccountStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def invitation_id(self) -> "builtins.str":
        """
        if a tenant user account is created during invitation it gets a reference to the invitation resource
        once invitation is accepted it looses this reference (and internally gets a reference to their global federated user account)
        """
        
        return super()._get_field("invitation_id", explicit_presence=False,
        )
    @invitation_id.setter
    def invitation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("invitation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def federation_id(self) -> "builtins.str":
        """
        currently can only accept the values: custom, unknown, google, github.
        """
        
        return super()._get_field("federation_id", explicit_presence=False,
        )
    @federation_id.setter
    def federation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("federation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def user_account_state(self) -> "UserAccountStatus.State":
        """
        user account state can help distinguish case when account is blocked globally
        """
        
        return super()._get_field("user_account_state", explicit_presence=False,
        wrap=UserAccountStatus.State,
        )
    @user_account_state.setter
    def user_account_state(self, value: "UserAccountStatus.State|user_account_pb2.UserAccountStatus.State|None") -> None:
        return super()._set_field("user_account_state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "state":"state",
        "invitation_id":"invitation_id",
        "federation_id":"federation_id",
        "user_account_state":"user_account_state",
        "State":"State",
    }
    
# file: nebius/iam/v1/group_membership.proto
class GroupMembership(pb_classes.Message):
    __PB2_CLASS__ = group_membership_pb2.GroupMembership
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMembership",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "revoke_at": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupMembershipSpec|group_membership_pb2.GroupMembershipSpec|None|unset.UnsetType" = unset.Unset,
        status: "GroupMembershipStatus|group_membership_pb2.GroupMembershipStatus|None|unset.UnsetType" = unset.Unset,
        revoke_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
        if not isinstance(revoke_at, unset.UnsetType):
            self.revoke_at = revoke_at
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
            "revoke_at",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupMembershipSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupMembershipSpec,
        )
    @spec.setter
    def spec(self, value: "GroupMembershipSpec|group_membership_pb2.GroupMembershipSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "GroupMembershipStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=GroupMembershipStatus,
        )
    @status.setter
    def status(self, value: "GroupMembershipStatus|group_membership_pb2.GroupMembershipStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    @builtins.property
    def revoke_at(self) -> "datetime.datetime":
        return super()._get_field("revoke_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @revoke_at.setter
    def revoke_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("revoke_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
        "revoke_at":"revoke_at",
    }
    
class GroupMembershipSpec(pb_classes.Message):
    __PB2_CLASS__ = group_membership_pb2.GroupMembershipSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMembershipSpec",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        member_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(member_id, unset.UnsetType):
            self.member_id = member_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "member_id",
        ]
    
    @builtins.property
    def member_id(self) -> "builtins.str":
        """
        Member of the group. Can be tenant user account id or service account id.
        """
        
        return super()._get_field("member_id", explicit_presence=False,
        )
    @member_id.setter
    def member_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("member_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "member_id":"member_id",
    }
    
class GroupMembershipStatus(pb_classes.Message):
    __PB2_CLASS__ = group_membership_pb2.GroupMembershipStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMembershipStatus",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_group_member_status__(pb_classes.OneOf):
        name: builtins.str= "group_member_status"
        
        def __init__(self, msg: "GroupMembershipStatus") -> None:
            super().__init__()
            self._message: "GroupMembershipStatus" = msg
    
    class __OneOfClass_group_member_status_tenant_user_account_status__(__OneOfClass_group_member_status__):
        field: typing.Literal["tenant_user_account_status"] = "tenant_user_account_status"
        
        def __init__(self, msg: "GroupMembershipStatus") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "TenantUserAccountStatus":
            return self._message.tenant_user_account_status
    
    class __OneOfClass_group_member_status_service_account_status__(__OneOfClass_group_member_status__):
        field: typing.Literal["service_account_status"] = "service_account_status"
        
        def __init__(self, msg: "GroupMembershipStatus") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ServiceAccountStatus":
            return self._message.service_account_status
    
    @builtins.property
    def group_member_status(self) -> __OneOfClass_group_member_status_tenant_user_account_status__|__OneOfClass_group_member_status_service_account_status__|None:
        field_name_1: str|None = super().which_field_in_oneof("group_member_status")
        match field_name_1:
            case "tenant_user_account_status":
                return self.__OneOfClass_group_member_status_tenant_user_account_status__(self)
            case "service_account_status":
                return self.__OneOfClass_group_member_status_service_account_status__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        tenant_user_account_status: "TenantUserAccountStatus|tenant_user_account_pb2.TenantUserAccountStatus|None|unset.UnsetType" = unset.Unset,
        service_account_status: "ServiceAccountStatus|service_account_pb2.ServiceAccountStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(tenant_user_account_status, unset.UnsetType):
            self.tenant_user_account_status = tenant_user_account_status
        if not isinstance(service_account_status, unset.UnsetType):
            self.service_account_status = service_account_status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "tenant_user_account_status",
            "service_account_status",
            "group_member_status",
        ]
    
    @builtins.property
    def tenant_user_account_status(self) -> "TenantUserAccountStatus|None":
        return super()._get_field("tenant_user_account_status", explicit_presence=True,
        wrap=TenantUserAccountStatus,
        )
    @tenant_user_account_status.setter
    def tenant_user_account_status(self, value: "TenantUserAccountStatus|tenant_user_account_pb2.TenantUserAccountStatus|None") -> None:
        return super()._set_field("tenant_user_account_status",value,explicit_presence=True,
        )
    
    @builtins.property
    def service_account_status(self) -> "ServiceAccountStatus|None":
        return super()._get_field("service_account_status", explicit_presence=True,
        wrap=ServiceAccountStatus,
        )
    @service_account_status.setter
    def service_account_status(self, value: "ServiceAccountStatus|service_account_pb2.ServiceAccountStatus|None") -> None:
        return super()._set_field("service_account_status",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "tenant_user_account_status":"tenant_user_account_status",
        "service_account_status":"service_account_status",
        "group_member_status":"group_member_status",
    }
    
class GroupMemberKind(pb_classes.Message):
    __PB2_CLASS__ = group_membership_pb2.GroupMemberKind
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMemberKind",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class Kind(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.GroupMemberKind.Kind",group_membership_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        KIND_UNSPECIFIED = 0
        ORDINARY_TENANT_USER_ACCOUNT = 1
        INVITED_TENANT_USER_ACCOUNT = 2
        SERVICE_ACCOUNT = 3
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        kind: "GroupMemberKind.Kind|group_membership_pb2.GroupMemberKind.Kind|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(kind, unset.UnsetType):
            self.kind = kind
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "kind",
            "Kind",
        ]
    
    @builtins.property
    def kind(self) -> "GroupMemberKind.Kind":
        return super()._get_field("kind", explicit_presence=False,
        wrap=GroupMemberKind.Kind,
        )
    @kind.setter
    def kind(self, value: "GroupMemberKind.Kind|group_membership_pb2.GroupMemberKind.Kind|None") -> None:
        return super()._set_field("kind",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "kind":"kind",
        "Kind":"Kind",
    }
    
class GroupMembershipWithAttributes(pb_classes.Message):
    """
    see also nebius/iam/v1/tenant_user_account.proto/TenantUserAccountWithAttributes
    """
    
    __PB2_CLASS__ = group_membership_pb2.GroupMembershipWithAttributes
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GroupMembershipWithAttributes",group_membership_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_attributesOptional__(pb_classes.OneOf):
        name: builtins.str= "attributesOptional"
        
        def __init__(self, msg: "GroupMembershipWithAttributes") -> None:
            super().__init__()
            self._message: "GroupMembershipWithAttributes" = msg
    
    class __OneOfClass_attributesOptional_user_attributes__(__OneOfClass_attributesOptional__):
        field: typing.Literal["user_attributes"] = "user_attributes"
        
        def __init__(self, msg: "GroupMembershipWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "UserAttributes":
            return self._message.user_attributes
    
    class __OneOfClass_attributesOptional_service_account_attributes__(__OneOfClass_attributesOptional__):
        field: typing.Literal["service_account_attributes"] = "service_account_attributes"
        
        def __init__(self, msg: "GroupMembershipWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ServiceAccountAttributes":
            return self._message.service_account_attributes
    
    class __OneOfClass_attributesOptional_error__(__OneOfClass_attributesOptional__):
        field: typing.Literal["error"] = "error"
        
        def __init__(self, msg: "GroupMembershipWithAttributes") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Error":
            return self._message.error
    
    @builtins.property
    def attributesOptional(self) -> __OneOfClass_attributesOptional_user_attributes__|__OneOfClass_attributesOptional_service_account_attributes__|__OneOfClass_attributesOptional_error__|None:
        field_name_1: str|None = super().which_field_in_oneof("attributesOptional")
        match field_name_1:
            case "user_attributes":
                return self.__OneOfClass_attributesOptional_user_attributes__(self)
            case "service_account_attributes":
                return self.__OneOfClass_attributesOptional_service_account_attributes__(self)
            case "error":
                return self.__OneOfClass_attributesOptional_error__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        group_membership: "GroupMembership|group_membership_pb2.GroupMembership|None|unset.UnsetType" = unset.Unset,
        group_member_kind: "GroupMemberKind|group_membership_pb2.GroupMemberKind|None|unset.UnsetType" = unset.Unset,
        user_attributes: "UserAttributes|tenant_user_account_pb2.UserAttributes|None|unset.UnsetType" = unset.Unset,
        service_account_attributes: "ServiceAccountAttributes|service_account_pb2.ServiceAccountAttributes|None|unset.UnsetType" = unset.Unset,
        error: "Error|tenant_user_account_pb2.Error|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(group_membership, unset.UnsetType):
            self.group_membership = group_membership
        if not isinstance(group_member_kind, unset.UnsetType):
            self.group_member_kind = group_member_kind
        if not isinstance(user_attributes, unset.UnsetType):
            self.user_attributes = user_attributes
        if not isinstance(service_account_attributes, unset.UnsetType):
            self.service_account_attributes = service_account_attributes
        if not isinstance(error, unset.UnsetType):
            self.error = error
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "group_membership",
            "group_member_kind",
            "user_attributes",
            "service_account_attributes",
            "error",
            "attributesOptional",
        ]
    
    @builtins.property
    def group_membership(self) -> "GroupMembership":
        return super()._get_field("group_membership", explicit_presence=False,
        wrap=GroupMembership,
        )
    @group_membership.setter
    def group_membership(self, value: "GroupMembership|group_membership_pb2.GroupMembership|None") -> None:
        return super()._set_field("group_membership",value,explicit_presence=False,
        )
    
    @builtins.property
    def group_member_kind(self) -> "GroupMemberKind":
        return super()._get_field("group_member_kind", explicit_presence=False,
        wrap=GroupMemberKind,
        )
    @group_member_kind.setter
    def group_member_kind(self, value: "GroupMemberKind|group_membership_pb2.GroupMemberKind|None") -> None:
        return super()._set_field("group_member_kind",value,explicit_presence=False,
        )
    
    @builtins.property
    def user_attributes(self) -> "UserAttributes|None":
        """
        filled with known data for members corresponding to tenant user accounts and provisional tenant user accounts (invitees)
        left unset for service accounts
        """
        
        return super()._get_field("user_attributes", explicit_presence=True,
        wrap=UserAttributes,
        )
    @user_attributes.setter
    def user_attributes(self, value: "UserAttributes|tenant_user_account_pb2.UserAttributes|None") -> None:
        return super()._set_field("user_attributes",value,explicit_presence=True,
        )
    
    @builtins.property
    def service_account_attributes(self) -> "ServiceAccountAttributes|None":
        """
        filled with known data for members corresponding to service accounts
        left unset for any kind of tenant user accounts
        """
        
        return super()._get_field("service_account_attributes", explicit_presence=True,
        wrap=ServiceAccountAttributes,
        )
    @service_account_attributes.setter
    def service_account_attributes(self, value: "ServiceAccountAttributes|service_account_pb2.ServiceAccountAttributes|None") -> None:
        return super()._set_field("service_account_attributes",value,explicit_presence=True,
        )
    
    @builtins.property
    def error(self) -> "Error|None":
        """
        in a case of issues of getting attributes from pds service, we can still return some data from cpl
        """
        
        return super()._get_field("error", explicit_presence=True,
        wrap=Error,
        )
    @error.setter
    def error(self, value: "Error|tenant_user_account_pb2.Error|None") -> None:
        return super()._set_field("error",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "group_membership":"group_membership",
        "group_member_kind":"group_member_kind",
        "user_attributes":"user_attributes",
        "service_account_attributes":"service_account_attributes",
        "error":"error",
        "attributesOptional":"attributesOptional",
    }
    
# file: nebius/iam/v1/group_membership_service.proto
class CreateGroupMembershipRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.CreateGroupMembershipRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateGroupMembershipRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupMembershipSpec|group_membership_pb2.GroupMembershipSpec|None|unset.UnsetType" = unset.Unset,
        revoke_after_hours: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(revoke_after_hours, unset.UnsetType):
            self.revoke_after_hours = revoke_after_hours
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "revoke_after_hours",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupMembershipSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupMembershipSpec,
        )
    @spec.setter
    def spec(self, value: "GroupMembershipSpec|group_membership_pb2.GroupMembershipSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def revoke_after_hours(self) -> "builtins.int":
        return super()._get_field("revoke_after_hours", explicit_presence=False,
        )
    @revoke_after_hours.setter
    def revoke_after_hours(self, value: "builtins.int|None") -> None:
        return super()._set_field("revoke_after_hours",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "revoke_after_hours":"revoke_after_hours",
    }
    
class DeleteGroupMembershipRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.DeleteGroupMembershipRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteGroupMembershipRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetGroupMembershipRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.GetGroupMembershipRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetGroupMembershipRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListGroupMembershipsRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListGroupMembershipsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupMembershipsRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListGroupMembershipsRequest") -> None:
            super().__init__()
            self._message: "ListGroupMembershipsRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListGroupMembershipsRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class ListMemberOfRequest(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListMemberOfRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListMemberOfRequest",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListMemberOfRequest") -> None:
            super().__init__()
            self._message: "ListMemberOfRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListMemberOfRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        subject_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(subject_id, unset.UnsetType):
            self.subject_id = subject_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "subject_id",
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def subject_id(self) -> "builtins.str":
        """
        Requested subject id. Can be tenant user account id or service account id.
        """
        
        return super()._get_field("subject_id", explicit_presence=False,
        )
    @subject_id.setter
    def subject_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("subject_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "subject_id":"subject_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class ListGroupMembershipsResponse(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListGroupMembershipsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupMembershipsResponse",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        memberships: "abc.Iterable[GroupMembership]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(memberships, unset.UnsetType):
            self.memberships = memberships
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "memberships",
            "next_page_token",
        ]
    
    @builtins.property
    def memberships(self) -> "abc.MutableSequence[GroupMembership]":
        """
        Members of the group. Can be tenant user account ids or service account ids.
        """
        
        return super()._get_field("memberships", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(GroupMembership,None,None),
        )
    @memberships.setter
    def memberships(self, value: "abc.Iterable[GroupMembership]|None") -> None:
        return super()._set_field("memberships",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "memberships":"memberships",
        "next_page_token":"next_page_token",
    }
    
class ListGroupMembershipsWithAttributesResponse(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListGroupMembershipsWithAttributesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupMembershipsWithAttributesResponse",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        memberships: "abc.Iterable[GroupMembershipWithAttributes]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(memberships, unset.UnsetType):
            self.memberships = memberships
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "memberships",
            "next_page_token",
        ]
    
    @builtins.property
    def memberships(self) -> "abc.MutableSequence[GroupMembershipWithAttributes]":
        """
        Members of the group with their attributes if supported by member type.
        Can be tenant user accounts (regular or provisional/invited) or service accounts.
        Regular tenant user accounts may have a full set of attributes, provisional may have contacts only,
        service accounts
        """
        
        return super()._get_field("memberships", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(GroupMembershipWithAttributes,None,None),
        )
    @memberships.setter
    def memberships(self, value: "abc.Iterable[GroupMembershipWithAttributes]|None") -> None:
        return super()._set_field("memberships",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "memberships":"memberships",
        "next_page_token":"next_page_token",
    }
    
class ListMemberOfResponse(pb_classes.Message):
    __PB2_CLASS__ = group_membership_service_pb2.ListMemberOfResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListMemberOfResponse",group_membership_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Group]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Group]":
        """
        Groups that requested entity is a member of
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Group,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Group]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class GroupMembershipServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.GroupMembershipService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.GroupMembershipService",group_membership_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.GroupMembershipService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateGroupMembershipRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateGroupMembershipRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateGroupMembershipRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get(self,
        request: "GetGroupMembershipRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetGroupMembershipRequest","GroupMembership"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetGroupMembershipRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.GroupMembership`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=group_membership_pb2.GroupMembership,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(GroupMembership),
        )
    
    def get_with_attributes(self,
        request: "GetGroupMembershipRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetGroupMembershipRequest","GroupMembershipWithAttributes"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetGroupMembershipRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.GroupMembershipWithAttributes`.
        """
        
        return super().request(
            method="GetWithAttributes",
            request=request,
            result_pb2_class=group_membership_pb2.GroupMembershipWithAttributes,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(GroupMembershipWithAttributes),
        )
    
    def delete(self,
        request: "DeleteGroupMembershipRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteGroupMembershipRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteGroupMembershipRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def list_members(self,
        request: "ListGroupMembershipsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListGroupMembershipsRequest","ListGroupMembershipsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListGroupMembershipsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListGroupMembershipsResponse`.
        """
        
        return super().request(
            method="ListMembers",
            request=request,
            result_pb2_class=group_membership_service_pb2.ListGroupMembershipsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListGroupMembershipsResponse),
        )
    
    def list_members_with_attributes(self,
        request: "ListGroupMembershipsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListGroupMembershipsRequest","ListGroupMembershipsWithAttributesResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListGroupMembershipsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListGroupMembershipsWithAttributesResponse`.
        """
        
        return super().request(
            method="ListMembersWithAttributes",
            request=request,
            result_pb2_class=group_membership_service_pb2.ListGroupMembershipsWithAttributesResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListGroupMembershipsWithAttributesResponse),
        )
    
    def list_member_of(self,
        request: "ListMemberOfRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListMemberOfRequest","ListMemberOfResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListMemberOfRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListMemberOfResponse`.
        """
        
        return super().request(
            method="ListMemberOf",
            request=request,
            result_pb2_class=group_membership_service_pb2.ListMemberOfResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListMemberOfResponse),
        )
    

# file: nebius/iam/v1/group_service.proto
class CreateGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.CreateGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateGroupRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupSpec|group_pb2.GroupSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupSpec,
        )
    @spec.setter
    def spec(self, value: "GroupSpec|group_pb2.GroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.GetGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetGroupRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetGroupByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.GetGroupByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetGroupByNameRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListGroupsRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.ListGroupsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupsRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListGroupsRequest") -> None:
            super().__init__()
            self._message: "ListGroupsRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListGroupsRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class ListGroupsResponse(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.ListGroupsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListGroupsResponse",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Group]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Group]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Group,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Group]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class DeleteGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.DeleteGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteGroupRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UpdateGroupRequest(pb_classes.Message):
    __PB2_CLASS__ = group_service_pb2.UpdateGroupRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateGroupRequest",group_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "GroupSpec|group_pb2.GroupSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "GroupSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=GroupSpec,
        )
    @spec.setter
    def spec(self, value: "GroupSpec|group_pb2.GroupSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    

class GroupServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.GroupService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.GroupService",group_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.GroupService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateGroupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateGroupRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateGroupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get(self,
        request: "GetGroupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetGroupRequest","Group"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetGroupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Group`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=group_pb2.Group,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Group),
        )
    
    def get_by_name(self,
        request: "GetGroupByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetGroupByNameRequest","Group"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetGroupByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Group`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=group_pb2.Group,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Group),
        )
    
    def list(self,
        request: "ListGroupsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListGroupsRequest","ListGroupsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListGroupsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListGroupsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=group_service_pb2.ListGroupsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListGroupsResponse),
        )
    
    def delete(self,
        request: "DeleteGroupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteGroupRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteGroupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def update(self,
        request: "UpdateGroupRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateGroupRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateGroupRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/invitation.proto
class Invitation(pb_classes.Message):
    __PB2_CLASS__ = invitation_pb2.Invitation
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.Invitation",invitation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InvitationSpec|invitation_pb2.InvitationSpec|None|unset.UnsetType" = unset.Unset,
        status: "InvitationStatus|invitation_pb2.InvitationStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InvitationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InvitationSpec,
        )
    @spec.setter
    def spec(self, value: "InvitationSpec|invitation_pb2.InvitationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "InvitationStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=InvitationStatus,
        )
    @status.setter
    def status(self, value: "InvitationStatus|invitation_pb2.InvitationStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class InvitationSpec(pb_classes.Message):
    __PB2_CLASS__ = invitation_pb2.InvitationSpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.InvitationSpec",invitation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_contact__(pb_classes.OneOf):
        name: builtins.str= "contact"
        
        def __init__(self, msg: "InvitationSpec") -> None:
            super().__init__()
            self._message: "InvitationSpec" = msg
    
    class __OneOfClass_contact_email__(__OneOfClass_contact__):
        field: typing.Literal["email"] = "email"
        
        def __init__(self, msg: "InvitationSpec") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.email
    
    @builtins.property
    def contact(self) -> __OneOfClass_contact_email__|None:
        field_name_1: str|None = super().which_field_in_oneof("contact")
        match field_name_1:
            case "email":
                return self.__OneOfClass_contact_email__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        email: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(email, unset.UnsetType):
            self.email = email
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "description",
            "email",
            "contact",
        ]
    
    @builtins.property
    def description(self) -> "builtins.str":
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def email(self) -> "builtins.str|None":
        return super()._get_field("email", explicit_presence=True,
        )
    @email.setter
    def email(self, value: "builtins.str|None") -> None:
        return super()._set_field("email",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "description":"description",
        "email":"email",
        "contact":"contact",
    }
    
class InvitationStatus(pb_classes.Message):
    __PB2_CLASS__ = invitation_pb2.InvitationStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.InvitationStatus",invitation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "expires_at": well_known_1.ts_mask,
    }
    
    class State(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.InvitationStatus.State",invitation_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CREATING = 4
        """
        contacts data is not stored in pds yet. probably will GC it later
        """
        
        CREATED = 5
        """
        notification is not sent yet
        """
        
        PENDING = 1
        """
        notification is sent, we are waiting for the user to approve the notification
        """
        
        EXPIRED = 2
        """
        notification is expired, accept is no longer possible
        """
        
        ACCEPTED = 3
        """
        notification is accepted
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        tenant_user_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        expires_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        state: "InvitationStatus.State|invitation_pb2.InvitationStatus.State|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(tenant_user_account_id, unset.UnsetType):
            self.tenant_user_account_id = tenant_user_account_id
        if not isinstance(expires_at, unset.UnsetType):
            self.expires_at = expires_at
        if not isinstance(state, unset.UnsetType):
            self.state = state
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "tenant_user_account_id",
            "expires_at",
            "state",
            "State",
        ]
    
    @builtins.property
    def tenant_user_account_id(self) -> "builtins.str":
        return super()._get_field("tenant_user_account_id", explicit_presence=False,
        )
    @tenant_user_account_id.setter
    def tenant_user_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("tenant_user_account_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def expires_at(self) -> "datetime.datetime":
        return super()._get_field("expires_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @expires_at.setter
    def expires_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("expires_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def state(self) -> "InvitationStatus.State":
        return super()._get_field("state", explicit_presence=False,
        wrap=InvitationStatus.State,
        )
    @state.setter
    def state(self, value: "InvitationStatus.State|invitation_pb2.InvitationStatus.State|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "tenant_user_account_id":"tenant_user_account_id",
        "expires_at":"expires_at",
        "state":"state",
        "State":"State",
    }
    
# file: nebius/iam/v1/invitation_service.proto
class CreateInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.CreateInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InvitationSpec|invitation_pb2.InvitationSpec|None|unset.UnsetType" = unset.Unset,
        no_send: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(no_send, unset.UnsetType):
            self.no_send = no_send
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "no_send",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InvitationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InvitationSpec,
        )
    @spec.setter
    def spec(self, value: "InvitationSpec|invitation_pb2.InvitationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def no_send(self) -> "builtins.bool":
        """
        if set, no sending is attempted (it's supposed that later a Resend method is called)
        """
        
        return super()._get_field("no_send", explicit_presence=False,
        )
    @no_send.setter
    def no_send(self, value: "builtins.bool|None") -> None:
        return super()._set_field("no_send",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "no_send":"no_send",
    }
    
class GetInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.GetInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListInvitationsRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.ListInvitationsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListInvitationsRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListInvitationsResponse(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.ListInvitationsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListInvitationsResponse",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Invitation]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Invitation]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Invitation,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Invitation]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class DeleteInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.DeleteInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UpdateInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.UpdateInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "InvitationSpec|invitation_pb2.InvitationSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "InvitationSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=InvitationSpec,
        )
    @spec.setter
    def spec(self, value: "InvitationSpec|invitation_pb2.InvitationSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ResendInvitationRequest(pb_classes.Message):
    __PB2_CLASS__ = invitation_service_pb2.ResendInvitationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ResendInvitationRequest",invitation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class InvitationServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.InvitationService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.InvitationService",invitation_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.InvitationService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateInvitationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateInvitationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateInvitationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get(self,
        request: "GetInvitationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetInvitationRequest","Invitation"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetInvitationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Invitation`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=invitation_pb2.Invitation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Invitation),
        )
    
    def list(self,
        request: "ListInvitationsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListInvitationsRequest","ListInvitationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListInvitationsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListInvitationsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=invitation_service_pb2.ListInvitationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListInvitationsResponse),
        )
    
    def delete(self,
        request: "DeleteInvitationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteInvitationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteInvitationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def update(self,
        request: "UpdateInvitationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateInvitationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateInvitationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def resend(self,
        request: "ResendInvitationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ResendInvitationRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ResendInvitationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Resend",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/profile_service.proto
class GetProfileRequest(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.GetProfileRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetProfileRequest",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    
class GetProfileResponse(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.GetProfileResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetProfileResponse",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_profile__(pb_classes.OneOf):
        name: builtins.str= "profile"
        
        def __init__(self, msg: "GetProfileResponse") -> None:
            super().__init__()
            self._message: "GetProfileResponse" = msg
    
    class __OneOfClass_profile_user_profile__(__OneOfClass_profile__):
        field: typing.Literal["user_profile"] = "user_profile"
        
        def __init__(self, msg: "GetProfileResponse") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "UserProfile":
            return self._message.user_profile
    
    class __OneOfClass_profile_service_account_profile__(__OneOfClass_profile__):
        field: typing.Literal["service_account_profile"] = "service_account_profile"
        
        def __init__(self, msg: "GetProfileResponse") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ServiceAccountProfile":
            return self._message.service_account_profile
    
    class __OneOfClass_profile_anonymous_profile__(__OneOfClass_profile__):
        field: typing.Literal["anonymous_profile"] = "anonymous_profile"
        
        def __init__(self, msg: "GetProfileResponse") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "AnonymousAccount":
            return self._message.anonymous_profile
    
    @builtins.property
    def profile(self) -> __OneOfClass_profile_user_profile__|__OneOfClass_profile_service_account_profile__|__OneOfClass_profile_anonymous_profile__|None:
        field_name_1: str|None = super().which_field_in_oneof("profile")
        match field_name_1:
            case "user_profile":
                return self.__OneOfClass_profile_user_profile__(self)
            case "service_account_profile":
                return self.__OneOfClass_profile_service_account_profile__(self)
            case "anonymous_profile":
                return self.__OneOfClass_profile_anonymous_profile__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        user_profile: "UserProfile|profile_service_pb2.UserProfile|None|unset.UnsetType" = unset.Unset,
        service_account_profile: "ServiceAccountProfile|profile_service_pb2.ServiceAccountProfile|None|unset.UnsetType" = unset.Unset,
        anonymous_profile: "AnonymousAccount|profile_service_pb2.AnonymousAccount|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(user_profile, unset.UnsetType):
            self.user_profile = user_profile
        if not isinstance(service_account_profile, unset.UnsetType):
            self.service_account_profile = service_account_profile
        if not isinstance(anonymous_profile, unset.UnsetType):
            self.anonymous_profile = anonymous_profile
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "user_profile",
            "service_account_profile",
            "anonymous_profile",
            "profile",
        ]
    
    @builtins.property
    def user_profile(self) -> "UserProfile|None":
        return super()._get_field("user_profile", explicit_presence=True,
        wrap=UserProfile,
        )
    @user_profile.setter
    def user_profile(self, value: "UserProfile|profile_service_pb2.UserProfile|None") -> None:
        return super()._set_field("user_profile",value,explicit_presence=True,
        )
    
    @builtins.property
    def service_account_profile(self) -> "ServiceAccountProfile|None":
        return super()._get_field("service_account_profile", explicit_presence=True,
        wrap=ServiceAccountProfile,
        )
    @service_account_profile.setter
    def service_account_profile(self, value: "ServiceAccountProfile|profile_service_pb2.ServiceAccountProfile|None") -> None:
        return super()._set_field("service_account_profile",value,explicit_presence=True,
        )
    
    @builtins.property
    def anonymous_profile(self) -> "AnonymousAccount|None":
        return super()._get_field("anonymous_profile", explicit_presence=True,
        wrap=AnonymousAccount,
        )
    @anonymous_profile.setter
    def anonymous_profile(self, value: "AnonymousAccount|profile_service_pb2.AnonymousAccount|None") -> None:
        return super()._set_field("anonymous_profile",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "user_profile":"user_profile",
        "service_account_profile":"service_account_profile",
        "anonymous_profile":"anonymous_profile",
        "profile":"profile",
    }
    
class UserProfile(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.UserProfile
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserProfile",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_attributes_optional__(pb_classes.OneOf):
        name: builtins.str= "attributes_optional"
        
        def __init__(self, msg: "UserProfile") -> None:
            super().__init__()
            self._message: "UserProfile" = msg
    
    class __OneOfClass_attributes_optional_attributes__(__OneOfClass_attributes_optional__):
        field: typing.Literal["attributes"] = "attributes"
        
        def __init__(self, msg: "UserProfile") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "UserAttributes":
            return self._message.attributes
    
    class __OneOfClass_attributes_optional_retrieving_error__(__OneOfClass_attributes_optional__):
        field: typing.Literal["retrieving_error"] = "retrieving_error"
        
        def __init__(self, msg: "UserProfile") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "Error":
            return self._message.retrieving_error
    
    @builtins.property
    def attributes_optional(self) -> __OneOfClass_attributes_optional_attributes__|__OneOfClass_attributes_optional_retrieving_error__|None:
        field_name_1: str|None = super().which_field_in_oneof("attributes_optional")
        match field_name_1:
            case "attributes":
                return self.__OneOfClass_attributes_optional_attributes__(self)
            case "retrieving_error":
                return self.__OneOfClass_attributes_optional_retrieving_error__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        federation_info: "UserAccountExternalId|user_account_pb2.UserAccountExternalId|None|unset.UnsetType" = unset.Unset,
        attributes: "UserAttributes|tenant_user_account_pb2.UserAttributes|None|unset.UnsetType" = unset.Unset,
        retrieving_error: "Error|tenant_user_account_pb2.Error|None|unset.UnsetType" = unset.Unset,
        tenants: "abc.Iterable[UserTenantInfo]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(federation_info, unset.UnsetType):
            self.federation_info = federation_info
        if not isinstance(attributes, unset.UnsetType):
            self.attributes = attributes
        if not isinstance(retrieving_error, unset.UnsetType):
            self.retrieving_error = retrieving_error
        if not isinstance(tenants, unset.UnsetType):
            self.tenants = tenants
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "federation_info",
            "attributes",
            "retrieving_error",
            "tenants",
            "attributes_optional",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def federation_info(self) -> "UserAccountExternalId":
        return super()._get_field("federation_info", explicit_presence=False,
        wrap=UserAccountExternalId,
        )
    @federation_info.setter
    def federation_info(self, value: "UserAccountExternalId|user_account_pb2.UserAccountExternalId|None") -> None:
        return super()._set_field("federation_info",value,explicit_presence=False,
        )
    
    @builtins.property
    def attributes(self) -> "UserAttributes|None":
        return super()._get_field("attributes", explicit_presence=True,
        wrap=UserAttributes,
        )
    @attributes.setter
    def attributes(self, value: "UserAttributes|tenant_user_account_pb2.UserAttributes|None") -> None:
        return super()._set_field("attributes",value,explicit_presence=True,
        )
    
    @builtins.property
    def retrieving_error(self) -> "Error|None":
        return super()._get_field("retrieving_error", explicit_presence=True,
        wrap=Error,
        )
    @retrieving_error.setter
    def retrieving_error(self, value: "Error|tenant_user_account_pb2.Error|None") -> None:
        return super()._set_field("retrieving_error",value,explicit_presence=True,
        )
    
    @builtins.property
    def tenants(self) -> "abc.MutableSequence[UserTenantInfo]":
        return super()._get_field("tenants", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(UserTenantInfo,None,None),
        )
    @tenants.setter
    def tenants(self, value: "abc.Iterable[UserTenantInfo]|None") -> None:
        return super()._set_field("tenants",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "federation_info":"federation_info",
        "attributes":"attributes",
        "retrieving_error":"retrieving_error",
        "tenants":"tenants",
        "attributes_optional":"attributes_optional",
    }
    
class UserTenantInfo(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.UserTenantInfo
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UserTenantInfo",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        tenant_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        tenant_user_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(tenant_id, unset.UnsetType):
            self.tenant_id = tenant_id
        if not isinstance(tenant_user_account_id, unset.UnsetType):
            self.tenant_user_account_id = tenant_user_account_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "tenant_id",
            "tenant_user_account_id",
        ]
    
    @builtins.property
    def tenant_id(self) -> "builtins.str":
        return super()._get_field("tenant_id", explicit_presence=False,
        )
    @tenant_id.setter
    def tenant_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("tenant_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def tenant_user_account_id(self) -> "builtins.str":
        return super()._get_field("tenant_user_account_id", explicit_presence=False,
        )
    @tenant_user_account_id.setter
    def tenant_user_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("tenant_user_account_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "tenant_id":"tenant_id",
        "tenant_user_account_id":"tenant_user_account_id",
    }
    
class ServiceAccountProfile(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.ServiceAccountProfile
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ServiceAccountProfile",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        info: "ServiceAccount|service_account_pb2.ServiceAccount|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(info, unset.UnsetType):
            self.info = info
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "info",
        ]
    
    @builtins.property
    def info(self) -> "ServiceAccount":
        return super()._get_field("info", explicit_presence=False,
        wrap=ServiceAccount,
        )
    @info.setter
    def info(self, value: "ServiceAccount|service_account_pb2.ServiceAccount|None") -> None:
        return super()._set_field("info",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "info":"info",
    }
    
class AnonymousAccount(pb_classes.Message):
    __PB2_CLASS__ = profile_service_pb2.AnonymousAccount
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.AnonymousAccount",profile_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    

class ProfileServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.ProfileService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.ProfileService",profile_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.ProfileService"
    
    def get(self,
        request: "GetProfileRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetProfileRequest","GetProfileResponse"]:
        """
        Returns the current user's profile.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetProfileRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.GetProfileResponse`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=profile_service_pb2.GetProfileResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(GetProfileResponse),
        )
    

# file: nebius/iam/v1/project_service.proto
class CreateProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.CreateProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ContainerSpec|container_pb2.ContainerSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ContainerSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ContainerSpec,
        )
    @spec.setter
    def spec(self, value: "ContainerSpec|container_pb2.ContainerSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.GetProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetProjectByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.GetProjectByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetProjectByNameRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListProjectsRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.ListProjectsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListProjectsRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListProjectsRequest") -> None:
            super().__init__()
            self._message: "ListProjectsRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListProjectsRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class UpdateProjectRequest(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.UpdateProjectRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateProjectRequest",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ContainerSpec|container_pb2.ContainerSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ContainerSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ContainerSpec,
        )
    @spec.setter
    def spec(self, value: "ContainerSpec|container_pb2.ContainerSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class ListProjectsResponse(pb_classes.Message):
    __PB2_CLASS__ = project_service_pb2.ListProjectsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListProjectsResponse",project_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Container]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Container]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Container,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Container]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class ProjectServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.ProjectService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.ProjectService",project_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.ProjectService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateProjectRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateProjectRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateProjectRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get(self,
        request: "GetProjectRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetProjectRequest","Container"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetProjectRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Container`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=container_pb2.Container,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Container),
        )
    
    def get_by_name(self,
        request: "GetProjectByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetProjectByNameRequest","Container"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetProjectByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Container`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=container_pb2.Container,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Container),
        )
    
    def list(self,
        request: "ListProjectsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListProjectsRequest","ListProjectsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListProjectsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListProjectsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=project_service_pb2.ListProjectsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListProjectsResponse),
        )
    
    def update(self,
        request: "UpdateProjectRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateProjectRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateProjectRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/service_account_service.proto
class CreateServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.CreateServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ServiceAccountSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ServiceAccountSpec,
        )
    @spec.setter
    def spec(self, value: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class GetServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.GetServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetServiceAccountByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.GetServiceAccountByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetServiceAccountByNameRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class ListServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.ListServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListServiceAccountRequest") -> None:
            super().__init__()
            self._message: "ListServiceAccountRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListServiceAccountRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class UpdateServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.UpdateServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UpdateServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "ServiceAccountSpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=ServiceAccountSpec,
        )
    @spec.setter
    def spec(self, value: "ServiceAccountSpec|service_account_pb2.ServiceAccountSpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class DeleteServiceAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.DeleteServiceAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteServiceAccountRequest",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListServiceAccountResponse(pb_classes.Message):
    __PB2_CLASS__ = service_account_service_pb2.ListServiceAccountResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListServiceAccountResponse",service_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[ServiceAccount]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[ServiceAccount]":
        """
        List of service accounts returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(ServiceAccount,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[ServiceAccount]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class ServiceAccountServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.ServiceAccountService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.ServiceAccountService",service_account_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.ServiceAccountService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Create"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def create(self,
        request: "CreateServiceAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["CreateServiceAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.CreateServiceAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Create",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def get(self,
        request: "GetServiceAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetServiceAccountRequest","ServiceAccount"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetServiceAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ServiceAccount`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=service_account_pb2.ServiceAccount,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ServiceAccount),
        )
    
    def get_by_name(self,
        request: "GetServiceAccountByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetServiceAccountByNameRequest","ServiceAccount"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetServiceAccountByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ServiceAccount`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=service_account_pb2.ServiceAccount,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ServiceAccount),
        )
    
    def list(self,
        request: "ListServiceAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListServiceAccountRequest","ListServiceAccountResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListServiceAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListServiceAccountResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=service_account_service_pb2.ListServiceAccountResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListServiceAccountResponse),
        )
    
    def update(self,
        request: "UpdateServiceAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UpdateServiceAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UpdateServiceAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        metadata = fieldmask_protobuf.ensure_reset_mask_in_metadata(request, metadata)
        return super().request(
            method="Update",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def delete(self,
        request: "DeleteServiceAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteServiceAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteServiceAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/session_management_service.proto
class RevokeSessionRequest(pb_classes.Message):
    __PB2_CLASS__ = session_management_service_pb2.RevokeSessionRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.RevokeSessionRequest",session_management_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_revoke__(pb_classes.OneOf):
        name: builtins.str= "revoke"
        
        def __init__(self, msg: "RevokeSessionRequest") -> None:
            super().__init__()
            self._message: "RevokeSessionRequest" = msg
    
    class __OneOfClass_revoke_service_account_id__(__OneOfClass_revoke__):
        field: typing.Literal["service_account_id"] = "service_account_id"
        
        def __init__(self, msg: "RevokeSessionRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.service_account_id
    
    class __OneOfClass_revoke_all_my_active__(__OneOfClass_revoke__):
        field: typing.Literal["all_my_active"] = "all_my_active"
        
        def __init__(self, msg: "RevokeSessionRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.bool":
            return self._message.all_my_active
    
    class __OneOfClass_revoke_tenant_user_account_id__(__OneOfClass_revoke__):
        field: typing.Literal["tenant_user_account_id"] = "tenant_user_account_id"
        
        def __init__(self, msg: "RevokeSessionRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.tenant_user_account_id
    
    @builtins.property
    def revoke(self) -> __OneOfClass_revoke_service_account_id__|__OneOfClass_revoke_all_my_active__|__OneOfClass_revoke_tenant_user_account_id__|None:
        field_name_1: str|None = super().which_field_in_oneof("revoke")
        match field_name_1:
            case "service_account_id":
                return self.__OneOfClass_revoke_service_account_id__(self)
            case "all_my_active":
                return self.__OneOfClass_revoke_all_my_active__(self)
            case "tenant_user_account_id":
                return self.__OneOfClass_revoke_tenant_user_account_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        service_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        all_my_active: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        tenant_user_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(service_account_id, unset.UnsetType):
            self.service_account_id = service_account_id
        if not isinstance(all_my_active, unset.UnsetType):
            self.all_my_active = all_my_active
        if not isinstance(tenant_user_account_id, unset.UnsetType):
            self.tenant_user_account_id = tenant_user_account_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "service_account_id",
            "all_my_active",
            "tenant_user_account_id",
            "revoke",
        ]
    
    @builtins.property
    def service_account_id(self) -> "builtins.str|None":
        """
        revoke all for specific service account - to revoke logout from all sessions for user
        """
        
        return super()._get_field("service_account_id", explicit_presence=True,
        )
    @service_account_id.setter
    def service_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("service_account_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def all_my_active(self) -> "builtins.bool|None":
        """
        revoke all active session of current user
        """
        
        return super()._get_field("all_my_active", explicit_presence=True,
        )
    @all_my_active.setter
    def all_my_active(self, value: "builtins.bool|None") -> None:
        return super()._set_field("all_my_active",value,explicit_presence=True,
        )
    
    @builtins.property
    def tenant_user_account_id(self) -> "builtins.str|None":
        """
        revoke all for specific tenant user - to revoke logout from all sessions for user
        """
        
        return super()._get_field("tenant_user_account_id", explicit_presence=True,
        )
    @tenant_user_account_id.setter
    def tenant_user_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("tenant_user_account_id",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "service_account_id":"service_account_id",
        "all_my_active":"all_my_active",
        "tenant_user_account_id":"tenant_user_account_id",
        "revoke":"revoke",
    }
    
class RevokeSessionResponse(pb_classes.Message):
    __PB2_CLASS__ = session_management_service_pb2.RevokeSessionResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.RevokeSessionResponse",session_management_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
    ) -> None:
        super().__init__(initial_message)
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
        ]
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
    }
    

class SessionManagementServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.SessionManagementService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.SessionManagementService",session_management_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.SessionManagementService"
    
    def revoke(self,
        request: "RevokeSessionRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["RevokeSessionRequest","RevokeSessionResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.RevokeSessionRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.RevokeSessionResponse`.
        """
        
        return super().request(
            method="Revoke",
            request=request,
            result_pb2_class=session_management_service_pb2.RevokeSessionResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(RevokeSessionResponse),
        )
    

# file: nebius/iam/v1/static_key.proto
class StaticKey(pb_classes.Message):
    __PB2_CLASS__ = static_key_pb2.StaticKey
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.StaticKey",static_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "StaticKeySpec|static_key_pb2.StaticKeySpec|None|unset.UnsetType" = unset.Unset,
        status: "StaticKeyStatus|static_key_pb2.StaticKeyStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
            "status",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "StaticKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=StaticKeySpec,
        )
    @spec.setter
    def spec(self, value: "StaticKeySpec|static_key_pb2.StaticKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "StaticKeyStatus":
        return super()._get_field("status", explicit_presence=False,
        wrap=StaticKeyStatus,
        )
    @status.setter
    def status(self, value: "StaticKeyStatus|static_key_pb2.StaticKeyStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
        "status":"status",
    }
    
class StaticKeySpec(pb_classes.Message):
    __PB2_CLASS__ = static_key_pb2.StaticKeySpec
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.StaticKeySpec",static_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "expiresAt": well_known_1.ts_mask,
    }
    
    class ClientService(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.iam.v1.StaticKeySpec.ClientService",static_key_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        CLIENT_SERVICE_UNSPECIFIED = 0
        OBSERVABILITY = 1
        CONTAINER_REGISTRY = 2
        AI_STUDIO = 3
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        account: "Account|access_pb2.Account|None|unset.UnsetType" = unset.Unset,
        service: "StaticKeySpec.ClientService|static_key_pb2.StaticKeySpec.ClientService|None|unset.UnsetType" = unset.Unset,
        expiresAt: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(account, unset.UnsetType):
            self.account = account
        if not isinstance(service, unset.UnsetType):
            self.service = service
        if not isinstance(expiresAt, unset.UnsetType):
            self.expiresAt = expiresAt
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "account",
            "service",
            "expiresAt",
            "ClientService",
        ]
    
    @builtins.property
    def account(self) -> "Account":
        """
        account of the static key. only service accounts are supported for now
        """
        
        return super()._get_field("account", explicit_presence=False,
        wrap=Account,
        )
    @account.setter
    def account(self, value: "Account|access_pb2.Account|None") -> None:
        return super()._set_field("account",value,explicit_presence=False,
        )
    
    @builtins.property
    def service(self) -> "StaticKeySpec.ClientService":
        """
        service static key is to be used for
        """
        
        return super()._get_field("service", explicit_presence=False,
        wrap=StaticKeySpec.ClientService,
        )
    @service.setter
    def service(self, value: "StaticKeySpec.ClientService|static_key_pb2.StaticKeySpec.ClientService|None") -> None:
        return super()._set_field("service",value,explicit_presence=False,
        )
    
    @builtins.property
    def expiresAt(self) -> "datetime.datetime":
        """
        when will the static key expire
        """
        
        return super()._get_field("expiresAt", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @expiresAt.setter
    def expiresAt(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("expiresAt",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "account":"account",
        "service":"service",
        "expiresAt":"expiresAt",
        "ClientService":"ClientService",
    }
    
class StaticKeyStatus(pb_classes.Message):
    __PB2_CLASS__ = static_key_pb2.StaticKeyStatus
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.StaticKeyStatus",static_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        active: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(active, unset.UnsetType):
            self.active = active
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "active",
        ]
    
    @builtins.property
    def active(self) -> "builtins.bool":
        return super()._get_field("active", explicit_presence=False,
        )
    @active.setter
    def active(self, value: "builtins.bool|None") -> None:
        return super()._set_field("active",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "active":"active",
    }
    
# file: nebius/iam/v1/static_key_service.proto
class GetStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.GetStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        id of the static key
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class GetStaticKeyByNameRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.GetStaticKeyByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetStaticKeyByNameRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        id of the parent container (service account)
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        name of the static key
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
class DeleteStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.DeleteStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.DeleteStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        id of the static key to delete
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListStaticKeysRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.ListStaticKeysRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListStaticKeysRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the container ID.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListStaticKeysResponse(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.ListStaticKeysResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListStaticKeysResponse",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[StaticKey]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[StaticKey]":
        """
        List of static keys returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(StaticKey,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[StaticKey]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class IssueStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.IssueStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.IssueStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        spec: "StaticKeySpec|static_key_pb2.StaticKeySpec|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(spec, unset.UnsetType):
            self.spec = spec
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "spec",
        ]
    
    @builtins.property
    def metadata(self) -> "v1_1.ResourceMetadata":
        return super()._get_field("metadata", explicit_presence=False,
        wrap=v1_1.ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "v1_1.ResourceMetadata|metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec(self) -> "StaticKeySpec":
        return super()._get_field("spec", explicit_presence=False,
        wrap=StaticKeySpec,
        )
    @spec.setter
    def spec(self, value: "StaticKeySpec|static_key_pb2.StaticKeySpec|None") -> None:
        return super()._set_field("spec",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "spec":"spec",
    }
    
class IssueStaticKeyResponse(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.IssueStaticKeyResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.IssueStaticKeyResponse",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        operation: "v1_1.Operation|operation_pb2.Operation|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(token, unset.UnsetType):
            self.token = token
        if not isinstance(operation, unset.UnsetType):
            self.operation = operation
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "token",
            "operation",
        ]
    
    @builtins.property
    def token(self) -> "builtins.str":
        return super()._get_field("token", explicit_presence=False,
        )
    @token.setter
    def token(self, value: "builtins.str|None") -> None:
        return super()._set_field("token",value,explicit_presence=False,
        )
    
    @builtins.property
    def operation(self) -> "v1_1.Operation":
        return super()._get_field("operation", explicit_presence=False,
        wrap=v1_1.Operation,
        )
    @operation.setter
    def operation(self, value: "v1_1.Operation|operation_pb2.Operation|None") -> None:
        return super()._set_field("operation",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "token":"token",
        "operation":"operation",
    }
    
class FindStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.FindStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FindStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(token, unset.UnsetType):
            self.token = token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "token",
        ]
    
    @builtins.property
    def token(self) -> "builtins.str":
        """
        the method accepts a static key token with and without signature as an input
        """
        
        return super()._get_field("token", explicit_presence=False,
        )
    @token.setter
    def token(self, value: "builtins.str|None") -> None:
        return super()._set_field("token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "token":"token",
    }
    
class FindStaticKeyResponse(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.FindStaticKeyResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.FindStaticKeyResponse",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        static_key: "StaticKey|static_key_pb2.StaticKey|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(static_key, unset.UnsetType):
            self.static_key = static_key
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "static_key",
        ]
    
    @builtins.property
    def static_key(self) -> "StaticKey":
        return super()._get_field("static_key", explicit_presence=False,
        wrap=StaticKey,
        )
    @static_key.setter
    def static_key(self, value: "StaticKey|static_key_pb2.StaticKey|None") -> None:
        return super()._set_field("static_key",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "static_key":"static_key",
    }
    
class RevokeStaticKeyRequest(pb_classes.Message):
    __PB2_CLASS__ = static_key_service_pb2.RevokeStaticKeyRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.RevokeStaticKeyRequest",static_key_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(token, unset.UnsetType):
            self.token = token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "token",
        ]
    
    @builtins.property
    def token(self) -> "builtins.str":
        """
        the method accepts a static key token with and without signature as an input
        """
        
        return super()._get_field("token", explicit_presence=False,
        )
    @token.setter
    def token(self, value: "builtins.str|None") -> None:
        return super()._set_field("token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "token":"token",
    }
    

class StaticKeyServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.StaticKeyService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.StaticKeyService",static_key_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.StaticKeyService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Delete"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def issue(self,
        request: "IssueStaticKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["IssueStaticKeyRequest","IssueStaticKeyResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.IssueStaticKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.IssueStaticKeyResponse`.
        """
        
        return super().request(
            method="Issue",
            request=request,
            result_pb2_class=static_key_service_pb2.IssueStaticKeyResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(IssueStaticKeyResponse),
        )
    
    def list(self,
        request: "ListStaticKeysRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListStaticKeysRequest","ListStaticKeysResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListStaticKeysRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListStaticKeysResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=static_key_service_pb2.ListStaticKeysResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListStaticKeysResponse),
        )
    
    def get(self,
        request: "GetStaticKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetStaticKeyRequest","StaticKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetStaticKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.StaticKey`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=static_key_pb2.StaticKey,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(StaticKey),
        )
    
    def get_by_name(self,
        request: "GetStaticKeyByNameRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetStaticKeyByNameRequest","StaticKey"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetStaticKeyByNameRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.StaticKey`.
        """
        
        return super().request(
            method="GetByName",
            request=request,
            result_pb2_class=static_key_pb2.StaticKey,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(StaticKey),
        )
    
    def delete(self,
        request: "DeleteStaticKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["DeleteStaticKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.DeleteStaticKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Delete",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def find(self,
        request: "FindStaticKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["FindStaticKeyRequest","FindStaticKeyResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.FindStaticKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.FindStaticKeyResponse`.
        """
        
        return super().request(
            method="Find",
            request=request,
            result_pb2_class=static_key_service_pb2.FindStaticKeyResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(FindStaticKeyResponse),
        )
    
    def revoke(self,
        request: "RevokeStaticKeyRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["RevokeStaticKeyRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.RevokeStaticKeyRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Revoke",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/tenant_service.proto
class GetTenantRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.GetTenantRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetTenantRequest",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListTenantsRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.ListTenantsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantsRequest",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListTenantsRequest") -> None:
            super().__init__()
            self._message: "ListTenantsRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListTenantsRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        A filter to narrow down the results based on specific criteria.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class ListTenantsResponse(pb_classes.Message):
    __PB2_CLASS__ = tenant_service_pb2.ListTenantsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantsResponse",tenant_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[Container]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[Container]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Container,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[Container]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class TenantServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.TenantService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.TenantService",tenant_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.TenantService"
    
    def get(self,
        request: "GetTenantRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetTenantRequest","Container"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetTenantRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.Container`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=container_pb2.Container,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(Container),
        )
    
    def list(self,
        request: "ListTenantsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListTenantsRequest","ListTenantsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListTenantsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListTenantsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=tenant_service_pb2.ListTenantsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListTenantsResponse),
        )
    

# file: nebius/iam/v1/tenant_user_account_service.proto
class GetTenantUserAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.GetTenantUserAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetTenantUserAccountRequest",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        tenant user account id like 'tenantuseraccount-{region}someuniquesuffix'
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListTenantUserAccountsRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.ListTenantUserAccountsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantUserAccountsRequest",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListTenantUserAccountsRequest") -> None:
            super().__init__()
            self._message: "ListTenantUserAccountsRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListTenantUserAccountsRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the tenant ID like 'tenant-someuniqueprefix'
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class ListTenantUserAccountsResponse(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.ListTenantUserAccountsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantUserAccountsResponse",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[TenantUserAccount]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[TenantUserAccount]":
        """
        List of service accounts returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(TenantUserAccount,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[TenantUserAccount]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    
class BlockTenantUserAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.BlockTenantUserAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.BlockTenantUserAccountRequest",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class UnblockTenantUserAccountRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_service_pb2.UnblockTenantUserAccountRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.UnblockTenantUserAccountRequest",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    

class TenantUserAccountServiceClient(client.ClientWithOperations[v1_1.Operation,v1_1.OperationServiceClient]):
    """
    This class provides the client methods for the ``.nebius.iam.v1.TenantUserAccountService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.TenantUserAccountService",tenant_user_account_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.TenantUserAccountService"
    __operation_type__ = v1_1.Operation
    __operation_service_class__ = v1_1.OperationServiceClient
    __operation_source_method__ = "Block"
    """The method name that can be used to fetch the address channel for the operation."""
    
    def get(self,
        request: "GetTenantUserAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetTenantUserAccountRequest","TenantUserAccount"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetTenantUserAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.TenantUserAccount`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=tenant_user_account_pb2.TenantUserAccount,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(TenantUserAccount),
        )
    
    def list(self,
        request: "ListTenantUserAccountsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListTenantUserAccountsRequest","ListTenantUserAccountsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListTenantUserAccountsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListTenantUserAccountsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=tenant_user_account_service_pb2.ListTenantUserAccountsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListTenantUserAccountsResponse),
        )
    
    def block(self,
        request: "BlockTenantUserAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["BlockTenantUserAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.BlockTenantUserAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Block",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    
    def unblock(self,
        request: "UnblockTenantUserAccountRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["UnblockTenantUserAccountRequest","operation_1.Operation[v1_1.Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.UnblockTenantUserAccountRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Unblock",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation_1.Operation,
        )
    

# file: nebius/iam/v1/tenant_user_account_with_attributes_service.proto
class GetTenantUserAccountWithAttributesRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_with_attributes_service_pb2.GetTenantUserAccountWithAttributesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.GetTenantUserAccountWithAttributesRequest",tenant_user_account_with_attributes_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        tenant user account id like 'tenantuseraccount-{region}someuniquesuffix'
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListTenantUserAccountsWithAttributesRequest(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_with_attributes_service_pb2.ListTenantUserAccountsWithAttributesRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantUserAccountsWithAttributesRequest",tenant_user_account_with_attributes_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass__page_size__(pb_classes.OneOf):
        name: builtins.str= "_page_size"
        
        def __init__(self, msg: "ListTenantUserAccountsWithAttributesRequest") -> None:
            super().__init__()
            self._message: "ListTenantUserAccountsWithAttributesRequest" = msg
    
    class __OneOfClass__page_size_page_size__(__OneOfClass__page_size__):
        field: typing.Literal["page_size"] = "page_size"
        
        def __init__(self, msg: "ListTenantUserAccountsWithAttributesRequest") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.int":
            return self._message.page_size
    
    @builtins.property
    def _page_size(self) -> __OneOfClass__page_size_page_size__|None:
        field_name_1: str|None = super().which_field_in_oneof("_page_size")
        match field_name_1:
            case "page_size":
                return self.__OneOfClass__page_size_page_size__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
            "_page_size",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Represents the tenant ID like 'tenant-{region}someuniquesuffix'
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int|None":
        """
        Specifies the maximum number of items to return in the response.
        Default value: 10
        """
        
        return super()._get_field("page_size", explicit_presence=True,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=True,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Token for pagination, allowing the retrieval of the next set of results.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
        "_page_size":"_page_size",
    }
    
class ListTenantUserAccountsWithAttributesResponse(pb_classes.Message):
    __PB2_CLASS__ = tenant_user_account_with_attributes_service_pb2.ListTenantUserAccountsWithAttributesResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ListTenantUserAccountsWithAttributesResponse",tenant_user_account_with_attributes_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[TenantUserAccountWithAttributes]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[TenantUserAccountWithAttributes]":
        """
        List of user accounts returned in the response. The field should be named as ``items`` for consistency.
        """
        
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(TenantUserAccountWithAttributes,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[TenantUserAccountWithAttributes]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Token for pagination, indicating the next set of results can be retrieved using this token.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class TenantUserAccountWithAttributesServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.TenantUserAccountWithAttributesService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.TenantUserAccountWithAttributesService",tenant_user_account_with_attributes_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.TenantUserAccountWithAttributesService"
    
    def get(self,
        request: "GetTenantUserAccountWithAttributesRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetTenantUserAccountWithAttributesRequest","TenantUserAccountWithAttributes"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.GetTenantUserAccountWithAttributesRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.TenantUserAccountWithAttributes`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=tenant_user_account_pb2.TenantUserAccountWithAttributes,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(TenantUserAccountWithAttributes),
        )
    
    def list(self,
        request: "ListTenantUserAccountsWithAttributesRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListTenantUserAccountsWithAttributesRequest","ListTenantUserAccountsWithAttributesResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ListTenantUserAccountsWithAttributesRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.ListTenantUserAccountsWithAttributesResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=tenant_user_account_with_attributes_service_pb2.ListTenantUserAccountsWithAttributesResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListTenantUserAccountsWithAttributesResponse),
        )
    

# file: nebius/iam/v1/token_service.proto
class ExchangeTokenRequest(pb_classes.Message):
    """
    https://www.rfc-editor.org/rfc/rfc8693.html
    """
    
    __PB2_CLASS__ = token_service_pb2.ExchangeTokenRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.ExchangeTokenRequest",token_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        grant_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        requested_token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        subject_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        subject_token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        scopes: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        audience: "builtins.str|None|unset.UnsetType" = unset.Unset,
        actor_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        actor_token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(grant_type, unset.UnsetType):
            self.grant_type = grant_type
        if not isinstance(requested_token_type, unset.UnsetType):
            self.requested_token_type = requested_token_type
        if not isinstance(subject_token, unset.UnsetType):
            self.subject_token = subject_token
        if not isinstance(subject_token_type, unset.UnsetType):
            self.subject_token_type = subject_token_type
        if not isinstance(scopes, unset.UnsetType):
            self.scopes = scopes
        if not isinstance(audience, unset.UnsetType):
            self.audience = audience
        if not isinstance(actor_token, unset.UnsetType):
            self.actor_token = actor_token
        if not isinstance(actor_token_type, unset.UnsetType):
            self.actor_token_type = actor_token_type
        if not isinstance(resource, unset.UnsetType):
            self.resource = resource
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "grant_type",
            "requested_token_type",
            "subject_token",
            "subject_token_type",
            "scopes",
            "audience",
            "actor_token",
            "actor_token_type",
            "resource",
        ]
    
    @builtins.property
    def grant_type(self) -> "builtins.str":
        """
        required - urn:ietf:params:oauth:grant-type:token-exchange
        """
        
        return super()._get_field("grant_type", explicit_presence=False,
        )
    @grant_type.setter
    def grant_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("grant_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def requested_token_type(self) -> "builtins.str":
        """
        optional type of requested token, default is urn:ietf:params:oauth:token-type:access_token
        """
        
        return super()._get_field("requested_token_type", explicit_presence=False,
        )
    @requested_token_type.setter
    def requested_token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("requested_token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def subject_token(self) -> "builtins.str":
        """
        required - could be self signed JWT token
        """
        
        return super()._get_field("subject_token", explicit_presence=False,
        )
    @subject_token.setter
    def subject_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("subject_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def subject_token_type(self) -> "builtins.str":
        """
        required, in case of jwt - urn:ietf:params:oauth:token-type:jwt
        """
        
        return super()._get_field("subject_token_type", explicit_presence=False,
        )
    @subject_token_type.setter
    def subject_token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("subject_token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def scopes(self) -> "abc.MutableSequence[builtins.str]":
        """
        optional (scopes of the token)
        """
        
        return super()._get_field("scopes", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @scopes.setter
    def scopes(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("scopes",value,explicit_presence=False,
        )
    
    @builtins.property
    def audience(self) -> "builtins.str":
        """
        optional, name of the oauth client id on which this token will be used
        """
        
        return super()._get_field("audience", explicit_presence=False,
        )
    @audience.setter
    def audience(self, value: "builtins.str|None") -> None:
        return super()._set_field("audience",value,explicit_presence=False,
        )
    
    @builtins.property
    def actor_token(self) -> "builtins.str":
        """
        optional, subject token for impersonation/delegation (who want to impersonate/delegate) in subject_token.
        """
        
        return super()._get_field("actor_token", explicit_presence=False,
        )
    @actor_token.setter
    def actor_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("actor_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def actor_token_type(self) -> "builtins.str":
        """
        optional, token type for the impersonation/delegation (who want to impersonate/delegate). Usually it's urn:ietf:params:oauth:token-type:access_token
        """
        
        return super()._get_field("actor_token_type", explicit_presence=False,
        )
    @actor_token_type.setter
    def actor_token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("actor_token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource(self) -> "abc.MutableSequence[builtins.str]":
        """
        optional, list of resources approved to use by token, if applicable
        """
        
        return super()._get_field("resource", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @resource.setter
    def resource(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("resource",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "grant_type":"grant_type",
        "requested_token_type":"requested_token_type",
        "subject_token":"subject_token",
        "subject_token_type":"subject_token_type",
        "scopes":"scopes",
        "audience":"audience",
        "actor_token":"actor_token",
        "actor_token_type":"actor_token_type",
        "resource":"resource",
    }
    
class CreateTokenResponse(pb_classes.Message):
    __PB2_CLASS__ = token_service_pb2.CreateTokenResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.iam.v1.CreateTokenResponse",token_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        access_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        issued_token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        token_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        expires_in: "builtins.int|None|unset.UnsetType" = unset.Unset,
        scopes: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(access_token, unset.UnsetType):
            self.access_token = access_token
        if not isinstance(issued_token_type, unset.UnsetType):
            self.issued_token_type = issued_token_type
        if not isinstance(token_type, unset.UnsetType):
            self.token_type = token_type
        if not isinstance(expires_in, unset.UnsetType):
            self.expires_in = expires_in
        if not isinstance(scopes, unset.UnsetType):
            self.scopes = scopes
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "access_token",
            "issued_token_type",
            "token_type",
            "expires_in",
            "scopes",
        ]
    
    @builtins.property
    def access_token(self) -> "builtins.str":
        """
        required
        """
        
        return super()._get_field("access_token", explicit_presence=False,
        )
    @access_token.setter
    def access_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("access_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def issued_token_type(self) -> "builtins.str":
        """
        required
        """
        
        return super()._get_field("issued_token_type", explicit_presence=False,
        )
    @issued_token_type.setter
    def issued_token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("issued_token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def token_type(self) -> "builtins.str":
        """
        required - Bearer
        """
        
        return super()._get_field("token_type", explicit_presence=False,
        )
    @token_type.setter
    def token_type(self, value: "builtins.str|None") -> None:
        return super()._set_field("token_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def expires_in(self) -> "builtins.int":
        return super()._get_field("expires_in", explicit_presence=False,
        )
    @expires_in.setter
    def expires_in(self, value: "builtins.int|None") -> None:
        return super()._set_field("expires_in",value,explicit_presence=False,
        )
    
    @builtins.property
    def scopes(self) -> "abc.MutableSequence[builtins.str]":
        return super()._get_field("scopes", explicit_presence=False,
        wrap=pb_classes.Repeated,
        )
    @scopes.setter
    def scopes(self, value: "abc.Iterable[builtins.str]|None") -> None:
        return super()._set_field("scopes",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "access_token":"access_token",
        "issued_token_type":"issued_token_type",
        "token_type":"token_type",
        "expires_in":"expires_in",
        "scopes":"scopes",
    }
    
# file: nebius/iam/v1/token_exchange_service.proto

class TokenExchangeServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.iam.v1.TokenExchangeService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.iam.v1.TokenExchangeService",token_exchange_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.iam.v1.TokenExchangeService"
    
    def exchange(self,
        request: "ExchangeTokenRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ExchangeTokenRequest","CreateTokenResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.iam.v1.ExchangeTokenRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.iam.v1.CreateTokenResponse`.
        """
        
        return super().request(
            method="Exchange",
            request=request,
            result_pb2_class=token_service_pb2.CreateTokenResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(CreateTokenResponse),
        )
    

__all__ = [
    #@ local import names here @#
    "Account",
    "AccessKey",
    "AccessKeySpec",
    "AccessKeyStatus",
    "CreateAccessKeyRequest",
    "KeyIdentity",
    "GetAccessKeySecretOnceRequest",
    "GetAccessKeyByIdRequest",
    "GetAccessKeyByAwsIdRequest",
    "ListAccessKeysRequest",
    "ListAccessKeysByAccountRequest",
    "UpdateAccessKeyRequest",
    "ActivateAccessKeyRequest",
    "DeactivateAccessKeyRequest",
    "DeleteAccessKeyRequest",
    "GetAccessKeySecretOnceResponse",
    "ListAccessKeysResponse",
    "AccessKeyServiceClient",
    "AccessPermit",
    "AccessPermitSpec",
    "AccessPermitStatus",
    "CreateAccessPermitRequest",
    "ListAccessPermitRequest",
    "DeleteAccessPermitRequest",
    "GetAccessPermitRequest",
    "ListAccessPermitResponse",
    "AccessPermitServiceClient",
    "AuthPublicKey",
    "AuthPublicKeySpec",
    "AuthPublicKeyStatus",
    "CreateAuthPublicKeyRequest",
    "GetAuthPublicKeyRequest",
    "ListAuthPublicKeyRequest",
    "ListAuthPublicKeyByAccountRequest",
    "UpdateAuthPublicKeyRequest",
    "ActivateAuthPublicKeyRequest",
    "DeactivateAuthPublicKeyRequest",
    "DeleteAuthPublicKeyRequest",
    "ListAuthPublicKeyResponse",
    "AuthPublicKeyServiceClient",
    "State",
    "SuspensionState",
    "Container",
    "ContainerSpec",
    "ContainerStatus",
    "FederatedCredentials",
    "FederatedCredentialsSpec",
    "OidcCredentialsProvider",
    "FederatedCredentialsStatus",
    "GetFederatedCredentialsRequest",
    "GetByNameFederatedCredentialsRequest",
    "CreateFederatedCredentialsRequest",
    "UpdateFederatedCredentialsRequest",
    "ListFederatedCredentialsRequest",
    "ListFederatedCredentialsResponse",
    "DeleteFederatedCredentialsRequest",
    "FederatedCredentialsServiceClient",
    "Federation",
    "FederationSpec",
    "SamlSettings",
    "FederationStatus",
    "FederationCertificate",
    "FederationCertificateSpec",
    "FederationCertificateStatus",
    "CreateFederationCertificateRequest",
    "GetFederationCertificateRequest",
    "ListFederationCertificateByFederationRequest",
    "UpdateFederationCertificateRequest",
    "DeleteFederationCertificateRequest",
    "ListFederationCertificateResponse",
    "FederationCertificateServiceClient",
    "CreateFederationRequest",
    "GetFederationRequest",
    "ListFederationsRequest",
    "ListFederationsResponse",
    "UpdateFederationRequest",
    "DeleteFederationRequest",
    "FederationServiceClient",
    "Group",
    "GroupSpec",
    "GroupStatus",
    "ServiceAccount",
    "ServiceAccountSpec",
    "ServiceAccountStatus",
    "ServiceAccountAttributes",
    "UserAccountExternalId",
    "UserAccountStatus",
    "TenantUserAccount",
    "TenantUserAccountWithAttributes",
    "UserAttributes",
    "Error",
    "TenantUserAccountSpec",
    "TenantUserAccountStatus",
    "GroupMembership",
    "GroupMembershipSpec",
    "GroupMembershipStatus",
    "GroupMemberKind",
    "GroupMembershipWithAttributes",
    "CreateGroupMembershipRequest",
    "DeleteGroupMembershipRequest",
    "GetGroupMembershipRequest",
    "ListGroupMembershipsRequest",
    "ListMemberOfRequest",
    "ListGroupMembershipsResponse",
    "ListGroupMembershipsWithAttributesResponse",
    "ListMemberOfResponse",
    "GroupMembershipServiceClient",
    "CreateGroupRequest",
    "GetGroupRequest",
    "GetGroupByNameRequest",
    "ListGroupsRequest",
    "ListGroupsResponse",
    "DeleteGroupRequest",
    "UpdateGroupRequest",
    "GroupServiceClient",
    "Invitation",
    "InvitationSpec",
    "InvitationStatus",
    "CreateInvitationRequest",
    "GetInvitationRequest",
    "ListInvitationsRequest",
    "ListInvitationsResponse",
    "DeleteInvitationRequest",
    "UpdateInvitationRequest",
    "ResendInvitationRequest",
    "InvitationServiceClient",
    "GetProfileRequest",
    "GetProfileResponse",
    "UserProfile",
    "UserTenantInfo",
    "ServiceAccountProfile",
    "AnonymousAccount",
    "ProfileServiceClient",
    "CreateProjectRequest",
    "GetProjectRequest",
    "GetProjectByNameRequest",
    "ListProjectsRequest",
    "UpdateProjectRequest",
    "ListProjectsResponse",
    "ProjectServiceClient",
    "CreateServiceAccountRequest",
    "GetServiceAccountRequest",
    "GetServiceAccountByNameRequest",
    "ListServiceAccountRequest",
    "UpdateServiceAccountRequest",
    "DeleteServiceAccountRequest",
    "ListServiceAccountResponse",
    "ServiceAccountServiceClient",
    "RevokeSessionRequest",
    "RevokeSessionResponse",
    "SessionManagementServiceClient",
    "StaticKey",
    "StaticKeySpec",
    "StaticKeyStatus",
    "GetStaticKeyRequest",
    "GetStaticKeyByNameRequest",
    "DeleteStaticKeyRequest",
    "ListStaticKeysRequest",
    "ListStaticKeysResponse",
    "IssueStaticKeyRequest",
    "IssueStaticKeyResponse",
    "FindStaticKeyRequest",
    "FindStaticKeyResponse",
    "RevokeStaticKeyRequest",
    "StaticKeyServiceClient",
    "GetTenantRequest",
    "ListTenantsRequest",
    "ListTenantsResponse",
    "TenantServiceClient",
    "GetTenantUserAccountRequest",
    "ListTenantUserAccountsRequest",
    "ListTenantUserAccountsResponse",
    "BlockTenantUserAccountRequest",
    "UnblockTenantUserAccountRequest",
    "TenantUserAccountServiceClient",
    "GetTenantUserAccountWithAttributesRequest",
    "ListTenantUserAccountsWithAttributesRequest",
    "ListTenantUserAccountsWithAttributesResponse",
    "TenantUserAccountWithAttributesServiceClient",
    "ExchangeTokenRequest",
    "CreateTokenResponse",
    "TokenExchangeServiceClient",
]
