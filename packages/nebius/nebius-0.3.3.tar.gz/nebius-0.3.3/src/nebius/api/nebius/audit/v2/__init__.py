# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.audit.v2``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import google.protobuf.struct_pb2 as struct_pb2
import google.protobuf.timestamp_pb2 as timestamp_pb2
import google.rpc.code_pb2 as code_pb2
import grpc as grpc
import nebius.aio.client as client
import nebius.aio.request as request_1
import nebius.api.nebius.audit.v2.access_token_pb2 as access_token_pb2
import nebius.api.nebius.audit.v2.audit_event_pb2 as audit_event_pb2
import nebius.api.nebius.audit.v2.audit_event_service_pb2 as audit_event_service_pb2
import nebius.api.nebius.audit.v2.authentication_pb2 as authentication_pb2
import nebius.api.nebius.audit.v2.authentication_type_pb2 as authentication_type_pb2
import nebius.api.nebius.audit.v2.authorization_pb2 as authorization_pb2
import nebius.api.nebius.audit.v2.federation_pb2 as federation_pb2
import nebius.api.nebius.audit.v2.region_pb2 as region_pb2
import nebius.api.nebius.audit.v2.request_pb2 as request_pb2
import nebius.api.nebius.audit.v2.resource_metadata_pb2 as resource_metadata_pb2
import nebius.api.nebius.audit.v2.resource_pb2 as resource_pb2
import nebius.api.nebius.audit.v2.resource_state_pb2 as resource_state_pb2
import nebius.api.nebius.audit.v2.response_pb2 as response_pb2
import nebius.api.nebius.audit.v2.service_pb2 as service_pb2
import nebius.api.nebius.audit.v2.static_key_pb2 as static_key_pb2
import nebius.api.nebius.audit.v2.status_pb2 as status_pb2
import nebius.api.nebius.audit.v2.subject_pb2 as subject_pb2
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
#@ local imports here @#

# file: nebius/audit/v2/access_token.proto
class AccessToken(pb_classes.Message):
    __PB2_CLASS__ = access_token_pb2.AccessToken
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.AccessToken",access_token_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        masked_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(masked_token, unset.UnsetType):
            self.masked_token = masked_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "masked_token",
        ]
    
    @builtins.property
    def masked_token(self) -> "builtins.str":
        """
        Token without signature.
        """
        
        return super()._get_field("masked_token", explicit_presence=False,
        )
    @masked_token.setter
    def masked_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("masked_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "masked_token":"masked_token",
    }
    
# file: nebius/audit/v2/authentication_type.proto
class AuthenticationType(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.audit.v2.AuthenticationType",authentication_type_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    AUTHENTICATION_TYPE_UNSPECIFIED = 0
    ACCESS_TOKEN = 1
    STATIC_KEY = 2

# file: nebius/audit/v2/federation.proto
class Federation(pb_classes.Message):
    __PB2_CLASS__ = federation_pb2.Federation
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.Federation",federation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "name",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Unique identifier of the federation.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Human-readable name of the federation.
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "name":"name",
    }
    
# file: nebius/audit/v2/static_key.proto
class StaticKey(pb_classes.Message):
    __PB2_CLASS__ = static_key_pb2.StaticKey
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.StaticKey",static_key_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Unique identifier of static key.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
# file: nebius/audit/v2/subject.proto
class Subject(pb_classes.Message):
    __PB2_CLASS__ = subject_pb2.Subject
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.Subject",subject_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_id__(pb_classes.OneOf):
        name: builtins.str= "id"
        
        def __init__(self, msg: "Subject") -> None:
            super().__init__()
            self._message: "Subject" = msg
    
    class __OneOfClass_id_service_account_id__(__OneOfClass_id__):
        field: typing.Literal["service_account_id"] = "service_account_id"
        
        def __init__(self, msg: "Subject") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.service_account_id
    
    class __OneOfClass_id_tenant_user_id__(__OneOfClass_id__):
        field: typing.Literal["tenant_user_id"] = "tenant_user_id"
        
        def __init__(self, msg: "Subject") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "builtins.str":
            return self._message.tenant_user_id
    
    @builtins.property
    def id(self) -> __OneOfClass_id_service_account_id__|__OneOfClass_id_tenant_user_id__|None:
        field_name_1: str|None = super().which_field_in_oneof("id")
        match field_name_1:
            case "service_account_id":
                return self.__OneOfClass_id_service_account_id__(self)
            case "tenant_user_id":
                return self.__OneOfClass_id_tenant_user_id__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        service_account_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        tenant_user_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(service_account_id, unset.UnsetType):
            self.service_account_id = service_account_id
        if not isinstance(tenant_user_id, unset.UnsetType):
            self.tenant_user_id = tenant_user_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "service_account_id",
            "tenant_user_id",
            "name",
            "id",
        ]
    
    @builtins.property
    def service_account_id(self) -> "builtins.str|None":
        """
        This field is filled in if the call was made on behalf of a service account.
        """
        
        return super()._get_field("service_account_id", explicit_presence=True,
        )
    @service_account_id.setter
    def service_account_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("service_account_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def tenant_user_id(self) -> "builtins.str|None":
        """
        This field is filled in if the call was made on behalf of a user.
        """
        
        return super()._get_field("tenant_user_id", explicit_presence=True,
        )
    @tenant_user_id.setter
    def tenant_user_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("tenant_user_id",value,explicit_presence=True,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Username of the subject.
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "service_account_id":"service_account_id",
        "tenant_user_id":"tenant_user_id",
        "name":"name",
        "id":"id",
    }
    
# file: nebius/audit/v2/authentication.proto
class Authentication(pb_classes.Message):
    __PB2_CLASS__ = authentication_pb2.Authentication
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.Authentication",authentication_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class __OneOfClass_credential__(pb_classes.OneOf):
        name: builtins.str= "credential"
        
        def __init__(self, msg: "Authentication") -> None:
            super().__init__()
            self._message: "Authentication" = msg
    
    class __OneOfClass_credential_token_credential__(__OneOfClass_credential__):
        field: typing.Literal["token_credential"] = "token_credential"
        
        def __init__(self, msg: "Authentication") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "AccessToken":
            return self._message.token_credential
    
    class __OneOfClass_credential_static_key_credential__(__OneOfClass_credential__):
        field: typing.Literal["static_key_credential"] = "static_key_credential"
        
        def __init__(self, msg: "Authentication") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "StaticKey":
            return self._message.static_key_credential
    
    @builtins.property
    def credential(self) -> __OneOfClass_credential_token_credential__|__OneOfClass_credential_static_key_credential__|None:
        field_name_1: str|None = super().which_field_in_oneof("credential")
        match field_name_1:
            case "token_credential":
                return self.__OneOfClass_credential_token_credential__(self)
            case "static_key_credential":
                return self.__OneOfClass_credential_static_key_credential__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        authenticated: "builtins.bool|None|unset.UnsetType" = unset.Unset,
        subject: "Subject|subject_pb2.Subject|None|unset.UnsetType" = unset.Unset,
        federation: "Federation|federation_pb2.Federation|None|unset.UnsetType" = unset.Unset,
        authentication_type: "AuthenticationType|authentication_type_pb2.AuthenticationType|None|unset.UnsetType" = unset.Unset,
        token_credential: "AccessToken|access_token_pb2.AccessToken|None|unset.UnsetType" = unset.Unset,
        static_key_credential: "StaticKey|static_key_pb2.StaticKey|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(authenticated, unset.UnsetType):
            self.authenticated = authenticated
        if not isinstance(subject, unset.UnsetType):
            self.subject = subject
        if not isinstance(federation, unset.UnsetType):
            self.federation = federation
        if not isinstance(authentication_type, unset.UnsetType):
            self.authentication_type = authentication_type
        if not isinstance(token_credential, unset.UnsetType):
            self.token_credential = token_credential
        if not isinstance(static_key_credential, unset.UnsetType):
            self.static_key_credential = static_key_credential
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "authenticated",
            "subject",
            "federation",
            "authentication_type",
            "token_credential",
            "static_key_credential",
            "credential",
        ]
    
    @builtins.property
    def authenticated(self) -> "builtins.bool":
        """
        Answers the question whether or not the subject has been successfully authenticated.
        """
        
        return super()._get_field("authenticated", explicit_presence=False,
        )
    @authenticated.setter
    def authenticated(self, value: "builtins.bool|None") -> None:
        return super()._set_field("authenticated",value,explicit_presence=False,
        )
    
    @builtins.property
    def subject(self) -> "Subject":
        """
        Contains information about the subject of the call.
        """
        
        return super()._get_field("subject", explicit_presence=False,
        wrap=Subject,
        )
    @subject.setter
    def subject(self, value: "Subject|subject_pb2.Subject|None") -> None:
        return super()._set_field("subject",value,explicit_presence=False,
        )
    
    @builtins.property
    def federation(self) -> "Federation":
        """
        Information on the federation within which the subject exists.
        """
        
        return super()._get_field("federation", explicit_presence=False,
        wrap=Federation,
        )
    @federation.setter
    def federation(self, value: "Federation|federation_pb2.Federation|None") -> None:
        return super()._set_field("federation",value,explicit_presence=False,
        )
    
    @builtins.property
    def authentication_type(self) -> "AuthenticationType":
        """
        Describes the type of authentication.
        """
        
        return super()._get_field("authentication_type", explicit_presence=False,
        wrap=AuthenticationType,
        )
    @authentication_type.setter
    def authentication_type(self, value: "AuthenticationType|authentication_type_pb2.AuthenticationType|None") -> None:
        return super()._set_field("authentication_type",value,explicit_presence=False,
        )
    
    @builtins.property
    def token_credential(self) -> "AccessToken|None":
        """
        Information about token.
        """
        
        return super()._get_field("token_credential", explicit_presence=True,
        wrap=AccessToken,
        )
    @token_credential.setter
    def token_credential(self, value: "AccessToken|access_token_pb2.AccessToken|None") -> None:
        return super()._set_field("token_credential",value,explicit_presence=True,
        )
    
    @builtins.property
    def static_key_credential(self) -> "StaticKey|None":
        """
        Information about static key.
        """
        
        return super()._get_field("static_key_credential", explicit_presence=True,
        wrap=StaticKey,
        )
    @static_key_credential.setter
    def static_key_credential(self, value: "StaticKey|static_key_pb2.StaticKey|None") -> None:
        return super()._set_field("static_key_credential",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "authenticated":"authenticated",
        "subject":"subject",
        "federation":"federation",
        "authentication_type":"authentication_type",
        "token_credential":"token_credential",
        "static_key_credential":"static_key_credential",
        "credential":"credential",
    }
    
# file: nebius/audit/v2/authorization.proto
class Authorization(pb_classes.Message):
    __PB2_CLASS__ = authorization_pb2.Authorization
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.Authorization",authorization_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        authorized: "builtins.bool|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(authorized, unset.UnsetType):
            self.authorized = authorized
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "authorized",
        ]
    
    @builtins.property
    def authorized(self) -> "builtins.bool":
        """
        Field is required. We do not use «(buf.validate.field).required = true» here as false value considered as unset (validation violation)
        """
        
        return super()._get_field("authorized", explicit_presence=False,
        )
    @authorized.setter
    def authorized(self, value: "builtins.bool|None") -> None:
        return super()._set_field("authorized",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "authorized":"authorized",
    }
    
# file: nebius/audit/v2/region.proto
class Region(pb_classes.Message):
    __PB2_CLASS__ = region_pb2.Region
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.Region",region_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Region name
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
    }
    
# file: nebius/audit/v2/request.proto
class Request(pb_classes.Message):
    __PB2_CLASS__ = request_pb2.Request
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.Request",request_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        client_ip: "builtins.str|None|unset.UnsetType" = unset.Unset,
        user_agent: "builtins.str|None|unset.UnsetType" = unset.Unset,
        request_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        parameters: "struct_pb2.Struct|None|unset.UnsetType" = unset.Unset,
        idempotency_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        trace_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ja3_fingerprint: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(client_ip, unset.UnsetType):
            self.client_ip = client_ip
        if not isinstance(user_agent, unset.UnsetType):
            self.user_agent = user_agent
        if not isinstance(request_id, unset.UnsetType):
            self.request_id = request_id
        if not isinstance(parameters, unset.UnsetType):
            self.parameters = parameters
        if not isinstance(idempotency_id, unset.UnsetType):
            self.idempotency_id = idempotency_id
        if not isinstance(trace_id, unset.UnsetType):
            self.trace_id = trace_id
        if not isinstance(ja3_fingerprint, unset.UnsetType):
            self.ja3_fingerprint = ja3_fingerprint
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "client_ip",
            "user_agent",
            "request_id",
            "parameters",
            "idempotency_id",
            "trace_id",
            "ja3_fingerprint",
        ]
    
    @builtins.property
    def client_ip(self) -> "builtins.str":
        """
        Ip of the subject who initiated the RPC call.
        """
        
        return super()._get_field("client_ip", explicit_presence=False,
        )
    @client_ip.setter
    def client_ip(self, value: "builtins.str|None") -> None:
        return super()._set_field("client_ip",value,explicit_presence=False,
        )
    
    @builtins.property
    def user_agent(self) -> "builtins.str":
        """
        User agent of the subject who initiated operation.
        """
        
        return super()._get_field("user_agent", explicit_presence=False,
        )
    @user_agent.setter
    def user_agent(self, value: "builtins.str|None") -> None:
        return super()._set_field("user_agent",value,explicit_presence=False,
        )
    
    @builtins.property
    def request_id(self) -> "builtins.str":
        """
        Unique identifier of the request.
        """
        
        return super()._get_field("request_id", explicit_presence=False,
        )
    @request_id.setter
    def request_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("request_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def parameters(self) -> "struct_pb2.Struct|None":
        """
        Parameters of the request.
        """
        
        return super()._get_field("parameters", explicit_presence=True,
        )
    @parameters.setter
    def parameters(self, value: "struct_pb2.Struct|None") -> None:
        return super()._set_field("parameters",value,explicit_presence=True,
        )
    
    @builtins.property
    def idempotency_id(self) -> "builtins.str":
        """
        Unique key that the server uses to recognize subsequent retries of the same request.
        """
        
        return super()._get_field("idempotency_id", explicit_presence=False,
        )
    @idempotency_id.setter
    def idempotency_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("idempotency_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def trace_id(self) -> "builtins.str":
        """
        A unique identifier that allows you to link calls to different services within an operation.
        """
        
        return super()._get_field("trace_id", explicit_presence=False,
        )
    @trace_id.setter
    def trace_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("trace_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def ja3_fingerprint(self) -> "builtins.str":
        """
        Client Ja3 fingerprint
        """
        
        return super()._get_field("ja3_fingerprint", explicit_presence=False,
        )
    @ja3_fingerprint.setter
    def ja3_fingerprint(self, value: "builtins.str|None") -> None:
        return super()._set_field("ja3_fingerprint",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "client_ip":"client_ip",
        "user_agent":"user_agent",
        "request_id":"request_id",
        "parameters":"parameters",
        "idempotency_id":"idempotency_id",
        "trace_id":"trace_id",
        "ja3_fingerprint":"ja3_fingerprint",
    }
    
# file: nebius/audit/v2/resource_metadata.proto
class ResourceMetadata(pb_classes.Message):
    __PB2_CLASS__ = resource_metadata_pb2.ResourceMetadata
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.ResourceMetadata",resource_metadata_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        type: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(type, unset.UnsetType):
            self.type = type
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "name",
            "type",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Unique identifier of the resource.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Name of the resource.
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    @builtins.property
    def type(self) -> "builtins.str":
        """
        Type of the resource.
        """
        
        return super()._get_field("type", explicit_presence=False,
        )
    @type.setter
    def type(self, value: "builtins.str|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "name":"name",
        "type":"type",
    }
    
# file: nebius/audit/v2/resource_state.proto
class ResourceState(pb_classes.Message):
    __PB2_CLASS__ = resource_state_pb2.ResourceState
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.ResourceState",resource_state_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        previous: "struct_pb2.Struct|None|unset.UnsetType" = unset.Unset,
        current: "struct_pb2.Struct|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(previous, unset.UnsetType):
            self.previous = previous
        if not isinstance(current, unset.UnsetType):
            self.current = current
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "previous",
            "current",
        ]
    
    @builtins.property
    def previous(self) -> "struct_pb2.Struct|None":
        """
        The state of the resource before the change in the call.
        """
        
        return super()._get_field("previous", explicit_presence=True,
        )
    @previous.setter
    def previous(self, value: "struct_pb2.Struct|None") -> None:
        return super()._set_field("previous",value,explicit_presence=True,
        )
    
    @builtins.property
    def current(self) -> "struct_pb2.Struct|None":
        """
        The state of the resource after the change in the call.
        """
        
        return super()._get_field("current", explicit_presence=True,
        )
    @current.setter
    def current(self, value: "struct_pb2.Struct|None") -> None:
        return super()._set_field("current",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "previous":"previous",
        "current":"current",
    }
    
# file: nebius/audit/v2/resource.proto
class Resource(pb_classes.Message):
    __PB2_CLASS__ = resource_pb2.Resource
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.Resource",resource_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        metadata: "ResourceMetadata|resource_metadata_pb2.ResourceMetadata|None|unset.UnsetType" = unset.Unset,
        state: "ResourceState|resource_state_pb2.ResourceState|None|unset.UnsetType" = unset.Unset,
        hierarchy: "abc.Iterable[ResourceMetadata]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(metadata, unset.UnsetType):
            self.metadata = metadata
        if not isinstance(state, unset.UnsetType):
            self.state = state
        if not isinstance(hierarchy, unset.UnsetType):
            self.hierarchy = hierarchy
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "metadata",
            "state",
            "hierarchy",
        ]
    
    @builtins.property
    def metadata(self) -> "ResourceMetadata":
        """
        Provides basic information about the resource.
        """
        
        return super()._get_field("metadata", explicit_presence=False,
        wrap=ResourceMetadata,
        )
    @metadata.setter
    def metadata(self, value: "ResourceMetadata|resource_metadata_pb2.ResourceMetadata|None") -> None:
        return super()._set_field("metadata",value,explicit_presence=False,
        )
    
    @builtins.property
    def state(self) -> "ResourceState":
        """
        Gives an understanding of how the resource was changed in the call.
        """
        
        return super()._get_field("state", explicit_presence=False,
        wrap=ResourceState,
        )
    @state.setter
    def state(self, value: "ResourceState|resource_state_pb2.ResourceState|None") -> None:
        return super()._set_field("state",value,explicit_presence=False,
        )
    
    @builtins.property
    def hierarchy(self) -> "abc.MutableSequence[ResourceMetadata]":
        """
        Top-down resources hierarchy from tenant to resource.
        """
        
        return super()._get_field("hierarchy", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(ResourceMetadata,None,None),
        )
    @hierarchy.setter
    def hierarchy(self, value: "abc.Iterable[ResourceMetadata]|None") -> None:
        return super()._set_field("hierarchy",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "metadata":"metadata",
        "state":"state",
        "hierarchy":"hierarchy",
    }
    
# file: nebius/audit/v2/response.proto
class Response(pb_classes.Message):
    __PB2_CLASS__ = response_pb2.Response
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.Response",response_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        status_code: "code_pb2.Code|None|unset.UnsetType" = unset.Unset,
        error_message: "builtins.str|None|unset.UnsetType" = unset.Unset,
        payload: "struct_pb2.Struct|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(status_code, unset.UnsetType):
            self.status_code = status_code
        if not isinstance(error_message, unset.UnsetType):
            self.error_message = error_message
        if not isinstance(payload, unset.UnsetType):
            self.payload = payload
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "status_code",
            "error_message",
            "payload",
        ]
    
    @builtins.property
    def status_code(self) -> "code_pb2.Code":
        """
        The status that the server returned to the client.
        """
        
        return super()._get_field("status_code", explicit_presence=False,
        )
    @status_code.setter
    def status_code(self, value: "code_pb2.Code|None") -> None:
        return super()._set_field("status_code",value,explicit_presence=False,
        )
    
    @builtins.property
    def error_message(self) -> "builtins.str":
        """
        Error message if the call was not successful.
        """
        
        return super()._get_field("error_message", explicit_presence=False,
        )
    @error_message.setter
    def error_message(self, value: "builtins.str|None") -> None:
        return super()._set_field("error_message",value,explicit_presence=False,
        )
    
    @builtins.property
    def payload(self) -> "struct_pb2.Struct|None":
        """
        The payload of the response.
        """
        
        return super()._get_field("payload", explicit_presence=True,
        )
    @payload.setter
    def payload(self, value: "struct_pb2.Struct|None") -> None:
        return super()._set_field("payload",value,explicit_presence=True,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "status_code":"status_code",
        "error_message":"error_message",
        "payload":"payload",
    }
    
# file: nebius/audit/v2/service.proto
class Service(pb_classes.Message):
    __PB2_CLASS__ = service_pb2.Service
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.Service",service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "name",
        ]
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "name":"name",
    }
    
# file: nebius/audit/v2/status.proto
class Status(pb_enum.Enum):
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.audit.v2.Status",status_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
    RESPONSE_STATUS_UNSPECIFIED = 0
    STARTED = 1
    """
    Asynchronous action started
    """
    
    DONE = 2
    """
    Action finished successfully
    """
    
    ERROR = 3
    """
    Action finished with error
    """
    

# file: nebius/audit/v2/audit_event.proto
class AuditEvent(pb_classes.Message):
    __PB2_CLASS__ = audit_event_pb2.AuditEvent
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.AuditEvent",audit_event_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "time": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        source: "builtins.str|None|unset.UnsetType" = unset.Unset,
        spec_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        type: "builtins.str|None|unset.UnsetType" = unset.Unset,
        service: "Service|service_pb2.Service|None|unset.UnsetType" = unset.Unset,
        action: "builtins.str|None|unset.UnsetType" = unset.Unset,
        time: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        event_version: "builtins.str|None|unset.UnsetType" = unset.Unset,
        authentication: "Authentication|authentication_pb2.Authentication|None|unset.UnsetType" = unset.Unset,
        authorization: "Authorization|authorization_pb2.Authorization|None|unset.UnsetType" = unset.Unset,
        resource: "Resource|resource_pb2.Resource|None|unset.UnsetType" = unset.Unset,
        request: "Request|request_pb2.Request|None|unset.UnsetType" = unset.Unset,
        response: "Response|response_pb2.Response|None|unset.UnsetType" = unset.Unset,
        status: "Status|status_pb2.Status|None|unset.UnsetType" = unset.Unset,
        project_region: "Region|region_pb2.Region|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(source, unset.UnsetType):
            self.source = source
        if not isinstance(spec_version, unset.UnsetType):
            self.spec_version = spec_version
        if not isinstance(type, unset.UnsetType):
            self.type = type
        if not isinstance(service, unset.UnsetType):
            self.service = service
        if not isinstance(action, unset.UnsetType):
            self.action = action
        if not isinstance(time, unset.UnsetType):
            self.time = time
        if not isinstance(event_version, unset.UnsetType):
            self.event_version = event_version
        if not isinstance(authentication, unset.UnsetType):
            self.authentication = authentication
        if not isinstance(authorization, unset.UnsetType):
            self.authorization = authorization
        if not isinstance(resource, unset.UnsetType):
            self.resource = resource
        if not isinstance(request, unset.UnsetType):
            self.request = request
        if not isinstance(response, unset.UnsetType):
            self.response = response
        if not isinstance(status, unset.UnsetType):
            self.status = status
        if not isinstance(project_region, unset.UnsetType):
            self.project_region = project_region
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "source",
            "spec_version",
            "type",
            "service",
            "action",
            "time",
            "event_version",
            "authentication",
            "authorization",
            "resource",
            "request",
            "response",
            "status",
            "project_region",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Unique event id.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def source(self) -> "builtins.str":
        """
        Identifies the context in which an event happened. Presented in the form of URI.
        """
        
        return super()._get_field("source", explicit_presence=False,
        )
    @source.setter
    def source(self, value: "builtins.str|None") -> None:
        return super()._set_field("source",value,explicit_presence=False,
        )
    
    @builtins.property
    def spec_version(self) -> "builtins.str":
        """
        Version of CloudEvents spec. See https://github.com/cloudevents/spec/blob/main/cloudevents/spec.md#specversion
        """
        
        return super()._get_field("spec_version", explicit_presence=False,
        )
    @spec_version.setter
    def spec_version(self, value: "builtins.str|None") -> None:
        return super()._set_field("spec_version",value,explicit_presence=False,
        )
    
    @builtins.property
    def type(self) -> "builtins.str":
        """
        .. role:: raw-html-m2r(raw)
           :format: html
        
        
        The type of event related to the originating occurrence. Formed according to template: "ai.nebius.\\ :raw-html-m2r:`<serviceName>`.\\ :raw-html-m2r:`<resourceType>`.\\ :raw-html-m2r:`<action>`\\ "
        """
        
        return super()._get_field("type", explicit_presence=False,
        )
    @type.setter
    def type(self, value: "builtins.str|None") -> None:
        return super()._set_field("type",value,explicit_presence=False,
        )
    
    @builtins.property
    def service(self) -> "Service":
        """
        Indicates the service that generated the event.
        """
        
        return super()._get_field("service", explicit_presence=False,
        wrap=Service,
        )
    @service.setter
    def service(self, value: "Service|service_pb2.Service|None") -> None:
        return super()._set_field("service",value,explicit_presence=False,
        )
    
    @builtins.property
    def action(self) -> "builtins.str":
        """
        Indicates an action taken on the resource.
        """
        
        return super()._get_field("action", explicit_presence=False,
        )
    @action.setter
    def action(self, value: "builtins.str|None") -> None:
        return super()._set_field("action",value,explicit_presence=False,
        )
    
    @builtins.property
    def time(self) -> "datetime.datetime":
        """
        Timestamp of when the occurrence happened.
        """
        
        return super()._get_field("time", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @time.setter
    def time(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("time",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def event_version(self) -> "builtins.str":
        """
        Audit event version, in "X.Y" format, events within different Y's are backwards compatible, events with different X's are not.
        """
        
        return super()._get_field("event_version", explicit_presence=False,
        )
    @event_version.setter
    def event_version(self, value: "builtins.str|None") -> None:
        return super()._set_field("event_version",value,explicit_presence=False,
        )
    
    @builtins.property
    def authentication(self) -> "Authentication":
        """
        Represents the subject of an API call.
        """
        
        return super()._get_field("authentication", explicit_presence=False,
        wrap=Authentication,
        )
    @authentication.setter
    def authentication(self, value: "Authentication|authentication_pb2.Authentication|None") -> None:
        return super()._set_field("authentication",value,explicit_presence=False,
        )
    
    @builtins.property
    def authorization(self) -> "Authorization":
        """
        Represents permissions that have been verified for the subject as part of the API call.
        """
        
        return super()._get_field("authorization", explicit_presence=False,
        wrap=Authorization,
        )
    @authorization.setter
    def authorization(self, value: "Authorization|authorization_pb2.Authorization|None") -> None:
        return super()._set_field("authorization",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource(self) -> "Resource":
        """
        A resource that was read or modified as part of the operation. Can be empty if no resource accessed or changed.
        """
        
        return super()._get_field("resource", explicit_presence=False,
        wrap=Resource,
        )
    @resource.setter
    def resource(self, value: "Resource|resource_pb2.Resource|None") -> None:
        return super()._set_field("resource",value,explicit_presence=False,
        )
    
    @builtins.property
    def request(self) -> "Request":
        """
        Contains information about the request from the customer.
        """
        
        return super()._get_field("request", explicit_presence=False,
        wrap=Request,
        )
    @request.setter
    def request(self, value: "Request|request_pb2.Request|None") -> None:
        return super()._set_field("request",value,explicit_presence=False,
        )
    
    @builtins.property
    def response(self) -> "Response":
        """
        Contains information about the response from the server.
        """
        
        return super()._get_field("response", explicit_presence=False,
        wrap=Response,
        )
    @response.setter
    def response(self, value: "Response|response_pb2.Response|None") -> None:
        return super()._set_field("response",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "Status":
        """
        The async operation status
        """
        
        return super()._get_field("status", explicit_presence=False,
        wrap=Status,
        )
    @status.setter
    def status(self, value: "Status|status_pb2.Status|None") -> None:
        return super()._set_field("status",value,explicit_presence=False,
        )
    
    @builtins.property
    def project_region(self) -> "Region":
        """
        Region of an application
        """
        
        return super()._get_field("project_region", explicit_presence=False,
        wrap=Region,
        )
    @project_region.setter
    def project_region(self, value: "Region|region_pb2.Region|None") -> None:
        return super()._set_field("project_region",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "source":"source",
        "spec_version":"spec_version",
        "type":"type",
        "service":"service",
        "action":"action",
        "time":"time",
        "event_version":"event_version",
        "authentication":"authentication",
        "authorization":"authorization",
        "resource":"resource",
        "request":"request",
        "response":"response",
        "status":"status",
        "project_region":"project_region",
    }
    
# file: nebius/audit/v2/audit_event_service.proto
class ListAuditEventRequest(pb_classes.Message):
    __PB2_CLASS__ = audit_event_service_pb2.ListAuditEventRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.ListAuditEventRequest",audit_event_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "start": well_known_1.ts_mask,
        "end": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        start: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        end: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(start, unset.UnsetType):
            self.start = start
        if not isinstance(end, unset.UnsetType):
            self.end = end
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "start",
            "end",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        A tenant id must be provided
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def start(self) -> "datetime.datetime":
        return super()._get_field("start", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @start.setter
    def start(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("start",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def end(self) -> "datetime.datetime":
        return super()._get_field("end", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @end.setter
    def end(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("end",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Example:
        service.name = 'iam' AND resource.hierarchy.id:'container-e0t' AND regex(resource.metadata.name, '^.\\ *test.*\\ $')
        
        Supported filters:
        "=" - equals
        "!=" - not equals
        ":" - contains
        regex - regular expression
        
        Fields that can be used for filtering:
        action
        authentication.static_key_credential.id
        authentication.subject.name
        authentication.subject.service_account_id
        authentication.subject.tenant_user_id
        authentication.token_credential.masked_token
        project_region.name
        resource.hierarchy.id
        resource.hierarchy.name
        resource.metadata.id
        resource.metadata.name
        resource.metadata.type
        service.name
        type
        status
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "start":"start",
        "end":"end",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListAuditEventResponse(pb_classes.Message):
    __PB2_CLASS__ = audit_event_service_pb2.ListAuditEventResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.audit.v2.ListAuditEventResponse",audit_event_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        items: "abc.Iterable[AuditEvent]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(items, unset.UnsetType):
            self.items = items
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "items",
            "next_page_token",
        ]
    
    @builtins.property
    def items(self) -> "abc.MutableSequence[AuditEvent]":
        return super()._get_field("items", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(AuditEvent,None,None),
        )
    @items.setter
    def items(self, value: "abc.Iterable[AuditEvent]|None") -> None:
        return super()._set_field("items",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "items":"items",
        "next_page_token":"next_page_token",
    }
    

class AuditEventServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.audit.v2.AuditEventService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.audit.v2.AuditEventService",audit_event_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.audit.v2.AuditEventService"
    
    def list(self,
        request: "ListAuditEventRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListAuditEventRequest","ListAuditEventResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.audit.v2.ListAuditEventRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.audit.v2.ListAuditEventResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=audit_event_service_pb2.ListAuditEventResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListAuditEventResponse),
        )
    

__all__ = [
    #@ local import names here @#
    "AccessToken",
    "AuthenticationType",
    "Federation",
    "StaticKey",
    "Subject",
    "Authentication",
    "Authorization",
    "Region",
    "Request",
    "ResourceMetadata",
    "ResourceState",
    "Resource",
    "Response",
    "Service",
    "Status",
    "AuditEvent",
    "ListAuditEventRequest",
    "ListAuditEventResponse",
    "AuditEventServiceClient",
]
