# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.common.v1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.any_pb2 as any_pb2
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import google.rpc.status_pb2 as status_pb2
import grpc as grpc
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.aio.request_status as request_status
import nebius.api.nebius.common.v1.error_pb2 as error_pb2
import nebius.api.nebius.common.v1.metadata_pb2 as metadata_pb2
import nebius.api.nebius.common.v1.operation_pb2 as operation_pb2
import nebius.api.nebius.common.v1.operation_service_pb2 as operation_service_pb2
import nebius.api.nebius.common.v1.resource_event_pb2 as resource_event_pb2
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.pb_enum as pb_enum
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
import typing as typing
#@ local imports here @#

# file: nebius/common/v1/error.proto
class ServiceError(pb_classes.Message):
    __PB2_CLASS__ = error_pb2.ServiceError
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.ServiceError",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class RetryType(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.common.v1.ServiceError.RetryType",error_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        CALL = 1
        """
        Just retry the failed call.
        """
        
        UNIT_OF_WORK = 2
        """
        Retry whole logic before call and make a new one.
        """
        
        NOTHING = 3
        """
        Do not retry, this is a fatal error.
        """
        
    
    class __OneOfClass_details__(pb_classes.OneOf):
        name: builtins.str= "details"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__()
            self._message: "ServiceError" = msg
    
    class __OneOfClass_details_bad_request__(__OneOfClass_details__):
        field: typing.Literal["bad_request"] = "bad_request"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "BadRequest":
            return self._message.bad_request
    
    class __OneOfClass_details_bad_resource_state__(__OneOfClass_details__):
        field: typing.Literal["bad_resource_state"] = "bad_resource_state"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "BadResourceState":
            return self._message.bad_resource_state
    
    class __OneOfClass_details_resource_not_found__(__OneOfClass_details__):
        field: typing.Literal["resource_not_found"] = "resource_not_found"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ResourceNotFound":
            return self._message.resource_not_found
    
    class __OneOfClass_details_resource_already_exists__(__OneOfClass_details__):
        field: typing.Literal["resource_already_exists"] = "resource_already_exists"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ResourceAlreadyExists":
            return self._message.resource_already_exists
    
    class __OneOfClass_details_out_of_range__(__OneOfClass_details__):
        field: typing.Literal["out_of_range"] = "out_of_range"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "OutOfRange":
            return self._message.out_of_range
    
    class __OneOfClass_details_permission_denied__(__OneOfClass_details__):
        field: typing.Literal["permission_denied"] = "permission_denied"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "PermissionDenied":
            return self._message.permission_denied
    
    class __OneOfClass_details_resource_conflict__(__OneOfClass_details__):
        field: typing.Literal["resource_conflict"] = "resource_conflict"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "ResourceConflict":
            return self._message.resource_conflict
    
    class __OneOfClass_details_operation_aborted__(__OneOfClass_details__):
        field: typing.Literal["operation_aborted"] = "operation_aborted"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "OperationAborted":
            return self._message.operation_aborted
    
    class __OneOfClass_details_too_many_requests__(__OneOfClass_details__):
        field: typing.Literal["too_many_requests"] = "too_many_requests"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "TooManyRequests":
            return self._message.too_many_requests
    
    class __OneOfClass_details_quota_failure__(__OneOfClass_details__):
        field: typing.Literal["quota_failure"] = "quota_failure"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "QuotaFailure":
            return self._message.quota_failure
    
    class __OneOfClass_details_not_enough_resources__(__OneOfClass_details__):
        field: typing.Literal["not_enough_resources"] = "not_enough_resources"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "NotEnoughResources":
            return self._message.not_enough_resources
    
    class __OneOfClass_details_internal_error__(__OneOfClass_details__):
        field: typing.Literal["internal_error"] = "internal_error"
        
        def __init__(self, msg: "ServiceError") -> None:
            super().__init__(msg)
        @builtins.property
        def value(self) -> "InternalError":
            return self._message.internal_error
    
    @builtins.property
    def details(self) -> __OneOfClass_details_bad_request__|__OneOfClass_details_bad_resource_state__|__OneOfClass_details_resource_not_found__|__OneOfClass_details_resource_already_exists__|__OneOfClass_details_out_of_range__|__OneOfClass_details_permission_denied__|__OneOfClass_details_resource_conflict__|__OneOfClass_details_operation_aborted__|__OneOfClass_details_too_many_requests__|__OneOfClass_details_quota_failure__|__OneOfClass_details_not_enough_resources__|__OneOfClass_details_internal_error__|None:
        """
        Additional message describing the error, if any.
        """
        
        field_name_1: str|None = super().which_field_in_oneof("details")
        match field_name_1:
            case "bad_request":
                return self.__OneOfClass_details_bad_request__(self)
            case "bad_resource_state":
                return self.__OneOfClass_details_bad_resource_state__(self)
            case "resource_not_found":
                return self.__OneOfClass_details_resource_not_found__(self)
            case "resource_already_exists":
                return self.__OneOfClass_details_resource_already_exists__(self)
            case "out_of_range":
                return self.__OneOfClass_details_out_of_range__(self)
            case "permission_denied":
                return self.__OneOfClass_details_permission_denied__(self)
            case "resource_conflict":
                return self.__OneOfClass_details_resource_conflict__(self)
            case "operation_aborted":
                return self.__OneOfClass_details_operation_aborted__(self)
            case "too_many_requests":
                return self.__OneOfClass_details_too_many_requests__(self)
            case "quota_failure":
                return self.__OneOfClass_details_quota_failure__(self)
            case "not_enough_resources":
                return self.__OneOfClass_details_not_enough_resources__(self)
            case "internal_error":
                return self.__OneOfClass_details_internal_error__(self)
            case None:
                return None
            case _:
                raise pb_classes.OneOfMatchError(field_name_1)
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        service: "builtins.str|None|unset.UnsetType" = unset.Unset,
        code: "builtins.str|None|unset.UnsetType" = unset.Unset,
        bad_request: "BadRequest|error_pb2.BadRequest|None|unset.UnsetType" = unset.Unset,
        bad_resource_state: "BadResourceState|error_pb2.BadResourceState|None|unset.UnsetType" = unset.Unset,
        resource_not_found: "ResourceNotFound|error_pb2.ResourceNotFound|None|unset.UnsetType" = unset.Unset,
        resource_already_exists: "ResourceAlreadyExists|error_pb2.ResourceAlreadyExists|None|unset.UnsetType" = unset.Unset,
        out_of_range: "OutOfRange|error_pb2.OutOfRange|None|unset.UnsetType" = unset.Unset,
        permission_denied: "PermissionDenied|error_pb2.PermissionDenied|None|unset.UnsetType" = unset.Unset,
        resource_conflict: "ResourceConflict|error_pb2.ResourceConflict|None|unset.UnsetType" = unset.Unset,
        operation_aborted: "OperationAborted|error_pb2.OperationAborted|None|unset.UnsetType" = unset.Unset,
        too_many_requests: "TooManyRequests|error_pb2.TooManyRequests|None|unset.UnsetType" = unset.Unset,
        quota_failure: "QuotaFailure|error_pb2.QuotaFailure|None|unset.UnsetType" = unset.Unset,
        not_enough_resources: "NotEnoughResources|error_pb2.NotEnoughResources|None|unset.UnsetType" = unset.Unset,
        internal_error: "InternalError|error_pb2.InternalError|None|unset.UnsetType" = unset.Unset,
        retry_type: "ServiceError.RetryType|error_pb2.ServiceError.RetryType|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(service, unset.UnsetType):
            self.service = service
        if not isinstance(code, unset.UnsetType):
            self.code = code
        if not isinstance(bad_request, unset.UnsetType):
            self.bad_request = bad_request
        if not isinstance(bad_resource_state, unset.UnsetType):
            self.bad_resource_state = bad_resource_state
        if not isinstance(resource_not_found, unset.UnsetType):
            self.resource_not_found = resource_not_found
        if not isinstance(resource_already_exists, unset.UnsetType):
            self.resource_already_exists = resource_already_exists
        if not isinstance(out_of_range, unset.UnsetType):
            self.out_of_range = out_of_range
        if not isinstance(permission_denied, unset.UnsetType):
            self.permission_denied = permission_denied
        if not isinstance(resource_conflict, unset.UnsetType):
            self.resource_conflict = resource_conflict
        if not isinstance(operation_aborted, unset.UnsetType):
            self.operation_aborted = operation_aborted
        if not isinstance(too_many_requests, unset.UnsetType):
            self.too_many_requests = too_many_requests
        if not isinstance(quota_failure, unset.UnsetType):
            self.quota_failure = quota_failure
        if not isinstance(not_enough_resources, unset.UnsetType):
            self.not_enough_resources = not_enough_resources
        if not isinstance(internal_error, unset.UnsetType):
            self.internal_error = internal_error
        if not isinstance(retry_type, unset.UnsetType):
            self.retry_type = retry_type
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "service",
            "code",
            "bad_request",
            "bad_resource_state",
            "resource_not_found",
            "resource_already_exists",
            "out_of_range",
            "permission_denied",
            "resource_conflict",
            "operation_aborted",
            "too_many_requests",
            "quota_failure",
            "not_enough_resources",
            "internal_error",
            "retry_type",
            "details",
            "RetryType",
        ]
    
    @builtins.property
    def service(self) -> "builtins.str":
        """
        ID of Service which the error originated in. E.g. "dns".
        """
        
        return super()._get_field("service", explicit_presence=False,
        )
    @service.setter
    def service(self, value: "builtins.str|None") -> None:
        return super()._set_field("service",value,explicit_presence=False,
        )
    
    @builtins.property
    def code(self) -> "builtins.str":
        """
        Detailed error code, service-specific. E.g. "DnsZoneNotEmpty".
        Name of the exception, without Exception suffix if not set.
        Example: for PermissionDeniedException -> code == PermissionDenied.
        """
        
        return super()._get_field("code", explicit_presence=False,
        )
    @code.setter
    def code(self, value: "builtins.str|None") -> None:
        return super()._set_field("code",value,explicit_presence=False,
        )
    
    @builtins.property
    def bad_request(self) -> "BadRequest|None":
        return super()._get_field("bad_request", explicit_presence=True,
        wrap=BadRequest,
        )
    @bad_request.setter
    def bad_request(self, value: "BadRequest|error_pb2.BadRequest|None") -> None:
        return super()._set_field("bad_request",value,explicit_presence=True,
        )
    
    @builtins.property
    def bad_resource_state(self) -> "BadResourceState|None":
        return super()._get_field("bad_resource_state", explicit_presence=True,
        wrap=BadResourceState,
        )
    @bad_resource_state.setter
    def bad_resource_state(self, value: "BadResourceState|error_pb2.BadResourceState|None") -> None:
        return super()._set_field("bad_resource_state",value,explicit_presence=True,
        )
    
    @builtins.property
    def resource_not_found(self) -> "ResourceNotFound|None":
        return super()._get_field("resource_not_found", explicit_presence=True,
        wrap=ResourceNotFound,
        )
    @resource_not_found.setter
    def resource_not_found(self, value: "ResourceNotFound|error_pb2.ResourceNotFound|None") -> None:
        return super()._set_field("resource_not_found",value,explicit_presence=True,
        )
    
    @builtins.property
    def resource_already_exists(self) -> "ResourceAlreadyExists|None":
        return super()._get_field("resource_already_exists", explicit_presence=True,
        wrap=ResourceAlreadyExists,
        )
    @resource_already_exists.setter
    def resource_already_exists(self, value: "ResourceAlreadyExists|error_pb2.ResourceAlreadyExists|None") -> None:
        return super()._set_field("resource_already_exists",value,explicit_presence=True,
        )
    
    @builtins.property
    def out_of_range(self) -> "OutOfRange|None":
        return super()._get_field("out_of_range", explicit_presence=True,
        wrap=OutOfRange,
        )
    @out_of_range.setter
    def out_of_range(self, value: "OutOfRange|error_pb2.OutOfRange|None") -> None:
        return super()._set_field("out_of_range",value,explicit_presence=True,
        )
    
    @builtins.property
    def permission_denied(self) -> "PermissionDenied|None":
        return super()._get_field("permission_denied", explicit_presence=True,
        wrap=PermissionDenied,
        )
    @permission_denied.setter
    def permission_denied(self, value: "PermissionDenied|error_pb2.PermissionDenied|None") -> None:
        return super()._set_field("permission_denied",value,explicit_presence=True,
        )
    
    @builtins.property
    def resource_conflict(self) -> "ResourceConflict|None":
        return super()._get_field("resource_conflict", explicit_presence=True,
        wrap=ResourceConflict,
        )
    @resource_conflict.setter
    def resource_conflict(self, value: "ResourceConflict|error_pb2.ResourceConflict|None") -> None:
        return super()._set_field("resource_conflict",value,explicit_presence=True,
        )
    
    @builtins.property
    def operation_aborted(self) -> "OperationAborted|None":
        return super()._get_field("operation_aborted", explicit_presence=True,
        wrap=OperationAborted,
        )
    @operation_aborted.setter
    def operation_aborted(self, value: "OperationAborted|error_pb2.OperationAborted|None") -> None:
        return super()._set_field("operation_aborted",value,explicit_presence=True,
        )
    
    @builtins.property
    def too_many_requests(self) -> "TooManyRequests|None":
        return super()._get_field("too_many_requests", explicit_presence=True,
        wrap=TooManyRequests,
        )
    @too_many_requests.setter
    def too_many_requests(self, value: "TooManyRequests|error_pb2.TooManyRequests|None") -> None:
        return super()._set_field("too_many_requests",value,explicit_presence=True,
        )
    
    @builtins.property
    def quota_failure(self) -> "QuotaFailure|None":
        return super()._get_field("quota_failure", explicit_presence=True,
        wrap=QuotaFailure,
        )
    @quota_failure.setter
    def quota_failure(self, value: "QuotaFailure|error_pb2.QuotaFailure|None") -> None:
        return super()._set_field("quota_failure",value,explicit_presence=True,
        )
    
    @builtins.property
    def not_enough_resources(self) -> "NotEnoughResources|None":
        return super()._get_field("not_enough_resources", explicit_presence=True,
        wrap=NotEnoughResources,
        )
    @not_enough_resources.setter
    def not_enough_resources(self, value: "NotEnoughResources|error_pb2.NotEnoughResources|None") -> None:
        return super()._set_field("not_enough_resources",value,explicit_presence=True,
        )
    
    @builtins.property
    def internal_error(self) -> "InternalError|None":
        return super()._get_field("internal_error", explicit_presence=True,
        wrap=InternalError,
        )
    @internal_error.setter
    def internal_error(self, value: "InternalError|error_pb2.InternalError|None") -> None:
        return super()._set_field("internal_error",value,explicit_presence=True,
        )
    
    @builtins.property
    def retry_type(self) -> "ServiceError.RetryType":
        """
        Retry type tells how to provide retry, e.g.: just a single call or the whole logic before it.
        """
        
        return super()._get_field("retry_type", explicit_presence=False,
        wrap=ServiceError.RetryType,
        )
    @retry_type.setter
    def retry_type(self, value: "ServiceError.RetryType|error_pb2.ServiceError.RetryType|None") -> None:
        return super()._set_field("retry_type",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "service":"service",
        "code":"code",
        "bad_request":"bad_request",
        "bad_resource_state":"bad_resource_state",
        "resource_not_found":"resource_not_found",
        "resource_already_exists":"resource_already_exists",
        "out_of_range":"out_of_range",
        "permission_denied":"permission_denied",
        "resource_conflict":"resource_conflict",
        "operation_aborted":"operation_aborted",
        "too_many_requests":"too_many_requests",
        "quota_failure":"quota_failure",
        "not_enough_resources":"not_enough_resources",
        "internal_error":"internal_error",
        "retry_type":"retry_type",
        "details":"details",
        "RetryType":"RetryType",
    }
    
class BadRequest(pb_classes.Message):
    """
    The request is invalid.
    """
    
    __PB2_CLASS__ = error_pb2.BadRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.BadRequest",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class Violation(pb_classes.Message):
        __PB2_CLASS__ = error_pb2.BadRequest.Violation
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.BadRequest.Violation",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            field: "builtins.str|None|unset.UnsetType" = unset.Unset,
            message: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(field, unset.UnsetType):
                self.field = field
            if not isinstance(message, unset.UnsetType):
                self.message = message
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "field",
                "message",
            ]
        
        @builtins.property
        def field(self) -> "builtins.str":
            """
            What field value is invalid.
            """
            
            return super()._get_field("field", explicit_presence=False,
            )
        @field.setter
        def field(self, value: "builtins.str|None") -> None:
            return super()._set_field("field",value,explicit_presence=False,
            )
        
        @builtins.property
        def message(self) -> "builtins.str":
            """
            Description why the value is invalid, in English.
            """
            
            return super()._get_field("message", explicit_presence=False,
            )
        @message.setter
        def message(self, value: "builtins.str|None") -> None:
            return super()._set_field("message",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "field":"field",
            "message":"message",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        violations: "abc.Iterable[BadRequest.Violation]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(violations, unset.UnsetType):
            self.violations = violations
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "violations",
            "Violation",
        ]
    
    @builtins.property
    def violations(self) -> "abc.MutableSequence[BadRequest.Violation]":
        """
        Describes all violations.
        """
        
        return super()._get_field("violations", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(BadRequest.Violation,None,None),
        )
    @violations.setter
    def violations(self, value: "abc.Iterable[BadRequest.Violation]|None") -> None:
        return super()._set_field("violations",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "violations":"violations",
        "Violation":"Violation",
    }
    
class BadResourceState(pb_classes.Message):
    """
    The resource we are trying to use, create, change or delete is in a bad state and cannot be used.
    """
    
    __PB2_CLASS__ = error_pb2.BadResourceState
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.BadResourceState",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        message: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
        if not isinstance(message, unset.UnsetType):
            self.message = message
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_id",
            "message",
        ]
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        ID of the resource which is bad.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def message(self) -> "builtins.str":
        """
        The reason why this state is bad and cannot be used.
        """
        
        return super()._get_field("message", explicit_presence=False,
        )
    @message.setter
    def message(self, value: "builtins.str|None") -> None:
        return super()._set_field("message",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_id":"resource_id",
        "message":"message",
    }
    
class ResourceNotFound(pb_classes.Message):
    """
    Resource we are trying to interact with does not exist.
    """
    
    __PB2_CLASS__ = error_pb2.ResourceNotFound
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.ResourceNotFound",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_id",
        ]
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        ID of the requested resource.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_id":"resource_id",
    }
    
class ResourceAlreadyExists(pb_classes.Message):
    """
    Resource we are trying to create already exists.
    """
    
    __PB2_CLASS__ = error_pb2.ResourceAlreadyExists
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.ResourceAlreadyExists",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_id",
        ]
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        ID of the existing resource.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_id":"resource_id",
    }
    
class ResourceConflict(pb_classes.Message):
    """
    There is a difference between the actual resource state and the expected one.
    """
    
    __PB2_CLASS__ = error_pb2.ResourceConflict
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.ResourceConflict",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        message: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
        if not isinstance(message, unset.UnsetType):
            self.message = message
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_id",
            "message",
        ]
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        ID of conflicting resource.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def message(self) -> "builtins.str":
        """
        Detailed info about conflict.
        """
        
        return super()._get_field("message", explicit_presence=False,
        )
    @message.setter
    def message(self, value: "builtins.str|None") -> None:
        return super()._set_field("message",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_id":"resource_id",
        "message":"message",
    }
    
class OperationAborted(pb_classes.Message):
    """
    Operation on the resource has been aborted by a subsequent operation.
    """
    
    __PB2_CLASS__ = error_pb2.OperationAborted
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.OperationAborted",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        operation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        aborted_by_operation_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(operation_id, unset.UnsetType):
            self.operation_id = operation_id
        if not isinstance(aborted_by_operation_id, unset.UnsetType):
            self.aborted_by_operation_id = aborted_by_operation_id
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "operation_id",
            "aborted_by_operation_id",
            "resource_id",
        ]
    
    @builtins.property
    def operation_id(self) -> "builtins.str":
        """
        ID of the aborted operation.
        """
        
        return super()._get_field("operation_id", explicit_presence=False,
        )
    @operation_id.setter
    def operation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("operation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def aborted_by_operation_id(self) -> "builtins.str":
        """
        ID of the subsequent operation.
        """
        
        return super()._get_field("aborted_by_operation_id", explicit_presence=False,
        )
    @aborted_by_operation_id.setter
    def aborted_by_operation_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("aborted_by_operation_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        Resource ID corresponding to both of the operations.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "operation_id":"operation_id",
        "aborted_by_operation_id":"aborted_by_operation_id",
        "resource_id":"resource_id",
    }
    
class OutOfRange(pb_classes.Message):
    """
    Indicates that element with requested parameters is exceeding the particular range.
    """
    
    __PB2_CLASS__ = error_pb2.OutOfRange
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.OutOfRange",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        requested: "builtins.str|None|unset.UnsetType" = unset.Unset,
        limit: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(requested, unset.UnsetType):
            self.requested = requested
        if not isinstance(limit, unset.UnsetType):
            self.limit = limit
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "requested",
            "limit",
        ]
    
    @builtins.property
    def requested(self) -> "builtins.str":
        """
        Requested value.
        """
        
        return super()._get_field("requested", explicit_presence=False,
        )
    @requested.setter
    def requested(self, value: "builtins.str|None") -> None:
        return super()._set_field("requested",value,explicit_presence=False,
        )
    
    @builtins.property
    def limit(self) -> "builtins.str":
        """
        Available limit.
        """
        
        return super()._get_field("limit", explicit_presence=False,
        )
    @limit.setter
    def limit(self, value: "builtins.str|None") -> None:
        return super()._set_field("limit",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "requested":"requested",
        "limit":"limit",
    }
    
class PermissionDenied(pb_classes.Message):
    """
    Indicates that the action cannot be performed because there are insufficient access rights to a resource.
    """
    
    __PB2_CLASS__ = error_pb2.PermissionDenied
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.PermissionDenied",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_id",
        ]
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        ID of the resource that cannot be accessed.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_id":"resource_id",
    }
    
class InternalError(pb_classes.Message):
    """
    Generic internal error.
    """
    
    __PB2_CLASS__ = error_pb2.InternalError
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.InternalError",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        request_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        trace_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(request_id, unset.UnsetType):
            self.request_id = request_id
        if not isinstance(trace_id, unset.UnsetType):
            self.trace_id = trace_id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "request_id",
            "trace_id",
        ]
    
    @builtins.property
    def request_id(self) -> "builtins.str":
        """
        Error request ID.
        """
        
        return super()._get_field("request_id", explicit_presence=False,
        )
    @request_id.setter
    def request_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("request_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def trace_id(self) -> "builtins.str":
        """
        Trace ID for the failing request.
        """
        
        return super()._get_field("trace_id", explicit_presence=False,
        )
    @trace_id.setter
    def trace_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("trace_id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "request_id":"request_id",
        "trace_id":"trace_id",
    }
    
class TooManyRequests(pb_classes.Message):
    """
    You initiated too many requests to the service at once. Enhance your calm.
    """
    
    __PB2_CLASS__ = error_pb2.TooManyRequests
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.TooManyRequests",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        violation: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(violation, unset.UnsetType):
            self.violation = violation
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "violation",
        ]
    
    @builtins.property
    def violation(self) -> "builtins.str":
        """
        What request limit is exceeded (service-dependent).
        """
        
        return super()._get_field("violation", explicit_presence=False,
        )
    @violation.setter
    def violation(self, value: "builtins.str|None") -> None:
        return super()._set_field("violation",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "violation":"violation",
    }
    
class QuotaFailure(pb_classes.Message):
    """
    Indicates a failure due to exceeding specified limits or allocations in a system or service.
    """
    
    __PB2_CLASS__ = error_pb2.QuotaFailure
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.QuotaFailure",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class Violation(pb_classes.Message):
        __PB2_CLASS__ = error_pb2.QuotaFailure.Violation
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.QuotaFailure.Violation",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            quota: "builtins.str|None|unset.UnsetType" = unset.Unset,
            message: "builtins.str|None|unset.UnsetType" = unset.Unset,
            limit: "builtins.str|None|unset.UnsetType" = unset.Unset,
            requested: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(quota, unset.UnsetType):
                self.quota = quota
            if not isinstance(message, unset.UnsetType):
                self.message = message
            if not isinstance(limit, unset.UnsetType):
                self.limit = limit
            if not isinstance(requested, unset.UnsetType):
                self.requested = requested
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "quota",
                "message",
                "limit",
                "requested",
            ]
        
        @builtins.property
        def quota(self) -> "builtins.str":
            """
            Which quota check failed.
            """
            
            return super()._get_field("quota", explicit_presence=False,
            )
        @quota.setter
        def quota(self, value: "builtins.str|None") -> None:
            return super()._set_field("quota",value,explicit_presence=False,
            )
        
        @builtins.property
        def message(self) -> "builtins.str":
            """
            A description of how the quota check failed.
            """
            
            return super()._get_field("message", explicit_presence=False,
            )
        @message.setter
        def message(self, value: "builtins.str|None") -> None:
            return super()._set_field("message",value,explicit_presence=False,
            )
        
        @builtins.property
        def limit(self) -> "builtins.str":
            """
            Maximum permissible value.
            """
            
            return super()._get_field("limit", explicit_presence=False,
            )
        @limit.setter
        def limit(self, value: "builtins.str|None") -> None:
            return super()._set_field("limit",value,explicit_presence=False,
            )
        
        @builtins.property
        def requested(self) -> "builtins.str":
            """
            Requested value.
            """
            
            return super()._get_field("requested", explicit_presence=False,
            )
        @requested.setter
        def requested(self, value: "builtins.str|None") -> None:
            return super()._set_field("requested",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "quota":"quota",
            "message":"message",
            "limit":"limit",
            "requested":"requested",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        violations: "abc.Iterable[QuotaFailure.Violation]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(violations, unset.UnsetType):
            self.violations = violations
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "violations",
            "Violation",
        ]
    
    @builtins.property
    def violations(self) -> "abc.MutableSequence[QuotaFailure.Violation]":
        """
        Describes all quota violations.
        """
        
        return super()._get_field("violations", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(QuotaFailure.Violation,None,None),
        )
    @violations.setter
    def violations(self, value: "abc.Iterable[QuotaFailure.Violation]|None") -> None:
        return super()._set_field("violations",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "violations":"violations",
        "Violation":"Violation",
    }
    
class NotEnoughResources(pb_classes.Message):
    """
    Indicates that there are not enough resources available to perform the requested action.
    """
    
    __PB2_CLASS__ = error_pb2.NotEnoughResources
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.NotEnoughResources",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    class Violation(pb_classes.Message):
        __PB2_CLASS__ = error_pb2.NotEnoughResources.Violation
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.NotEnoughResources.Violation",error_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            resource_type: "builtins.str|None|unset.UnsetType" = unset.Unset,
            message: "builtins.str|None|unset.UnsetType" = unset.Unset,
            requested: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(resource_type, unset.UnsetType):
                self.resource_type = resource_type
            if not isinstance(message, unset.UnsetType):
                self.message = message
            if not isinstance(requested, unset.UnsetType):
                self.requested = requested
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "resource_type",
                "message",
                "requested",
            ]
        
        @builtins.property
        def resource_type(self) -> "builtins.str":
            """
            The type of resource that is insufficient.
            This field is populated when it is possible to determine the lacking resource type.
            **Not for programmatic use.**
            """
            
            return super()._get_field("resource_type", explicit_presence=False,
            )
        @resource_type.setter
        def resource_type(self, value: "builtins.str|None") -> None:
            return super()._set_field("resource_type",value,explicit_presence=False,
            )
        
        @builtins.property
        def message(self) -> "builtins.str":
            """
            A description of how the resource is insufficient.
            """
            
            return super()._get_field("message", explicit_presence=False,
            )
        @message.setter
        def message(self, value: "builtins.str|None") -> None:
            return super()._set_field("message",value,explicit_presence=False,
            )
        
        @builtins.property
        def requested(self) -> "builtins.str":
            """
            Requested value.
            """
            
            return super()._get_field("requested", explicit_presence=False,
            )
        @requested.setter
        def requested(self, value: "builtins.str|None") -> None:
            return super()._set_field("requested",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "resource_type":"resource_type",
            "message":"message",
            "requested":"requested",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        violations: "abc.Iterable[NotEnoughResources.Violation]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(violations, unset.UnsetType):
            self.violations = violations
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "violations",
            "Violation",
        ]
    
    @builtins.property
    def violations(self) -> "abc.MutableSequence[NotEnoughResources.Violation]":
        """
        Describes all resource violations.
        """
        
        return super()._get_field("violations", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(NotEnoughResources.Violation,None,None),
        )
    @violations.setter
    def violations(self, value: "abc.Iterable[NotEnoughResources.Violation]|None") -> None:
        return super()._set_field("violations",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "violations":"violations",
        "Violation":"Violation",
    }
    
# file: nebius/common/v1/metadata.proto
class ResourceMetadata(pb_classes.Message):
    """
    Common resource metadata.
    """
    
    __PB2_CLASS__ = metadata_pb2.ResourceMetadata
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.ResourceMetadata",metadata_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "created_at": well_known_1.ts_mask,
        "updated_at": well_known_1.ts_mask,
    }
    
    class LabelsEntry(pb_classes.Message):
        __PB2_CLASS__ = metadata_pb2.ResourceMetadata.LabelsEntry
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.ResourceMetadata.LabelsEntry",metadata_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            key: "builtins.str|None|unset.UnsetType" = unset.Unset,
            value: "builtins.str|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(key, unset.UnsetType):
                self.key = key
            if not isinstance(value, unset.UnsetType):
                self.value = value
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "key",
                "value",
            ]
        
        @builtins.property
        def key(self) -> "builtins.str":
            return super()._get_field("key", explicit_presence=False,
            )
        @key.setter
        def key(self, value: "builtins.str|None") -> None:
            return super()._set_field("key",value,explicit_presence=False,
            )
        
        @builtins.property
        def value(self) -> "builtins.str":
            return super()._get_field("value", explicit_presence=False,
            )
        @value.setter
        def value(self, value: "builtins.str|None") -> None:
            return super()._set_field("value",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "key":"key",
            "value":"value",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource_version: "builtins.int|None|unset.UnsetType" = unset.Unset,
        created_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        updated_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        labels: "abc.Mapping[builtins.str,builtins.str]|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
        if not isinstance(resource_version, unset.UnsetType):
            self.resource_version = resource_version
        if not isinstance(created_at, unset.UnsetType):
            self.created_at = created_at
        if not isinstance(updated_at, unset.UnsetType):
            self.updated_at = updated_at
        if not isinstance(labels, unset.UnsetType):
            self.labels = labels
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "parent_id",
            "name",
            "resource_version",
            "created_at",
            "updated_at",
            "labels",
            "LabelsEntry",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Identifier for the resource, unique for its resource type.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        Identifier of the parent resource to which the resource belongs.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        """
        Human readable name for the resource.
        """
        
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_version(self) -> "builtins.int":
        """
        Version of the resource for safe concurrent modifications and consistent reads.
        Positive and monotonically increases on each resource spec change (but *not* on each change of the
        resource's container(s) or status).
        Service allows zero value or current.
        """
        
        return super()._get_field("resource_version", explicit_presence=False,
        )
    @resource_version.setter
    def resource_version(self, value: "builtins.int|None") -> None:
        return super()._set_field("resource_version",value,explicit_presence=False,
        )
    
    @builtins.property
    def created_at(self) -> "datetime.datetime":
        """
        Timestamp indicating when the resource was created.
        """
        
        return super()._get_field("created_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @created_at.setter
    def created_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("created_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def updated_at(self) -> "datetime.datetime":
        """
        Timestamp indicating when the resource was last updated.
        """
        
        return super()._get_field("updated_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @updated_at.setter
    def updated_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("updated_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def labels(self) -> "abc.MutableMapping[builtins.str,builtins.str]":
        """
        Labels associated with the resource.
        """
        
        return super()._get_field("labels", explicit_presence=False,
        wrap=pb_classes.Map,
        )
    @labels.setter
    def labels(self, value: "abc.Mapping[builtins.str,builtins.str]|None") -> None:
        return super()._set_field("labels",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "parent_id":"parent_id",
        "name":"name",
        "resource_version":"resource_version",
        "created_at":"created_at",
        "updated_at":"updated_at",
        "labels":"labels",
        "LabelsEntry":"LabelsEntry",
    }
    
class GetByNameRequest(pb_classes.Message):
    """
    if service supports uniqueness of ResourceMetadata.name within tuple (scope) <resource_type, parent_id>
    it also must have grpc method GetByName
    """
    
    __PB2_CLASS__ = metadata_pb2.GetByNameRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.GetByNameRequest",metadata_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        name: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(name, unset.UnsetType):
            self.name = name
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "name",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def name(self) -> "builtins.str":
        return super()._get_field("name", explicit_presence=False,
        )
    @name.setter
    def name(self, value: "builtins.str|None") -> None:
        return super()._set_field("name",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "name":"name",
    }
    
# file: nebius/common/v1/operation.proto
class Operation(pb_classes.Message):
    __PB2_CLASS__ = operation_pb2.Operation
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.Operation",operation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "created_at": well_known_1.ts_mask,
        "finished_at": well_known_1.ts_mask,
        "status": well_known_1.status_mask,
    }
    
    class RequestHeader(pb_classes.Message):
        """
        Request header is a container for all the values of a particular header of a request because there is no such thing as ``map<string, repeated string>``
        """
        
        __PB2_CLASS__ = operation_pb2.Operation.RequestHeader
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.Operation.RequestHeader",operation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            values: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(values, unset.UnsetType):
                self.values = values
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "values",
            ]
        
        @builtins.property
        def values(self) -> "abc.MutableSequence[builtins.str]":
            """
            The values of a particular header from a request
            """
            
            return super()._get_field("values", explicit_presence=False,
            wrap=pb_classes.Repeated,
            )
        @values.setter
        def values(self, value: "abc.Iterable[builtins.str]|None") -> None:
            return super()._set_field("values",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "values":"values",
        }
        
    
    class RequestHeadersEntry(pb_classes.Message):
        __PB2_CLASS__ = operation_pb2.Operation.RequestHeadersEntry
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.Operation.RequestHeadersEntry",operation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            key: "builtins.str|None|unset.UnsetType" = unset.Unset,
            value: "Operation.RequestHeader|operation_pb2.Operation.RequestHeader|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(key, unset.UnsetType):
                self.key = key
            if not isinstance(value, unset.UnsetType):
                self.value = value
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "key",
                "value",
            ]
        
        @builtins.property
        def key(self) -> "builtins.str":
            return super()._get_field("key", explicit_presence=False,
            )
        @key.setter
        def key(self, value: "builtins.str|None") -> None:
            return super()._set_field("key",value,explicit_presence=False,
            )
        
        @builtins.property
        def value(self) -> "Operation.RequestHeader":
            return super()._get_field("value", explicit_presence=False,
            wrap=Operation.RequestHeader,
            )
        @value.setter
        def value(self, value: "Operation.RequestHeader|operation_pb2.Operation.RequestHeader|None") -> None:
            return super()._set_field("value",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "key":"key",
            "value":"value",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        created_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        created_by: "builtins.str|None|unset.UnsetType" = unset.Unset,
        finished_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        request: "any_pb2.Any|None|unset.UnsetType" = unset.Unset,
        request_headers: "abc.Mapping[builtins.str,Operation.RequestHeader]|None|unset.UnsetType" = unset.Unset,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        status: "status_pb2.Status|request_status.RequestStatus|None|unset.UnsetType" = unset.Unset,
        progress_data: "any_pb2.Any|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(created_at, unset.UnsetType):
            self.created_at = created_at
        if not isinstance(created_by, unset.UnsetType):
            self.created_by = created_by
        if not isinstance(finished_at, unset.UnsetType):
            self.finished_at = finished_at
        if not isinstance(request, unset.UnsetType):
            self.request = request
        if not isinstance(request_headers, unset.UnsetType):
            self.request_headers = request_headers
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
        if not isinstance(status, unset.UnsetType):
            self.status = status
        if not isinstance(progress_data, unset.UnsetType):
            self.progress_data = progress_data
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "description",
            "created_at",
            "created_by",
            "finished_at",
            "request",
            "request_headers",
            "resource_id",
            "status",
            "progress_data",
            "RequestHeader",
            "RequestHeadersEntry",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of the operation.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        """
        Human-readable description of the operation. 0-256 characters long.
        """
        
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def created_at(self) -> "datetime.datetime":
        """
        Creation timestamp.
        """
        
        return super()._get_field("created_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @created_at.setter
    def created_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("created_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def created_by(self) -> "builtins.str":
        """
        ID of the user or service account who initiated the operation.
        """
        
        return super()._get_field("created_by", explicit_presence=False,
        )
    @created_by.setter
    def created_by(self, value: "builtins.str|None") -> None:
        return super()._set_field("created_by",value,explicit_presence=False,
        )
    
    @builtins.property
    def finished_at(self) -> "datetime.datetime":
        """
        The time when the operation has finished.
        """
        
        return super()._get_field("finished_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @finished_at.setter
    def finished_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("finished_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def request(self) -> "any_pb2.Any":
        """
        The request that generated this operation.
        """
        
        return super()._get_field("request", explicit_presence=False,
        )
    @request.setter
    def request(self, value: "any_pb2.Any|None") -> None:
        return super()._set_field("request",value,explicit_presence=False,
        )
    
    @builtins.property
    def request_headers(self) -> "abc.MutableMapping[builtins.str,Operation.RequestHeader]":
        """
        The request headers that are essential for the request that generated the operation.
        For instance, ``x-resetmask``. Without these headers the request might have been processed
        differently if repeated.
        All the header names *must* be converted to lower case.
        Validator is based on:
        https://httpwg.org/specs/rfc9110.html#considerations.for.new.field.names
        """
        
        return super()._get_field("request_headers", explicit_presence=False,
        wrap=pb_classes.Map.with_wrap(Operation.RequestHeader,None,None),
        )
    @request_headers.setter
    def request_headers(self, value: "abc.Mapping[builtins.str,Operation.RequestHeader]|None") -> None:
        return super()._set_field("request_headers",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        ID of the resource that this operation creates, updates, deletes or otherwise changes.
        
        If the operation affects multiple resources or does not affect any API resources at all
        (e.g. a routine maintenance operation visible to the user), the [resource_id] must be empty.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "request_status.RequestStatus|None":
        """
        The status of this operation. Set when this operation is completed.
        See https://github.com/grpc/grpc/blob/master/src/proto/grpc/status/status.proto.
        
        [status.code] is https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto:
        
        
        * If [status.code] == OK, the operation has completed successfully.
        * If [status.code] != OK, the operation has failed or has been cancelled.
        
          * [status.message] will contain a user-readable and actionable error message.
          * [status.details] will contain additional diagnostic information in the form of [ServiceError] from nebius/common/v1/error.proto
        
        * [status.code] must belong to an Operation-compatible subset of GRPC codes:
          OK, CANCELLED, PERMISSION_DENIED, RESOURCE_EXHAUSTED, FAILED_PRECONDITION, ABORTED, INTERNAL
        """
        
        return super()._get_field("status", explicit_presence=True,
        wrap=request_status.request_status_from_rpc_status
        )
    @status.setter
    def status(self, value: "status_pb2.Status|request_status.RequestStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=True,
        unwrap=request_status.request_status_to_rpc_status
        )
    
    @builtins.property
    def progress_data(self) -> "any_pb2.Any":
        """
        Extra information about this operation's progress. MAY be absent while the operation is running, MUST be absent after the operation has completed.
        
        Type of message that's stored inside [progress_data] is service-dependent.
        """
        
        return super()._get_field("progress_data", explicit_presence=False,
        )
    @progress_data.setter
    def progress_data(self, value: "any_pb2.Any|None") -> None:
        return super()._set_field("progress_data",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "description":"description",
        "created_at":"created_at",
        "created_by":"created_by",
        "finished_at":"finished_at",
        "request":"request",
        "request_headers":"request_headers",
        "resource_id":"resource_id",
        "status":"status",
        "progress_data":"progress_data",
        "RequestHeader":"RequestHeader",
        "RequestHeadersEntry":"RequestHeadersEntry",
    }
    
# file: nebius/common/v1/operation_service.proto
class GetOperationRequest(pb_classes.Message):
    __PB2_CLASS__ = operation_service_pb2.GetOperationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.GetOperationRequest",operation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListOperationsRequest(pb_classes.Message):
    __PB2_CLASS__ = operation_service_pb2.ListOperationsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.ListOperationsRequest",operation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_id",
            "page_size",
            "page_token",
        ]
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        ID of the Resource to list operations for.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Page size. [1...1000]. Optional, if not specified, a reasonable default will be chosen by the service.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Listing continuation token. Empty to start listing from the first page.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_id":"resource_id",
        "page_size":"page_size",
        "page_token":"page_token",
    }
    
class ListOperationsResponse(pb_classes.Message):
    __PB2_CLASS__ = operation_service_pb2.ListOperationsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.ListOperationsResponse",operation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        operations: "abc.Iterable[Operation]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(operations, unset.UnsetType):
            self.operations = operations
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "operations",
            "next_page_token",
        ]
    
    @builtins.property
    def operations(self) -> "abc.MutableSequence[Operation]":
        return super()._get_field("operations", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Operation,None,None),
        )
    @operations.setter
    def operations(self, value: "abc.Iterable[Operation]|None") -> None:
        return super()._set_field("operations",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "operations":"operations",
        "next_page_token":"next_page_token",
    }
    

class OperationServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.common.v1.OperationService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.common.v1.OperationService",operation_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.common.v1.OperationService"
    
    def get(self,
        request: "GetOperationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetOperationRequest","operation.Operation[Operation]"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.GetOperationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.Operation`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list(self,
        request: "ListOperationsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListOperationsRequest","ListOperationsResponse"]:
        """
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1.ListOperationsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1.ListOperationsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=operation_service_pb2.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListOperationsResponse),
        )
    

# file: nebius/common/v1/resource_event.proto
class ResourceEvent(pb_classes.Message):
    """
    Represents an API Resource-related event which is potentially important to the end-user. What exactly constitutes an *event* to be reported is service-dependent
    """
    
    __PB2_CLASS__ = resource_event_pb2.ResourceEvent
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.ResourceEvent",resource_event_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "occurred_at": well_known_1.ts_mask,
        "error": well_known_1.status_mask,
    }
    
    class Level(pb_enum.Enum):
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.EnumDescriptor](".nebius.common.v1.ResourceEvent.Level",resource_event_pb2.DESCRIPTOR,descriptor_1.EnumDescriptor)
        UNSPECIFIED = 0
        """
        Unspecified event severity level
        """
        
        DEBUG = 1
        """
        A debug event providing detailed insight. Such events are used to debug problems with specific resource(s) and process(es)
        """
        
        INFO = 2
        """
        A normal event or state change. Informs what is happening with the API resource. Does not require user attention or interaction
        """
        
        WARN = 3
        """
        Warning event. Indicates a potential or minor problem with the API resource and/or the corresponding processes. Needs user attention, but requires no immediate action (yet)
        """
        
        ERROR = 4
        """
        Error event. Indicates a serious problem with the API resource and/or the corresponding processes. Requires immediate user action
        """
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        occurred_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        level: "ResourceEvent.Level|resource_event_pb2.ResourceEvent.Level|None|unset.UnsetType" = unset.Unset,
        code: "builtins.str|None|unset.UnsetType" = unset.Unset,
        message: "builtins.str|None|unset.UnsetType" = unset.Unset,
        error: "status_pb2.Status|request_status.RequestStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(occurred_at, unset.UnsetType):
            self.occurred_at = occurred_at
        if not isinstance(level, unset.UnsetType):
            self.level = level
        if not isinstance(code, unset.UnsetType):
            self.code = code
        if not isinstance(message, unset.UnsetType):
            self.message = message
        if not isinstance(error, unset.UnsetType):
            self.error = error
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "occurred_at",
            "level",
            "code",
            "message",
            "error",
            "Level",
        ]
    
    @builtins.property
    def occurred_at(self) -> "datetime.datetime":
        """
        Time at which the event has occurred
        """
        
        return super()._get_field("occurred_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @occurred_at.setter
    def occurred_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("occurred_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def level(self) -> "ResourceEvent.Level":
        """
        Severity level for the event
        """
        
        return super()._get_field("level", explicit_presence=False,
        wrap=ResourceEvent.Level,
        )
    @level.setter
    def level(self, value: "ResourceEvent.Level|resource_event_pb2.ResourceEvent.Level|None") -> None:
        return super()._set_field("level",value,explicit_presence=False,
        )
    
    @builtins.property
    def code(self) -> "builtins.str":
        """
        Event code (unique within the API service), in UpperCamelCase, e.g. ``"DiskAttached"``
        """
        
        return super()._get_field("code", explicit_presence=False,
        )
    @code.setter
    def code(self, value: "builtins.str|None") -> None:
        return super()._set_field("code",value,explicit_presence=False,
        )
    
    @builtins.property
    def message(self) -> "builtins.str":
        """
        A human-readable message describing what has happened (and suggested actions for the user, if this is a ``WARN``\\ - or ``ERROR``\\ -level event)
        """
        
        return super()._get_field("message", explicit_presence=False,
        )
    @message.setter
    def message(self, value: "builtins.str|None") -> None:
        return super()._set_field("message",value,explicit_presence=False,
        )
    
    @builtins.property
    def error(self) -> "request_status.RequestStatus|None":
        """
        Describes a GRPC error status associated with an ``ERROR``\\ - or ``WARN``\\ -level event, if known. The ``error`` **must** have a standard GRPC ``code`` (which **must not** be ``OK`` (0)) and a human-readable ``message``. A standard ``common.v1.ServiceError`` **should** also be included in ``details``
        """
        
        return super()._get_field("error", explicit_presence=True,
        wrap=request_status.request_status_from_rpc_status
        )
    @error.setter
    def error(self, value: "status_pb2.Status|request_status.RequestStatus|None") -> None:
        return super()._set_field("error",value,explicit_presence=True,
        unwrap=request_status.request_status_to_rpc_status
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "occurred_at":"occurred_at",
        "level":"level",
        "code":"code",
        "message":"message",
        "error":"error",
        "Level":"Level",
    }
    
class RecurrentResourceEvent(pb_classes.Message):
    """
    A resource event that has occurred (more or less in the same way) multiple times across a service-defined aggregation interval
    """
    
    __PB2_CLASS__ = resource_event_pb2.RecurrentResourceEvent
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1.RecurrentResourceEvent",resource_event_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "first_occurred_at": well_known_1.ts_mask,
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        first_occurred_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        last_occurrence: "ResourceEvent|resource_event_pb2.ResourceEvent|None|unset.UnsetType" = unset.Unset,
        occurrence_count: "builtins.int|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(first_occurred_at, unset.UnsetType):
            self.first_occurred_at = first_occurred_at
        if not isinstance(last_occurrence, unset.UnsetType):
            self.last_occurrence = last_occurrence
        if not isinstance(occurrence_count, unset.UnsetType):
            self.occurrence_count = occurrence_count
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "first_occurred_at",
            "last_occurrence",
            "occurrence_count",
        ]
    
    @builtins.property
    def first_occurred_at(self) -> "datetime.datetime":
        """
        Time of the first occurrence of a recurrent event
        """
        
        return super()._get_field("first_occurred_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @first_occurred_at.setter
    def first_occurred_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("first_occurred_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def last_occurrence(self) -> "ResourceEvent":
        """
        Last occurrence of a recurrent event
        """
        
        return super()._get_field("last_occurrence", explicit_presence=False,
        wrap=ResourceEvent,
        )
    @last_occurrence.setter
    def last_occurrence(self, value: "ResourceEvent|resource_event_pb2.ResourceEvent|None") -> None:
        return super()._set_field("last_occurrence",value,explicit_presence=False,
        )
    
    @builtins.property
    def occurrence_count(self) -> "builtins.int":
        """
        The number of times this event has occurred between ``first_occurred_at`` and ``last_occurrence.occurred_at``. Must be > 0
        """
        
        return super()._get_field("occurrence_count", explicit_presence=False,
        )
    @occurrence_count.setter
    def occurrence_count(self, value: "builtins.int|None") -> None:
        return super()._set_field("occurrence_count",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "first_occurred_at":"first_occurred_at",
        "last_occurrence":"last_occurrence",
        "occurrence_count":"occurrence_count",
    }
    
__all__ = [
    #@ local import names here @#
    "ServiceError",
    "BadRequest",
    "BadResourceState",
    "ResourceNotFound",
    "ResourceAlreadyExists",
    "ResourceConflict",
    "OperationAborted",
    "OutOfRange",
    "PermissionDenied",
    "InternalError",
    "TooManyRequests",
    "QuotaFailure",
    "NotEnoughResources",
    "ResourceMetadata",
    "GetByNameRequest",
    "Operation",
    "GetOperationRequest",
    "ListOperationsRequest",
    "ListOperationsResponse",
    "OperationServiceClient",
    "ResourceEvent",
    "RecurrentResourceEvent",
]
