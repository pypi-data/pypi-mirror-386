# 
# Generated by the nebius.base.protos.compiler.  DO NOT EDIT!
# 

"""Auto-generated Nebius SDK package for ``nebius.common.v1alpha1``"""

import builtins as builtins
import collections.abc as abc
import datetime as datetime
import google.protobuf.any_pb2 as any_pb2
import google.protobuf.descriptor as descriptor_1
import google.protobuf.message as message_1
import google.protobuf.timestamp_pb2 as timestamp_pb2
import google.rpc.status_pb2 as status_pb2
import grpc as grpc
import nebius.aio.client as client
import nebius.aio.operation as operation
import nebius.aio.request as request_1
import nebius.aio.request_status as request_status
import nebius.api.nebius.common.v1alpha1.operation_pb2 as operation_pb2
import nebius.api.nebius.common.v1alpha1.operation_service_pb2 as operation_service_pb2
import nebius.base.protos.descriptor as descriptor
import nebius.base.protos.pb_classes as pb_classes
import nebius.base.protos.unset as unset
import nebius.base.protos.well_known as well_known_1
#@ local imports here @#

# file: nebius/common/v1alpha1/operation.proto
class Operation(pb_classes.Message):
    __PB2_CLASS__ = operation_pb2.Operation
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1alpha1.Operation",operation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
        "created_at": well_known_1.ts_mask,
        "finished_at": well_known_1.ts_mask,
        "status": well_known_1.status_mask,
    }
    
    class request_header(pb_classes.Message):
        """
        Request header is a container for all the values of a particular header of a request
        as there is no such thing as map<string, repeated string>
        """
        
        __PB2_CLASS__ = operation_pb2.Operation.request_header
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1alpha1.Operation.request_header",operation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            values: "abc.Iterable[builtins.str]|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(values, unset.UnsetType):
                self.values = values
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "values",
            ]
        
        @builtins.property
        def values(self) -> "abc.MutableSequence[builtins.str]":
            """
            The values of a particular header from a request
            """
            
            return super()._get_field("values", explicit_presence=False,
            wrap=pb_classes.Repeated,
            )
        @values.setter
        def values(self, value: "abc.Iterable[builtins.str]|None") -> None:
            return super()._set_field("values",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "values":"values",
        }
        
    
    class RequestHeadersEntry(pb_classes.Message):
        __PB2_CLASS__ = operation_pb2.Operation.RequestHeadersEntry
        __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1alpha1.Operation.RequestHeadersEntry",operation_pb2.DESCRIPTOR,descriptor_1.Descriptor)
        __mask_functions__ = {
        }
        
        def __init__(
            self,
            initial_message: message_1.Message|None = None,
            *,
            key: "builtins.str|None|unset.UnsetType" = unset.Unset,
            value: "Operation.request_header|operation_pb2.Operation.request_header|None|unset.UnsetType" = unset.Unset,
        ) -> None:
            super().__init__(initial_message)
            if not isinstance(key, unset.UnsetType):
                self.key = key
            if not isinstance(value, unset.UnsetType):
                self.value = value
        
        def __dir__(self) ->abc.Iterable[builtins.str]:
            return [
                "key",
                "value",
            ]
        
        @builtins.property
        def key(self) -> "builtins.str":
            return super()._get_field("key", explicit_presence=False,
            )
        @key.setter
        def key(self, value: "builtins.str|None") -> None:
            return super()._set_field("key",value,explicit_presence=False,
            )
        
        @builtins.property
        def value(self) -> "Operation.request_header":
            return super()._get_field("value", explicit_presence=False,
            wrap=Operation.request_header,
            )
        @value.setter
        def value(self, value: "Operation.request_header|operation_pb2.Operation.request_header|None") -> None:
            return super()._set_field("value",value,explicit_presence=False,
            )
        
        __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
            "key":"key",
            "value":"value",
        }
        
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        description: "builtins.str|None|unset.UnsetType" = unset.Unset,
        created_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        created_by: "builtins.str|None|unset.UnsetType" = unset.Unset,
        finished_at: "timestamp_pb2.Timestamp|datetime.datetime|None|unset.UnsetType" = unset.Unset,
        request: "any_pb2.Any|None|unset.UnsetType" = unset.Unset,
        request_headers: "abc.Mapping[builtins.str,Operation.request_header]|None|unset.UnsetType" = unset.Unset,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        resource: "any_pb2.Any|None|unset.UnsetType" = unset.Unset,
        progress_data: "any_pb2.Any|None|unset.UnsetType" = unset.Unset,
        status: "status_pb2.Status|request_status.RequestStatus|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
        if not isinstance(description, unset.UnsetType):
            self.description = description
        if not isinstance(created_at, unset.UnsetType):
            self.created_at = created_at
        if not isinstance(created_by, unset.UnsetType):
            self.created_by = created_by
        if not isinstance(finished_at, unset.UnsetType):
            self.finished_at = finished_at
        if not isinstance(request, unset.UnsetType):
            self.request = request
        if not isinstance(request_headers, unset.UnsetType):
            self.request_headers = request_headers
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
        if not isinstance(resource, unset.UnsetType):
            self.resource = resource
        if not isinstance(progress_data, unset.UnsetType):
            self.progress_data = progress_data
        if not isinstance(status, unset.UnsetType):
            self.status = status
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
            "description",
            "created_at",
            "created_by",
            "finished_at",
            "request",
            "request_headers",
            "resource_id",
            "resource",
            "progress_data",
            "status",
            "request_header",
            "RequestHeadersEntry",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        ID of the operation.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    @builtins.property
    def description(self) -> "builtins.str":
        """
        Human readable description of the operation. 0-256 characters long.
        """
        
        return super()._get_field("description", explicit_presence=False,
        )
    @description.setter
    def description(self, value: "builtins.str|None") -> None:
        return super()._set_field("description",value,explicit_presence=False,
        )
    
    @builtins.property
    def created_at(self) -> "datetime.datetime":
        """
        Creation timestamp.
        """
        
        return super()._get_field("created_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @created_at.setter
    def created_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("created_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def created_by(self) -> "builtins.str":
        """
        ID of the user or service account who initiated the operation.
        """
        
        return super()._get_field("created_by", explicit_presence=False,
        )
    @created_by.setter
    def created_by(self, value: "builtins.str|None") -> None:
        return super()._set_field("created_by",value,explicit_presence=False,
        )
    
    @builtins.property
    def finished_at(self) -> "datetime.datetime":
        """
        The time when the operation finished.
        """
        
        return super()._get_field("finished_at", explicit_presence=False,
        wrap=well_known_1.from_timestamp
        )
    @finished_at.setter
    def finished_at(self, value: "timestamp_pb2.Timestamp|datetime.datetime|None") -> None:
        return super()._set_field("finished_at",value,explicit_presence=False,
        unwrap=well_known_1.to_timestamp
        )
    
    @builtins.property
    def request(self) -> "any_pb2.Any":
        """
        The request that generated this operation.
        """
        
        return super()._get_field("request", explicit_presence=False,
        )
    @request.setter
    def request(self, value: "any_pb2.Any|None") -> None:
        return super()._set_field("request",value,explicit_presence=False,
        )
    
    @builtins.property
    def request_headers(self) -> "abc.MutableMapping[builtins.str,Operation.request_header]":
        """
        The request headers that are essential for the request that generated the operation.
        For instance, ``x-resetmask``. Without these headers the request might have been processed
        differently if repeated.
        All the header names *must* be converted to lower case.
        Validator is based on:
        https://httpwg.org/specs/rfc9110.html#considerations.for.new.field.names
        """
        
        return super()._get_field("request_headers", explicit_presence=False,
        wrap=pb_classes.Map.with_wrap(Operation.request_header,None,None),
        )
    @request_headers.setter
    def request_headers(self, value: "abc.Mapping[builtins.str,Operation.request_header]|None") -> None:
        return super()._set_field("request_headers",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        ID of the resource that this operation creates, updates, deletes or otherwise changes.
        
        If the operation affects multiple resources or does not affect any API resources at all
        (e.g. a routine maintenance operation visible to the user), the [resource_id] must be empty.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def resource(self) -> "any_pb2.Any":
        """
        .. role:: raw-html-m2r(raw)
           :format: html
        
        
        Snapshot of the resource at the moment this operation started.
        
        
        * [resource.spec] and [resource.metadata] reflect the desired resource state at the moment
          this operation started.
          E.g., in an Update operation it will be the *updated* resource spec and metadata,
          in a Create operation it will be the spec and metadata *of the resource being created*\\ ,
          and so on.
        * [resource.status] reflects the status of the resource at the moment this operation started.
          This is a snapshot, call the :raw-html-m2r:`<Resource>`\\ Service/Get to get current status of the resource.
        
        The [resource] field MUST never be updated *after* this operation has started.
        
        In a Delete operation, an operation affecting multiple resources or an operation that doesn't
        affect any API resources at all (e.g. a routine maintenance operation visible to the user),
        the [resource] inside MUST be a [google.protobuf.Empty].
        """
        
        return super()._get_field("resource", explicit_presence=False,
        )
    @resource.setter
    def resource(self, value: "any_pb2.Any|None") -> None:
        return super()._set_field("resource",value,explicit_presence=False,
        )
    
    @builtins.property
    def progress_data(self) -> "any_pb2.Any":
        """
        Additional information about the progress of an operation, e.g., a progress percentage.
        MAY be absent while the operation is running, MUST be absent after the operation has completed.
        
        Format of message inside [progress_data] is service-dependent and MUST be documented by the
        service, IF it is used.
        """
        
        return super()._get_field("progress_data", explicit_presence=False,
        )
    @progress_data.setter
    def progress_data(self, value: "any_pb2.Any|None") -> None:
        return super()._set_field("progress_data",value,explicit_presence=False,
        )
    
    @builtins.property
    def status(self) -> "request_status.RequestStatus|None":
        """
        The status of this operation. Set when this operation is completed.
        See https://github.com/grpc/grpc/blob/master/src/proto/grpc/status/status.proto.
        
        [status.code] is https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto:
        
        
        * If [status.code] == OK, the operation has completed successfully.
        * If [status.code] != OK, the operation has failed or has been cancelled.
        
          * [status.message] will contain a user-readable and actionable error message.
          * [status.details] will contain additional diagnostic information in the form of
            [ServiceError] from ../error/v1alpha1/error.proto
        
        * [status.code] must belong to an Operation-compatible subset of GRPC codes:
          OK, CANCELLED, PERMISSION_DENIED, RESOURCE_EXHAUSTED, FAILED_PRECONDITION, ABORTED, INTERNAL
        """
        
        return super()._get_field("status", explicit_presence=True,
        wrap=request_status.request_status_from_rpc_status
        )
    @status.setter
    def status(self, value: "status_pb2.Status|request_status.RequestStatus|None") -> None:
        return super()._set_field("status",value,explicit_presence=True,
        unwrap=request_status.request_status_to_rpc_status
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
        "description":"description",
        "created_at":"created_at",
        "created_by":"created_by",
        "finished_at":"finished_at",
        "request":"request",
        "request_headers":"request_headers",
        "resource_id":"resource_id",
        "resource":"resource",
        "progress_data":"progress_data",
        "status":"status",
        "request_header":"request_header",
        "RequestHeadersEntry":"RequestHeadersEntry",
    }
    
# file: nebius/common/v1alpha1/operation_service.proto
class GetOperationRequest(pb_classes.Message):
    __PB2_CLASS__ = operation_service_pb2.GetOperationRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1alpha1.GetOperationRequest",operation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        id: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(id, unset.UnsetType):
            self.id = id
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "id",
        ]
    
    @builtins.property
    def id(self) -> "builtins.str":
        """
        Operation ID.
        """
        
        return super()._get_field("id", explicit_presence=False,
        )
    @id.setter
    def id(self, value: "builtins.str|None") -> None:
        return super()._set_field("id",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "id":"id",
    }
    
class ListOperationsRequest(pb_classes.Message):
    __PB2_CLASS__ = operation_service_pb2.ListOperationsRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1alpha1.ListOperationsRequest",operation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        resource_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(resource_id, unset.UnsetType):
            self.resource_id = resource_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "resource_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def resource_id(self) -> "builtins.str":
        """
        ID of the Resource to list operations for.
        """
        
        return super()._get_field("resource_id", explicit_presence=False,
        )
    @resource_id.setter
    def resource_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("resource_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Page size. [1...1000]. Optional, if not specified, a reasonable default will be chosen by the service.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Listing continuation token. Empty to start listing from the first page.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Filter expression for the listing results. Optional.
        Filter expression format: TBD.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "resource_id":"resource_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    
class ListOperationsResponse(pb_classes.Message):
    __PB2_CLASS__ = operation_service_pb2.ListOperationsResponse
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1alpha1.ListOperationsResponse",operation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        operations: "abc.Iterable[Operation]|None|unset.UnsetType" = unset.Unset,
        next_page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(operations, unset.UnsetType):
            self.operations = operations
        if not isinstance(next_page_token, unset.UnsetType):
            self.next_page_token = next_page_token
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "operations",
            "next_page_token",
        ]
    
    @builtins.property
    def operations(self) -> "abc.MutableSequence[Operation]":
        """
        List of operations on this result page.
        """
        
        return super()._get_field("operations", explicit_presence=False,
        wrap=pb_classes.Repeated.with_wrap(Operation,None,None),
        )
    @operations.setter
    def operations(self, value: "abc.Iterable[Operation]|None") -> None:
        return super()._set_field("operations",value,explicit_presence=False,
        )
    
    @builtins.property
    def next_page_token(self) -> "builtins.str":
        """
        Listing continuation token for the next page of results.
        """
        
        return super()._get_field("next_page_token", explicit_presence=False,
        )
    @next_page_token.setter
    def next_page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("next_page_token",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "operations":"operations",
        "next_page_token":"next_page_token",
    }
    
class ListOperationsByParentRequest(pb_classes.Message):
    __PB2_CLASS__ = operation_service_pb2.ListOperationsByParentRequest
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.Descriptor](".nebius.common.v1alpha1.ListOperationsByParentRequest",operation_service_pb2.DESCRIPTOR,descriptor_1.Descriptor)
    __mask_functions__ = {
    }
    
    def __init__(
        self,
        initial_message: message_1.Message|None = None,
        *,
        parent_id: "builtins.str|None|unset.UnsetType" = unset.Unset,
        page_size: "builtins.int|None|unset.UnsetType" = unset.Unset,
        page_token: "builtins.str|None|unset.UnsetType" = unset.Unset,
        filter: "builtins.str|None|unset.UnsetType" = unset.Unset,
    ) -> None:
        super().__init__(initial_message)
        if not isinstance(parent_id, unset.UnsetType):
            self.parent_id = parent_id
        if not isinstance(page_size, unset.UnsetType):
            self.page_size = page_size
        if not isinstance(page_token, unset.UnsetType):
            self.page_token = page_token
        if not isinstance(filter, unset.UnsetType):
            self.filter = filter
    
    def __dir__(self) ->abc.Iterable[builtins.str]:
        return [
            "parent_id",
            "page_size",
            "page_token",
            "filter",
        ]
    
    @builtins.property
    def parent_id(self) -> "builtins.str":
        """
        ID of the parent to list operations for resource type at.
        """
        
        return super()._get_field("parent_id", explicit_presence=False,
        )
    @parent_id.setter
    def parent_id(self, value: "builtins.str|None") -> None:
        return super()._set_field("parent_id",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_size(self) -> "builtins.int":
        """
        Page size. [1...1000]. Optional, if not specified, a reasonable default will be chosen by the service.
        """
        
        return super()._get_field("page_size", explicit_presence=False,
        )
    @page_size.setter
    def page_size(self, value: "builtins.int|None") -> None:
        return super()._set_field("page_size",value,explicit_presence=False,
        )
    
    @builtins.property
    def page_token(self) -> "builtins.str":
        """
        Listing continuation token. Empty to start listing from the first page.
        """
        
        return super()._get_field("page_token", explicit_presence=False,
        )
    @page_token.setter
    def page_token(self, value: "builtins.str|None") -> None:
        return super()._set_field("page_token",value,explicit_presence=False,
        )
    
    @builtins.property
    def filter(self) -> "builtins.str":
        """
        Filter expression for the listing results. Optional.
        Filter expression format: TBD.
        """
        
        return super()._get_field("filter", explicit_presence=False,
        )
    @filter.setter
    def filter(self, value: "builtins.str|None") -> None:
        return super()._set_field("filter",value,explicit_presence=False,
        )
    
    __PY_TO_PB2__: builtins.dict[builtins.str,builtins.str] = {
        "parent_id":"parent_id",
        "page_size":"page_size",
        "page_token":"page_token",
        "filter":"filter",
    }
    

class OperationServiceClient(client.Client):
    """
    This class provides the client methods for the ``.nebius.common.v1alpha1.OperationService`` service.
    
    Each method constructs a :class:`nebius.aio.request.Request` object
    that represents the in-flight RPC. The request can be awaited (async)
    or waited synchronously using its ``.wait()`` helpers.
    
    The request methods accept various parameters to configure metadata,
    timeouts, authorization, and retries. See individual method docstrings
    for details.
    
    :cvar __service_name__: The full protobuf service name.
    """
    
    __PB2_DESCRIPTOR__ = descriptor.DescriptorWrap[descriptor_1.ServiceDescriptor](".nebius.common.v1alpha1.OperationService",operation_service_pb2.DESCRIPTOR,descriptor_1.ServiceDescriptor)
    """The protobuf service descriptor extraction function."""
    __service_name__ = ".nebius.common.v1alpha1.OperationService"
    
    def get(self,
        request: "GetOperationRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["GetOperationRequest","operation.Operation[Operation]"]:
        """
        Returns the latest state of the specified operation.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1alpha1.GetOperationRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.Operation`.
        """
        
        return super().request(
            method="Get",
            request=request,
            result_pb2_class=operation_pb2.Operation,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=operation.Operation,
        )
    
    def list(self,
        request: "ListOperationsRequest",
        metadata: abc.Iterable[builtins.tuple[builtins.str,builtins.str]]|None = None,
        timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
        auth_options: builtins.dict[builtins.str,builtins.str] | None = None,
        credentials: grpc.CallCredentials | None = None,
        compression: grpc.Compression | None = None,
        retries: builtins.int | None = 3,
        per_retry_timeout: builtins.float|unset.UnsetType|None = unset.Unset,
    ) -> request_1.Request["ListOperationsRequest","ListOperationsResponse"]:
        """
        Lists operations for the specified resource.
        
        :param request: The request object to send.
        :type request: :class:`nebius.api.nebius.common.v1alpha1.ListOperationsRequest`
        :param metadata: attach these values as gRPC metadata to the outgoing request.
        :type metadata: optional sequence of (str, str) pairs
        :param timeout: Request timeout in seconds, not accounting for authorization.
            If ``None``, disables the request deadline.
        :type timeout: optional float
        :param auth_timeout: Bound on the total time spent authenticating (token
            acquisition and renewal) plus the enclosed request execution. See README for
            details. Unset parameter sets the default.
        :type auth_timeout: optional float
        :param auth_options: Authorization-specific options that are forwarded to the
            authorization subsystem (for example, to make token renewal synchronous or
            to surface renewal errors as request errors).
        :type auth_options: optional dict[str, str]
        :param credentials: Overrides any SDK-level credentials.
        :type credentials: optional :class:`grpc.CallCredentials`
        :param compression: Compression setting to apply to the call, overrides
            SDK-level settings.
        :type compression: optional :class:`grpc.Compression`
        :param retries: Number of retry attempts for the request.
        :type retries: optional int
        :param per_retry_timeout: Optional per-attempt timeout in seconds. If not
            provided, will be set to default.
        :type per_retry_timeout: optional float
        
        :return: A :class:`nebius.aio.request.Request` object representing the
            in-flight RPC. It can be awaited (async) or waited
            synchronously using its ``.wait()`` helpers.
        :rtype: :class:`nebius.aio.request.Request` of
            :class:`nebius.api.nebius.common.v1alpha1.ListOperationsResponse`.
        """
        
        return super().request(
            method="List",
            request=request,
            result_pb2_class=operation_service_pb2.ListOperationsResponse,
            metadata=metadata,
            timeout=timeout,
            auth_timeout=auth_timeout,
            auth_options=auth_options,
            credentials=credentials,
            compression=compression,
            retries=retries,
            per_retry_timeout=per_retry_timeout,
            result_wrapper=pb_classes.simple_wrapper(ListOperationsResponse),
        )
    

__all__ = [
    #@ local import names here @#
    "Operation",
    "GetOperationRequest",
    "ListOperationsRequest",
    "ListOperationsResponse",
    "ListOperationsByParentRequest",
    "OperationServiceClient",
]
