{"guide": {"name": "state-in-blocks", "category": "building-with-blocks", "pretty_category": "Building With Blocks", "guide_index": 3, "absolute_index": 9, "pretty_name": "State In Blocks", "content": "# Managing State\n\nWhen building a Gradio application with `gr.Blocks()`, you may want to share certain values between users (e.g. a count of visitors to your page), or persist values for a single user across certain interactions (e.g. a chat history). This referred to as **state** and there are three general ways to manage state in a Gradio application:\n\n* **Global state**: persist and share values among all users of your Gradio application while your Gradio application is running\n* **Session state**: persist values for each user of your Gradio application while they are using your Gradio application in a single session. If they refresh the page, session state will be reset.\n* **Browser state**: persist values for each user of your Gradio application in the browser's localStorage, allowing data to persist even after the page is refreshed or closed.\n\n## Global State\n\nGlobal state in Gradio apps is very simple: any variable created outside of a function is shared globally between all users.\n\nThis makes managing global state very simple and without the need for external services. For example, in this application, the `visitor_count` variable is shared between all users\n\n```py\nimport gradio as gr\n\n# Shared between all users\nvisitor_count = 0\n\ndef increment_counter():\n    global visitor_count\n    visitor_count += 1\n    return visitor_count\n\nwith gr.Blocks() as demo:    \n    number = gr.Textbox(label=\"Total Visitors\", value=\"Counting...\")\n    demo.load(increment_counter, inputs=None, outputs=number)\n\ndemo.launch()\n```\n\nThis means that any time you do _not_ want to share a value between users, you should declare it _within_ a function. But what if you need to share values between function calls, e.g. a chat history? In that case, you should use one of the subsequent approaches to manage state.\n\n## Session State\n\nGradio supports session state, where data persists across multiple submits within a page session. To reiterate, session data is _not_ shared between different users of your model, and does _not_ persist if a user refreshes the page to reload the Gradio app. To store data in a session state, you need to do three things:\n\n1. Create a `gr.State()` object. If there is a default value to this stateful object, pass that into the constructor. Note that `gr.State` objects must be [deepcopy-able](https://docs.python.org/3/library/copy.html), otherwise you will need to use a different approach as described below.\n2. In the event listener, put the `State` object as an input and output as needed.\n3. In the event listener function, add the variable to the input parameters and the return value.\n\nLet's take a look at a simple example. We have a simple checkout app below where you add items to a cart. You can also see the size of the cart.\n\n```python\nimport gradio as gr\n\nwith gr.Blocks() as demo:\n    cart = gr.State([])\n    items_to_add = gr.CheckboxGroup([\"Cereal\", \"Milk\", \"Orange Juice\", \"Water\"])\n\n    def add_items(new_items, previous_cart):\n        cart = previous_cart + new_items\n        return cart\n\n    gr.Button(\"Add Items\").click(add_items, [items_to_add, cart], cart)\n\n    cart_size = gr.Number(label=\"Cart Size\")\n    cart.change(lambda cart: len(cart), cart, cart_size)\n\ndemo.launch()\n```\n\nNotice how we do this with state:\n\n1. We store the cart items in a `gr.State()` object, initialized here to be an empty list.\n2. When adding items to the cart, the event listener uses the cart as both input and output - it returns the updated cart with all the items inside. \n3. We can attach a `.change` listener to cart, that uses the state variable as input as well.\n\nYou can think of `gr.State` as an invisible Gradio component that can store any kind of value. Here, `cart` is not visible in the frontend but is used for calculations.\n\nThe `.change` listener for a state variable triggers after any event listener changes the value of a state variable. If the state variable holds a sequence (like a `list`, `set`, or `dict`), a change is triggered if any of the elements inside change. If it holds an object or primitive, a change is triggered if the **hash** of the  value changes. So if you define a custom class and create a `gr.State` variable that is an instance of that class, make sure that the the class includes a sensible `__hash__` implementation.\n\nThe value of a session State variable is cleared when the user refreshes the page. The value is stored on in the app backend for 60 minutes after the user closes the tab (this can be configured by the `delete_cache` parameter in `gr.Blocks`).\n\nLearn more about `State` in the [docs](https://gradio.app/docs/gradio/state).\n\n**What about objects that cannot be deepcopied?**\n\nAs mentioned earlier, the value stored in `gr.State` must be [deepcopy-able](https://docs.python.org/3/library/copy.html). If you are working with a complex object that cannot be deepcopied, you can take a different approach to manually read the user's `session_hash` and store a global `dictionary` with instances of your object for each user. Here's how you would do that:\n\n```py\nimport gradio as gr\n\nclass NonDeepCopyable:\n    def __init__(self):\n        from threading import Lock\n        self.counter = 0\n        self.lock = Lock()  # Lock objects cannot be deepcopied\n    \n    def increment(self):\n        with self.lock:\n            self.counter += 1\n            return self.counter\n\n# Global dictionary to store user-specific instances\ninstances = {}\n\ndef initialize_instance(request: gr.Request):\n    instances[request.session_hash] = NonDeepCopyable()\n    return \"Session initialized!\"\n\ndef cleanup_instance(request: gr.Request):\n    if request.session_hash in instances:\n        del instances[request.session_hash]\n\ndef increment_counter(request: gr.Request):\n    if request.session_hash in instances:\n        instance = instances[request.session_hash]\n        return instance.increment()\n    return \"Error: Session not initialized\"\n\nwith gr.Blocks() as demo:\n    output = gr.Textbox(label=\"Status\")\n    counter = gr.Number(label=\"Counter Value\")\n    increment_btn = gr.Button(\"Increment Counter\")\n    increment_btn.click(increment_counter, inputs=None, outputs=counter)\n    \n    # Initialize instance when page loads\n    demo.load(initialize_instance, inputs=None, outputs=output)    \n    # Clean up instance when page is closed/refreshed\n    demo.unload(cleanup_instance)    \n\ndemo.launch()\n```\n\n## Browser State\n\nGradio also supports browser state, where data persists in the browser's localStorage even after the page is refreshed or closed. This is useful for storing user preferences, settings, API keys, or other data that should persist across sessions. To use local state:\n\n1. Create a `gr.BrowserState` object. You can optionally provide an initial default value and a key to identify the data in the browser's localStorage.\n2. Use it like a regular `gr.State` component in event listeners as inputs and outputs.\n\nHere's a simple example that saves a user's username and password across sessions:\n\n```python\nimport random\nimport string\nimport gradio as gr\nimport time\nwith gr.Blocks() as demo:\n    gr.Markdown(\"Your Username and Password will get saved in the browser's local storage. \"\n                \"If you refresh the page, the values will be retained.\")\n    username = gr.Textbox(label=\"Username\")\n    password = gr.Textbox(label=\"Password\", type=\"password\")\n    btn = gr.Button(\"Generate Randomly\")\n    local_storage = gr.BrowserState([\"\", \"\"])\n    saved_message = gr.Markdown(\"\u2705 Saved to local storage\", visible=False)\n\n    @btn.click(outputs=[username, password])\n    def generate_randomly():\n        u = \"\".join(random.choices(string.ascii_letters + string.digits, k=10))\n        p = \"\".join(random.choices(string.ascii_letters + string.digits, k=10))\n        return u, p\n\n    @demo.load(inputs=[local_storage], outputs=[username, password])\n    def load_from_local_storage(saved_values):\n        print(\"loading from local storage\", saved_values)\n        return saved_values[0], saved_values[1]\n\n    @gr.on([username.change, password.change], inputs=[username, password], outputs=[local_storage])\n    def save_to_local_storage(username, password):\n        return [username, password]\n\n    @gr.on(local_storage.change, outputs=[saved_message])\n    def show_saved_message():\n        timestamp = time.strftime(\"%I:%M:%S %p\")\n        return gr.Markdown(\n            f\"\u2705 Saved to local storage at {timestamp}\",\n            visible=True\n        )\n\ndemo.launch()\n\n```\n\nNote: The value stored in `gr.BrowserState` does not persist if the Grado app is restarted. To persist it, you can hardcode specific values of `storage_key` and `secret` in the `gr.BrowserState` component and restart the Gradio app on the same server name and server port. However, this should only be done if you are running trusted Gradio apps, as in principle, this can allow one Gradio app to access localStorage data that was created by a different Gradio app.\n", "tags": [], "spaces": [], "url": "/guides/state-in-blocks/", "contributor": null}}