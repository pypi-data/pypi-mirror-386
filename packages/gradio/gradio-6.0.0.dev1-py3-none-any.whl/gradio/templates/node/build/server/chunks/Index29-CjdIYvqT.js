import { I as It, E as Et, U as Ue, j as O, $ as $t, T as Te, L as yt, _ as _t, at as Ae, an as globals } from './2-BcuNmVBB.js';
import { c as create_ssr_component, v as validate_component, e as escape, d as add_attribute } from './ssr-C3HYbsxA.js';
import './index-ClteBeTX.js';
import './Component-NmRBwSfF.js';
import 'path';
import 'url';
import 'fs';

const{Object:Ge}=globals,Ye={code:"div.svelte-19qacdz{width:100%;height:100%}#vg-tooltip-element{font-family:var(--font) !important;font-size:var(--text-xs) !important;box-shadow:none !important;background-color:var(--block-background-fill) !important;border:1px solid var(--border-color-primary) !important;color:var(--body-text-color) !important}#vg-tooltip-element .key{color:var(--body-text-color-subdued) !important}.caption.svelte-19qacdz{padding:0 4px;margin:0;text-align:center}",map:'{"version":3,"file":"Index.svelte","sources":["Index.svelte"],"sourcesContent":["<script lang=\\"ts\\">import { BlockTitle } from \\"@gradio/atoms\\";\\nimport { Block } from \\"@gradio/atoms\\";\\nimport { FullscreenButton, IconButtonWrapper, IconButton } from \\"@gradio/atoms\\";\\nimport { StatusTracker } from \\"@gradio/statustracker\\";\\nimport { onMount } from \\"svelte\\";\\nimport { LineChart as LabelIcon, Download } from \\"@gradio/icons\\";\\nimport { Empty } from \\"@gradio/atoms\\";\\nexport let value;\\nexport let x;\\nexport let y;\\nexport let color = null;\\n$: unique_colors = color && value && value.datatypes[color] === \\"nominal\\" ? Array.from(new Set(_data.map((d) => d[color]))) : [];\\nexport let title = null;\\nexport let x_title = null;\\nexport let y_title = null;\\nexport let color_title = null;\\nexport let x_bin = null;\\nexport let y_aggregate = void 0;\\nexport let color_map = null;\\nexport let x_lim = null;\\nexport let y_lim = null;\\n$: x_lim = x_lim || null;\\n$: y_lim = y_lim || null;\\n$: x_start = x_lim?.[0] !== null ? x_lim?.[0] : void 0;\\n$: x_end = x_lim?.[1] !== null ? x_lim?.[1] : void 0;\\n$: y_start = y_lim?.[0] !== null ? y_lim?.[0] : void 0;\\n$: y_end = y_lim?.[1] !== null ? y_lim?.[1] : void 0;\\nexport let x_label_angle = null;\\nexport let y_label_angle = null;\\nexport let x_axis_labels_visible = true;\\nexport let caption = null;\\nexport let sort = null;\\nexport let tooltip = \\"axis\\";\\nexport let buttons = null;\\nlet fullscreen = false;\\nfunction reformat_sort(_sort2) {\\n    if (_sort2 === \\"x\\") {\\n        return \\"ascending\\";\\n    }\\n    else if (_sort2 === \\"-x\\") {\\n        return \\"descending\\";\\n    }\\n    else if (_sort2 === \\"y\\") {\\n        return { field: y, order: \\"ascending\\" };\\n    }\\n    else if (_sort2 === \\"-y\\") {\\n        return { field: y, order: \\"descending\\" };\\n    }\\n    else if (_sort2 === null) {\\n        return null;\\n    }\\n    else if (Array.isArray(_sort2)) {\\n        return _sort2;\\n    }\\n}\\n$: _sort = reformat_sort(sort);\\nexport let _selectable = false;\\nlet _data;\\nexport let gradio;\\nfunction escape_field_name(fieldName) {\\n    return fieldName.replace(/\\\\./g, \\"\\\\\\\\.\\").replace(/\\\\[/g, \\"\\\\\\\\[\\").replace(/\\\\]/g, \\"\\\\\\\\]\\");\\n}\\n$: x_temporal = value && value.datatypes[x] === \\"temporal\\";\\n$: _x_lim = x_temporal ? [\\n    x_start !== void 0 ? x_start * 1e3 : null,\\n    x_end !== void 0 ? x_end * 1e3 : null\\n] : x_lim;\\nlet _x_bin;\\nlet mouse_down_on_chart = false;\\nconst SUFFIX_DURATION = {\\n    s: 1,\\n    m: 60,\\n    h: 60 * 60,\\n    d: 24 * 60 * 60\\n};\\n$: _x_bin = x_bin ? typeof x_bin === \\"string\\" ? 1e3 * parseInt(x_bin.substring(0, x_bin.length - 1)) * SUFFIX_DURATION[x_bin[x_bin.length - 1]] : x_bin : void 0;\\nlet _y_aggregate;\\nlet aggregating;\\n$: {\\n    if (value) {\\n        if (value.mark === \\"point\\") {\\n            aggregating = _x_bin !== void 0;\\n            _y_aggregate = y_aggregate || aggregating ? \\"sum\\" : void 0;\\n        }\\n        else {\\n            aggregating = _x_bin !== void 0 || value.datatypes[x] === \\"nominal\\";\\n            _y_aggregate = y_aggregate ? y_aggregate : \\"sum\\";\\n        }\\n    }\\n}\\nfunction downsample(data, x_index, y_index, color_index, x_start2, x_end2) {\\n    if (data.length < 1e3 || x_bin !== null || value?.mark !== \\"line\\" || value?.datatypes[x] === \\"nominal\\") {\\n        return data;\\n    }\\n    const bin_count = 250;\\n    let min_max_bins_per_color = {};\\n    if (x_start2 === void 0 || x_end2 === void 0) {\\n        data.forEach((row) => {\\n            let x_value = row[x_index];\\n            if (x_start2 === void 0 || x_value < x_start2) {\\n                x_start2 = x_value;\\n            }\\n            if (x_end2 === void 0 || x_value > x_end2) {\\n                x_end2 = x_value;\\n            }\\n        });\\n    }\\n    if (x_start2 === void 0 || x_end2 === void 0) {\\n        return data;\\n    }\\n    const x_range = x_end2 - x_start2;\\n    const bin_size = x_range / bin_count;\\n    data.forEach((row, i) => {\\n        const x_value = row[x_index];\\n        const y_value = row[y_index];\\n        const color_value = color_index !== null ? row[color_index] : \\"any\\";\\n        const bin_index = Math.floor((x_value - x_start2) / bin_size);\\n        if (min_max_bins_per_color[color_value] === void 0) {\\n            min_max_bins_per_color[color_value] = [];\\n        }\\n        min_max_bins_per_color[color_value][bin_index] = min_max_bins_per_color[color_value][bin_index] || [\\n            null,\\n            Number.POSITIVE_INFINITY,\\n            null,\\n            Number.NEGATIVE_INFINITY\\n        ];\\n        if (y_value < min_max_bins_per_color[color_value][bin_index][1]) {\\n            min_max_bins_per_color[color_value][bin_index][0] = i;\\n            min_max_bins_per_color[color_value][bin_index][1] = y_value;\\n        }\\n        if (y_value > min_max_bins_per_color[color_value][bin_index][3]) {\\n            min_max_bins_per_color[color_value][bin_index][2] = i;\\n            min_max_bins_per_color[color_value][bin_index][3] = y_value;\\n        }\\n    });\\n    const downsampled_data = [];\\n    Object.values(min_max_bins_per_color).forEach((bins) => {\\n        bins.forEach(([min_index, _, max_index, __]) => {\\n            let indices = [];\\n            if (min_index !== null && max_index !== null) {\\n                indices = [\\n                    Math.min(min_index, max_index),\\n                    Math.max(min_index, max_index)\\n                ];\\n            }\\n            else if (min_index !== null) {\\n                indices = [min_index];\\n            }\\n            else if (max_index !== null) {\\n                indices = [max_index];\\n            }\\n            indices.forEach((index) => {\\n                downsampled_data.push(data[index]);\\n            });\\n        });\\n    });\\n    return downsampled_data;\\n}\\nfunction reformat_data(data, x_start2, x_end2) {\\n    let x_index = data.columns.indexOf(x);\\n    let y_index = data.columns.indexOf(y);\\n    let color_index = color ? data.columns.indexOf(color) : null;\\n    let datatable = data.data;\\n    if (x_start2 !== void 0 && x_end2 !== void 0) {\\n        const time_factor = data.datatypes[x] === \\"temporal\\" ? 1e3 : 1;\\n        const _x_start = x_start2 * time_factor;\\n        const _x_end = x_end2 * time_factor;\\n        let largest_before_start = {};\\n        let smallest_after_end = {};\\n        const _datatable = datatable.filter((row, i) => {\\n            const x_value = row[x_index];\\n            const color_value = color_index !== null ? row[color_index] : \\"any\\";\\n            if (x_value < _x_start && (largest_before_start[color_value] === void 0 || x_value > largest_before_start[color_value][1])) {\\n                largest_before_start[color_value] = [i, x_value];\\n            }\\n            if (x_value > _x_end && (smallest_after_end[color_value] === void 0 || x_value < smallest_after_end[color_value][1])) {\\n                smallest_after_end[color_value] = [i, x_value];\\n            }\\n            return x_value >= _x_start && x_value <= _x_end;\\n        });\\n        datatable = [\\n            ...Object.values(largest_before_start).map(([i, _]) => datatable[i]),\\n            ...downsample(_datatable, x_index, y_index, color_index, _x_start, _x_end),\\n            ...Object.values(smallest_after_end).map(([i, _]) => datatable[i])\\n        ];\\n    }\\n    else {\\n        datatable = downsample(datatable, x_index, y_index, color_index, void 0, void 0);\\n    }\\n    if (tooltip == \\"all\\" || Array.isArray(tooltip)) {\\n        return datatable.map((row) => {\\n            const obj = {};\\n            data.columns.forEach((col, i) => {\\n                obj[col] = row[i];\\n            });\\n            return obj;\\n        });\\n    }\\n    return datatable.map((row) => {\\n        const obj = {\\n            [x]: row[x_index],\\n            [y]: row[y_index]\\n        };\\n        if (color && color_index !== null) {\\n            obj[color] = row[color_index];\\n        }\\n        return obj;\\n    });\\n}\\n$: _data = value ? reformat_data(value, x_start, x_end) : [];\\nlet old_value = value;\\n$: if (old_value !== value && view) {\\n    old_value = value;\\n    view.data(\\"data\\", _data).runAsync();\\n}\\nconst is_browser = typeof window !== \\"undefined\\";\\nlet chart_element;\\n$: computed_style = chart_element ? window.getComputedStyle(chart_element) : null;\\nlet view;\\nlet mounted = false;\\nlet old_width;\\nlet old_height;\\nlet resizeObserver;\\nlet vegaEmbed;\\nasync function load_chart() {\\n    if (mouse_down_on_chart) {\\n        refresh_pending = true;\\n        return;\\n    }\\n    if (view) {\\n        view.finalize();\\n    }\\n    if (!value || !chart_element)\\n        return;\\n    old_width = chart_element.offsetWidth;\\n    old_height = chart_element.offsetHeight;\\n    const spec = create_vega_lite_spec();\\n    if (!spec)\\n        return;\\n    resizeObserver = new ResizeObserver((el) => {\\n        if (!el[0].target || !(el[0].target instanceof HTMLElement))\\n            return;\\n        if (old_width === 0 && chart_element.offsetWidth !== 0 && value.datatypes[x] === \\"nominal\\") {\\n            load_chart();\\n        }\\n        else {\\n            const width_change = Math.abs(old_width - el[0].target.offsetWidth);\\n            const height_change = Math.abs(old_height - el[0].target.offsetHeight);\\n            if (width_change > 100 || height_change > 100) {\\n                old_width = el[0].target.offsetWidth;\\n                old_height = el[0].target.offsetHeight;\\n                load_chart();\\n            }\\n            else {\\n                view.signal(\\"width\\", el[0].target.offsetWidth).run();\\n                if (fullscreen) {\\n                    view.signal(\\"height\\", el[0].target.offsetHeight).run();\\n                }\\n            }\\n        }\\n    });\\n    if (!vegaEmbed) {\\n        vegaEmbed = (await import(\\"vega-embed\\")).default;\\n    }\\n    vegaEmbed(chart_element, spec, { actions: false }).then(function (result) {\\n        view = result.view;\\n        resizeObserver.observe(chart_element);\\n        var debounceTimeout;\\n        var lastSelectTime = 0;\\n        view.addEventListener(\\"dblclick\\", () => {\\n            gradio.dispatch(\\"double_click\\");\\n        });\\n        chart_element.addEventListener(\\"mousedown\\", function (e) {\\n            if (e.detail > 1) {\\n                e.preventDefault();\\n            }\\n        }, false);\\n        if (_selectable) {\\n            view.addSignalListener(\\"brush\\", function (_, value2) {\\n                if (Date.now() - lastSelectTime < 1e3)\\n                    return;\\n                mouse_down_on_chart = true;\\n                if (Object.keys(value2).length === 0)\\n                    return;\\n                clearTimeout(debounceTimeout);\\n                let range = value2[Object.keys(value2)[0]];\\n                if (x_temporal) {\\n                    range = [range[0] / 1e3, range[1] / 1e3];\\n                }\\n                debounceTimeout = setTimeout(function () {\\n                    mouse_down_on_chart = false;\\n                    lastSelectTime = Date.now();\\n                    gradio.dispatch(\\"select\\", {\\n                        value: range,\\n                        index: range,\\n                        selected: true\\n                    });\\n                    if (refresh_pending) {\\n                        refresh_pending = false;\\n                        load_chart();\\n                    }\\n                }, 250);\\n            });\\n        }\\n    });\\n}\\nlet refresh_pending = false;\\nonMount(() => {\\n    mounted = true;\\n    return () => {\\n        mounted = false;\\n        if (view) {\\n            view.finalize();\\n        }\\n        if (resizeObserver) {\\n            resizeObserver.disconnect();\\n        }\\n    };\\n});\\nfunction export_chart() {\\n    if (!view || !computed_style)\\n        return;\\n    const block_background = computed_style.getPropertyValue(\\"--block-background-fill\\");\\n    const export_background = block_background || \\"white\\";\\n    view.background(export_background).run();\\n    view.toImageURL(\\"png\\", 2).then(function (url) {\\n        view.background(\\"transparent\\").run();\\n        const link = document.createElement(\\"a\\");\\n        link.setAttribute(\\"href\\", url);\\n        link.setAttribute(\\"download\\", \\"chart.png\\");\\n        link.style.display = \\"none\\";\\n        document.body.appendChild(link);\\n        link.click();\\n        document.body.removeChild(link);\\n    }).catch(function (err) {\\n        console.error(\\"Export failed:\\", err);\\n        view.background(\\"transparent\\").run();\\n    });\\n}\\n$: _color_map = JSON.stringify(color_map);\\n$: title, x_title, y_title, color_title, x, y, color, x_bin, _y_aggregate, _color_map, x_start, x_end, y_start, y_end, caption, sort, mounted, chart_element, fullscreen, computed_style && requestAnimationFrame(load_chart);\\nfunction create_vega_lite_spec() {\\n    if (!value || !computed_style)\\n        return null;\\n    let accent_color = computed_style.getPropertyValue(\\"--color-accent\\");\\n    let body_text_color = computed_style.getPropertyValue(\\"--body-text-color\\");\\n    let borderColorPrimary = computed_style.getPropertyValue(\\"--border-color-primary\\");\\n    let font_family = computed_style.fontFamily;\\n    let title_weight = computed_style.getPropertyValue(\\"--block-title-text-weight\\");\\n    const font_to_px_val = (font) => {\\n        return font.endsWith(\\"px\\") ? parseFloat(font.slice(0, -2)) : 12;\\n    };\\n    let text_size_md = font_to_px_val(computed_style.getPropertyValue(\\"--text-md\\"));\\n    let text_size_sm = font_to_px_val(computed_style.getPropertyValue(\\"--text-sm\\"));\\n    return {\\n        $schema: \\"https://vega.github.io/schema/vega-lite/v5.17.0.json\\",\\n        background: \\"transparent\\",\\n        config: {\\n            autosize: { type: \\"fit\\", contains: \\"padding\\" },\\n            axis: {\\n                labelFont: font_family,\\n                labelColor: body_text_color,\\n                titleFont: font_family,\\n                titleColor: body_text_color,\\n                titlePadding: 8,\\n                tickColor: borderColorPrimary,\\n                labelFontSize: text_size_sm,\\n                gridColor: borderColorPrimary,\\n                titleFontWeight: \\"normal\\",\\n                titleFontSize: text_size_sm,\\n                labelFontWeight: \\"normal\\",\\n                domain: false,\\n                labelAngle: 0,\\n                titleLimit: chart_element.offsetHeight * 0.8\\n            },\\n            legend: {\\n                labelColor: body_text_color,\\n                labelFont: font_family,\\n                titleColor: body_text_color,\\n                titleFont: font_family,\\n                titleFontWeight: \\"normal\\",\\n                titleFontSize: text_size_sm,\\n                labelFontWeight: \\"normal\\",\\n                offset: 2\\n            },\\n            title: {\\n                color: body_text_color,\\n                font: font_family,\\n                fontSize: text_size_md,\\n                fontWeight: title_weight,\\n                anchor: \\"middle\\"\\n            },\\n            view: { stroke: borderColorPrimary },\\n            mark: {\\n                stroke: value.mark !== \\"bar\\" ? accent_color : void 0,\\n                fill: value.mark === \\"bar\\" ? accent_color : void 0,\\n                cursor: \\"crosshair\\"\\n            }\\n        },\\n        data: { name: \\"data\\" },\\n        datasets: {\\n            data: _data\\n        },\\n        layer: [\\"plot\\", ...value.mark === \\"line\\" ? [\\"hover\\"] : []].map((mode) => {\\n            return {\\n                encoding: {\\n                    size: value.mark === \\"line\\" ? mode == \\"plot\\" ? {\\n                        condition: {\\n                            empty: false,\\n                            param: \\"hoverPlot\\",\\n                            value: 3\\n                        },\\n                        value: 2\\n                    } : {\\n                        condition: { empty: false, param: \\"hover\\", value: 100 },\\n                        value: 0\\n                    } : void 0,\\n                    opacity: mode === \\"plot\\" ? void 0 : {\\n                        condition: { empty: false, param: \\"hover\\", value: 1 },\\n                        value: 0\\n                    },\\n                    x: {\\n                        axis: {\\n                            ...x_label_angle !== null && { labelAngle: x_label_angle },\\n                            labels: x_axis_labels_visible,\\n                            ticks: x_axis_labels_visible\\n                        },\\n                        field: escape_field_name(x),\\n                        title: x_title || x,\\n                        type: value.datatypes[x],\\n                        scale: {\\n                            zero: false,\\n                            domainMin: _x_lim?.[0] !== null ? _x_lim?.[0] : void 0,\\n                            domainMax: _x_lim?.[1] !== null ? _x_lim?.[1] : void 0\\n                        },\\n                        bin: _x_bin ? { step: _x_bin } : void 0,\\n                        sort: _sort\\n                    },\\n                    y: {\\n                        axis: y_label_angle ? { labelAngle: y_label_angle } : {},\\n                        field: escape_field_name(y),\\n                        title: y_title || y,\\n                        type: value.datatypes[y],\\n                        scale: {\\n                            zero: false,\\n                            domainMin: y_start ?? void 0,\\n                            domainMax: y_end ?? void 0\\n                        },\\n                        aggregate: aggregating ? _y_aggregate : void 0\\n                    },\\n                    color: color ? {\\n                        field: escape_field_name(color),\\n                        legend: { orient: \\"bottom\\", title: color_title },\\n                        scale: value.datatypes[color] === \\"nominal\\" ? {\\n                            domain: unique_colors,\\n                            range: color_map ? unique_colors.map((c) => color_map[c]) : void 0\\n                        } : {\\n                            range: [\\n                                100,\\n                                200,\\n                                300,\\n                                400,\\n                                500,\\n                                600,\\n                                700,\\n                                800,\\n                                900\\n                            ].map((n) => computed_style.getPropertyValue(\\"--primary-\\" + n)),\\n                            interpolate: \\"hsl\\"\\n                        },\\n                        type: value.datatypes[color]\\n                    } : void 0,\\n                    tooltip: tooltip == \\"none\\" ? void 0 : [\\n                        {\\n                            field: escape_field_name(y),\\n                            type: value.datatypes[y],\\n                            aggregate: aggregating ? _y_aggregate : void 0,\\n                            title: y_title || y\\n                        },\\n                        {\\n                            field: escape_field_name(x),\\n                            type: value.datatypes[x],\\n                            title: x_title || x,\\n                            format: x_temporal ? \\"%Y-%m-%d %H:%M:%S\\" : void 0,\\n                            bin: _x_bin ? { step: _x_bin } : void 0\\n                        },\\n                        ...color ? [\\n                            {\\n                                field: escape_field_name(color),\\n                                type: value.datatypes[color]\\n                            }\\n                        ] : [],\\n                        ...tooltip === \\"axis\\" ? [] : value?.columns.filter((col) => col !== x && col !== y && col !== color && (tooltip === \\"all\\" || tooltip.includes(col))).map((column) => ({\\n                            field: escape_field_name(column),\\n                            type: value.datatypes[column]\\n                        }))\\n                    ]\\n                },\\n                strokeDash: {},\\n                mark: { clip: true, type: mode === \\"hover\\" ? \\"point\\" : value.mark },\\n                name: mode\\n            };\\n        }),\\n        // @ts-ignore\\n        params: [\\n            ...value.mark === \\"line\\" ? [\\n                {\\n                    name: \\"hoverPlot\\",\\n                    select: {\\n                        clear: \\"mouseout\\",\\n                        fields: color ? [color] : [],\\n                        nearest: true,\\n                        on: \\"mouseover\\",\\n                        type: \\"point\\"\\n                    },\\n                    views: [\\"hover\\"]\\n                },\\n                {\\n                    name: \\"hover\\",\\n                    select: {\\n                        clear: \\"mouseout\\",\\n                        nearest: true,\\n                        on: \\"mouseover\\",\\n                        type: \\"point\\"\\n                    },\\n                    views: [\\"hover\\"]\\n                }\\n            ] : [],\\n            ..._selectable ? [\\n                {\\n                    name: \\"brush\\",\\n                    select: {\\n                        encodings: [\\"x\\"],\\n                        mark: { fill: \\"gray\\", fillOpacity: 0.3, stroke: \\"none\\" },\\n                        type: \\"interval\\"\\n                    },\\n                    views: [\\"plot\\"]\\n                }\\n            ] : []\\n        ],\\n        width: chart_element.offsetWidth,\\n        height: height || fullscreen ? \\"container\\" : void 0,\\n        title: title || void 0\\n    };\\n}\\nexport let label = \\"Textbox\\";\\nexport let elem_id = \\"\\";\\nexport let elem_classes = [];\\nexport let visible = true;\\nexport let show_label;\\nexport let scale = null;\\nexport let min_width = void 0;\\nexport let loading_status = void 0;\\nexport let height = void 0;\\n<\/script>\\n\\n<Block\\n\\t{visible}\\n\\t{elem_id}\\n\\t{elem_classes}\\n\\t{scale}\\n\\t{min_width}\\n\\tallow_overflow={false}\\n\\tpadding={true}\\n\\t{height}\\n\\tbind:fullscreen\\n>\\n\\t{#if loading_status}\\n\\t\\t<StatusTracker\\n\\t\\t\\tautoscroll={gradio.autoscroll}\\n\\t\\t\\ti18n={gradio.i18n}\\n\\t\\t\\t{...loading_status}\\n\\t\\t\\ton:clear_status={() => gradio.dispatch(\\"clear_status\\", loading_status)}\\n\\t\\t/>\\n\\t{/if}\\n\\t{#if buttons?.length}\\n\\t\\t<IconButtonWrapper>\\n\\t\\t\\t{#if buttons?.includes(\\"export\\")}\\n\\t\\t\\t\\t<IconButton Icon={Download} label=\\"Export\\" on:click={export_chart} />\\n\\t\\t\\t{/if}\\n\\t\\t\\t{#if buttons?.includes(\\"fullscreen\\")}\\n\\t\\t\\t\\t<FullscreenButton\\n\\t\\t\\t\\t\\t{fullscreen}\\n\\t\\t\\t\\t\\ton:fullscreen={({ detail }) => {\\n\\t\\t\\t\\t\\t\\tfullscreen = detail;\\n\\t\\t\\t\\t\\t}}\\n\\t\\t\\t\\t/>\\n\\t\\t\\t{/if}\\n\\t\\t</IconButtonWrapper>\\n\\t{/if}\\n\\t<BlockTitle {show_label} info={undefined}>{label}</BlockTitle>\\n\\n\\t{#if value && is_browser}\\n\\t\\t<div bind:this={chart_element}></div>\\n\\n\\t\\t{#if caption}\\n\\t\\t\\t<p class=\\"caption\\">{caption}</p>\\n\\t\\t{/if}\\n\\t{:else}\\n\\t\\t<Empty unpadded_box={true}><LabelIcon /></Empty>\\n\\t{/if}\\n</Block>\\n\\n<style>\\n\\tdiv {\\n\\t\\twidth: 100%;\\n\\t\\theight: 100%;\\n\\t}\\n\\t:global(#vg-tooltip-element) {\\n\\t\\tfont-family: var(--font) !important;\\n\\t\\tfont-size: var(--text-xs) !important;\\n\\t\\tbox-shadow: none !important;\\n\\t\\tbackground-color: var(--block-background-fill) !important;\\n\\t\\tborder: 1px solid var(--border-color-primary) !important;\\n\\t\\tcolor: var(--body-text-color) !important;\\n\\t}\\n\\t:global(#vg-tooltip-element .key) {\\n\\t\\tcolor: var(--body-text-color-subdued) !important;\\n\\t}\\n\\t.caption {\\n\\t\\tpadding: 0 4px;\\n\\t\\tmargin: 0;\\n\\t\\ttext-align: center;\\n\\t}</style>\\n"],"names":[],"mappings":"AA4lBC,kBAAI,CACH,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IACT,CACQ,mBAAqB,CAC5B,WAAW,CAAE,IAAI,MAAM,CAAC,CAAC,UAAU,CACnC,SAAS,CAAE,IAAI,SAAS,CAAC,CAAC,UAAU,CACpC,UAAU,CAAE,IAAI,CAAC,UAAU,CAC3B,gBAAgB,CAAE,IAAI,uBAAuB,CAAC,CAAC,UAAU,CACzD,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,sBAAsB,CAAC,CAAC,UAAU,CACxD,KAAK,CAAE,IAAI,iBAAiB,CAAC,CAAC,UAC/B,CACQ,wBAA0B,CACjC,KAAK,CAAE,IAAI,yBAAyB,CAAC,CAAC,UACvC,CACA,uBAAS,CACR,OAAO,CAAE,CAAC,CAAC,GAAG,CACd,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,MACb"}'};function S(p){return p.replace(/\./g,"\\.").replace(/\[/g,"\\[").replace(/\]/g,"\\]")}const et=create_ssr_component((p,e,t,Xe)=>{let oe,L,D,he,be,Ae$1,H,W,A,{value:n}=e,{x:v}=e,{y}=e,{color:d=null}=e,{title:ae=null}=e,{x_title:q=null}=e,{y_title:K=null}=e,{color_title:ie=null}=e,{x_bin:C=null}=e,{y_aggregate:P=void 0}=e,{color_map:j=null}=e,{x_lim:I=null}=e,{y_lim:B=null}=e,{x_label_angle:R=null}=e,{y_label_angle:G=null}=e,{x_axis_labels_visible:Y=!0}=e,{caption:X=null}=e,{sort:re=null}=e,{tooltip:F="axis"}=e,{buttons:U=null}=e,N=!1;function Ee(l){if(l==="x")return "ascending";if(l==="-x")return "descending";if(l==="y")return {field:y,order:"ascending"};if(l==="-y")return {field:y,order:"descending"};if(l===null)return null;if(Array.isArray(l))return l}let{_selectable:J=!1}=e,Q,{gradio:M}=e,T,_e=!1;const ze={s:1,m:60,h:60*60,d:24*60*60};let Z,V;function we(l,a,h,c,f,i){if(l.length<1e3||C!==null||n?.mark!=="line"||n?.datatypes[v]==="nominal")return l;const u=250;let o={};if((f===void 0||i===void 0)&&l.forEach(b=>{let x=b[a];(f===void 0||x<f)&&(f=x),(i===void 0||x>i)&&(i=x);}),f===void 0||i===void 0)return l;const s=(i-f)/u;l.forEach((b,x)=>{const z=b[a],g=b[h],r=c!==null?b[c]:"any",_=Math.floor((z-f)/s);o[r]===void 0&&(o[r]=[]),o[r][_]=o[r][_]||[null,Number.POSITIVE_INFINITY,null,Number.NEGATIVE_INFINITY],g<o[r][_][1]&&(o[r][_][0]=x,o[r][_][1]=g),g>o[r][_][3]&&(o[r][_][2]=x,o[r][_][3]=g);});const E=[];return Object.values(o).forEach(b=>{b.forEach(([x,z,g,r])=>{let _=[];x!==null&&g!==null?_=[Math.min(x,g),Math.max(x,g)]:x!==null?_=[x]:g!==null&&(_=[g]),_.forEach(Se=>{E.push(l[Se]);});});}),E}function Be(l,a,h){let c=l.columns.indexOf(v),f=l.columns.indexOf(y),i=d?l.columns.indexOf(d):null,u=l.data;if(a!==void 0&&h!==void 0){const o=l.datatypes[v]==="temporal"?1e3:1,m=a*o,s=h*o;let E={},b={};const x=u.filter((z,g)=>{const r=z[c],_=i!==null?z[i]:"any";return r<m&&(E[_]===void 0||r>E[_][1])&&(E[_]=[g,r]),r>s&&(b[_]===void 0||r<b[_][1])&&(b[_]=[g,r]),r>=m&&r<=s});u=[...Object.values(E).map(([z,g])=>u[z]),...we(x,c,f,i,m,s),...Object.values(b).map(([z,g])=>u[z])];}else u=we(u,c,f,i,void 0,void 0);return F=="all"||Array.isArray(F)?u.map(o=>{const m={};return l.columns.forEach((s,E)=>{m[s]=o[E];}),m}):u.map(o=>{const m={[v]:o[c],[y]:o[f]};return d&&i!==null&&(m[d]=o[i]),m})}let Ce=n;const Fe=typeof window<"u";let k,w,$,de,ee,se;async function te(){if(_e){ce=!0;return}if(w&&w.finalize(),!n||!k)return;$=k.offsetWidth,de=k.offsetHeight;const l=Oe();l&&(ee=new ResizeObserver(a=>{if(!(!a[0].target||!(a[0].target instanceof HTMLElement)))if($===0&&k.offsetWidth!==0&&n.datatypes[v]==="nominal")te();else {const h=Math.abs($-a[0].target.offsetWidth),c=Math.abs(de-a[0].target.offsetHeight);h>100||c>100?($=a[0].target.offsetWidth,de=a[0].target.offsetHeight,te()):(w.signal("width",a[0].target.offsetWidth).run(),N&&w.signal("height",a[0].target.offsetHeight).run());}}),se||(se=(await import('./vega-embed.module-jlSqZjux.js')).default),se(k,l,{actions:!1}).then(function(a){w=a.view,ee.observe(k);var h,c=0;w.addEventListener("dblclick",()=>{M.dispatch("double_click");}),k.addEventListener("mousedown",function(f){f.detail>1&&f.preventDefault();},!1),J&&w.addSignalListener("brush",function(f,i){if(Date.now()-c<1e3||(_e=!0,Object.keys(i).length===0))return;clearTimeout(h);let u=i[Object.keys(i)[0]];H&&(u=[u[0]/1e3,u[1]/1e3]),h=setTimeout(function(){_e=!1,c=Date.now(),M.dispatch("select",{value:u,index:u,selected:!0}),ce&&(ce=!1,te());},250);});}));}let ce=!1;function Oe(){if(!n||!A)return null;let l=A.getPropertyValue("--color-accent"),a=A.getPropertyValue("--body-text-color"),h=A.getPropertyValue("--border-color-primary"),c=A.fontFamily,f=A.getPropertyValue("--block-title-text-weight");const i=m=>m.endsWith("px")?parseFloat(m.slice(0,-2)):12;let u=i(A.getPropertyValue("--text-md")),o=i(A.getPropertyValue("--text-sm"));return {$schema:"https://vega.github.io/schema/vega-lite/v5.17.0.json",background:"transparent",config:{autosize:{type:"fit",contains:"padding"},axis:{labelFont:c,labelColor:a,titleFont:c,titleColor:a,titlePadding:8,tickColor:h,labelFontSize:o,gridColor:h,titleFontWeight:"normal",titleFontSize:o,labelFontWeight:"normal",domain:!1,labelAngle:0,titleLimit:k.offsetHeight*.8},legend:{labelColor:a,labelFont:c,titleColor:a,titleFont:c,titleFontWeight:"normal",titleFontSize:o,labelFontWeight:"normal",offset:2},title:{color:a,font:c,fontSize:u,fontWeight:f,anchor:"middle"},view:{stroke:h},mark:{stroke:n.mark!=="bar"?l:void 0,fill:n.mark==="bar"?l:void 0,cursor:"crosshair"}},data:{name:"data"},datasets:{data:Q},layer:["plot",...n.mark==="line"?["hover"]:[]].map(m=>({encoding:{size:n.mark==="line"?m=="plot"?{condition:{empty:!1,param:"hoverPlot",value:3},value:2}:{condition:{empty:!1,param:"hover",value:100},value:0}:void 0,opacity:m==="plot"?void 0:{condition:{empty:!1,param:"hover",value:1},value:0},x:{axis:{...R!==null&&{labelAngle:R},labels:Y,ticks:Y},field:S(v),title:q||v,type:n.datatypes[v],scale:{zero:!1,domainMin:W?.[0]!==null?W?.[0]:void 0,domainMax:W?.[1]!==null?W?.[1]:void 0},bin:T?{step:T}:void 0,sort:Ae$1},y:{axis:G?{labelAngle:G}:{},field:S(y),title:K||y,type:n.datatypes[y],scale:{zero:!1,domainMin:he??void 0,domainMax:be??void 0},aggregate:V?Z:void 0},color:d?{field:S(d),legend:{orient:"bottom",title:ie},scale:n.datatypes[d]==="nominal"?{domain:oe,range:j?oe.map(s=>j[s]):void 0}:{range:[100,200,300,400,500,600,700,800,900].map(s=>A.getPropertyValue("--primary-"+s)),interpolate:"hsl"},type:n.datatypes[d]}:void 0,tooltip:F=="none"?void 0:[{field:S(y),type:n.datatypes[y],aggregate:V?Z:void 0,title:K||y},{field:S(v),type:n.datatypes[v],title:q||v,format:H?"%Y-%m-%d %H:%M:%S":void 0,bin:T?{step:T}:void 0},...d?[{field:S(d),type:n.datatypes[d]}]:[],...F==="axis"?[]:n?.columns.filter(s=>s!==v&&s!==y&&s!==d&&(F==="all"||F.includes(s))).map(s=>({field:S(s),type:n.datatypes[s]}))]},strokeDash:{},mark:{clip:!0,type:m==="hover"?"point":n.mark},name:m})),params:[...n.mark==="line"?[{name:"hoverPlot",select:{clear:"mouseout",fields:d?[d]:[],nearest:!0,on:"mouseover",type:"point"},views:["hover"]},{name:"hover",select:{clear:"mouseout",nearest:!0,on:"mouseover",type:"point"},views:["hover"]}]:[],...J?[{name:"brush",select:{encodings:["x"],mark:{fill:"gray",fillOpacity:.3,stroke:"none"},type:"interval"},views:["plot"]}]:[]],width:k.offsetWidth,height:le||N?"container":void 0,title:ae||void 0}}let{label:ue="Textbox"}=e,{elem_id:me=""}=e,{elem_classes:fe=[]}=e,{visible:ve=!0}=e,{show_label:xe}=e,{scale:ge=null}=e,{min_width:pe=void 0}=e,{loading_status:ne=void 0}=e,{height:le=void 0}=e;e.value===void 0&&t.value&&n!==void 0&&t.value(n),e.x===void 0&&t.x&&v!==void 0&&t.x(v),e.y===void 0&&t.y&&y!==void 0&&t.y(y),e.color===void 0&&t.color&&d!==void 0&&t.color(d),e.title===void 0&&t.title&&ae!==void 0&&t.title(ae),e.x_title===void 0&&t.x_title&&q!==void 0&&t.x_title(q),e.y_title===void 0&&t.y_title&&K!==void 0&&t.y_title(K),e.color_title===void 0&&t.color_title&&ie!==void 0&&t.color_title(ie),e.x_bin===void 0&&t.x_bin&&C!==void 0&&t.x_bin(C),e.y_aggregate===void 0&&t.y_aggregate&&P!==void 0&&t.y_aggregate(P),e.color_map===void 0&&t.color_map&&j!==void 0&&t.color_map(j),e.x_lim===void 0&&t.x_lim&&I!==void 0&&t.x_lim(I),e.y_lim===void 0&&t.y_lim&&B!==void 0&&t.y_lim(B),e.x_label_angle===void 0&&t.x_label_angle&&R!==void 0&&t.x_label_angle(R),e.y_label_angle===void 0&&t.y_label_angle&&G!==void 0&&t.y_label_angle(G),e.x_axis_labels_visible===void 0&&t.x_axis_labels_visible&&Y!==void 0&&t.x_axis_labels_visible(Y),e.caption===void 0&&t.caption&&X!==void 0&&t.caption(X),e.sort===void 0&&t.sort&&re!==void 0&&t.sort(re),e.tooltip===void 0&&t.tooltip&&F!==void 0&&t.tooltip(F),e.buttons===void 0&&t.buttons&&U!==void 0&&t.buttons(U),e._selectable===void 0&&t._selectable&&J!==void 0&&t._selectable(J),e.gradio===void 0&&t.gradio&&M!==void 0&&t.gradio(M),e.label===void 0&&t.label&&ue!==void 0&&t.label(ue),e.elem_id===void 0&&t.elem_id&&me!==void 0&&t.elem_id(me),e.elem_classes===void 0&&t.elem_classes&&fe!==void 0&&t.elem_classes(fe),e.visible===void 0&&t.visible&&ve!==void 0&&t.visible(ve),e.show_label===void 0&&t.show_label&&xe!==void 0&&t.show_label(xe),e.scale===void 0&&t.scale&&ge!==void 0&&t.scale(ge),e.min_width===void 0&&t.min_width&&pe!==void 0&&t.min_width(pe),e.loading_status===void 0&&t.loading_status&&ne!==void 0&&t.loading_status(ne),e.height===void 0&&t.height&&le!==void 0&&t.height(le),p.css.add(Ye);let ye,ke,Te$1=p.head;do ye=!0,p.head=Te$1,I=I||null,L=I?.[0]!==null?I?.[0]:void 0,D=I?.[1]!==null?I?.[1]:void 0,Q=n?Be(n,L,D):[],oe=d&&n&&n.datatypes[d]==="nominal"?Array.from(new Set(Q.map(l=>l[d]))):[],B=B||null,he=B?.[0]!==null?B?.[0]:void 0,be=B?.[1]!==null?B?.[1]:void 0,Ae$1=Ee(re),H=n&&n.datatypes[v]==="temporal",W=H?[L!==void 0?L*1e3:null,D!==void 0?D*1e3:null]:I,T=C?typeof C=="string"?1e3*parseInt(C.substring(0,C.length-1))*ze[C[C.length-1]]:C:void 0,n&&(n.mark==="point"?(V=T!==void 0,Z=P||V?"sum":void 0):(V=T!==void 0||n.datatypes[v]==="nominal",Z=P||"sum")),Ce!==n&&w&&(Ce=n,w.data("data",Q).runAsync()),A=null,JSON.stringify(j),A&&requestAnimationFrame(te),ke=`${validate_component(It,"Block").$$render(p,{visible:ve,elem_id:me,elem_classes:fe,scale:ge,min_width:pe,allow_overflow:!1,padding:!0,height:le,fullscreen:N},{fullscreen:l=>{N=l,ye=!1;}},{default:()=>`${ne?`${validate_component(Et,"StatusTracker").$$render(p,Ge.assign({},{autoscroll:M.autoscroll},{i18n:M.i18n},ne),{},{})}`:""} ${U?.length?`${validate_component(Ue,"IconButtonWrapper").$$render(p,{},{},{default:()=>`${U?.includes("export")?`${validate_component(O,"IconButton").$$render(p,{Icon:$t,label:"Export"},{},{})}`:""} ${U?.includes("fullscreen")?`${validate_component(Te,"FullscreenButton").$$render(p,{fullscreen:N},{},{})}`:""}`})}`:""} ${validate_component(yt,"BlockTitle").$$render(p,{show_label:xe,info:void 0},{},{default:()=>`${escape(ue)}`})} ${n&&Fe?`<div class="svelte-19qacdz"${add_attribute("this",k,0)}></div> ${X?`<p class="caption svelte-19qacdz">${escape(X)}</p>`:""}`:`${validate_component(_t,"Empty").$$render(p,{unpadded_box:!0},{},{default:()=>`${validate_component(Ae,"LabelIcon").$$render(p,{},{},{})}`})}`}`})}`;while(!ye);return ke});

export { et as default };
//# sourceMappingURL=Index29-CjdIYvqT.js.map
