# generated by datamodel-codegen:
#   filename:  type/recognizerFeedback.json
#   timestamp: 2025-10-22T04:03:21+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import ConfigDict, Field
from typing_extensions import Annotated

from metadata.ingestion.models.custom_pydantic import BaseModel

from . import basic, entityReference


class FeedbackType(Enum):
    FALSE_POSITIVE = 'FALSE_POSITIVE'
    INCORRECT_CLASSIFICATION = 'INCORRECT_CLASSIFICATION'
    OVERLY_BROAD = 'OVERLY_BROAD'
    CONTEXT_SPECIFIC = 'CONTEXT_SPECIFIC'


class UserReason(Enum):
    NOT_SENSITIVE_DATA = 'NOT_SENSITIVE_DATA'
    WRONG_DATA_TYPE = 'WRONG_DATA_TYPE'
    INTERNAL_IDENTIFIER = 'INTERNAL_IDENTIFIER'
    PUBLIC_INFORMATION = 'PUBLIC_INFORMATION'
    TEST_DATA = 'TEST_DATA'
    ENCRYPTED_DATA = 'ENCRYPTED_DATA'
    OTHER = 'OTHER'


class RecognizerInfo(BaseModel):
    recognizerId: Optional[basic.Uuid] = None
    recognizerName: Optional[str] = None
    matchPattern: Annotated[
        Optional[str],
        Field(None, description='The pattern that matched (for debugging)'),
    ]
    confidenceScore: Optional[float] = None


class Status(Enum):
    PENDING = 'PENDING'
    REVIEWED = 'REVIEWED'
    APPLIED = 'APPLIED'
    REJECTED = 'REJECTED'


class Action(Enum):
    ADDED_TO_EXCEPTION_LIST = 'ADDED_TO_EXCEPTION_LIST'
    PATTERN_ADJUSTED = 'PATTERN_ADJUSTED'
    THRESHOLD_INCREASED = 'THRESHOLD_INCREASED'
    RECOGNIZER_DISABLED_FOR_ENTITY = 'RECOGNIZER_DISABLED_FOR_ENTITY'
    NO_ACTION_NEEDED = 'NO_ACTION_NEEDED'


class Resolution(BaseModel):
    action: Optional[Action] = None
    resolvedBy: Optional[entityReference.EntityReference] = None
    resolvedAt: Optional[basic.Timestamp] = None
    resolutionNotes: Optional[str] = None


class RecognizerFeedback(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: Annotated[
        Optional[basic.Uuid],
        Field(None, description='Unique identifier of the feedback'),
    ]
    entityLink: Annotated[
        basic.EntityLink,
        Field(
            description='Link to the specific field where the tag was incorrectly applied (e.g., <#E::table::customers::columns::company_name>)'
        ),
    ]
    tagFQN: Annotated[
        basic.FullyQualifiedEntityName,
        Field(description='Fully qualified name of the incorrectly applied tag'),
    ]
    feedbackType: Annotated[FeedbackType, Field(description='Type of feedback')]
    userReason: Annotated[
        Optional[UserReason],
        Field(None, description='User-selected reason for reporting'),
    ]
    userComments: Annotated[
        Optional[str], Field(None, description='Additional context from the user')
    ]
    suggestedTag: Annotated[
        Optional[basic.FullyQualifiedEntityName],
        Field(
            None, description='Tag the user thinks should be applied instead (optional)'
        ),
    ]
    sampleValues: Annotated[
        Optional[List[str]],
        Field(
            None,
            description='Example values from this field that triggered the false positive (anonymized)',
        ),
    ]
    recognizerInfo: Annotated[
        Optional[RecognizerInfo],
        Field(None, description='Information about which recognizer triggered this'),
    ]
    createdBy: Annotated[
        Optional[entityReference.EntityReference],
        Field(None, description='User who provided the feedback'),
    ]
    createdAt: Optional[basic.Timestamp] = None
    status: Annotated[
        Optional[Status], Field(Status.PENDING, description='Processing status')
    ]
    resolution: Annotated[
        Optional[Resolution], Field(None, description='How this feedback was resolved')
    ]
