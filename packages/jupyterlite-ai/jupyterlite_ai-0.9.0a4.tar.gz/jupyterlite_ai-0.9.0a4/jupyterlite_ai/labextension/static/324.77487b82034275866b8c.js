"use strict";(self.webpackChunk_jupyterlite_ai=self.webpackChunk_jupyterlite_ai||[]).push([[324],{1408:(e,t,r)=>{r.d(t,{Z:()=>i});class o extends Error{constructor(e,t){super(e),this.name="ParseError",this.type=t.type,this.field=t.field,this.value=t.value,this.line=t.line}}function n(e){}class i extends TransformStream{constructor({onError:e,onRetry:t,onComment:r}={}){let i;super({start(s){i=function(e){if("function"==typeof e)throw new TypeError("`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?");const{onEvent:t=n,onError:r=n,onRetry:i=n,onComment:s}=e;let a,c="",l=!0,d="",u="";function p(e){if(""===e)return d.length>0&&t({id:a,event:u||void 0,data:d.endsWith("\n")?d.slice(0,-1):d}),a=void 0,d="",void(u="");if(e.startsWith(":"))return void(s&&s(e.slice(e.startsWith(": ")?2:1)));const r=e.indexOf(":");if(-1!==r){const t=e.slice(0,r),o=" "===e[r+1]?2:1;return void h(t,e.slice(r+o),e)}h(e,"",e)}function h(e,t,n){switch(e){case"event":u=t;break;case"data":d=`${d}${t}\n`;break;case"id":a=t.includes("\0")?void 0:t;break;case"retry":/^\d+$/.test(t)?i(parseInt(t,10)):r(new o(`Invalid \`retry\` value: "${t}"`,{type:"invalid-retry",value:t,line:n}));break;default:r(new o(`Unknown field "${e.length>20?`${e.slice(0,20)}â€¦`:e}"`,{type:"unknown-field",field:e,value:t,line:n}))}}return{feed:function(e){const t=l?e.replace(/^\xEF\xBB\xBF/,""):e,[r,o]=function(e){const t=[];let r="",o=0;for(;o<e.length;){const n=e.indexOf("\r",o),i=e.indexOf("\n",o);let s=-1;if(-1!==n&&-1!==i?s=Math.min(n,i):-1!==n?s=n===e.length-1?-1:n:-1!==i&&(s=i),-1===s){r=e.slice(o);break}{const r=e.slice(o,s);t.push(r),o=s+1,"\r"===e[o-1]&&"\n"===e[o]&&o++}}return[t,r]}(`${c}${t}`);for(const e of r)p(e);c=o,l=!1},reset:function(e={}){c&&e.consume&&p(c),l=!0,a=void 0,d="",u="",c=""}}}({onEvent:e=>{s.enqueue(e)},onError(t){"terminate"===e?s.error(t):"function"==typeof e&&e(t)},onRetry:t,onComment:r})},transform(e){i.feed(e)}})}}},2324:(e,t,r)=>{r.d(t,{StreamableHTTPClientTransport:()=>Z});var o=r(8092);let n;async function i(e){const t=await(await n).subtle.digest("SHA-256",(new TextEncoder).encode(e));return btoa(String.fromCharCode(...new Uint8Array(t))).replace(/\//g,"_").replace(/\+/g,"-").replace(/=/g,"")}async function s(e){if(e||(e=43),e<43||e>128)throw`Expected a length between 43 and 128. Received ${e}.`;const t=await async function(e){return await async function(e){let t="";const r=await async function(e){return(await n).getRandomValues(new Uint8Array(e))}(e);for(let o=0;o<e;o++)t+="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~"[r[o]%66];return t}(e)}(e);return{code_verifier:t,code_challenge:await i(t)}}n=globalThis.crypto;var a=r(9661);const c=a.z.string().url().superRefine((e,t)=>{if(!URL.canParse(e))return t.addIssue({code:a.z.ZodIssueCode.custom,message:"URL must be parseable",fatal:!0}),a.z.NEVER}).refine(e=>{const t=new URL(e);return"javascript:"!==t.protocol&&"data:"!==t.protocol&&"vbscript:"!==t.protocol},{message:"URL cannot use javascript:, data:, or vbscript: scheme"}),l=a.z.object({resource:a.z.string().url(),authorization_servers:a.z.array(c).optional(),jwks_uri:a.z.string().url().optional(),scopes_supported:a.z.array(a.z.string()).optional(),bearer_methods_supported:a.z.array(a.z.string()).optional(),resource_signing_alg_values_supported:a.z.array(a.z.string()).optional(),resource_name:a.z.string().optional(),resource_documentation:a.z.string().optional(),resource_policy_uri:a.z.string().url().optional(),resource_tos_uri:a.z.string().url().optional(),tls_client_certificate_bound_access_tokens:a.z.boolean().optional(),authorization_details_types_supported:a.z.array(a.z.string()).optional(),dpop_signing_alg_values_supported:a.z.array(a.z.string()).optional(),dpop_bound_access_tokens_required:a.z.boolean().optional()}).passthrough(),d=a.z.object({issuer:a.z.string(),authorization_endpoint:c,token_endpoint:c,registration_endpoint:c.optional(),scopes_supported:a.z.array(a.z.string()).optional(),response_types_supported:a.z.array(a.z.string()),response_modes_supported:a.z.array(a.z.string()).optional(),grant_types_supported:a.z.array(a.z.string()).optional(),token_endpoint_auth_methods_supported:a.z.array(a.z.string()).optional(),token_endpoint_auth_signing_alg_values_supported:a.z.array(a.z.string()).optional(),service_documentation:c.optional(),revocation_endpoint:c.optional(),revocation_endpoint_auth_methods_supported:a.z.array(a.z.string()).optional(),revocation_endpoint_auth_signing_alg_values_supported:a.z.array(a.z.string()).optional(),introspection_endpoint:a.z.string().optional(),introspection_endpoint_auth_methods_supported:a.z.array(a.z.string()).optional(),introspection_endpoint_auth_signing_alg_values_supported:a.z.array(a.z.string()).optional(),code_challenge_methods_supported:a.z.array(a.z.string()).optional()}).passthrough(),u=a.z.object({issuer:a.z.string(),authorization_endpoint:c,token_endpoint:c,userinfo_endpoint:c.optional(),jwks_uri:c,registration_endpoint:c.optional(),scopes_supported:a.z.array(a.z.string()).optional(),response_types_supported:a.z.array(a.z.string()),response_modes_supported:a.z.array(a.z.string()).optional(),grant_types_supported:a.z.array(a.z.string()).optional(),acr_values_supported:a.z.array(a.z.string()).optional(),subject_types_supported:a.z.array(a.z.string()),id_token_signing_alg_values_supported:a.z.array(a.z.string()),id_token_encryption_alg_values_supported:a.z.array(a.z.string()).optional(),id_token_encryption_enc_values_supported:a.z.array(a.z.string()).optional(),userinfo_signing_alg_values_supported:a.z.array(a.z.string()).optional(),userinfo_encryption_alg_values_supported:a.z.array(a.z.string()).optional(),userinfo_encryption_enc_values_supported:a.z.array(a.z.string()).optional(),request_object_signing_alg_values_supported:a.z.array(a.z.string()).optional(),request_object_encryption_alg_values_supported:a.z.array(a.z.string()).optional(),request_object_encryption_enc_values_supported:a.z.array(a.z.string()).optional(),token_endpoint_auth_methods_supported:a.z.array(a.z.string()).optional(),token_endpoint_auth_signing_alg_values_supported:a.z.array(a.z.string()).optional(),display_values_supported:a.z.array(a.z.string()).optional(),claim_types_supported:a.z.array(a.z.string()).optional(),claims_supported:a.z.array(a.z.string()).optional(),service_documentation:a.z.string().optional(),claims_locales_supported:a.z.array(a.z.string()).optional(),ui_locales_supported:a.z.array(a.z.string()).optional(),claims_parameter_supported:a.z.boolean().optional(),request_parameter_supported:a.z.boolean().optional(),request_uri_parameter_supported:a.z.boolean().optional(),require_request_uri_registration:a.z.boolean().optional(),op_policy_uri:c.optional(),op_tos_uri:c.optional()}).passthrough().merge(d.pick({code_challenge_methods_supported:!0})),p=a.z.object({access_token:a.z.string(),id_token:a.z.string().optional(),token_type:a.z.string(),expires_in:a.z.number().optional(),scope:a.z.string().optional(),refresh_token:a.z.string().optional()}).strip(),h=a.z.object({error:a.z.string(),error_description:a.z.string().optional(),error_uri:a.z.string().optional()}),_=a.z.object({redirect_uris:a.z.array(c),token_endpoint_auth_method:a.z.string().optional(),grant_types:a.z.array(a.z.string()).optional(),response_types:a.z.array(a.z.string()).optional(),client_name:a.z.string().optional(),client_uri:c.optional(),logo_uri:c.optional(),scope:a.z.string().optional(),contacts:a.z.array(a.z.string()).optional(),tos_uri:c.optional(),policy_uri:a.z.string().optional(),jwks_uri:c.optional(),jwks:a.z.any().optional(),software_id:a.z.string().optional(),software_version:a.z.string().optional(),software_statement:a.z.string().optional()}).strip(),f=a.z.object({client_id:a.z.string(),client_secret:a.z.string().optional(),client_id_issued_at:a.z.number().optional(),client_secret_expires_at:a.z.number().optional()}).strip(),w=_.merge(f);a.z.object({error:a.z.string(),error_description:a.z.string().optional()}).strip(),a.z.object({token:a.z.string(),token_type_hint:a.z.string().optional()}).strip();class g extends Error{constructor(e,t){super(e),this.errorUri=t,this.name=this.constructor.name}toResponseObject(){const e={error:this.errorCode,error_description:this.message};return this.errorUri&&(e.error_uri=this.errorUri),e}get errorCode(){return this.constructor.errorCode}}class v extends g{}v.errorCode="invalid_request";class m extends g{}m.errorCode="invalid_client";class y extends g{}y.errorCode="invalid_grant";class z extends g{}z.errorCode="unauthorized_client";class k extends g{}k.errorCode="unsupported_grant_type";class b extends g{}b.errorCode="invalid_scope";class C extends g{}C.errorCode="access_denied";class U extends g{}U.errorCode="server_error";class R extends g{}R.errorCode="temporarily_unavailable";class E extends g{}E.errorCode="unsupported_response_type";class T extends g{}T.errorCode="unsupported_token_type";class x extends g{}x.errorCode="invalid_token";class S extends g{}S.errorCode="method_not_allowed";class I extends g{}I.errorCode="too_many_requests";class P extends g{}P.errorCode="invalid_client_metadata";class $ extends g{}$.errorCode="insufficient_scope";const A={[v.errorCode]:v,[m.errorCode]:m,[y.errorCode]:y,[z.errorCode]:z,[k.errorCode]:k,[b.errorCode]:b,[C.errorCode]:C,[U.errorCode]:U,[R.errorCode]:R,[E.errorCode]:E,[T.errorCode]:T,[x.errorCode]:x,[S.errorCode]:S,[I.errorCode]:I,[P.errorCode]:P,[$.errorCode]:$};class O extends Error{constructor(e){super(null!=e?e:"Unauthorized")}}function j(e,t){const r=void 0!==e.client_secret;return 0===t.length?r?"client_secret_post":"none":r&&t.includes("client_secret_basic")?"client_secret_basic":r&&t.includes("client_secret_post")?"client_secret_post":t.includes("none")?"none":r?"client_secret_post":"none"}function L(e,t,r,o){const{client_id:n,client_secret:i}=t;switch(e){case"client_secret_basic":return void function(e,t,r){if(!t)throw new Error("client_secret_basic authentication requires a client_secret");const o=btoa(`${e}:${t}`);r.set("Authorization",`Basic ${o}`)}(n,i,r);case"client_secret_post":return void function(e,t,r){r.set("client_id",e),t&&r.set("client_secret",t)}(n,i,o);case"none":return void function(e,t){t.set("client_id",e)}(n,o);default:throw new Error(`Unsupported client authentication method: ${e}`)}}async function M(e){const t=e instanceof Response?e.status:void 0,r=e instanceof Response?await e.text():e;try{const e=h.parse(JSON.parse(r)),{error:t,error_description:o,error_uri:n}=e;return new(A[t]||U)(o||"",n)}catch(e){return new U(`${t?`HTTP ${t}: `:""}Invalid OAuth error response: ${e}. Raw body: ${r}`)}}async function F(e,t){var r,o;try{return await H(e,t)}catch(n){if(n instanceof m||n instanceof z)return await(null===(r=e.invalidateCredentials)||void 0===r?void 0:r.call(e,"all")),await H(e,t);if(n instanceof y)return await(null===(o=e.invalidateCredentials)||void 0===o?void 0:o.call(e,"tokens")),await H(e,t);throw n}}async function H(e,{serverUrl:t,authorizationCode:r,scope:n,resourceMetadataUrl:i,fetchFn:a}){let c,h;try{c=await async function(e,t,r=fetch){const n=await async function(e,t,r,n){var i,s;const a=new URL(e),c=null!==(i=null==n?void 0:n.protocolVersion)&&void 0!==i?i:o.aE;let l;if(null==n?void 0:n.metadataUrl)l=new URL(n.metadataUrl);else{const e=function(e,t="",r={}){return t.endsWith("/")&&(t=t.slice(0,-1)),r.prependPathname?`${t}/.well-known/${e}`:`/.well-known/${e}${t}`}(t,a.pathname);l=new URL(e,null!==(s=null==n?void 0:n.metadataServerUrl)&&void 0!==s?s:a),l.search=a.search}let d=await V(l,c,r);if(!(null==n?void 0:n.metadataUrl)&&function(e,t){return!e||e.status>=400&&e.status<500&&"/"!==t}(d,a.pathname)){const e=new URL(`/.well-known/${t}`,a);d=await V(e,c,r)}return d}(e,"oauth-protected-resource",r,{protocolVersion:null==t?void 0:t.protocolVersion,metadataUrl:null==t?void 0:t.resourceMetadataUrl});if(!n||404===n.status)throw new Error("Resource server does not implement OAuth 2.0 Protected Resource Metadata.");if(!n.ok)throw new Error(`HTTP ${n.status} trying to load well-known OAuth protected resource metadata.`);return l.parse(await n.json())}(t,{resourceMetadataUrl:i},a),c.authorization_servers&&c.authorization_servers.length>0&&(h=c.authorization_servers[0])}catch(e){}h||(h=t);const _=await async function(e,t,r){const o=function(e){const t="string"==typeof e?new URL(e):new URL(e.href);return t.hash="",t}(e);if(t.validateResourceURL)return await t.validateResourceURL(o,null==r?void 0:r.resource);if(r){if(!function({requestedResource:e,configuredResource:t}){const r="string"==typeof e?new URL(e):new URL(e.href),o="string"==typeof t?new URL(t):new URL(t.href);if(r.origin!==o.origin)return!1;if(r.pathname.length<o.pathname.length)return!1;const n=r.pathname.endsWith("/")?r.pathname:r.pathname+"/",i=o.pathname.endsWith("/")?o.pathname:o.pathname+"/";return n.startsWith(i)}({requestedResource:o,configuredResource:r.resource}))throw new Error(`Protected resource ${r.resource} does not match expected ${o} (or origin)`);return new URL(r.resource)}}(t,e,c),f=await async function(e,{fetchFn:t=fetch,protocolVersion:r=o.aE}={}){var n;const i={"MCP-Protocol-Version":r},s=function(e){const t="string"==typeof e?new URL(e):e,r=[];if(!("/"!==t.pathname))return r.push({url:new URL("/.well-known/oauth-authorization-server",t.origin),type:"oauth"}),r.push({url:new URL("/.well-known/openid-configuration",t.origin),type:"oidc"}),r;let o=t.pathname;return o.endsWith("/")&&(o=o.slice(0,-1)),r.push({url:new URL(`/.well-known/oauth-authorization-server${o}`,t.origin),type:"oauth"}),r.push({url:new URL("/.well-known/oauth-authorization-server",t.origin),type:"oauth"}),r.push({url:new URL(`/.well-known/openid-configuration${o}`,t.origin),type:"oidc"}),r.push({url:new URL(`${o}/.well-known/openid-configuration`,t.origin),type:"oidc"}),r}(e);for(const{url:e,type:r}of s){const o=await q(e,i,t);if(o){if(!o.ok){if(o.status>=400&&o.status<500)continue;throw new Error(`HTTP ${o.status} trying to load ${"oauth"===r?"OAuth":"OpenID provider"} metadata from ${e}`)}if("oauth"===r)return d.parse(await o.json());{const t=u.parse(await o.json());if(!(null===(n=t.code_challenge_methods_supported)||void 0===n?void 0:n.includes("S256")))throw new Error(`Incompatible OIDC provider at ${e}: does not support S256 code challenge method required by MCP specification`);return t}}}}(h,{fetchFn:a});let v=await Promise.resolve(e.clientInformation());if(!v){if(void 0!==r)throw new Error("Existing OAuth client information is required when exchanging an authorization code");if(!e.saveClientInformation)throw new Error("OAuth client information must be saveable for dynamic registration");const t=await async function(e,{metadata:t,clientMetadata:r,fetchFn:o}){let n;if(t){if(!t.registration_endpoint)throw new Error("Incompatible auth server: does not support dynamic client registration");n=new URL(t.registration_endpoint)}else n=new URL("/register",e);const i=await(null!=o?o:fetch)(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!i.ok)throw await M(i);return w.parse(await i.json())}(h,{metadata:f,clientMetadata:e.clientMetadata,fetchFn:a});await e.saveClientInformation(t),v=t}if(void 0!==r){const t=await e.codeVerifier(),o=await async function(e,{metadata:t,clientInformation:r,authorizationCode:o,codeVerifier:n,redirectUri:i,resource:s,addClientAuthentication:a,fetchFn:c}){var l;const d="authorization_code",u=(null==t?void 0:t.token_endpoint)?new URL(t.token_endpoint):new URL("/token",e);if((null==t?void 0:t.grant_types_supported)&&!t.grant_types_supported.includes(d))throw new Error(`Incompatible auth server: does not support grant type ${d}`);const h=new Headers({"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"}),_=new URLSearchParams({grant_type:d,code:o,code_verifier:n,redirect_uri:String(i)});a?a(h,_,e,t):L(j(r,null!==(l=null==t?void 0:t.token_endpoint_auth_methods_supported)&&void 0!==l?l:[]),r,h,_),s&&_.set("resource",s.href);const f=await(null!=c?c:fetch)(u,{method:"POST",headers:h,body:_});if(!f.ok)throw await M(f);return p.parse(await f.json())}(h,{metadata:f,clientInformation:v,authorizationCode:r,codeVerifier:t,redirectUri:e.redirectUrl,resource:_,addClientAuthentication:e.addClientAuthentication,fetchFn:a});return await e.saveTokens(o),"AUTHORIZED"}const m=await e.tokens();if(null==m?void 0:m.refresh_token)try{const t=await async function(e,{metadata:t,clientInformation:r,refreshToken:o,resource:n,addClientAuthentication:i,fetchFn:s}){var a;const c="refresh_token";let l;if(t){if(l=new URL(t.token_endpoint),t.grant_types_supported&&!t.grant_types_supported.includes(c))throw new Error(`Incompatible auth server: does not support grant type ${c}`)}else l=new URL("/token",e);const d=new Headers({"Content-Type":"application/x-www-form-urlencoded"}),u=new URLSearchParams({grant_type:c,refresh_token:o});i?i(d,u,e,t):L(j(r,null!==(a=null==t?void 0:t.token_endpoint_auth_methods_supported)&&void 0!==a?a:[]),r,d,u),n&&u.set("resource",n.href);const h=await(null!=s?s:fetch)(l,{method:"POST",headers:d,body:u});if(!h.ok)throw await M(h);return p.parse({refresh_token:o,...await h.json()})}(h,{metadata:f,clientInformation:v,refreshToken:m.refresh_token,resource:_,addClientAuthentication:e.addClientAuthentication,fetchFn:a});return await e.saveTokens(t),"AUTHORIZED"}catch(e){if(e instanceof g&&!(e instanceof U))throw e}const y=e.state?await e.state():void 0,{authorizationUrl:z,codeVerifier:k}=await async function(e,{metadata:t,clientInformation:r,redirectUrl:o,scope:n,state:i,resource:a}){const c="code",l="S256";let d;if(t){if(d=new URL(t.authorization_endpoint),!t.response_types_supported.includes(c))throw new Error(`Incompatible auth server: does not support response type ${c}`);if(!t.code_challenge_methods_supported||!t.code_challenge_methods_supported.includes(l))throw new Error(`Incompatible auth server: does not support code challenge method ${l}`)}else d=new URL("/authorize",e);const u=await s(),p=u.code_verifier,h=u.code_challenge;return d.searchParams.set("response_type",c),d.searchParams.set("client_id",r.client_id),d.searchParams.set("code_challenge",h),d.searchParams.set("code_challenge_method",l),d.searchParams.set("redirect_uri",String(o)),i&&d.searchParams.set("state",i),n&&d.searchParams.set("scope",n),(null==n?void 0:n.includes("offline_access"))&&d.searchParams.append("prompt","consent"),a&&d.searchParams.set("resource",a.href),{authorizationUrl:d,codeVerifier:p}}(h,{metadata:f,clientInformation:v,state:y,redirectUrl:e.redirectUrl,scope:n||e.clientMetadata.scope,resource:_});return await e.saveCodeVerifier(k),await e.redirectToAuthorization(z),"REDIRECT"}async function q(e,t,r=fetch){try{return await r(e,{headers:t})}catch(o){if(o instanceof TypeError)return t?q(e,void 0,r):void 0;throw o}}async function V(e,t,r=fetch){const o={"MCP-Protocol-Version":t};return await q(e,o,r)}var D=r(1408);const W={initialReconnectionDelay:1e3,maxReconnectionDelay:3e4,reconnectionDelayGrowFactor:1.5,maxRetries:2};class N extends Error{constructor(e,t){super(`Streamable HTTP error: ${t}`),this.code=e}}class Z{constructor(e,t){var r;this._hasCompletedAuthFlow=!1,this._url=e,this._resourceMetadataUrl=void 0,this._requestInit=null==t?void 0:t.requestInit,this._authProvider=null==t?void 0:t.authProvider,this._fetch=null==t?void 0:t.fetch,this._sessionId=null==t?void 0:t.sessionId,this._reconnectionOptions=null!==(r=null==t?void 0:t.reconnectionOptions)&&void 0!==r?r:W}async _authThenStart(){var e;if(!this._authProvider)throw new O("No auth provider");let t;try{t=await F(this._authProvider,{serverUrl:this._url,resourceMetadataUrl:this._resourceMetadataUrl,fetchFn:this._fetch})}catch(t){throw null===(e=this.onerror)||void 0===e||e.call(this,t),t}if("AUTHORIZED"!==t)throw new O;return await this._startOrAuthSse({resumptionToken:void 0})}async _commonHeaders(){var e;const t={};if(this._authProvider){const e=await this._authProvider.tokens();e&&(t.Authorization=`Bearer ${e.access_token}`)}this._sessionId&&(t["mcp-session-id"]=this._sessionId),this._protocolVersion&&(t["mcp-protocol-version"]=this._protocolVersion);const r=this._normalizeHeaders(null===(e=this._requestInit)||void 0===e?void 0:e.headers);return new Headers({...t,...r})}async _startOrAuthSse(e){var t,r,o;const{resumptionToken:n}=e;try{const o=await this._commonHeaders();o.set("Accept","text/event-stream"),n&&o.set("last-event-id",n);const i=await(null!==(t=this._fetch)&&void 0!==t?t:fetch)(this._url,{method:"GET",headers:o,signal:null===(r=this._abortController)||void 0===r?void 0:r.signal});if(!i.ok){if(401===i.status&&this._authProvider)return await this._authThenStart();if(405===i.status)return;throw new N(i.status,`Failed to open SSE stream: ${i.statusText}`)}this._handleSseStream(i.body,e,!0)}catch(e){throw null===(o=this.onerror)||void 0===o||o.call(this,e),e}}_getNextReconnectionDelay(e){const t=this._reconnectionOptions.initialReconnectionDelay,r=this._reconnectionOptions.reconnectionDelayGrowFactor,o=this._reconnectionOptions.maxReconnectionDelay;return Math.min(t*Math.pow(r,e),o)}_normalizeHeaders(e){return e?e instanceof Headers?Object.fromEntries(e.entries()):Array.isArray(e)?Object.fromEntries(e):{...e}:{}}_scheduleReconnection(e,t=0){var r;const o=this._reconnectionOptions.maxRetries;if(o>0&&t>=o)return void(null===(r=this.onerror)||void 0===r||r.call(this,new Error(`Maximum reconnection attempts (${o}) exceeded.`)));const n=this._getNextReconnectionDelay(t);setTimeout(()=>{this._startOrAuthSse(e).catch(r=>{var o;null===(o=this.onerror)||void 0===o||o.call(this,new Error(`Failed to reconnect SSE stream: ${r instanceof Error?r.message:String(r)}`)),this._scheduleReconnection(e,t+1)})},n)}_handleSseStream(e,t,r){if(!e)return;const{onresumptiontoken:n,replayMessageId:i}=t;let s;(async()=>{var t,a,c,l;try{const r=e.pipeThrough(new TextDecoderStream).pipeThrough(new D.Z).getReader();for(;;){const{value:e,done:c}=await r.read();if(c)break;if(e.id&&(s=e.id,null==n||n(e.id)),!e.event||"message"===e.event)try{const r=o.OR.parse(JSON.parse(e.data));void 0!==i&&(0,o.tG)(r)&&(r.id=i),null===(t=this.onmessage)||void 0===t||t.call(this,r)}catch(e){null===(a=this.onerror)||void 0===a||a.call(this,e)}}}catch(e){if(null===(c=this.onerror)||void 0===c||c.call(this,new Error(`SSE stream disconnected: ${e}`)),r&&this._abortController&&!this._abortController.signal.aborted)try{this._scheduleReconnection({resumptionToken:s,onresumptiontoken:n,replayMessageId:i},0)}catch(e){null===(l=this.onerror)||void 0===l||l.call(this,new Error(`Failed to reconnect: ${e instanceof Error?e.message:String(e)}`))}}})()}async start(){if(this._abortController)throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");this._abortController=new AbortController}async finishAuth(e){if(!this._authProvider)throw new O("No auth provider");if("AUTHORIZED"!==await F(this._authProvider,{serverUrl:this._url,authorizationCode:e,resourceMetadataUrl:this._resourceMetadataUrl,fetchFn:this._fetch}))throw new O("Failed to authorize")}async close(){var e,t;null===(e=this._abortController)||void 0===e||e.abort(),null===(t=this.onclose)||void 0===t||t.call(this)}async send(e,t){var r,n,i,s;try{const{resumptionToken:s,onresumptiontoken:a}=t||{};if(s)return void this._startOrAuthSse({resumptionToken:s,replayMessageId:(0,o.vo)(e)?e.id:void 0}).catch(e=>{var t;return null===(t=this.onerror)||void 0===t?void 0:t.call(this,e)});const c=await this._commonHeaders();c.set("content-type","application/json"),c.set("accept","application/json, text/event-stream");const l={...this._requestInit,method:"POST",headers:c,body:JSON.stringify(e),signal:null===(r=this._abortController)||void 0===r?void 0:r.signal},d=await(null!==(n=this._fetch)&&void 0!==n?n:fetch)(this._url,l),u=d.headers.get("mcp-session-id");if(u&&(this._sessionId=u),!d.ok){if(401===d.status&&this._authProvider){if(this._hasCompletedAuthFlow)throw new N(401,"Server returned 401 after successful authentication");if(this._resourceMetadataUrl=function(e){const t=e.headers.get("WWW-Authenticate");if(!t)return;const[r,o]=t.split(" ");if("bearer"!==r.toLowerCase()||!o)return;const n=/resource_metadata="([^"]*)"/.exec(t);if(n)try{return new URL(n[1])}catch(e){return}}(d),"AUTHORIZED"!==await F(this._authProvider,{serverUrl:this._url,resourceMetadataUrl:this._resourceMetadataUrl,fetchFn:this._fetch}))throw new O;return this._hasCompletedAuthFlow=!0,this.send(e)}const t=await d.text().catch(()=>null);throw new Error(`Error POSTing to endpoint (HTTP ${d.status}): ${t}`)}if(this._hasCompletedAuthFlow=!1,202===d.status)return void((0,o.wU)(e)&&this._startOrAuthSse({resumptionToken:void 0}).catch(e=>{var t;return null===(t=this.onerror)||void 0===t?void 0:t.call(this,e)}));const p=(Array.isArray(e)?e:[e]).filter(e=>"method"in e&&"id"in e&&void 0!==e.id).length>0,h=d.headers.get("content-type");if(p)if(null==h?void 0:h.includes("text/event-stream"))this._handleSseStream(d.body,{onresumptiontoken:a},!1);else{if(!(null==h?void 0:h.includes("application/json")))throw new N(-1,`Unexpected content type: ${h}`);{const e=await d.json(),t=Array.isArray(e)?e.map(e=>o.OR.parse(e)):[o.OR.parse(e)];for(const e of t)null===(i=this.onmessage)||void 0===i||i.call(this,e)}}}catch(e){throw null===(s=this.onerror)||void 0===s||s.call(this,e),e}}get sessionId(){return this._sessionId}async terminateSession(){var e,t,r;if(this._sessionId)try{const r=await this._commonHeaders(),o={...this._requestInit,method:"DELETE",headers:r,signal:null===(e=this._abortController)||void 0===e?void 0:e.signal},n=await(null!==(t=this._fetch)&&void 0!==t?t:fetch)(this._url,o);if(!n.ok&&405!==n.status)throw new N(n.status,`Failed to terminate session: ${n.statusText}`);this._sessionId=void 0}catch(e){throw null===(r=this.onerror)||void 0===r||r.call(this,e),e}}setProtocolVersion(e){this._protocolVersion=e}get protocolVersion(){return this._protocolVersion}}}}]);