from abc import ABC, abstractmethod
from enum import Enum
from typing import (
    Any,
    Dict,
    List,
    Optional,
    Protocol,
    Union,
    runtime_checkable,
)

from pydantic import BaseModel, ConfigDict, Field

from wallaroo.engine_config import ModelOptimizationConfigError
from wallaroo.wallaroo_ml_ops_api_client.models.kv_cache_dtype import KvCacheDtype
from wallaroo.wallaroo_ml_ops_api_client.models.quantization import Quantization
from wallaroo.wallaroo_ml_ops_api_client.types import Unset

from .wallaroo_ml_ops_api_client.models.custom_config import (
    CustomConfig as OpenapiCustomConfig,
)
from .wallaroo_ml_ops_api_client.models.framework import Framework as OpenapiFramework
from .wallaroo_ml_ops_api_client.models.framework_config_type_0 import (
    FrameworkConfigType0 as OpenapiFrameworkConfigVLLM,
)
from .wallaroo_ml_ops_api_client.models.framework_config_type_1 import (
    FrameworkConfigType1 as OpenapiFrameworkConfigCustom,
)
from .wallaroo_ml_ops_api_client.models.vllm_config import (
    VLLMConfig as OpenapiVLLMConfig,
)


class Framework(str, Enum):
    """
    An Enum to represent the supported frameworks.
    """

    # Models supported by upload / upload_stream endpoint
    ONNX = "onnx"
    TENSORFLOW = "tensorflow"
    PYTHON = "python"

    # Models supported by upload_and_convert endpoint
    KERAS = "keras"
    SKLEARN = "sklearn"
    PYTORCH = "pytorch"
    XGBOOST = "xgboost"
    HUGGING_FACE_AUTOMATIC_SPEECH_RECOGNITION = (
        "hugging-face-automatic-speech-recognition"
    )
    HUGGING_FACE_FEATURE_EXTRACTION = "hugging-face-feature-extraction"
    HUGGING_FACE_IMAGE_CLASSIFICATION = "hugging-face-image-classification"
    HUGGING_FACE_IMAGE_SEGMENTATION = "hugging-face-image-segmentation"
    HUGGING_FACE_IMAGE_TO_TEXT = "hugging-face-image-to-text"
    HUGGING_FACE_OBJECT_DETECTION = "hugging-face-object-detection"
    HUGGING_FACE_QUESTION_ANSWERING = "hugging-face-question-answering"
    HUGGING_FACE_STABLE_DIFFUSION_TEXT_2_IMG = (
        "hugging-face-stable-diffusion-text-2-img"
    )
    HUGGING_FACE_SUMMARIZATION = "hugging-face-summarization"
    HUGGING_FACE_TEXT_CLASSIFICATION = "hugging-face-text-classification"
    HUGGING_FACE_TRANSLATION = "hugging-face-translation"
    HUGGING_FACE_ZERO_SHOT_CLASSIFICATION = "hugging-face-zero-shot-classification"
    HUGGING_FACE_ZERO_SHOT_IMAGE_CLASSIFICATION = (
        "hugging-face-zero-shot-image-classification"
    )
    HUGGING_FACE_ZERO_SHOT_OBJECT_DETECTION = "hugging-face-zero-shot-object-detection"
    HUGGING_FACE_SENTIMENT_ANALYSIS = "hugging-face-sentiment-analysis"
    HUGGING_FACE_TEXT_GENERATION = "hugging-face-text-generation"
    CUSTOM = "custom"
    VLLM = "vllm"

    def get_default_config(self) -> Optional["FrameworkConfig"]:
        """Get the default config for the framework."""
        match self:
            case Framework.CUSTOM:
                return CustomConfig()
            case Framework.VLLM:
                return VLLMConfig()
            case _:
                return None

    def requires_config(self) -> bool:
        """Check if the framework requires a config."""
        return self in (Framework.CUSTOM, Framework.VLLM)

    def validate(self, config: Optional["FrameworkConfig"]) -> None:
        """Validate the config for the framework.

        :param config: The config to validate.

        :raises ModelOptimizationConfigError: If the config is invalid.
        """
        if self.requires_config() and config is None:
            raise ModelOptimizationConfigError()

        if config is not None:
            config.validate_config(self)

    def _to_openapi_framework(self) -> OpenapiFramework:
        """This is used to convert the enum into the autogenerated version.

        This is really for type-checking, since Python won't actually stop you,
        and the strings should be the same.
        """
        return OpenapiFramework[self.name]


@runtime_checkable
class OpenapiFrameworkConfig(Protocol):
    def to_dict(self) -> Dict[str, Any]: ...

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "OpenapiFrameworkConfig": ...


class FrameworkConfig(BaseModel, ABC):
    """
    A base class for all framework configs.
    """

    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        extra="forbid",
        use_enum_values=True,
        protected_namespaces=(),
    )

    @property
    @abstractmethod
    def framework(self) -> Framework:
        """The framework that this config is for."""

    def to_dict(self) -> Dict[str, Any]:
        """Convert the config to a dictionary."""
        return self._to_openapi_framework_config().to_dict()

    def validate_config(self, framework: Framework) -> None:
        """Validate the config for the framework.

        :param framework: The framework to validate the config for.

        :raises ModelOptimizationConfigError: If the config is invalid.
        """
        if framework != self.framework:
            raise ModelOptimizationConfigError()

    @abstractmethod
    def _to_openapi_framework_config(self) -> OpenapiFrameworkConfig:
        """Convert the config to the autogenerated OpenAPI version
        in order to validate the config."""

    def _parse_to_openapi(self) -> Dict[str, Any]:
        """Convert the config to the autogenerated OpenAPI version
        in order to validate the config."""
        return {
            "framework": self.framework.value,
            "config": self.model_dump(),
        }


# initialize the equivalent OpenAPI config so we can get the default values
_open_api_custom_config: OpenapiCustomConfig = OpenapiCustomConfig()


class CustomConfig(FrameworkConfig):
    """
    A config for the custom framework.
    """

    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        extra="allow",  # allow arbitrary fields
        use_enum_values=True,
        protected_namespaces=(),
    )

    model_path: str | Unset = Field(
        default=_open_api_custom_config.model_path,
        validate_default=True,
        description="The relative path of the model artifacts to the provided zip file. Defaults to './model/'.",
    )

    @property
    def framework(self) -> Framework:
        return Framework.CUSTOM

    def _to_openapi_framework_config(self) -> OpenapiFrameworkConfigCustom:
        """Convert the config to the autogenerated OpenAPI version
        in order to validate the config."""
        return OpenapiFrameworkConfigCustom.from_dict(self._parse_to_openapi())


# initialize the equivalent OpenAPI config so we can get the default values
_open_api_vllm_config: OpenapiVLLMConfig = OpenapiVLLMConfig()


class VLLMConfig(FrameworkConfig):
    """
    A config for the VLLM framework.
    """

    device_group: Union[List[int], None, Unset] = Field(
        default=_open_api_vllm_config.device_group,
        validate_default=True,
        description="List of device ids to compile the model for that is only supported for `Acceleration.QAIC`. Defaults to `None`.",
    )
    gpu_memory_utilization: Union[Unset, float] = Field(
        default=_open_api_vllm_config.gpu_memory_utilization,
        validate_default=True,
        description="The percentage of GPU memory to use. Defaults to `0.9`.",
    )
    kv_cache_dtype: Union[Unset, KvCacheDtype] = Field(
        default=_open_api_vllm_config.kv_cache_dtype,
        validate_default=True,
        description="The data type of the KV cache. `mxint8` is only supported for `Acceleration.QAIC`. Defaults to 'auto'.",
    )
    max_model_len: Union[None, Unset, int] = Field(
        default=_open_api_vllm_config.max_model_len,
        validate_default=True,
        description="The maximum length of the model. Defaults to `None`.",
    )
    max_num_seqs: Union[Unset, int] = Field(
        default=_open_api_vllm_config.max_num_seqs,
        validate_default=True,
        description="The maximum number of sequences to run in parallel. Defaults to `None`.",
    )
    max_seq_len_to_capture: Union[Unset, int] = Field(
        default=_open_api_vllm_config.max_seq_len_to_capture,
        validate_default=True,
        description="The maximum length of the sequences to capture. Defaults to `8192`.",
    )
    quantization: Union[Unset, Quantization] = Field(
        default=_open_api_vllm_config.quantization,
        validate_default=True,
        description="The quantization to use. `mxfp6` is only supported for `Acceleration.QAIC`. Defaults to 'none'.",
    )
    block_size: Union[None, Unset, int] = Field(
        default=_open_api_vllm_config.block_size,
        validate_default=True,
        description="The block size to use for the model. Recommended to set to `32` for better performance with `Acceleration.QAIC`. Defaults to `None`.",
    )

    @property
    def framework(self) -> Framework:
        """The framework that this config is for."""
        return Framework.VLLM

    def _to_openapi_framework_config(self) -> OpenapiFrameworkConfigVLLM:
        """Convert the config to the autogenerated OpenAPI version
        in order to validate the config."""
        return OpenapiFrameworkConfigVLLM.from_dict(self._parse_to_openapi())
