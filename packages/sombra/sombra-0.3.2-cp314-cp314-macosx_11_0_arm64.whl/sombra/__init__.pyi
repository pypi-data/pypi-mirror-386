from typing import Dict, List, Optional, Union

class SombraNode:
    id: int
    labels: List[str]
    
    @property
    def properties(self) -> Dict[str, Union[bool, int, float, str, bytes]]: ...

class SombraEdge:
    id: int
    source_node_id: int
    target_node_id: int
    type_name: str
    
    @property
    def properties(self) -> Dict[str, Union[bool, int, float, str, bytes]]: ...

class BfsResult:
    node_id: int
    depth: int

class DegreeDistribution:
    in_degree: List[tuple[int, int]]
    out_degree: List[tuple[int, int]]
    total_degree: List[tuple[int, int]]

class Subgraph:
    boundary_nodes: List[int]
    
    @property
    def nodes(self) -> List[SombraNode]: ...
    
    @property
    def edges(self) -> List[SombraEdge]: ...

class PropertyBound:
    value: Union[bool, int, float, str, bytes]
    inclusive: bool
    
    def __init__(
        self,
        value: Union[bool, int, float, str, bytes],
        inclusive: bool
    ) -> None: ...

class PropertyRangeFilter:
    key: str
    min: Optional[PropertyBound]
    max: Optional[PropertyBound]
    
    def __init__(
        self,
        key: str,
        min: Optional[PropertyBound] = None,
        max: Optional[PropertyBound] = None
    ) -> None: ...

class PropertyFilters:
    equals: Optional[Dict[str, Union[bool, int, float, str, bytes]]]
    not_equals: Optional[Dict[str, Union[bool, int, float, str, bytes]]]
    ranges: Optional[List[PropertyRangeFilter]]
    
    def __init__(
        self,
        equals: Optional[Dict[str, Union[bool, int, float, str, bytes]]] = None,
        not_equals: Optional[Dict[str, Union[bool, int, float, str, bytes]]] = None,
        ranges: Optional[List[PropertyRangeFilter]] = None
    ) -> None: ...

class NodePattern:
    var_name: str
    labels: Optional[List[str]]
    properties: Optional[PropertyFilters]
    
    def __init__(
        self,
        var_name: str,
        labels: Optional[List[str]] = None,
        properties: Optional[PropertyFilters] = None
    ) -> None: ...

class EdgePattern:
    from_var: str
    to_var: str
    types: Optional[List[str]]
    properties: Optional[PropertyFilters]
    direction: str
    
    def __init__(
        self,
        from_var: str,
        to_var: str,
        types: Optional[List[str]] = None,
        properties: Optional[PropertyFilters] = None,
        direction: str = "outgoing"
    ) -> None: ...

class Pattern:
    nodes: List[NodePattern]
    edges: List[EdgePattern]
    
    def __init__(
        self,
        nodes: List[NodePattern],
        edges: List[EdgePattern]
    ) -> None: ...

class Match:
    node_bindings: Dict[str, int]
    edge_ids: List[int]

class QueryResult:
    start_nodes: List[int]
    node_ids: List[int]
    limited: bool
    
    @property
    def nodes(self) -> List[SombraNode]: ...
    
    @property
    def edges(self) -> List[SombraEdge]: ...

class QueryBuilder:
    def start_from(self, node_ids: List[int]) -> "QueryBuilder": ...
    def start_from_label(self, label: str) -> "QueryBuilder": ...
    def start_from_property(
        self,
        label: str,
        key: str,
        value: Union[bool, int, float, str, bytes]
    ) -> "QueryBuilder": ...
    def traverse(
        self,
        edge_types: List[str],
        direction: str,
        depth: int
    ) -> "QueryBuilder": ...
    def limit(self, n: int) -> "QueryBuilder": ...
    def execute(self) -> QueryResult: ...

class SombraDB:
    def __init__(self, path: str) -> None: ...
    def begin_transaction(self) -> "SombraTransaction": ...
    def add_node(
        self, 
        labels: List[str], 
        properties: Optional[Dict[str, Union[bool, int, float, str, bytes]]] = None
    ) -> int: ...
    def add_edge(
        self,
        source_node_id: int,
        target_node_id: int,
        label: str,
        properties: Optional[Dict[str, Union[bool, int, float, str, bytes]]] = None
    ) -> int: ...
    def get_edge(self, edge_id: int) -> SombraEdge: ...
    def get_outgoing_edges(self, node_id: int) -> List[int]: ...
    def get_incoming_edges(self, node_id: int) -> List[int]: ...
    def get_node(self, node_id: int) -> SombraNode: ...
    def get_neighbors(self, node_id: int) -> List[int]: ...
    def delete_node(self, node_id: int) -> None: ...
    def delete_edge(self, edge_id: int) -> None: ...
    def flush(self) -> None: ...
    def checkpoint(self) -> None: ...
    def get_incoming_neighbors(self, node_id: int) -> List[int]: ...
    def get_neighbors_two_hops(self, node_id: int) -> List[int]: ...
    def get_neighbors_three_hops(self, node_id: int) -> List[int]: ...
    def bfs_traversal(self, start_node_id: int, max_depth: int) -> List[BfsResult]: ...
    def get_nodes_by_label(self, label: str) -> List[int]: ...
    def get_nodes_in_range(self, start: int, end: int) -> List[int]: ...
    def get_nodes_from(self, start: int) -> List[int]: ...
    def get_nodes_to(self, end: int) -> List[int]: ...
    def get_first_node(self) -> Optional[int]: ...
    def get_last_node(self) -> Optional[int]: ...
    def get_first_n_nodes(self, n: int) -> List[int]: ...
    def get_last_n_nodes(self, n: int) -> List[int]: ...
    def get_all_node_ids_ordered(self) -> List[int]: ...
    def count_outgoing_edges(self, node_id: int) -> int: ...
    def count_incoming_edges(self, node_id: int) -> int: ...
    def set_node_property(
        self,
        node_id: int,
        key: str,
        value: Union[bool, int, float, str, bytes]
    ) -> None: ...
    def remove_node_property(self, node_id: int, key: str) -> None: ...
    def count_nodes_by_label(self) -> Dict[str, int]: ...
    def count_edges_by_type(self) -> Dict[str, int]: ...
    def get_total_node_count(self) -> int: ...
    def get_total_edge_count(self) -> int: ...
    def degree_distribution(self) -> DegreeDistribution: ...
    def find_hubs(self, min_degree: int, degree_type: str) -> List[tuple[int, int]]: ...
    def find_isolated_nodes(self) -> List[int]: ...
    def find_leaf_nodes(self, direction: str) -> List[int]: ...
    def get_average_degree(self) -> float: ...
    def get_density(self) -> float: ...
    def count_nodes_with_label(self, label: str) -> int: ...
    def count_edges_with_type(self, edge_type: str) -> int: ...
    def extract_subgraph(
        self,
        root_nodes: List[int],
        depth: int,
        edge_types: Optional[List[str]] = None,
        direction: Optional[str] = None
    ) -> Subgraph: ...
    def extract_induced_subgraph(self, node_ids: List[int]) -> Subgraph: ...
    def query(self) -> QueryBuilder: ...
    def find_ancestor_by_label(
        self,
        node_id: int,
        label: str,
        edge_type: str
    ) -> Optional[int]: ...
    def get_ancestors(
        self,
        node_id: int,
        edge_type: str,
        max_depth: Optional[int] = None
    ) -> List[int]: ...
    def get_descendants(
        self,
        node_id: int,
        edge_type: str,
        max_depth: Optional[int] = None
    ) -> List[int]: ...
    def get_containing_file(self, node_id: int) -> int: ...
    def match_pattern(self, pattern: Pattern) -> List[Match]: ...

class SombraTransaction:
    def id(self) -> int: ...
    def add_node(
        self, 
        labels: List[str], 
        properties: Optional[Dict[str, Union[bool, int, float, str, bytes]]] = None
    ) -> int: ...
    def add_edge(
        self,
        source_node_id: int,
        target_node_id: int,
        label: str,
        properties: Optional[Dict[str, Union[bool, int, float, str, bytes]]] = None
    ) -> int: ...
    def get_edge(self, edge_id: int) -> SombraEdge: ...
    def get_outgoing_edges(self, node_id: int) -> List[int]: ...
    def get_incoming_edges(self, node_id: int) -> List[int]: ...
    def get_node(self, node_id: int) -> SombraNode: ...
    def get_neighbors(self, node_id: int) -> List[int]: ...
    def delete_node(self, node_id: int) -> None: ...
    def delete_edge(self, edge_id: int) -> None: ...
    def commit(self) -> None: ...
    def rollback(self) -> None: ...
    def get_incoming_neighbors(self, node_id: int) -> List[int]: ...
    def get_neighbors_two_hops(self, node_id: int) -> List[int]: ...
    def get_neighbors_three_hops(self, node_id: int) -> List[int]: ...
    def bfs_traversal(self, start_node_id: int, max_depth: int) -> List[BfsResult]: ...
    def get_nodes_by_label(self, label: str) -> List[int]: ...
    def get_nodes_in_range(self, start: int, end: int) -> List[int]: ...
    def get_nodes_from(self, start: int) -> List[int]: ...
    def get_nodes_to(self, end: int) -> List[int]: ...
    def get_first_node(self) -> Optional[int]: ...
    def get_last_node(self) -> Optional[int]: ...
    def get_first_n_nodes(self, n: int) -> List[int]: ...
    def get_last_n_nodes(self, n: int) -> List[int]: ...
    def get_all_node_ids_ordered(self) -> List[int]: ...
    def count_outgoing_edges(self, node_id: int) -> int: ...
    def count_incoming_edges(self, node_id: int) -> int: ...
    def set_node_property(
        self,
        node_id: int,
        key: str,
        value: Union[bool, int, float, str, bytes]
    ) -> None: ...
    def remove_node_property(self, node_id: int, key: str) -> None: ...

__version__: str