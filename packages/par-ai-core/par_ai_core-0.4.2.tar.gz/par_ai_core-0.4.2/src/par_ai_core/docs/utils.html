<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>par_ai_core.utils API documentation</title>
<meta name="description" content="Various types, utility functions and decorators for the par_ai_core package …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>par_ai_core.utils</code></h1>
</header>
<section id="section-intro">
<p>Various types, utility functions and decorators for the par_ai_core package.</p>
<p>This module provides a wide range of utility functions and decorators to support
common operations in AI and data processing tasks. It includes functions for:</p>
<ul>
<li>String manipulation (e.g., camel case to snake case conversion)</li>
<li>Data structure operations (e.g., nested dictionary access)</li>
<li>File and I/O operations (e.g., CSV parsing, file reading)</li>
<li>Type checking and conversion</li>
<li>Hashing and encryption</li>
<li>Command execution and shell interactions</li>
<li>Timing and performance measurement</li>
<li>Exception handling and logging</li>
<li>UUID validation</li>
<li>Environment variable management</li>
</ul>
<p>The module also includes several context managers for temporary modifications
to system state or execution environment.</p>
<p>These utilities are designed to streamline development and improve code
readability across the par_ai_core package and related projects.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="par_ai_core.utils.add_module_path"><code class="name flex">
<span>def <span class="ident">add_module_path</span></span>(<span>path: str) ‑> Generator[None, None, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def add_module_path(path: str) -&gt; Generator[None, None, None]:
    &#34;&#34;&#34;Add a module path to sys.path temporarily.&#34;&#34;&#34;
    sys.path.append(path)
    try:
        yield
    finally:
        if path in sys.path:
            sys.path.remove(path)</code></pre>
</details>
<div class="desc"><p>Add a module path to sys.path temporarily.</p></div>
</dd>
<dt id="par_ai_core.utils.all_subclasses"><code class="name flex">
<span>def <span class="ident">all_subclasses</span></span>(<span>cls: type) ‑> set[type]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_subclasses(cls: type) -&gt; set[type]:
    &#34;&#34;&#34;Return all subclasses of a given class.&#34;&#34;&#34;
    return set(cls.__subclasses__()).union([s for c in cls.__subclasses__() for s in all_subclasses(c)])</code></pre>
</details>
<div class="desc"><p>Return all subclasses of a given class.</p></div>
</dd>
<dt id="par_ai_core.utils.camel_to_snake"><code class="name flex">
<span>def <span class="ident">camel_to_snake</span></span>(<span>name: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def camel_to_snake(name: str) -&gt; str:
    &#34;&#34;&#34;Convert name from CamelCase to snake_case.

    Args:
        name: A symbol name, such as a class name.

    Returns:
        Name in snake case.

    Examples:
        &gt;&gt;&gt; camel_to_snake(&#34;camelCase&#34;)
        &#39;camel_case&#39;
        &gt;&gt;&gt; camel_to_snake(&#34;ThisIsATest&#34;)
        &#39;this_is_a_test&#39;
        &gt;&gt;&gt; camel_to_snake(&#34;ABC&#34;)
        &#39;abc&#39;
    &#34;&#34;&#34;
    # Special case for all uppercase strings
    if name.isupper():
        return name.lower()

    pattern = re.compile(r&#34;(?&lt;!^)(?&lt;!_)(?:[A-Z][a-z]+|[A-Z]+(?=[A-Z][a-z]|\d|\W|$))&#34;)
    return pattern.sub(lambda m: f&#34;_{m.group(0).lower()}&#34;, name).lower()</code></pre>
</details>
<div class="desc"><p>Convert name from CamelCase to snake_case.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>A symbol name, such as a class name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Name in snake case.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; camel_to_snake(&quot;camelCase&quot;)
'camel_case'
&gt;&gt;&gt; camel_to_snake(&quot;ThisIsATest&quot;)
'this_is_a_test'
&gt;&gt;&gt; camel_to_snake(&quot;ABC&quot;)
'abc'
</code></pre></div>
</dd>
<dt id="par_ai_core.utils.catch_to_logger"><code class="name flex">
<span>def <span class="ident">catch_to_logger</span></span>(<span>logger: object, re_throw: bool = False) ‑> Generator[None, None, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def catch_to_logger(logger: object, re_throw: bool = False) -&gt; Generator[None, None, None]:
    &#34;&#34;&#34;Catch exceptions and log them to a logger.&#34;&#34;&#34;
    try:
        yield
    except Exception as e:
        if logger and hasattr(logger, &#34;exception&#34;):
            logger.exception(e)  # type: ignore
            if re_throw:
                raise e
        else:
            raise e</code></pre>
</details>
<div class="desc"><p>Catch exceptions and log them to a logger.</p></div>
</dd>
<dt id="par_ai_core.utils.chunks"><code class="name flex">
<span>def <span class="ident">chunks</span></span>(<span>lst: list[Any], n: int) ‑> Generator[list[typing.Any], None, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chunks(lst: list[Any], n: int) -&gt; Generator[list[Any], None, None]:
    &#34;&#34;&#34;Yield successive n-sized chunks from a list.

    Args:
        lst: The list to split into chunks
        n: The size of each chunk

    Returns:
        Generator[list[Any], None, None]: Generator yielding chunks of the list
    &#34;&#34;&#34;
    for i in range(0, len(lst), n):
        yield lst[i : i + n]</code></pre>
</details>
<div class="desc"><p>Yield successive n-sized chunks from a list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lst</code></strong></dt>
<dd>The list to split into chunks</dd>
<dt><strong><code>n</code></strong></dt>
<dd>The size of each chunk</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Generator[list[Any], None, None]</code></dt>
<dd>Generator yielding chunks of the list</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.coalesce"><code class="name flex">
<span>def <span class="ident">coalesce</span></span>(<span>*arg: Any) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coalesce(*arg: Any) -&gt; Any:
    &#34;&#34;&#34;Return first non-None item from the provided arguments.

    Args:
        *arg: Variable number of arguments to check.

    Returns:
        Any: The first non-None item in the arguments.
        If all arguments are None, returns None.

    Example:
        &gt;&gt;&gt; coalesce(None, &#34;&#34;, 0, &#34;hello&#34;)
        &#39;&#39;
        &gt;&gt;&gt; coalesce(None, None, 42)
        42
    &#34;&#34;&#34;
    return next((a for a in arg if a is not None), None)</code></pre>
</details>
<div class="desc"><p>Return first non-None item from the provided arguments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*arg</code></strong></dt>
<dd>Variable number of arguments to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>The first non-None item in the arguments.</dd>
</dl>
<p>If all arguments are None, returns None.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; coalesce(None, &quot;&quot;, 0, &quot;hello&quot;)
''
&gt;&gt;&gt; coalesce(None, None, 42)
42
</code></pre></div>
</dd>
<dt id="par_ai_core.utils.detect_syntax"><code class="name flex">
<span>def <span class="ident">detect_syntax</span></span>(<span>text: str) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_syntax(text: str) -&gt; str | None:
    &#34;&#34;&#34;Detect the syntax of the text.&#34;&#34;&#34;
    lines = text.split(&#34;\n&#34;)
    if len(lines) &gt; 0:
        line = lines[0]
        if line.startswith(&#34;#!&#34;):
            if line.endswith(&#34;/bash&#34;) or line.endswith(&#34;/sh&#34;) or line.endswith(&#34; bash&#34;) or line.endswith(&#34; sh&#34;):
                return &#34;bash&#34;
    return None</code></pre>
</details>
<div class="desc"><p>Detect the syntax of the text.</p></div>
</dd>
<dt id="par_ai_core.utils.dict_keys_to_lower"><code class="name flex">
<span>def <span class="ident">dict_keys_to_lower</span></span>(<span>dictionary: dict) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dict_keys_to_lower(dictionary: dict) -&gt; dict:
    &#34;&#34;&#34;
    Return a new dictionary with all keys lowercase
    @param dictionary: dict with keys that you want to lowercase
    @return: new dictionary with lowercase keys
    &#34;&#34;&#34;
    return {k.lower(): v for k, v in dictionary.items()}</code></pre>
</details>
<div class="desc"><p>Return a new dictionary with all keys lowercase
@param dictionary: dict with keys that you want to lowercase
@return: new dictionary with lowercase keys</p></div>
</dd>
<dt id="par_ai_core.utils.extract_url_auth"><code class="name flex">
<span>def <span class="ident">extract_url_auth</span></span>(<span>url: str) ‑> tuple[str, tuple[str, str] | None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_url_auth(url: str) -&gt; tuple[str, tuple[str, str] | None]:
    &#34;&#34;&#34;
    Separate auth info from url if present and return clean url and auth info as tuple.

    url str: url to parse

    Returns:
        tuple[str, tuple[str, str] | None]: clean url and auth info as tuple
    &#34;&#34;&#34;
    parsed_url = urlsplit(url)
    username = parsed_url.username
    password = parsed_url.password
    new_netloc = parsed_url.hostname
    if parsed_url.port is not None:
        if new_netloc:
            new_netloc = f&#34;{new_netloc}:{parsed_url.port}&#34;
        else:
            new_netloc = f&#34;:{parsed_url.port}&#34;
    components = (parsed_url.scheme, new_netloc or &#34;&#34;, parsed_url.path, parsed_url.query, parsed_url.fragment)
    clean_host_url = str(urlunsplit(components))
    if username and password:
        auth = (username, password)
    else:
        auth = None
    return clean_host_url, auth</code></pre>
</details>
<div class="desc"><p>Separate auth info from url if present and return clean url and auth info as tuple.</p>
<p>url str: url to parse</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple[str, tuple[str, str] | None]</code></dt>
<dd>clean url and auth info as tuple</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.gather_files_for_context"><code class="name flex">
<span>def <span class="ident">gather_files_for_context</span></span>(<span>file_patterns: list[str | Path], max_context_length: int = 0) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gather_files_for_context(file_patterns: list[str | Path], max_context_length: int = 0) -&gt; str:
    &#34;&#34;&#34;
    Gather files for context.

    Args:
        file_patterns (list[str | Path]): List of file glob patterns to match
        max_context_length (int, optional): Maximum context length. Defaults to 0 (no limit).

    Returns:
        str: xml formatted list of files and their contents
    &#34;&#34;&#34;
    files = get_file_list_for_context(file_patterns)

    if not files:
        return &#34;&lt;files&gt;\n&lt;/files&gt;\n&#34;

    if max_context_length &lt; 0:
        max_context_length = 0
    doc = StringIO()
    doc.write(&#34;&lt;files&gt;\n&#34;)
    i: int = 0
    curr_len = 17
    for file in files:
        try:
            st = f&#34;&#34;&#34;&lt;file index=&#34;{i}&#34;&gt;\n&lt;source&gt;{html.escape(file.as_posix(), quote=True)}&lt;/source&gt;\n&lt;file-content&gt;{html.escape(file.read_text(encoding=&#34;utf-8&#34;), quote=True)}&lt;/file-content&gt;\n&lt;/file&gt;\n&#34;&#34;&#34;
            if max_context_length and curr_len + len(st) &gt; max_context_length:
                break
            doc.write(st)
            curr_len += len(st)
            i += 1
        except Exception as _:
            pass

    doc.write(&#34;&lt;/files&gt;\n&#34;)
    return doc.getvalue()</code></pre>
</details>
<div class="desc"><p>Gather files for context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_patterns</code></strong> :&ensp;<code>list[str | Path]</code></dt>
<dd>List of file glob patterns to match</dd>
<dt><strong><code>max_context_length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum context length. Defaults to 0 (no limit).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>xml formatted list of files and their contents</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.get_file_list_for_context"><code class="name flex">
<span>def <span class="ident">get_file_list_for_context</span></span>(<span>file_patterns: list[str | Path]) ‑> list[pathlib.Path]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_list_for_context(file_patterns: list[str | Path]) -&gt; list[Path]:
    &#34;&#34;&#34;
    Gather files for context.

    Args:
        file_patterns (list[str | Path]): List of file glob patterns to match

    Returns:
        list[Path]: List of files matching the patterns
    &#34;&#34;&#34;
    files = []
    for pattern in file_patterns:
        try:
            if isinstance(pattern, Path):
                pattern = pattern.as_posix()
            if sys.version_info &gt;= (3, 11):  # noqa: UP036
                files += glob.glob(pattern, recursive=True, include_hidden=False)
            else:
                # Python 3.10 doesn&#39;t have include_hidden parameter
                files += glob.glob(pattern, recursive=True)  # noqa: UP036
        except Exception as _:
            raise _
    result = []
    for file in files:
        f = Path(file)
        if f.is_file():
            f_path = str(f.as_posix())
            if (
                f.name.startswith(&#34;.&#34;)
                or &#34;/.git/&#34; in f_path
                or &#34;/.venv/&#34; in f_path
                or &#34;/venv/&#34; in f_path
                or &#34;/node_modules/&#34; in f_path
                or &#34;/__pycache__/&#34; in f_path
            ):
                continue
            result.append(f)

    return result</code></pre>
</details>
<div class="desc"><p>Gather files for context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_patterns</code></strong> :&ensp;<code>list[str | Path]</code></dt>
<dd>List of file glob patterns to match</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[Path]</code></dt>
<dd>List of files matching the patterns</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.get_file_suffix"><code class="name flex">
<span>def <span class="ident">get_file_suffix</span></span>(<span>path: str, default='.jpg') ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_suffix(path: str, default=&#34;.jpg&#34;) -&gt; str:
    &#34;&#34;&#34;
    Get file suffix

    Args:
        path (str): file path or url
        default (str): Default file suffix if none found

    Returns:
        str: File suffix in lowercase with leading dot
    &#34;&#34;&#34;
    if is_url(path):
        return get_url_file_suffix(path)
    try:
        suffix = os.path.splitext(Path(path).name)[1].lower()
        return suffix or default
    except Exception:
        return default</code></pre>
</details>
<div class="desc"><p>Get file suffix</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>file path or url</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>str</code></dt>
<dd>Default file suffix if none found</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>File suffix in lowercase with leading dot</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.get_files"><code class="name flex">
<span>def <span class="ident">get_files</span></span>(<span>path: str | Path | os.PathLike[str], ext: str = '') ‑> list[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_files(path: str | Path | os.PathLike[str], ext: str = &#34;&#34;) -&gt; list[str]:
    &#34;&#34;&#34;Get list of files in a directory, optionally filtered by extension.

    Args:
        path: Directory path to search
        ext: File extension to filter by. If empty, returns all files. Defaults to &#34;&#34;.

    Returns:
        list[str]: Alphabetically sorted list of filenames in the directory,
            excluding files ending with the specified extension if provided.
    &#34;&#34;&#34;
    ret = [f for f in os.listdir(path) if isfile(join(path, f)) and (not ext or not f.endswith(ext))]
    ret.sort()
    return ret</code></pre>
</details>
<div class="desc"><p>Get list of files in a directory, optionally filtered by extension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>Directory path to search</dd>
<dt><strong><code>ext</code></strong></dt>
<dd>File extension to filter by. If empty, returns all files. Defaults to "".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>Alphabetically sorted list of filenames in the directory,
excluding files ending with the specified extension if provided.</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.get_url_file_suffix"><code class="name flex">
<span>def <span class="ident">get_url_file_suffix</span></span>(<span>url: str, default='.jpg') ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_url_file_suffix(url: str, default=&#34;.jpg&#34;) -&gt; str:
    &#34;&#34;&#34;
    Get url file suffix

    Args:
        url (str): URL
        default (str): Default file suffix if none found

    Returns:
        str: File suffix in lowercase with leading dot
    &#34;&#34;&#34;
    parsed_url = urlparse(url)
    filename = os.path.basename(parsed_url.path)
    suffix = os.path.splitext(filename)[1].lower()
    return suffix or default</code></pre>
</details>
<div class="desc"><p>Get url file suffix</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>URL</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>str</code></dt>
<dd>Default file suffix if none found</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>File suffix in lowercase with leading dot</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.has_stdin_content"><code class="name flex">
<span>def <span class="ident">has_stdin_content</span></span>(<span>) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_stdin_content() -&gt; bool:
    &#34;&#34;&#34;Check if there is content available on stdin.

    Returns:
        bool: True if there is content available on stdin, False otherwise.
    &#34;&#34;&#34;
    if sys.stdin.isatty():
        return False

    # For Windows
    if os.name == &#34;nt&#34;:
        import msvcrt

        return msvcrt.kbhit()

    # For Unix-like systems (Linux and macOS)
    else:
        # First check if stdin is readable
        if hasattr(sys.stdin, &#34;readable&#34;) and not sys.stdin.readable():
            return False

        import select

        rlist, _, _ = select.select([sys.stdin], [], [], 0)
        return bool(rlist)</code></pre>
</details>
<div class="desc"><p>Check if there is content available on stdin.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if there is content available on stdin, False otherwise.</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.has_value"><code class="name flex">
<span>def <span class="ident">has_value</span></span>(<span>v: Any, search: str, depth: int = 0) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_value(v: Any, search: str, depth: int = 0) -&gt; bool:
    &#34;&#34;&#34;Recursively search a data structure for a value.

    Args:
        v: The data structure to search (can be dict, list, or primitive type).
        search: The string value to search for.
        depth: Current recursion depth (used internally, defaults to 0).

    Returns:
        bool: True if the search value is found, False otherwise.

    Notes:
        - Searches dictionaries recursively up to depth of 4
        - For integers, trims .00 from search string before comparing
        - For floats, truncates to length of search string before comparing
        - For strings, checks if they start or end with search value (case-insensitive)
    &#34;&#34;&#34;
    # don&#39;t go more than 3 levels deep
    if depth &gt; 4:
        return False
    # if is a dict, search all dict values recursively
    if isinstance(v, dict):
        for dv in v.values():
            if has_value(dv, search, depth + 1):
                return True
    # if is a list, search all list values recursively
    if isinstance(v, list):
        for li in v:
            if has_value(li, search, depth + 1):
                return True
    # if is an int, trim off .00 for search if it exists then compare
    if isinstance(v, int):
        search = search.rstrip(&#34;.00&#34;)
        if str(v) == search:
            return True
    # if is a float, truncate string version of float to same size as search
    if isinstance(v, float):
        v = str(v)[0 : len(search)]
        if search == v:
            return True
    # if is a string, strip and lowercase it then check if string starts with search
    if isinstance(v, str):
        if v.strip().lower().startswith(search) or v.strip().lower().endswith(search):
            return True
    return False</code></pre>
</details>
<div class="desc"><p>Recursively search a data structure for a value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong></dt>
<dd>The data structure to search (can be dict, list, or primitive type).</dd>
<dt><strong><code>search</code></strong></dt>
<dd>The string value to search for.</dd>
<dt><strong><code>depth</code></strong></dt>
<dd>Current recursion depth (used internally, defaults to 0).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the search value is found, False otherwise.</dd>
</dl>
<h2 id="notes">Notes</h2>
<ul>
<li>Searches dictionaries recursively up to depth of 4</li>
<li>For integers, trims .00 from search string before comparing</li>
<li>For floats, truncates to length of search string before comparing</li>
<li>For strings, checks if they start or end with search value (case-insensitive)</li>
</ul></div>
</dd>
<dt id="par_ai_core.utils.hash_list_by_key"><code class="name flex">
<span>def <span class="ident">hash_list_by_key</span></span>(<span>data: list[dict], id_key: str = 'message_id') ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash_list_by_key(data: list[dict], id_key: str = &#34;message_id&#34;) -&gt; dict:
    &#34;&#34;&#34;Hash a list of dictionaries by a key.&#34;&#34;&#34;
    return {item[id_key]: item for item in data}</code></pre>
</details>
<div class="desc"><p>Hash a list of dictionaries by a key.</p></div>
</dd>
<dt id="par_ai_core.utils.id_generator"><code class="name flex">
<span>def <span class="ident">id_generator</span></span>(<span>size: int = 6, chars: str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_generator(size: int = 6, chars: str = string.ascii_uppercase + string.digits) -&gt; str:
    &#34;&#34;&#34;Generate a random string of uppercase letters and digits.

    Args:
        size: Length of the string to generate. Defaults to 6.
        chars: Characters to use for the string. Defaults to uppercase letters and digits.

    Returns:
        str: The generated random string
    &#34;&#34;&#34;
    return &#34;&#34;.join(random.choice(chars) for _ in range(size))</code></pre>
</details>
<div class="desc"><p>Generate a random string of uppercase letters and digits.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong></dt>
<dd>Length of the string to generate. Defaults to 6.</dd>
<dt><strong><code>chars</code></strong></dt>
<dd>Characters to use for the string. Defaults to uppercase letters and digits.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated random string</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.is_date"><code class="name flex">
<span>def <span class="ident">is_date</span></span>(<span>date_text: str, fmt: str = '%Y/%m/%d') ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_date(date_text: str, fmt: str = &#34;%Y/%m/%d&#34;) -&gt; bool:
    &#34;&#34;&#34;Test if a string represents a valid date in the specified format.

    Args:
        date_text: String to test as a date.
        fmt: Date format string using strftime format codes. Defaults to &#34;%Y/%m/%d&#34;.

    Returns:
        bool: True if the string represents a valid date in the specified format,
        False otherwise.

    Example:
        &gt;&gt;&gt; is_date(&#34;2024/01/20&#34;)
        True
        &gt;&gt;&gt; is_date(&#34;2024-01-20&#34;, fmt=&#34;%Y-%m-%d&#34;)
        True
    &#34;&#34;&#34;
    try:
        datetime.strptime(date_text, fmt)
        return True
    except ValueError:
        return False</code></pre>
</details>
<div class="desc"><p>Test if a string represents a valid date in the specified format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>date_text</code></strong></dt>
<dd>String to test as a date.</dd>
<dt><strong><code>fmt</code></strong></dt>
<dd>Date format string using strftime format codes. Defaults to "%Y/%m/%d".</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the string represents a valid date in the specified format,</dd>
</dl>
<p>False otherwise.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; is_date(&quot;2024/01/20&quot;)
True
&gt;&gt;&gt; is_date(&quot;2024-01-20&quot;, fmt=&quot;%Y-%m-%d&quot;)
True
</code></pre></div>
</dd>
<dt id="par_ai_core.utils.is_float"><code class="name flex">
<span>def <span class="ident">is_float</span></span>(<span>s: Any) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_float(s: Any) -&gt; bool:
    &#34;&#34;&#34;Test if a value can be converted to float.

    Args:
        s: Any value to test.

    Returns:
        bool: True if the value can be converted to float, False otherwise.

    Example:
        &gt;&gt;&gt; is_float(&#34;3.14&#34;)
        True
        &gt;&gt;&gt; is_float(&#34;abc&#34;)
        False
    &#34;&#34;&#34;
    try:
        float(s)
        return True
    except (ValueError, TypeError):
        return False</code></pre>
</details>
<div class="desc"><p>Test if a value can be converted to float.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong></dt>
<dd>Any value to test.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the value can be converted to float, False otherwise.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; is_float(&quot;3.14&quot;)
True
&gt;&gt;&gt; is_float(&quot;abc&quot;)
False
</code></pre></div>
</dd>
<dt id="par_ai_core.utils.is_int"><code class="name flex">
<span>def <span class="ident">is_int</span></span>(<span>s: Any) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_int(s: Any) -&gt; bool:
    &#34;&#34;&#34;Test if a value can be converted to integer.

    Args:
        s: Any value to test.

    Returns:
        bool: True if the value can be converted to integer, False otherwise.

    Example:
        &gt;&gt;&gt; is_int(&#34;42&#34;)
        True
        &gt;&gt;&gt; is_int(&#34;3.14&#34;)
        False
    &#34;&#34;&#34;
    try:
        int(s)
        return True
    except (ValueError, TypeError):
        return False</code></pre>
</details>
<div class="desc"><p>Test if a value can be converted to integer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong></dt>
<dd>Any value to test.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the value can be converted to integer, False otherwise.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; is_int(&quot;42&quot;)
True
&gt;&gt;&gt; is_int(&quot;3.14&quot;)
False
</code></pre></div>
</dd>
<dt id="par_ai_core.utils.is_url"><code class="name flex">
<span>def <span class="ident">is_url</span></span>(<span>url: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_url(url: str) -&gt; bool:
    &#34;&#34;&#34;
    Return True if the given string is a valid URL.

    Args:
        url (str): The string to check.

    Returns:
        bool: True if the string is a valid URL, False otherwise.
    &#34;&#34;&#34;
    try:
        result = urlparse(url)
        matches = re.match(r&#34;^https?://&#34;, url) is not None
        return all([result.scheme, result.netloc, matches, &#34; &#34; not in url])
    except ValueError:
        return False</code></pre>
</details>
<div class="desc"><p>Return True if the given string is a valid URL.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>The string to check.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the string is a valid URL, False otherwise.</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.is_valid_uuid_v4"><code class="name flex">
<span>def <span class="ident">is_valid_uuid_v4</span></span>(<span>value: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_uuid_v4(value: str) -&gt; bool:
    &#34;&#34;&#34;Test if value is a valid UUID v4.&#34;&#34;&#34;
    try:
        uuid_obj = uuid.UUID(value, version=4)
        return str(uuid_obj) == value  # Check if the string representation matches
    except ValueError:
        return False</code></pre>
</details>
<div class="desc"><p>Test if value is a valid UUID v4.</p></div>
</dd>
<dt id="par_ai_core.utils.is_zero"><code class="name flex">
<span>def <span class="ident">is_zero</span></span>(<span>val: Any) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_zero(val: Any) -&gt; bool:
    &#34;&#34;&#34;Test if a value equals zero, handling different numeric types.

    Args:
        val: Value to test (can be int, float, or Decimal).

    Returns:
        bool: True if the value equals zero, False otherwise.
        Returns False for None values.

    Notes:
        - For Decimal, rounds to DECIMAL_PRECESSION before comparing
        - For float, uses math.isclose() with relative tolerance of 1e-05
        - For int, uses exact comparison
    &#34;&#34;&#34;
    if val is None:
        return False
    t = type(val)
    if t is Decimal:
        return val.quantize(Decimal(f&#34;1e-{DECIMAL_PRECESSION}&#34;)).is_zero()
    if t is float:
        return math.isclose(round(val, 5), 0, rel_tol=1e-05)
    if t is int:
        return 0 == val
    return False</code></pre>
</details>
<div class="desc"><p>Test if a value equals zero, handling different numeric types.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>val</code></strong></dt>
<dd>Value to test (can be int, float, or Decimal).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the value equals zero, False otherwise.</dd>
</dl>
<p>Returns False for None values.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>For Decimal, rounds to DECIMAL_PRECESSION before comparing</li>
<li>For float, uses math.isclose() with relative tolerance of 1e-05</li>
<li>For int, uses exact comparison</li>
</ul></div>
</dd>
<dt id="par_ai_core.utils.json_serial"><code class="name flex">
<span>def <span class="ident">json_serial</span></span>(<span>obj: Any) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_serial(obj: Any) -&gt; str:
    &#34;&#34;&#34;
    JSON serializer for objects not serializable by default json code.

    :param obj: The object to serialize.
    :return: The serialized object.
    &#34;&#34;&#34;

    if isinstance(obj, datetime | date):
        return obj.isoformat()
    raise TypeError(f&#34;Type {type(obj)} not serializable&#34;)</code></pre>
</details>
<div class="desc"><p>JSON serializer for objects not serializable by default json code.</p>
<p>:param obj: The object to serialize.
:return: The serialized object.</p></div>
</dd>
<dt id="par_ai_core.utils.md"><code class="name flex">
<span>def <span class="ident">md</span></span>(<span>soup: BeautifulSoup, **options: Any) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def md(soup: BeautifulSoup, **options: Any) -&gt; str:
    &#34;&#34;&#34;Convert BeautifulSoup object to Markdown.

    Args:
        soup: The BeautifulSoup object to convert
        **options: Additional options to pass to the MarkdownConverter

    Returns:
        str: The converted Markdown string
    &#34;&#34;&#34;
    return MarkdownConverter(**options).convert_soup(soup)</code></pre>
</details>
<div class="desc"><p>Convert BeautifulSoup object to Markdown.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>soup</code></strong></dt>
<dd>The BeautifulSoup object to convert</dd>
<dt><strong><code>**options</code></strong></dt>
<dd>Additional options to pass to the MarkdownConverter</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The converted Markdown string</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.md5_hash"><code class="name flex">
<span>def <span class="ident">md5_hash</span></span>(<span>data: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def md5_hash(data: str) -&gt; str:
    &#34;&#34;&#34;
    Returns a md5 hash of the input data.

    Args:
            data (str): The input data.

    Returns:
            str: The md5 hash of the input data.
    &#34;&#34;&#34;
    md5 = hashlib.md5(data.encode(&#34;utf-8&#34;))
    return md5.hexdigest()</code></pre>
</details>
<div class="desc"><p>Returns a md5 hash of the input data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The input data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The md5 hash of the input data.</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.nested_get"><code class="name flex">
<span>def <span class="ident">nested_get</span></span>(<span>dictionary: dict, keys: str | list[str]) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nested_get(dictionary: dict, keys: str | list[str]) -&gt; Any:
    &#34;&#34;&#34;
    Returns the value for a given key in a nested dictionary.

    Args:
            dictionary (dict): The nested dictionary to search.
            keys (str | list[str]): The key or list of keys to search for.

    Returns:
            Any: The value for the given key or None if the key does not exist.
    &#34;&#34;&#34;
    if isinstance(keys, str):
        keys = keys.split(&#34;.&#34;)
    if keys and dictionary:
        element = keys[0]
        if element in dictionary:
            if len(keys) == 1:
                return dictionary[element]
            return nested_get(dictionary[element], keys[1:])
    return None</code></pre>
</details>
<div class="desc"><p>Returns the value for a given key in a nested dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dictionary</code></strong> :&ensp;<code>dict</code></dt>
<dd>The nested dictionary to search.</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>str | list[str]</code></dt>
<dd>The key or list of keys to search for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>The value for the given key or None if the key does not exist.</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.non_zero"><code class="name flex">
<span>def <span class="ident">non_zero</span></span>(<span>val: Any) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def non_zero(val: Any) -&gt; bool:
    &#34;&#34;&#34;Test if a value is not equal to zero.

    Args:
        val: Value to test (can be int, float, or Decimal).

    Returns:
        bool: True if the value is not zero, False if it is zero.
        Returns True for None values.

    Note:
        This is the inverse of is_zero().
    &#34;&#34;&#34;
    return not is_zero(val)</code></pre>
</details>
<div class="desc"><p>Test if a value is not equal to zero.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>val</code></strong></dt>
<dd>Value to test (can be int, float, or Decimal).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the value is not zero, False if it is zero.</dd>
</dl>
<p>Returns True for None values.</p>
<h2 id="note">Note</h2>
<p>This is the inverse of is_zero().</p></div>
</dd>
<dt id="par_ai_core.utils.output_to_dicts"><code class="name flex">
<span>def <span class="ident">output_to_dicts</span></span>(<span>output: str) ‑> list[dict[str, typing.Any]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_to_dicts(output: str) -&gt; list[dict[str, Any]]:
    &#34;&#34;&#34;Convert a tab-delimited output to a list of dicts.&#34;&#34;&#34;
    if not output:
        return []
    # split string on newline loop over each line and convert
    # Use csv module to parse the tab-delimited output
    reader = csv.DictReader(StringIO(output), delimiter=&#34;\t&#34;)
    ret = []
    for model in reader:
        mod = {}
        for key, value in model.items():
            mod[key.strip().lower()] = value.strip()
        ret.append(mod)
    return ret</code></pre>
</details>
<div class="desc"><p>Convert a tab-delimited output to a list of dicts.</p></div>
</dd>
<dt id="par_ai_core.utils.parse_csv_text"><code class="name flex">
<span>def <span class="ident">parse_csv_text</span></span>(<span>csv_data: StringIO, has_header: bool = True) ‑> list[dict]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_csv_text(csv_data: StringIO, has_header: bool = True) -&gt; list[dict]:
    &#34;&#34;&#34;
    Reads in a CSV file as text and returns it as a list of dictionaries.

    Args:
            csv_data (StringIO): The CSV file as text.
            has_header (bool): Whether the CSV has a header row. Defaults to True.

    Returns:
            list[dict]: The CSV data as a list of dictionaries.

    Raises:
            csv.Error: If there&#39;s an issue parsing the CSV data.
    &#34;&#34;&#34;
    try:
        if has_header:
            reader = csv.DictReader(csv_data, strict=True)
            try:
                rows = []
                for row in reader:
                    rows.append(row)
                return rows
            except Exception as e:
                raise csv.Error(f&#34;Error parsing CSV data: {str(e)}&#34;)
        else:
            reader = csv.reader(csv_data, strict=True)
            try:
                rows = list(reader)
                if not rows:
                    return []
                # Use column indices as keys when no header
                headers = [str(i) for i in range(len(rows[0]))]
                return [dict(zip(headers, row)) for row in rows]
            except Exception as e:
                raise csv.Error(f&#34;Error parsing CSV data: {str(e)}&#34;)
    except Exception as e:
        raise csv.Error(f&#34;Error parsing CSV data: {str(e)}&#34;)</code></pre>
</details>
<div class="desc"><p>Reads in a CSV file as text and returns it as a list of dictionaries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>csv_data</code></strong> :&ensp;<code>StringIO</code></dt>
<dd>The CSV file as text.</dd>
<dt><strong><code>has_header</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the CSV has a header row. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[dict]</code></dt>
<dd>The CSV data as a list of dictionaries.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>csv.Error</code></dt>
<dd>If there's an issue parsing the CSV data.</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.read_env_file"><code class="name flex">
<span>def <span class="ident">read_env_file</span></span>(<span>filename: str, console: Console | None = None) ‑> dict[str, str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_env_file(filename: str, console: Console | None = None) -&gt; dict[str, str]:
    &#34;&#34;&#34;
    Read environment variables from a file into a dictionary
    Lines starting with # are ignored

    Args:
        filename (str): The name of the file to read
        console (Console, optional): The console to use for output

    Returns:
        Dict[str, str]: A dictionary containing the environment variables
    &#34;&#34;&#34;
    env_vars: dict[str, str] = {}
    if not os.path.exists(filename):
        return env_vars
    with open(filename, encoding=&#34;utf-8&#34;) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith(&#34;#&#34;):
                continue
            try:
                key, value = line.split(&#34;=&#34;, 1)
                env_vars[key.strip()] = value.strip()
            except ValueError:
                if not console:
                    console = console_err
                console.print(&#34;Invalid line format&#34;)
    return env_vars</code></pre>
</details>
<div class="desc"><p>Read environment variables from a file into a dictionary
Lines starting with # are ignored</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the file to read</dd>
<dt><strong><code>console</code></strong> :&ensp;<code>Console</code>, optional</dt>
<dd>The console to use for output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, str]</code></dt>
<dd>A dictionary containing the environment variables</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.read_text_file_to_stringio"><code class="name flex">
<span>def <span class="ident">read_text_file_to_stringio</span></span>(<span>file_path: str, encoding: str = 'utf-8') ‑> _io.StringIO</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_text_file_to_stringio(file_path: str, encoding: str = &#34;utf-8&#34;) -&gt; StringIO:
    &#34;&#34;&#34;
    Reads in a text file and returns it as a StringIO object.

    Args:
            file_path (str): The path to the file to read.
            encoding (str): The encoding of the file.

    Returns:
            StringIO: The text file as a StringIO object.
    &#34;&#34;&#34;
    with open(file_path, encoding=encoding) as file:
        return StringIO(file.read())</code></pre>
</details>
<div class="desc"><p>Reads in a text file and returns it as a StringIO object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file to read.</dd>
<dt><strong><code>encoding</code></strong> :&ensp;<code>str</code></dt>
<dd>The encoding of the file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>StringIO</code></dt>
<dd>The text file as a StringIO object.</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.run_cmd"><code class="name flex">
<span>def <span class="ident">run_cmd</span></span>(<span>params: list[str], console: Console | None = None, check: bool = True) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_cmd(params: list[str], console: Console | None = None, check: bool = True) -&gt; str | None:
    &#34;&#34;&#34;Run a command and return the output.

    Args:
        params: Command and arguments as list of strings
        console: Optional console for error output
        check: Whether to raise CalledProcessError on command failure

    Returns:
        Command output as string, or None if command failed
    &#34;&#34;&#34;
    try:
        result = subprocess.run(params, capture_output=True, text=True, check=check)
        if result.returncode != 0:
            if not console:
                console = console_err
            console.print(f&#34;Error running command: {result.stderr}&#34;)
            return None

        ret = result.stdout.strip()
        # Split the output into lines
        lines = [line for line in ret.splitlines() if not line.startswith(&#34;failed to get console mode&#34;)]
        # Get the last two lines
        return &#34;\n&#34;.join(lines)
    except FileNotFoundError as e:
        if not console:
            console = console_err
        console.print(f&#34;Error running command: {e}&#34;)
        return None
    except subprocess.CalledProcessError as e:
        if not console:
            console = console_err
        console.print(f&#34;Error running command: {e.stderr}&#34;)
        return None</code></pre>
</details>
<div class="desc"><p>Run a command and return the output.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong></dt>
<dd>Command and arguments as list of strings</dd>
<dt><strong><code>console</code></strong></dt>
<dd>Optional console for error output</dd>
<dt><strong><code>check</code></strong></dt>
<dd>Whether to raise CalledProcessError on command failure</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Command output as string, or None if command failed</p></div>
</dd>
<dt id="par_ai_core.utils.run_shell_cmd"><code class="name flex">
<span>def <span class="ident">run_shell_cmd</span></span>(<span>cmd: str) ‑> str | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_shell_cmd(cmd: str) -&gt; str | None:
    &#34;&#34;&#34;Run a command and return the output.&#34;&#34;&#34;
    try:
        return subprocess.run(
            shlex.split(cmd), shell=False, capture_output=True, check=True, encoding=&#34;utf-8&#34;
        ).stdout.strip()
    except Exception as _:
        return None</code></pre>
</details>
<div class="desc"><p>Run a command and return the output.</p></div>
</dd>
<dt id="par_ai_core.utils.sha1_hash"><code class="name flex">
<span>def <span class="ident">sha1_hash</span></span>(<span>data: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sha1_hash(data: str) -&gt; str:
    &#34;&#34;&#34;
    Returns a SHA1 hash of the input data.

    Args:
            data (str): The input data.

    Returns:
            str: The SHA1 hash of the input data.
    &#34;&#34;&#34;
    sha1 = hashlib.sha1(data.encode(&#34;utf-8&#34;))
    return sha1.hexdigest()</code></pre>
</details>
<div class="desc"><p>Returns a SHA1 hash of the input data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The input data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The SHA1 hash of the input data.</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.sha256_hash"><code class="name flex">
<span>def <span class="ident">sha256_hash</span></span>(<span>data: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sha256_hash(data: str) -&gt; str:
    &#34;&#34;&#34;
    Returns a SHA256 hash of the input data.

    Args:
            data (str): The input data.

    Returns:
            str: The SHA256 hash of the input data.
    &#34;&#34;&#34;
    sha256 = hashlib.sha256(data.encode(&#34;utf-8&#34;))
    return sha256.hexdigest()</code></pre>
</details>
<div class="desc"><p>Returns a SHA256 hash of the input data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>str</code></dt>
<dd>The input data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The SHA256 hash of the input data.</dd>
</dl></div>
</dd>
<dt id="par_ai_core.utils.str_ellipsis"><code class="name flex">
<span>def <span class="ident">str_ellipsis</span></span>(<span>s: str, max_len: int, pad_char: str = ' ') ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def str_ellipsis(s: str, max_len: int, pad_char: str = &#34; &#34;) -&gt; str:
    &#34;&#34;&#34;Return a left space padded string exactly max_len with ellipsis if it exceeds max_len.&#34;&#34;&#34;
    if len(s) &lt;= max_len:
        if pad_char:
            return s.ljust(max_len, pad_char)
        return s
    return s[: max_len - 3] + &#34;...&#34;</code></pre>
</details>
<div class="desc"><p>Return a left space padded string exactly max_len with ellipsis if it exceeds max_len.</p></div>
</dd>
<dt id="par_ai_core.utils.suppress_output"><code class="name flex">
<span>def <span class="ident">suppress_output</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def suppress_output():
    &#34;&#34;&#34;Context manager to suppress stdout and stderr.&#34;&#34;&#34;
    with open(os.devnull, &#34;w&#34;, encoding=&#34;utf-8&#34;) as devnull:
        old_stdout = sys.stdout
        old_stderr = sys.stderr
        try:
            sys.stdout = devnull
            sys.stderr = devnull
            yield
        finally:
            sys.stdout = old_stdout
            sys.stderr = old_stderr</code></pre>
</details>
<div class="desc"><p>Context manager to suppress stdout and stderr.</p></div>
</dd>
<dt id="par_ai_core.utils.timer_block"><code class="name flex">
<span>def <span class="ident">timer_block</span></span>(<span>label: str = 'Timer', console: Console | None = None) ‑> Generator[None, None, None]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def timer_block(label: str = &#34;Timer&#34;, console: Console | None = None) -&gt; Generator[None, None, None]:
    &#34;&#34;&#34;Time a block of code.&#34;&#34;&#34;

    start_time = time.time()
    try:
        yield
    finally:
        end_time = time.time()
        elapsed_time = end_time - start_time
        if not console:
            console = console_err
        console.print(f&#34;{label} took {elapsed_time:.4f} seconds.&#34;)</code></pre>
</details>
<div class="desc"><p>Time a block of code.</p></div>
</dd>
<dt id="par_ai_core.utils.to_camel_case"><code class="name flex">
<span>def <span class="ident">to_camel_case</span></span>(<span>snake_str: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_camel_case(snake_str: str) -&gt; str:
    &#34;&#34;&#34;Convert a snake_case string to camelCase.

    Args:
        snake_str: The snake_case string to convert

    Returns:
        str: The converted camelCase string

    Example:
        &gt;&gt;&gt; to_camel_case(&#34;hello_world&#34;)
        &#39;helloWorld&#39;
    &#34;&#34;&#34;
    components = snake_str.split(&#34;_&#34;)
    # We capitalize the first letter of each component except the first one
    # with the &#39;title&#39; method and join them together.
    return components[0] + &#34;&#34;.join(x.title() for x in components[1:])</code></pre>
</details>
<div class="desc"><p>Convert a snake_case string to camelCase.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snake_str</code></strong></dt>
<dd>The snake_case string to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The converted camelCase string</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; to_camel_case(&quot;hello_world&quot;)
'helloWorld'
</code></pre></div>
</dd>
<dt id="par_ai_core.utils.to_class_case"><code class="name flex">
<span>def <span class="ident">to_class_case</span></span>(<span>snake_str: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_class_case(snake_str: str) -&gt; str:
    &#34;&#34;&#34;Convert a snake_case string to PascalCase (ClassCase).

    Spaces are converted to underscores before conversion.

    Args:
        snake_str: The snake_case string to convert

    Returns:
        str: The converted PascalCase string

    Example:
        &gt;&gt;&gt; to_class_case(&#34;hello_world&#34;)
        &#39;HelloWorld&#39;
        &gt;&gt;&gt; to_class_case(&#34;hello world&#34;)
        &#39;HelloWorld&#39;
    &#34;&#34;&#34;
    components = snake_str.replace(&#34; &#34;, &#34;_&#34;).split(&#34;_&#34;)
    # We capitalize the first letter of each component
    # with the &#39;title&#39; method and join them together.
    return &#34;&#34;.join(x.title() for x in components[0:])</code></pre>
</details>
<div class="desc"><p>Convert a snake_case string to PascalCase (ClassCase).</p>
<p>Spaces are converted to underscores before conversion.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snake_str</code></strong></dt>
<dd>The snake_case string to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The converted PascalCase string</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; to_class_case(&quot;hello_world&quot;)
'HelloWorld'
&gt;&gt;&gt; to_class_case(&quot;hello world&quot;)
'HelloWorld'
</code></pre></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="par_ai_core" href="index.html">par_ai_core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="par_ai_core.utils.add_module_path" href="#par_ai_core.utils.add_module_path">add_module_path</a></code></li>
<li><code><a title="par_ai_core.utils.all_subclasses" href="#par_ai_core.utils.all_subclasses">all_subclasses</a></code></li>
<li><code><a title="par_ai_core.utils.camel_to_snake" href="#par_ai_core.utils.camel_to_snake">camel_to_snake</a></code></li>
<li><code><a title="par_ai_core.utils.catch_to_logger" href="#par_ai_core.utils.catch_to_logger">catch_to_logger</a></code></li>
<li><code><a title="par_ai_core.utils.chunks" href="#par_ai_core.utils.chunks">chunks</a></code></li>
<li><code><a title="par_ai_core.utils.coalesce" href="#par_ai_core.utils.coalesce">coalesce</a></code></li>
<li><code><a title="par_ai_core.utils.detect_syntax" href="#par_ai_core.utils.detect_syntax">detect_syntax</a></code></li>
<li><code><a title="par_ai_core.utils.dict_keys_to_lower" href="#par_ai_core.utils.dict_keys_to_lower">dict_keys_to_lower</a></code></li>
<li><code><a title="par_ai_core.utils.extract_url_auth" href="#par_ai_core.utils.extract_url_auth">extract_url_auth</a></code></li>
<li><code><a title="par_ai_core.utils.gather_files_for_context" href="#par_ai_core.utils.gather_files_for_context">gather_files_for_context</a></code></li>
<li><code><a title="par_ai_core.utils.get_file_list_for_context" href="#par_ai_core.utils.get_file_list_for_context">get_file_list_for_context</a></code></li>
<li><code><a title="par_ai_core.utils.get_file_suffix" href="#par_ai_core.utils.get_file_suffix">get_file_suffix</a></code></li>
<li><code><a title="par_ai_core.utils.get_files" href="#par_ai_core.utils.get_files">get_files</a></code></li>
<li><code><a title="par_ai_core.utils.get_url_file_suffix" href="#par_ai_core.utils.get_url_file_suffix">get_url_file_suffix</a></code></li>
<li><code><a title="par_ai_core.utils.has_stdin_content" href="#par_ai_core.utils.has_stdin_content">has_stdin_content</a></code></li>
<li><code><a title="par_ai_core.utils.has_value" href="#par_ai_core.utils.has_value">has_value</a></code></li>
<li><code><a title="par_ai_core.utils.hash_list_by_key" href="#par_ai_core.utils.hash_list_by_key">hash_list_by_key</a></code></li>
<li><code><a title="par_ai_core.utils.id_generator" href="#par_ai_core.utils.id_generator">id_generator</a></code></li>
<li><code><a title="par_ai_core.utils.is_date" href="#par_ai_core.utils.is_date">is_date</a></code></li>
<li><code><a title="par_ai_core.utils.is_float" href="#par_ai_core.utils.is_float">is_float</a></code></li>
<li><code><a title="par_ai_core.utils.is_int" href="#par_ai_core.utils.is_int">is_int</a></code></li>
<li><code><a title="par_ai_core.utils.is_url" href="#par_ai_core.utils.is_url">is_url</a></code></li>
<li><code><a title="par_ai_core.utils.is_valid_uuid_v4" href="#par_ai_core.utils.is_valid_uuid_v4">is_valid_uuid_v4</a></code></li>
<li><code><a title="par_ai_core.utils.is_zero" href="#par_ai_core.utils.is_zero">is_zero</a></code></li>
<li><code><a title="par_ai_core.utils.json_serial" href="#par_ai_core.utils.json_serial">json_serial</a></code></li>
<li><code><a title="par_ai_core.utils.md" href="#par_ai_core.utils.md">md</a></code></li>
<li><code><a title="par_ai_core.utils.md5_hash" href="#par_ai_core.utils.md5_hash">md5_hash</a></code></li>
<li><code><a title="par_ai_core.utils.nested_get" href="#par_ai_core.utils.nested_get">nested_get</a></code></li>
<li><code><a title="par_ai_core.utils.non_zero" href="#par_ai_core.utils.non_zero">non_zero</a></code></li>
<li><code><a title="par_ai_core.utils.output_to_dicts" href="#par_ai_core.utils.output_to_dicts">output_to_dicts</a></code></li>
<li><code><a title="par_ai_core.utils.parse_csv_text" href="#par_ai_core.utils.parse_csv_text">parse_csv_text</a></code></li>
<li><code><a title="par_ai_core.utils.read_env_file" href="#par_ai_core.utils.read_env_file">read_env_file</a></code></li>
<li><code><a title="par_ai_core.utils.read_text_file_to_stringio" href="#par_ai_core.utils.read_text_file_to_stringio">read_text_file_to_stringio</a></code></li>
<li><code><a title="par_ai_core.utils.run_cmd" href="#par_ai_core.utils.run_cmd">run_cmd</a></code></li>
<li><code><a title="par_ai_core.utils.run_shell_cmd" href="#par_ai_core.utils.run_shell_cmd">run_shell_cmd</a></code></li>
<li><code><a title="par_ai_core.utils.sha1_hash" href="#par_ai_core.utils.sha1_hash">sha1_hash</a></code></li>
<li><code><a title="par_ai_core.utils.sha256_hash" href="#par_ai_core.utils.sha256_hash">sha256_hash</a></code></li>
<li><code><a title="par_ai_core.utils.str_ellipsis" href="#par_ai_core.utils.str_ellipsis">str_ellipsis</a></code></li>
<li><code><a title="par_ai_core.utils.suppress_output" href="#par_ai_core.utils.suppress_output">suppress_output</a></code></li>
<li><code><a title="par_ai_core.utils.timer_block" href="#par_ai_core.utils.timer_block">timer_block</a></code></li>
<li><code><a title="par_ai_core.utils.to_camel_case" href="#par_ai_core.utils.to_camel_case">to_camel_case</a></code></li>
<li><code><a title="par_ai_core.utils.to_class_case" href="#par_ai_core.utils.to_class_case">to_class_case</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
