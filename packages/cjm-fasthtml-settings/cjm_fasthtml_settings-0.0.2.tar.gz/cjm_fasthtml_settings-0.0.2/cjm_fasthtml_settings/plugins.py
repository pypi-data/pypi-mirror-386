"""Optional plugin integration for extensible settings systems"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/plugins.ipynb.

# %% auto 0
__all__ = ['PluginRegistryProtocol', 'SimplePluginRegistry']

# %% ../nbs/plugins.ipynb 3
from pathlib import Path
from typing import Dict, Any, Optional, Protocol, runtime_checkable

# Import from cjm-fasthtml-plugins
from cjm_fasthtml_plugins.core.metadata import PluginMetadata

# %% ../nbs/plugins.ipynb 8
@runtime_checkable
class PluginRegistryProtocol(Protocol):
    """Protocol that plugin registries should implement.
    
    This allows the settings library to work with any plugin system
    that implements these methods.
    """
    
    def get_plugin(self, unique_id: str) -> Optional[PluginMetadata]:
        """Get plugin metadata by unique ID."""
        ...
    
    def get_plugins_by_category(self, category: str) -> list[PluginMetadata]:
        """Get all plugins in a category."""
        ...
    
    def get_categories_with_plugins(self) -> list[str]:
        """Get all categories that have registered plugins."""
        ...
    
    def load_plugin_config(self, unique_id: str) -> Dict[str, Any]:
        """Load saved configuration for a plugin."""
        ...
    
    def save_plugin_config(self, unique_id: str, config: Dict[str, Any]) -> bool:
        """Save configuration for a plugin."""
        ...

# %% ../nbs/plugins.ipynb 10
class SimplePluginRegistry:
    """Simple implementation of PluginRegistryProtocol.
    
    This provides a basic plugin registry that can be used with the settings
    library. Applications with more complex needs can implement their own
    registry that follows the PluginRegistryProtocol.
    
    Categories are arbitrary strings defined by the application.
    """
    
    def __init__(self, config_dir: Optional[Path] = None):
        self._plugins: Dict[str, PluginMetadata] = {}
        self._config_dir = config_dir or Path("configs")
    
    def register_plugin(self, metadata: PluginMetadata):
        """Register a plugin."""
        # Check if plugin is configured
        config_file = self._config_dir / f"{metadata.get_unique_id()}.json"
        metadata.is_configured = config_file.exists()
        
        self._plugins[metadata.get_unique_id()] = metadata
    
    def get_plugin(self, unique_id: str) -> Optional[PluginMetadata]:
        """Get plugin metadata by unique ID."""
        return self._plugins.get(unique_id)
    
    def get_plugins_by_category(self, category: str) -> list:
        """Get all plugins in a category."""
        return [p for p in self._plugins.values() if p.category == category]
    
    def get_categories_with_plugins(self) -> list:
        """Get all categories that have registered plugins."""
        categories = set(p.category for p in self._plugins.values())
        return sorted(categories)
    
    def load_plugin_config(self, unique_id: str) -> Dict[str, Any]:
        """Load saved configuration for a plugin."""
        import json
        config_file = self._config_dir / f"{unique_id}.json"
        if config_file.exists():
            with open(config_file, 'r') as f:
                return json.load(f)
        return {}
    
    def save_plugin_config(self, unique_id: str, config: Dict[str, Any]) -> bool:
        """Save configuration for a plugin."""
        import json
        try:
            self._config_dir.mkdir(exist_ok=True, parents=True)
            config_file = self._config_dir / f"{unique_id}.json"
            with open(config_file, 'w') as f:
                json.dump(config, f, indent=2)
            
            # Update is_configured status
            if unique_id in self._plugins:
                self._plugins[unique_id].is_configured = True
            
            return True
        except Exception as e:
            print(f"Error saving plugin config: {e}")
            return False
