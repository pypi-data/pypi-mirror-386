# (generated with --quick)

import abc
import dataclasses
import importlib
import pkgutil
import typing
from typing import Any, Optional, TypeVar, Union, overload

ABC: type[abc.ABC]
BaseModel: Any
Callable: type
ModuleType: type[module]

_FuncT = TypeVar('_FuncT', bound=typing.Callable)
_T = TypeVar('_T', bound=BaseTarget)

class BaseTarget(abc.ABC):
    UNKNOWN_BYTE: int
    __doc__: str
    config: Any
    def __init__(self, config = ...) -> None: ...
    @abstractmethod
    def connect(self) -> None: ...
    @abstractmethod
    def disconnect(self) -> None: ...
    @abstractmethod
    def get_core_registers(self) -> list[CoreRegister]: ...
    @abstractmethod
    def is_connected(self) -> bool: ...
    @abstractmethod
    def is_stopped(self) -> bool: ...
    def read(self, target: TargetData) -> Optional[Union[int, list[int]]]: ...
    @abstractmethod
    def run(self) -> None: ...
    @abstractmethod
    def stop(self) -> None: ...

@dataclasses.dataclass
class CoreRegister(TargetData):
    name: str
    __doc__: str
    def __init__(self, name: str) -> None: ...
    def __str__(self) -> str: ...

@dataclasses.dataclass
class MemoryArea(TargetData):
    address: int
    size: int
    __doc__: str
    def __init__(self, address: int, size: int) -> None: ...
    def __str__(self) -> str: ...

class TargetData(abc.ABC):
    __doc__: str
    @classmethod
    def format(cls, value: Optional[Union[int, list[int]]]) -> Union[str, list[str]]: ...
    def read_from(self, target: BaseTarget) -> list[int]: ...

class TargetFactory:
    __doc__: str
    _is_initialised: bool
    _registry: dict[str, tuple[type[BaseTarget], Optional[type]]]
    @classmethod
    def _prepare_config(cls, cfg, config_cls: type) -> Any: ...
    @classmethod
    def available(cls) -> list[str]: ...
    @classmethod
    def create(cls, name: str, cfg = ...) -> BaseTarget: ...
    @classmethod
    def get_config_type(cls, name: str) -> Optional[type]: ...
    @classmethod
    def get_target_type(cls, name: str) -> type[BaseTarget]: ...
    @classmethod
    def init(cls, targets_package: module) -> None: ...
    @classmethod
    def register(cls, name: str, target_cls: type[BaseTarget], config_cls: Optional[type]) -> None: ...

def abstractmethod(funcobj: _FuncT) -> _FuncT: ...
@overload
def dataclass(cls: None, /) -> typing.Callable[[type[_T]], type[_T]]: ...
@overload
def dataclass(cls: type[_T], /) -> type[_T]: ...
@overload
def dataclass(*, init: bool = ..., repr: bool = ..., eq: bool = ..., order: bool = ..., unsafe_hash: bool = ..., frozen: bool = ..., match_args: bool = ..., kw_only: bool = ..., slots: bool = ...) -> typing.Callable[[type[_T]], type[_T]]: ...
def register_target(name: str, config_cls: Optional[type] = ...) -> typing.Callable[[type[_T]], type[_T]]: ...
