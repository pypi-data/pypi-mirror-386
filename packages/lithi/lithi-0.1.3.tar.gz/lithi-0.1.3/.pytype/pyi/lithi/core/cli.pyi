# (generated with --quick)

import abc
import argparse
import dataclasses
import enum
import importlib
import inspect
import lithi.core.logger
import pkgutil
import types
import typing
from typing import Annotated, Any, ClassVar, Optional, TypeVar, overload

ABC: type[abc.ABC]
Callable: type
Enum: type[enum.Enum]
logger: lithi.core.logger._GlobalLoggerProxy

_FuncT = TypeVar('_FuncT', bound=typing.Callable)
_T = TypeVar('_T')

@dataclasses.dataclass
class Argument:
    name: str
    short: Optional[str] = ...
    help: Optional[str] = ...
    default: Any = ...
    required: bool = ...
    choices: Optional[list] = ...
    metavar: Optional[str] = ...
    __doc__: str
    dest: Annotated[str, 'property']
    arg_type: Annotated[ArgumentType, 'property']
    def __init__(self, *, name: str, short: Optional[str] = ..., help: Optional[str] = ..., default = ..., required: bool = ..., choices: Optional[list] = ..., metavar: Optional[str] = ...) -> None: ...
    def __post_init__(self) -> None: ...
    def _add_default_and_required(self, kwargs: dict[str, Any]) -> None: ...
    def _build_argument_kwargs(self) -> dict[str, Any]: ...
    def _build_argument_names(self) -> list[str]: ...
    def _build_help_text(self) -> str: ...
    def register(self, parser: argparse.ArgumentParser) -> None: ...

class ArgumentType(str, enum.Enum):
    BOOL: str
    CHOICE: str
    FLOAT: str
    INT: str
    STRING: str
    __doc__: ClassVar[str]

class Cli:
    __doc__: str
    commands: dict[str, Command]
    name: str
    on_init: Any
    on_no_command: Optional[typing.Callable[[Cli, argparse.Namespace], None]]
    parser: argparse.ArgumentParser
    def __init__(self, name: str = ..., description: Optional[str] = ..., on_init: Optional[typing.Callable[[Cli, argparse.Namespace], None]] = ..., on_no_command: Optional[typing.Callable[[Cli, argparse.Namespace], None]] = ...) -> None: ...
    def exec(self) -> None: ...
    def load_commands(self, package: module) -> None: ...
    def print_help(self) -> None: ...
    def register(self, command: Command) -> None: ...

class Command(abc.ABC):
    __doc__: str
    args: ClassVar[list[Argument]]
    name: ClassVar[str]
    def __init_subclass__(cls, **kwargs) -> None: ...
    @abstractmethod
    def exec(self, args: argparse.Namespace) -> None: ...

def abstractmethod(funcobj: _FuncT) -> _FuncT: ...
@overload
def dataclass(cls: None, /) -> typing.Callable[[type[_T]], type[_T]]: ...
@overload
def dataclass(cls: type[_T], /) -> type[_T]: ...
@overload
def dataclass(*, init: bool = ..., repr: bool = ..., eq: bool = ..., order: bool = ..., unsafe_hash: bool = ..., frozen: bool = ..., match_args: bool = ..., kw_only: bool = ..., slots: bool = ...) -> typing.Callable[[type[_T]], type[_T]]: ...
