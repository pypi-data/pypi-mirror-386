# 线程安全性

`AIMDAsyncLimiter` 主要面向单个 `asyncio` 事件循环内的协作式并发。理解其同步保证有助于安全部署。

## 事件循环语义

- 限流器使用 `asyncio.Lock` 同时保护获取流程与状态更新。
- 同一事件循环内的多个并发任务可安全调用 `acquire()`。
- `record_success` / `record_failure` 在受保护的状态锁下执行，确保速率调整具有确定性。

## 跨线程使用

- `asyncio` 事件循环本身并非线程安全。若在多线程场景下使用，应为每个线程创建独立的限流器，或通过线程安全的队列将任务回传给拥有事件循环的线程。
- 即使在 CPython 3.13+ 的实验性无 GIL 运行时中，也应避免在不属于该事件循环的线程中直接调用限流器方法。

## 多进程部署

- 每个进程应维护各自的限流器实例。若需跨进程共享状态，需要额外的协调机制，库本身不提供此功能。

## 自定义时钟与睡眠函数

若提供自定义的 `clock` 或 `sleep`，请确保它们本身是线程安全的，并且与调度器兼容。避免在 `sleep` 中阻塞事件循环，否则会削弱整体吞吐。

## 取消与背压

- 取消会立即传播；尚未完成的获取请求会被释放且不会修改内部状态。
- 正在执行的许可会独立结束；若忘记显式标记成功/失败，限流器会处于保守状态。因此推荐优先使用上下文管理器模式。

## 并发测试建议

可结合 `pytest-asyncio` 等工具模拟并发场景。在单元测试中注入可控的 `clock` 与 `sleep`，以便模拟时间推进。
