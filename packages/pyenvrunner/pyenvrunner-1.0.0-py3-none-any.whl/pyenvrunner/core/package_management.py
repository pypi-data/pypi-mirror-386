"""
Package Management Module

This module handles:
- Script execution with real-time output streaming
- Detection of missing Python packages (ModuleNotFoundError)
- Automatic installation of missing packages via pip
- Saving installed packages to requirements file
- Clearing packages from virtual environments

Key Features:
- Multi-threaded I/O for real-time stdout/stderr streaming
- Retry mechanism for automatic package installation
- Import name to PyPI package name mapping support
- Requirements file management with version pinning

Author: PyEnvRunner Team
License: MIT
"""

import os
import sys
import subprocess
import threading
from queue import Queue, Empty

from .exceptions import RequirementsFileError, PackageInstallationError, ScriptExecutionError
from .config import DEFAULT_REQUIREMENTS_FILE


def _stream_reader(stream, queue, stream_name):
    """
    Helper function to read from a stream and put lines into a queue.
    Runs in a separate thread to enable real-time output streaming.

    This function is designed to be run in a background thread. It reads
    from stdout or stderr line by line and puts each line into a queue
    for the main thread to process and display immediately.

    Args:
        stream: The stream to read from (stdout or stderr)
        queue: Thread-safe queue to put lines into
        stream_name: Identifier string ('stdout' or 'stderr')

    Note:
        - Uses iter(stream.readline, '') to read until EOF
        - Closes the stream when done
        - Handles both stdout and stderr streams identically
    """
    try:
        for line in iter(stream.readline, ''):
            if line:
                queue.put((stream_name, line))
    finally:
        stream.close()


def append_requirement(
    module_name: str,
    save_reqs_flag: bool = False,
    requirements_file_name: str = DEFAULT_REQUIREMENTS_FILE,
    venv_python_executable: str = sys.executable
) -> None:
    """
    Append a newly installed package to the requirements file with version pinning.

    This function saves installed packages to a requirements.txt file for
    reproducibility. It queries pip to get the exact installed version and
    writes it in the format "package==version".

    Args:
        module_name: Name of the package to add (e.g., "requests")
        save_reqs_flag: Whether to actually save (if False, function returns immediately)
        requirements_file_name: Path to the requirements file
        venv_python_executable: Python executable to use for pip show command

    Behavior:
        - If save_reqs_flag is False, does nothing
        - Strips version specifiers from module_name to get normalized name
        - Queries pip show to get exact installed version
        - Creates requirements file if it doesn't exist
        - Only adds package if not already in the file
        - Adds with version pin: "package==version"

    Example:
        append_requirement("requests", True, "requirements.txt", "/path/to/python")
        # Adds line: requests==2.32.5
    """
    if not save_reqs_flag:
        return

    normalized_name: str = module_name.split("==")[0].split(">=")[0].split("<=")[0].split(">")[0].split("<")[0].split("~=")[0].split(" @")[0].strip()
    requirement_line: str = normalized_name

    try:
        show_result: subprocess.CompletedProcess[str] = subprocess.run(
            [venv_python_executable, "-m", "pip", "show", normalized_name],
            capture_output=True, text=True, check=True
        )
        version: str = ""
        for line in show_result.stdout.strip().splitlines():
            if line.startswith("Version:"):
                version = line.split(":", 1)[1].strip()
                break
        if version:
            requirement_line = f"{normalized_name}=={version}"
    except subprocess.CalledProcessError:
        pass

    if not os.path.exists(requirements_file_name):
        with open(requirements_file_name, "w") as f:
            f.write("# Auto-generated by pyenvrunner\n")

    with open(requirements_file_name, "r") as f:
        existing_lines: list[str] = [line.strip() for line in f.readlines()]
        existing_modules: set[str] = {
            line.split("==")[0].strip() for line in existing_lines
            if line and not line.startswith("#")
        }

    if normalized_name not in existing_modules:
        with open(requirements_file_name, "a") as f:
            f.write(f"{requirement_line}\n")

def install_missing_packages(
    script_path: str,
    import_to_package_map: dict[str, str],
    venv_python_executable: str,
    venv_pip_command_list: list[str],
    save_requirements_flag: bool,
    requirements_file_name: str = DEFAULT_REQUIREMENTS_FILE,
    script_args: list[str] | None = None
) -> None:
    """
    Execute a Python script with automatic missing package installation.

    This is the core function of PyEnvRunner. It runs the script, detects
    ModuleNotFoundError in stderr, automatically installs missing packages,
    and retries until the script succeeds or encounters a non-module error.

    Args:
        script_path: Path to the Python script to execute
        import_to_package_map: Dict mapping import names to PyPI package names
                               (e.g., {"cv2": "opencv-python"})
        venv_python_executable: Python executable to use for running the script
        venv_pip_command_list: Command list for pip (e.g., ["pip"] or ["/path/to/pip"])
        save_requirements_flag: Whether to save installed packages to requirements file
        requirements_file_name: Path to requirements file (if save_requirements_flag=True)
        script_args: Arguments to pass to the script

    Algorithm:
        1. Execute script with real-time output streaming (using threads)
        2. Collect stderr to check for ModuleNotFoundError
        3. If ModuleNotFoundError detected:
           a. Parse the missing module name
           b. Map it to PyPI package name (using import_to_package_map)
           c. Install the package via pip
           d. Optionally save to requirements file
           e. Retry the script (goto step 1)
        4. If script succeeds (exit code 0), return successfully
        5. If script fails with non-module error, raise ScriptExecutionError

    Real-time Output:
        Uses multi-threading to read stdout and stderr simultaneously and
        display output immediately as it's produced (no buffering).

    Raises:
        ScriptExecutionError: If script fails with non-module error
        PackageInstallationError: If pip install fails
        FileNotFoundError: If script or python executable not found

    Example:
        install_missing_packages(
            script_path="my_script.py",
            import_to_package_map={"cv2": "opencv-python"},
            venv_python_executable="/path/to/venv/bin/python",
            venv_pip_command_list=["/path/to/venv/bin/pip"],
            save_requirements_flag=True,
            requirements_file_name="requirements.txt",
            script_args=["--arg1", "value1"]
        )
    """
    if script_args is None:
        script_args = []

    # ============================================================================
    # RETRY LOOP: Continue until script succeeds or encounters non-module error
    # ============================================================================
    while True:
        print(f"\n--- Running script: {script_path} using {venv_python_executable} ---")
        if script_args:
            print(f"Script arguments: {' '.join(script_args)}")

        # Execute the script as a subprocess
        # Using -u flag for unbuffered output (required for real-time streaming)
        try:
            command: list[str] = [venv_python_executable, "-u", script_path] + script_args
            process: subprocess.Popen = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,  # Capture stdout
                stderr=subprocess.PIPE,  # Capture stderr (contains ModuleNotFoundError)
                text=True,               # Text mode (not bytes)
                bufsize=1                # Line-buffered for real-time streaming
            )
        except FileNotFoundError:
            raise ScriptExecutionError(
                f"Script not found: {script_path} or Python executable not found: {venv_python_executable}"
            )

        # Variables to track script execution state
        missing_module: str | None = None  # Will store name of missing module if found
        script_started: bool = False       # Track if script produced any output
        stdout_lines: list[str] = []       # Store stdout for later analysis
        stderr_lines: list[str] = []       # Store stderr for error detection

        # ========================================================================
        # REAL-TIME OUTPUT STREAMING using Multi-Threading
        # ========================================================================
        # Problem: Reading stdout and stderr sequentially can cause deadlocks if
        #          buffers fill up. Also, we want to display output in real-time.
        # Solution: Use separate threads to read each stream and put output in a
        #           queue. Main thread reads from queue and displays immediately.
        # ========================================================================

        # Create a thread-safe queue for inter-thread communication
        output_queue: Queue = Queue()

        # Create thread to read stdout continuously
        stdout_thread = threading.Thread(
            target=_stream_reader,
            args=(process.stdout, output_queue, 'stdout')
        )
        # Create thread to read stderr continuously
        stderr_thread = threading.Thread(
            target=_stream_reader,
            args=(process.stderr, output_queue, 'stderr')
        )

        # Mark threads as daemon so they don't prevent program exit
        stdout_thread.daemon = True
        stderr_thread.daemon = True
        # Start both threads (they run concurrently)
        stdout_thread.start()
        stderr_thread.start()

        # ========================================================================
        # Main thread: Read from queue and display output in real-time
        # ========================================================================
        while True:
            try:
                # Wait for output from either stream (timeout to check thread status)
                stream_name, line = output_queue.get(timeout=0.1)
                script_started = True  # Script has produced output

                # Print immediately for real-time output (this is the key feature!)
                print(line, end='')
                sys.stdout.flush()  # Force flush to display immediately

                # Store for later analysis (needed to detect ModuleNotFoundError)
                if stream_name == 'stdout':
                    stdout_lines.append(line)
                else:
                    stderr_lines.append(line)

            except Empty:
                # Queue is empty - check if both threads have finished reading
                if not stdout_thread.is_alive() and not stderr_thread.is_alive():
                    # Drain any remaining items in queue before exiting loop
                    while not output_queue.empty():
                        try:
                            stream_name, line = output_queue.get_nowait()
                            print(line, end='')
                            sys.stdout.flush()
                            if stream_name == 'stdout':
                                stdout_lines.append(line)
                            else:
                                stderr_lines.append(line)
                        except Empty:
                            break
                    break  # Exit main loop - all output has been read

        # Wait for the subprocess to complete and get exit code
        process.wait()

        # ========================================================================
        # ERROR DETECTION: Check stderr for ModuleNotFoundError
        # ========================================================================
        # Combine all stderr lines into a single string for analysis
        stderr_output: str = ''.join(stderr_lines)

        # Look for the specific error pattern that indicates missing module
        if "ModuleNotFoundError: No module named" in stderr_output:
            try:
                # Parse the module name from the error message
                # Example stderr: "ModuleNotFoundError: No module named 'requests'"
                missing_module_token: str = "ModuleNotFoundError: No module named"
                missing_module_part: str = stderr_output.split(missing_module_token)[-1]
                # Extract module name and strip quotes
                missing_module = missing_module_part.strip().split()[0].strip("'\"")
            except IndexError:
                raise ScriptExecutionError("Could not parse missing module name from stderr.")

        # ========================================================================
        # AUTOMATIC PACKAGE INSTALLATION & RETRY
        # ========================================================================
        if process.returncode != 0 and missing_module:
            # Script failed due to missing module - install it and retry
            # Use import_to_package_map to handle cases like: cv2 → opencv-python
            install_module: str = import_to_package_map.get(missing_module, missing_module)
            print(f"\n>>> Detected missing module: '{missing_module}'. Attempting to install '{install_module}'...")

            try:
                # Run pip install command
                pip_command_to_run: list[str] = venv_pip_command_list + ["install", install_module]
                install_result: subprocess.CompletedProcess[str] = subprocess.run(
                    pip_command_to_run, check=True, capture_output=True, text=True
                )
                # Display pip output
                print(f"--- pip install STDOUT for {install_module} ---")
                print(install_result.stdout.strip())
                if install_result.stderr:
                    print(f"--- pip install STDERR for {install_module} ---")
                    print(install_result.stderr.strip())

                # Optionally save to requirements file with version pinning
                append_requirement(install_module, save_requirements_flag, requirements_file_name)
                print(f">>> Installation of {install_module} successful. Retrying script...")

            except subprocess.CalledProcessError as e:
                # pip install failed - package doesn't exist or network error
                stderr_msg: str = f"\nStderr: {e.stderr.strip()}" if e.stderr else ""
                pip_cmd_str: str = ' '.join(venv_pip_command_list)
                raise PackageInstallationError(
                    f"Error installing module {install_module} using '{pip_cmd_str}': {e}{stderr_msg}"
                )
            # Continue to next iteration of while loop (retry the script)
            continue

        elif process.returncode != 0:
            # Script failed but NOT due to missing module - this is a real error
            if script_started:
                print(f"\n--- Script {script_path} failed with exit code {process.returncode} ---")
                raise ScriptExecutionError(f"Script failed with exit code {process.returncode}")
            else:
                raise ScriptExecutionError(f"Script failed to start or exited early with code {process.returncode}")

        else:
            # Script succeeded (exit code 0) - we're done!
            print(f"\n--- Script {script_path} completed successfully ---")
            break  # Exit the while True retry loop

def clear_environment_packages(
    pip_command_list: list[str]
) -> None:
    """
    Clear all installed packages from a Python environment.

    This utility function removes all non-editable packages from an environment.
    Useful for cleaning up before rebuilding from a requirements.txt file.

    Args:
        pip_command_list: Command to invoke pip (e.g., ["pip"] or ["/path/to/venv/bin/pip"])

    Behavior:
        1. Runs `pip freeze` to list all installed packages
        2. Filters out editable installs (-e) and pyenvrunner itself
        3. Prompts user for confirmation (y/N)
        4. Uninstalls all packages using `pip uninstall -y`

    Raises:
        PackageInstallationError: If pip commands fail
        FileNotFoundError: If pip executable not found

    Example:
        clear_environment_packages(["/path/to/venv/bin/pip"])
        # Prompts: "Are you sure you want to uninstall these packages? (y/N):"
        # If y: Removes all packages except pyenvrunner
    """
    pip_cmd_str: str = ' '.join(pip_command_list)
    print(f"Attempting to clear packages from environment using pip: {pip_cmd_str}")
    try:
        freeze_command: list[str] = pip_command_list + ["freeze"]
        freeze_result: subprocess.CompletedProcess[str] = subprocess.run(
            freeze_command,
            capture_output=True, text=True, check=True
        )

        installed_packages_lines: list[str] = freeze_result.stdout.strip().splitlines()
        installed_packages: list[str] = []

        for line in installed_packages_lines:
            line = line.strip()
            if not line or line.startswith('#') or line.startswith('-e '):
                continue
            if '==' in line:
                pkg_name: str = line.split('==')[0]
            elif ' @ ' in line:
                pkg_name = line.split(' @ ')[0]
            else:
                continue
            if pkg_name != 'pyenvrunner':
                installed_packages.append(pkg_name)

        if not installed_packages:
            print("No packages to remove from this environment (or only editable installs found).")
            return

        print(f"Found packages to remove: {', '.join(installed_packages)}")

        try:
            user_confirmation: str = input("Are you sure you want to uninstall these packages? (y/N): ")
        except EOFError:
            print("Non-interactive environment detected, cannot confirm. Aborting package clearing.")
            return
        if user_confirmation.lower() != 'y':
            print("Package clearing cancelled by user.")
            return

        uninstall_command: list[str] = pip_command_list + ["uninstall", "-y"] + installed_packages

        print(f"Running: {' '.join(uninstall_command)}")
        uninstall_result: subprocess.CompletedProcess[str] = subprocess.run(
            uninstall_command,
            capture_output=True, text=True, check=False
        )
        print("--- pip uninstall STDOUT ---")
        print(uninstall_result.stdout.strip())
        print("----------------------------")
        if uninstall_result.stderr:
            print("--- pip uninstall STDERR ---")
            print(uninstall_result.stderr.strip())
            print("----------------------------")

        if uninstall_result.returncode == 0:
            print("Environment packages cleared successfully.")
        else:
            print("Error or partial success during package clearing. Check output above.")

    except subprocess.CalledProcessError as e:
        stderr_msg: str = f"\nStderr: {e.stderr.strip()}" if e.stderr else ""
        stdout_msg: str = f"\nStdout: {e.stdout.strip()}" if e.stdout else ""
        raise PackageInstallationError(
            f"Error during environment clearing: {e}. Command: {' '.join(e.cmd)}{stdout_msg}{stderr_msg}"
        )
    except FileNotFoundError:
        raise PackageInstallationError(
            f"pip command '{pip_cmd_str}' or its components not found for clearing environment."
        )