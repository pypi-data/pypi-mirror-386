# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _actuators
else:
    import _actuators

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _actuators.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _actuators.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _actuators.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _actuators.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""
        distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _actuators.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""
        equal(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _actuators.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _actuators.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _actuators.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _actuators.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _actuators.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""
        advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _actuators.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""
        __eq__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _actuators.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""
        __ne__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _actuators.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""
        __iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _actuators.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""
        __isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _actuators.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""
        __add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _actuators.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _actuators.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _actuators:
_actuators.SwigPyIterator_swigregister(SwigPyIterator)
import opensim.simulation
import opensim.common
import opensim.simbody
class CoordinateActuator(opensim.simulation.ScalarActuator):
    r"""
    An actuator that applies a generalized force in the direction of a
    generalized coordinate. The applied generalized force is proportional to the
    input control of the CoordinateActuator. Replaces the GeneralizedForce class.

    Author: Ajay Seth
    Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> CoordinateActuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.CoordinateActuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(CoordinateActuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.CoordinateActuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.CoordinateActuator_getClassName()

    def clone(self):
        r"""clone(CoordinateActuator self) -> CoordinateActuator"""
        return _actuators.CoordinateActuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(CoordinateActuator self) -> std::string const &"""
        return _actuators.CoordinateActuator_getConcreteClassName(self)

    def copyProperty_coordinate(self, source):
        r"""
        copyProperty_coordinate(CoordinateActuator self, CoordinateActuator source)

        Parameters
        ----------
        source: OpenSim::CoordinateActuator::Self const &

        """
        return _actuators.CoordinateActuator_copyProperty_coordinate(self, source)

    def append_coordinate(self, value):
        r"""
        append_coordinate(CoordinateActuator self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.CoordinateActuator_append_coordinate(self, value)

    def constructProperty_coordinate(self, *args):
        r"""
        constructProperty_coordinate(CoordinateActuator self)
        constructProperty_coordinate(CoordinateActuator self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.CoordinateActuator_constructProperty_coordinate(self, *args)

    def get_coordinate(self, *args):
        r"""
        get_coordinate(CoordinateActuator self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_coordinate(CoordinateActuator self) -> std::string const &
        """
        return _actuators.CoordinateActuator_get_coordinate(self, *args)

    def upd_coordinate(self, *args):
        r"""
        upd_coordinate(CoordinateActuator self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_coordinate(CoordinateActuator self) -> std::string &
        """
        return _actuators.CoordinateActuator_upd_coordinate(self, *args)

    def set_coordinate(self, *args):
        r"""
        set_coordinate(CoordinateActuator self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_coordinate(CoordinateActuator self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.CoordinateActuator_set_coordinate(self, *args)

    def copyProperty_optimal_force(self, source):
        r"""
        copyProperty_optimal_force(CoordinateActuator self, CoordinateActuator source)

        Parameters
        ----------
        source: OpenSim::CoordinateActuator::Self const &

        """
        return _actuators.CoordinateActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value):
        r"""
        append_optimal_force(CoordinateActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.CoordinateActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue):
        r"""
        constructProperty_optimal_force(CoordinateActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.CoordinateActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args):
        r"""
        get_optimal_force(CoordinateActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_force(CoordinateActuator self) -> double const &
        """
        return _actuators.CoordinateActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args):
        r"""
        upd_optimal_force(CoordinateActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_optimal_force(CoordinateActuator self) -> double &
        """
        return _actuators.CoordinateActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args):
        r"""
        set_optimal_force(CoordinateActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_optimal_force(CoordinateActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.CoordinateActuator_set_optimal_force(self, *args)

    def __init__(self, *args):
        r"""
        Default constructor leaves coordinate name unspecified, or you can
           provide it. *
        """
        _actuators.CoordinateActuator_swiginit(self, _actuators.new_CoordinateActuator(*args))

    def setOptimalForce(self, optimalForce):
        r""" %Set the 'optimal_force' property. *"""
        return _actuators.CoordinateActuator_setOptimalForce(self, optimalForce)

    def getOptimalForce(self):
        r""" Get the current setting of the 'optimal_force' property. *"""
        return _actuators.CoordinateActuator_getOptimalForce(self)

    @staticmethod
    def CreateForceSetOfCoordinateActuatorsForModel(s, aModel, aOptimalForce=1, aIncludeLockedAndConstrainedCoordinates=True):
        r"""
        CreateForceSetOfCoordinateActuatorsForModel(State s, Model aModel, double aOptimalForce=1, bool aIncludeLockedAndConstrainedCoordinates=True) -> ForceSet

        Parameters
        ----------
        s: SimTK::State const &
        aModel: OpenSim::Model &
        aOptimalForce: double
        aIncludeLockedAndConstrainedCoordinates: bool

        """
        return _actuators.CoordinateActuator_CreateForceSetOfCoordinateActuatorsForModel(s, aModel, aOptimalForce, aIncludeLockedAndConstrainedCoordinates)

    def isCoordinateValid(self):
        r"""isCoordinateValid(CoordinateActuator self) -> bool"""
        return _actuators.CoordinateActuator_isCoordinateValid(self)

    def getSpeed(self, s):
        r"""
        getSpeed(CoordinateActuator self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _actuators.CoordinateActuator_getSpeed(self, s)

    def setCoordinate(self, aCoordinate):
        r"""
        %Set the reference pointer to point to the given Coordinate and set
           the 'coordinate' name property also. *
        """
        return _actuators.CoordinateActuator_setCoordinate(self, aCoordinate)

    def getCoordinate(self):
        r""" Get a pointer to the Coordinate to which this actuator refers. *"""
        return _actuators.CoordinateActuator_getCoordinate(self)
    __swig_destroy__ = _actuators.delete_CoordinateActuator

# Register CoordinateActuator in _actuators:
_actuators.CoordinateActuator_swigregister(CoordinateActuator)
class ActivationCoordinateActuator(CoordinateActuator):
    r"""
    Similar to CoordinateActuator (simply produces a generalized force) but
    with first-order linear activation dynamics. This actuator has one state
    variable, `activation`, with :math:`\dot{a} = (x - a) / \tau`, where
    :math:`a` is activation, :math:`x` is excitation, and :math:`\tau` is the
    activation time constant (there is no separate deactivation time constant).
    The statebounds_activation output is used in Moco to set default values for
    the activation state variable.
    **Default %Property Values**
    activation_time_constant: 0.01
    default_activation: 0.5
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ActivationCoordinateActuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ActivationCoordinateActuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ActivationCoordinateActuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ActivationCoordinateActuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ActivationCoordinateActuator_getClassName()

    def clone(self):
        r"""clone(ActivationCoordinateActuator self) -> ActivationCoordinateActuator"""
        return _actuators.ActivationCoordinateActuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ActivationCoordinateActuator self) -> std::string const &"""
        return _actuators.ActivationCoordinateActuator_getConcreteClassName(self)

    def copyProperty_activation_time_constant(self, source):
        r"""
        copyProperty_activation_time_constant(ActivationCoordinateActuator self, ActivationCoordinateActuator source)

        Parameters
        ----------
        source: OpenSim::ActivationCoordinateActuator::Self const &

        """
        return _actuators.ActivationCoordinateActuator_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value):
        r"""
        append_activation_time_constant(ActivationCoordinateActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ActivationCoordinateActuator_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue):
        r"""
        constructProperty_activation_time_constant(ActivationCoordinateActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.ActivationCoordinateActuator_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args):
        r"""
        get_activation_time_constant(ActivationCoordinateActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_time_constant(ActivationCoordinateActuator self) -> double const &
        """
        return _actuators.ActivationCoordinateActuator_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args):
        r"""
        upd_activation_time_constant(ActivationCoordinateActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_time_constant(ActivationCoordinateActuator self) -> double &
        """
        return _actuators.ActivationCoordinateActuator_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args):
        r"""
        set_activation_time_constant(ActivationCoordinateActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_time_constant(ActivationCoordinateActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ActivationCoordinateActuator_set_activation_time_constant(self, *args)

    def copyProperty_default_activation(self, source):
        r"""
        copyProperty_default_activation(ActivationCoordinateActuator self, ActivationCoordinateActuator source)

        Parameters
        ----------
        source: OpenSim::ActivationCoordinateActuator::Self const &

        """
        return _actuators.ActivationCoordinateActuator_copyProperty_default_activation(self, source)

    def append_default_activation(self, value):
        r"""
        append_default_activation(ActivationCoordinateActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ActivationCoordinateActuator_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue):
        r"""
        constructProperty_default_activation(ActivationCoordinateActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.ActivationCoordinateActuator_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args):
        r"""
        get_default_activation(ActivationCoordinateActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_activation(ActivationCoordinateActuator self) -> double const &
        """
        return _actuators.ActivationCoordinateActuator_get_default_activation(self, *args)

    def upd_default_activation(self, *args):
        r"""
        upd_default_activation(ActivationCoordinateActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_activation(ActivationCoordinateActuator self) -> double &
        """
        return _actuators.ActivationCoordinateActuator_upd_default_activation(self, *args)

    def set_default_activation(self, *args):
        r"""
        set_default_activation(ActivationCoordinateActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_activation(ActivationCoordinateActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ActivationCoordinateActuator_set_default_activation(self, *args)
    _has_output_statebounds_activation = property(_actuators.ActivationCoordinateActuator__has_output_statebounds_activation_get, _actuators.ActivationCoordinateActuator__has_output_statebounds_activation_set, doc=r"""_has_output_statebounds_activation : bool""")

    def __init__(self, *args):
        r""" Provide the coordinate name."""
        _actuators.ActivationCoordinateActuator_swiginit(self, _actuators.new_ActivationCoordinateActuator(*args))

    def getBoundsActivation(self, arg2):
        r"""
        The lower bound on activation is getMinControl() and the upper bound is
        getMaxControl().
        Whether these bounds are enforced is determined by the solver used.
        """
        return _actuators.ActivationCoordinateActuator_getBoundsActivation(self, arg2)
    __swig_destroy__ = _actuators.delete_ActivationCoordinateActuator

# Register ActivationCoordinateActuator in _actuators:
_actuators.ActivationCoordinateActuator_swigregister(ActivationCoordinateActuator)
class PointActuator(opensim.simulation.ScalarActuator):
    r"""
    A class that implements a point actuator acting on the model.
    This actuator has no states; the control is simply the force to
    be applied to the model.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PointActuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.PointActuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PointActuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.PointActuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.PointActuator_getClassName()

    def clone(self):
        r"""clone(PointActuator self) -> PointActuator"""
        return _actuators.PointActuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PointActuator self) -> std::string const &"""
        return _actuators.PointActuator_getConcreteClassName(self)

    def copyProperty_body(self, source):
        r"""
        copyProperty_body(PointActuator self, PointActuator source)

        Parameters
        ----------
        source: OpenSim::PointActuator::Self const &

        """
        return _actuators.PointActuator_copyProperty_body(self, source)

    def append_body(self, value):
        r"""
        append_body(PointActuator self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.PointActuator_append_body(self, value)

    def constructProperty_body(self, *args):
        r"""
        constructProperty_body(PointActuator self)
        constructProperty_body(PointActuator self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.PointActuator_constructProperty_body(self, *args)

    def get_body(self, *args):
        r"""
        get_body(PointActuator self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_body(PointActuator self) -> std::string const &
        """
        return _actuators.PointActuator_get_body(self, *args)

    def upd_body(self, *args):
        r"""
        upd_body(PointActuator self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_body(PointActuator self) -> std::string &
        """
        return _actuators.PointActuator_upd_body(self, *args)

    def set_body(self, *args):
        r"""
        set_body(PointActuator self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_body(PointActuator self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.PointActuator_set_body(self, *args)

    def copyProperty_point(self, source):
        r"""
        copyProperty_point(PointActuator self, PointActuator source)

        Parameters
        ----------
        source: OpenSim::PointActuator::Self const &

        """
        return _actuators.PointActuator_copyProperty_point(self, source)

    def append_point(self, value):
        r"""
        append_point(PointActuator self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.PointActuator_append_point(self, value)

    def constructProperty_point(self, initValue):
        r"""
        constructProperty_point(PointActuator self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _actuators.PointActuator_constructProperty_point(self, initValue)

    def get_point(self, *args):
        r"""
        get_point(PointActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_point(PointActuator self) -> Vec3
        """
        return _actuators.PointActuator_get_point(self, *args)

    def upd_point(self, *args):
        r"""
        upd_point(PointActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_point(PointActuator self) -> Vec3
        """
        return _actuators.PointActuator_upd_point(self, *args)

    def set_point(self, *args):
        r"""
        set_point(PointActuator self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_point(PointActuator self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.PointActuator_set_point(self, *args)

    def copyProperty_point_is_global(self, source):
        r""" The default is point_is_global=false. *"""
        return _actuators.PointActuator_copyProperty_point_is_global(self, source)

    def append_point_is_global(self, value):
        r"""
        append_point_is_global(PointActuator self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.PointActuator_append_point_is_global(self, value)

    def constructProperty_point_is_global(self, initValue):
        r"""
        constructProperty_point_is_global(PointActuator self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _actuators.PointActuator_constructProperty_point_is_global(self, initValue)

    def get_point_is_global(self, *args):
        r"""
        get_point_is_global(PointActuator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_point_is_global(PointActuator self) -> bool const &
        """
        return _actuators.PointActuator_get_point_is_global(self, *args)

    def upd_point_is_global(self, *args):
        r"""
        upd_point_is_global(PointActuator self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_point_is_global(PointActuator self) -> bool &
        """
        return _actuators.PointActuator_upd_point_is_global(self, *args)

    def set_point_is_global(self, *args):
        r"""
        set_point_is_global(PointActuator self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_point_is_global(PointActuator self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.PointActuator_set_point_is_global(self, *args)

    def copyProperty_direction(self, source):
        r"""
        copyProperty_direction(PointActuator self, PointActuator source)

        Parameters
        ----------
        source: OpenSim::PointActuator::Self const &

        """
        return _actuators.PointActuator_copyProperty_direction(self, source)

    def append_direction(self, value):
        r"""
        append_direction(PointActuator self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.PointActuator_append_direction(self, value)

    def constructProperty_direction(self, initValue):
        r"""
        constructProperty_direction(PointActuator self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _actuators.PointActuator_constructProperty_direction(self, initValue)

    def get_direction(self, *args):
        r"""
        get_direction(PointActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_direction(PointActuator self) -> Vec3
        """
        return _actuators.PointActuator_get_direction(self, *args)

    def upd_direction(self, *args):
        r"""
        upd_direction(PointActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_direction(PointActuator self) -> Vec3
        """
        return _actuators.PointActuator_upd_direction(self, *args)

    def set_direction(self, *args):
        r"""
        set_direction(PointActuator self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_direction(PointActuator self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.PointActuator_set_direction(self, *args)

    def copyProperty_force_is_global(self, source):
        r""" The default is force_is_global=false. *"""
        return _actuators.PointActuator_copyProperty_force_is_global(self, source)

    def append_force_is_global(self, value):
        r"""
        append_force_is_global(PointActuator self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.PointActuator_append_force_is_global(self, value)

    def constructProperty_force_is_global(self, initValue):
        r"""
        constructProperty_force_is_global(PointActuator self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _actuators.PointActuator_constructProperty_force_is_global(self, initValue)

    def get_force_is_global(self, *args):
        r"""
        get_force_is_global(PointActuator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_force_is_global(PointActuator self) -> bool const &
        """
        return _actuators.PointActuator_get_force_is_global(self, *args)

    def upd_force_is_global(self, *args):
        r"""
        upd_force_is_global(PointActuator self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_force_is_global(PointActuator self) -> bool &
        """
        return _actuators.PointActuator_upd_force_is_global(self, *args)

    def set_force_is_global(self, *args):
        r"""
        set_force_is_global(PointActuator self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_force_is_global(PointActuator self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.PointActuator_set_force_is_global(self, *args)

    def copyProperty_optimal_force(self, source):
        r"""
        copyProperty_optimal_force(PointActuator self, PointActuator source)

        Parameters
        ----------
        source: OpenSim::PointActuator::Self const &

        """
        return _actuators.PointActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value):
        r"""
        append_optimal_force(PointActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.PointActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue):
        r"""
        constructProperty_optimal_force(PointActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.PointActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args):
        r"""
        get_optimal_force(PointActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_force(PointActuator self) -> double const &
        """
        return _actuators.PointActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args):
        r"""
        upd_optimal_force(PointActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_optimal_force(PointActuator self) -> double &
        """
        return _actuators.PointActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args):
        r"""
        set_optimal_force(PointActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_optimal_force(PointActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.PointActuator_set_optimal_force(self, *args)

    def __init__(self, *args):
        r"""
        Default constructor or construct with body name given. An empty
           name ("") is treated as though it were unspecified. *
        """
        _actuators.PointActuator_swiginit(self, _actuators.new_PointActuator(*args))

    def setOptimalForce(self, aOptimalForce):
        r""" %Set the 'optimal_force' property. *"""
        return _actuators.PointActuator_setOptimalForce(self, aOptimalForce)

    def getOptimalForce(self):
        r""" Get the current value of the 'optimal_force' property. *"""
        return _actuators.PointActuator_getOptimalForce(self)
    __swig_destroy__ = _actuators.delete_PointActuator

# Register PointActuator in _actuators:
_actuators.PointActuator_swigregister(PointActuator)
class TorqueActuator(opensim.simulation.ScalarActuator):
    r"""
    A TorqueActuator applies equal and opposite torques on the two bodies
    (bodyA and B) that it connects. The torque is applied about an axis
    specified in ground (global) by default, otherwise it is in bodyA's frame.
    The magnitude of the torque is equal to the product of the optimal_force of
    the actuator and its control signal.

    Author: Ajay Seth, Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> TorqueActuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.TorqueActuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(TorqueActuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.TorqueActuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.TorqueActuator_getClassName()

    def clone(self):
        r"""clone(TorqueActuator self) -> TorqueActuator"""
        return _actuators.TorqueActuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(TorqueActuator self) -> std::string const &"""
        return _actuators.TorqueActuator_getConcreteClassName(self)

    def copyProperty_bodyA(self, source):
        r"""
        copyProperty_bodyA(TorqueActuator self, TorqueActuator source)

        Parameters
        ----------
        source: OpenSim::TorqueActuator::Self const &

        """
        return _actuators.TorqueActuator_copyProperty_bodyA(self, source)

    def append_bodyA(self, value):
        r"""
        append_bodyA(TorqueActuator self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.TorqueActuator_append_bodyA(self, value)

    def constructProperty_bodyA(self, *args):
        r"""
        constructProperty_bodyA(TorqueActuator self)
        constructProperty_bodyA(TorqueActuator self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.TorqueActuator_constructProperty_bodyA(self, *args)

    def get_bodyA(self, *args):
        r"""
        get_bodyA(TorqueActuator self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_bodyA(TorqueActuator self) -> std::string const &
        """
        return _actuators.TorqueActuator_get_bodyA(self, *args)

    def upd_bodyA(self, *args):
        r"""
        upd_bodyA(TorqueActuator self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_bodyA(TorqueActuator self) -> std::string &
        """
        return _actuators.TorqueActuator_upd_bodyA(self, *args)

    def set_bodyA(self, *args):
        r"""
        set_bodyA(TorqueActuator self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_bodyA(TorqueActuator self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.TorqueActuator_set_bodyA(self, *args)

    def copyProperty_bodyB(self, source):
        r"""
        copyProperty_bodyB(TorqueActuator self, TorqueActuator source)

        Parameters
        ----------
        source: OpenSim::TorqueActuator::Self const &

        """
        return _actuators.TorqueActuator_copyProperty_bodyB(self, source)

    def append_bodyB(self, value):
        r"""
        append_bodyB(TorqueActuator self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.TorqueActuator_append_bodyB(self, value)

    def constructProperty_bodyB(self, *args):
        r"""
        constructProperty_bodyB(TorqueActuator self)
        constructProperty_bodyB(TorqueActuator self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.TorqueActuator_constructProperty_bodyB(self, *args)

    def get_bodyB(self, *args):
        r"""
        get_bodyB(TorqueActuator self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_bodyB(TorqueActuator self) -> std::string const &
        """
        return _actuators.TorqueActuator_get_bodyB(self, *args)

    def upd_bodyB(self, *args):
        r"""
        upd_bodyB(TorqueActuator self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_bodyB(TorqueActuator self) -> std::string &
        """
        return _actuators.TorqueActuator_upd_bodyB(self, *args)

    def set_bodyB(self, *args):
        r"""
        set_bodyB(TorqueActuator self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_bodyB(TorqueActuator self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.TorqueActuator_set_bodyB(self, *args)

    def copyProperty_torque_is_global(self, source):
        r""" The default is torque_is_global=true. *"""
        return _actuators.TorqueActuator_copyProperty_torque_is_global(self, source)

    def append_torque_is_global(self, value):
        r"""
        append_torque_is_global(TorqueActuator self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.TorqueActuator_append_torque_is_global(self, value)

    def constructProperty_torque_is_global(self, initValue):
        r"""
        constructProperty_torque_is_global(TorqueActuator self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _actuators.TorqueActuator_constructProperty_torque_is_global(self, initValue)

    def get_torque_is_global(self, *args):
        r"""
        get_torque_is_global(TorqueActuator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_torque_is_global(TorqueActuator self) -> bool const &
        """
        return _actuators.TorqueActuator_get_torque_is_global(self, *args)

    def upd_torque_is_global(self, *args):
        r"""
        upd_torque_is_global(TorqueActuator self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_torque_is_global(TorqueActuator self) -> bool &
        """
        return _actuators.TorqueActuator_upd_torque_is_global(self, *args)

    def set_torque_is_global(self, *args):
        r"""
        set_torque_is_global(TorqueActuator self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_torque_is_global(TorqueActuator self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.TorqueActuator_set_torque_is_global(self, *args)

    def copyProperty_axis(self, source):
        r""" The default direction for the axis is z (0,0,1). *"""
        return _actuators.TorqueActuator_copyProperty_axis(self, source)

    def append_axis(self, value):
        r"""
        append_axis(TorqueActuator self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.TorqueActuator_append_axis(self, value)

    def constructProperty_axis(self, initValue):
        r"""
        constructProperty_axis(TorqueActuator self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _actuators.TorqueActuator_constructProperty_axis(self, initValue)

    def get_axis(self, *args):
        r"""
        get_axis(TorqueActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_axis(TorqueActuator self) -> Vec3
        """
        return _actuators.TorqueActuator_get_axis(self, *args)

    def upd_axis(self, *args):
        r"""
        upd_axis(TorqueActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_axis(TorqueActuator self) -> Vec3
        """
        return _actuators.TorqueActuator_upd_axis(self, *args)

    def set_axis(self, *args):
        r"""
        set_axis(TorqueActuator self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_axis(TorqueActuator self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.TorqueActuator_set_axis(self, *args)

    def copyProperty_optimal_force(self, source):
        r""" The default for optimal force is 1. *"""
        return _actuators.TorqueActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value):
        r"""
        append_optimal_force(TorqueActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.TorqueActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue):
        r"""
        constructProperty_optimal_force(TorqueActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.TorqueActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args):
        r"""
        get_optimal_force(TorqueActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_force(TorqueActuator self) -> double const &
        """
        return _actuators.TorqueActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args):
        r"""
        upd_optimal_force(TorqueActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_optimal_force(TorqueActuator self) -> double &
        """
        return _actuators.TorqueActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args):
        r"""
        set_optimal_force(TorqueActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_optimal_force(TorqueActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.TorqueActuator_set_optimal_force(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor leaves body names unspecified. *

        |

        *Overload 2:*
        Convenience Constructor.
            Create a torque actuator that applies equal and opposite torques
            on the two bodies (bodyA and B) that it connects. The torque is applied
            about an axis specified in ground if axisInGround is true, otherwise
            it is specified in bodyA's body frame.

            :type bodyA: :py:class:`PhysicalFrame`
            :param bodyA:   the body that the actuator applies torque to
            :type bodyB: :py:class:`PhysicalFrame`
            :param bodyB:   the body that the actuator applies the opposite torque to
            :type axis: :py:class:`Vec3`
            :param axis:    the axis about which the torque is applied
            :type axisInGround: boolean, optional
            :param axisInGround: flag to indicate the axis is expressed in ground
                                      otherwise, it is expressed in bodyA's frame

        |

        *Overload 3:*
        Convenience Constructor.
            Create a torque actuator that applies equal and opposite torques
            on the two bodies (bodyA and B) that it connects. The torque is applied
            about an axis specified in ground if axisInGround is true, otherwise
            it is specified in bodyA's body frame.

            :type bodyA: :py:class:`PhysicalFrame`
            :param bodyA:   the body that the actuator applies torque to
            :type bodyB: :py:class:`PhysicalFrame`
            :param bodyB:   the body that the actuator applies the opposite torque to
            :type axis: :py:class:`Vec3`
            :param axis:    the axis about which the torque is applied
            :param axisInGround: flag to indicate the axis is expressed in ground
                                      otherwise, it is expressed in bodyA's frame
        """
        _actuators.TorqueActuator_swiginit(self, _actuators.new_TorqueActuator(*args))

    def setAxis(self, axis):
        r"""
        %Set the 'axis' property to the supplied value; frame is interpreted
           according to the 'torque_is_global' property. *
        """
        return _actuators.TorqueActuator_setAxis(self, axis)

    def getAxis(self):
        r""" Return the current value of the 'axis' property. *"""
        return _actuators.TorqueActuator_getAxis(self)

    def setTorqueIsGlobal(self, isGlobal):
        r"""
        %Set the 'torque_is_global' property that determines how to interpret
           the 'axis' vector; if not global (Ground frame) it is in body A's frame. *
        """
        return _actuators.TorqueActuator_setTorqueIsGlobal(self, isGlobal)

    def getTorqueIsGlobal(self):
        r""" Return the current value of the 'torque_is_global' property. *"""
        return _actuators.TorqueActuator_getTorqueIsGlobal(self)

    def setOptimalForce(self, optimalForce):
        r""" %Set the 'optimal_force' property. *"""
        return _actuators.TorqueActuator_setOptimalForce(self, optimalForce)

    def getOptimalForce(self):
        r""" Get the current value of the 'optimal_force' property. *"""
        return _actuators.TorqueActuator_getOptimalForce(self)

    def setBodyA(self, body):
        r""" %Set the first body (bodyA) to which this actuator applies torque."""
        return _actuators.TorqueActuator_setBodyA(self, body)

    def setBodyB(self, body):
        r""" %Set the second body (bodyB) to which this actuator applies torque."""
        return _actuators.TorqueActuator_setBodyB(self, body)

    def getBodyA(self):
        r""" Get the first body (bodyA) to which this actuator applies torque."""
        return _actuators.TorqueActuator_getBodyA(self)

    def getBodyB(self):
        r""" Get the second body (bodyB) to which this actuator applies torque."""
        return _actuators.TorqueActuator_getBodyB(self)
    __swig_destroy__ = _actuators.delete_TorqueActuator

# Register TorqueActuator in _actuators:
_actuators.TorqueActuator_swigregister(TorqueActuator)
class BodyActuator(opensim.simulation.Actuator):
    r"""
    Apply a spatial force (that is, [torque, force]) on a given point of the
    given body. That is, the force is applied at the given point; torques don't
    have associated points. This actuator has no states; the control signal
    should provide a 6D vector including [torque(3D), force(3D)] that is supposed
    to be applied to the body.
    The associated controller can generate the spatial force [torque, force] both
    in the body and global (ground) frame. The default is assumed to be global
    frame. The point of application can be specified both in the body and global
    (ground) frame. The default is assumed to be the body frame.

    Author: Soha Pouya, Michael Sherman
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> BodyActuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.BodyActuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(BodyActuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.BodyActuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.BodyActuator_getClassName()

    def clone(self):
        r"""clone(BodyActuator self) -> BodyActuator"""
        return _actuators.BodyActuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(BodyActuator self) -> std::string const &"""
        return _actuators.BodyActuator_getConcreteClassName(self)

    def copyProperty_point(self, source):
        r"""
        copyProperty_point(BodyActuator self, BodyActuator source)

        Parameters
        ----------
        source: OpenSim::BodyActuator::Self const &

        """
        return _actuators.BodyActuator_copyProperty_point(self, source)

    def append_point(self, value):
        r"""
        append_point(BodyActuator self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.BodyActuator_append_point(self, value)

    def constructProperty_point(self, initValue):
        r"""
        constructProperty_point(BodyActuator self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _actuators.BodyActuator_constructProperty_point(self, initValue)

    def get_point(self, *args):
        r"""
        get_point(BodyActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_point(BodyActuator self) -> Vec3
        """
        return _actuators.BodyActuator_get_point(self, *args)

    def upd_point(self, *args):
        r"""
        upd_point(BodyActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_point(BodyActuator self) -> Vec3
        """
        return _actuators.BodyActuator_upd_point(self, *args)

    def set_point(self, *args):
        r"""
        set_point(BodyActuator self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_point(BodyActuator self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.BodyActuator_set_point(self, *args)

    def copyProperty_point_is_global(self, source):
        r""" The default is point_is_global=false. *"""
        return _actuators.BodyActuator_copyProperty_point_is_global(self, source)

    def append_point_is_global(self, value):
        r"""
        append_point_is_global(BodyActuator self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.BodyActuator_append_point_is_global(self, value)

    def constructProperty_point_is_global(self, initValue):
        r"""
        constructProperty_point_is_global(BodyActuator self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _actuators.BodyActuator_constructProperty_point_is_global(self, initValue)

    def get_point_is_global(self, *args):
        r"""
        get_point_is_global(BodyActuator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_point_is_global(BodyActuator self) -> bool const &
        """
        return _actuators.BodyActuator_get_point_is_global(self, *args)

    def upd_point_is_global(self, *args):
        r"""
        upd_point_is_global(BodyActuator self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_point_is_global(BodyActuator self) -> bool &
        """
        return _actuators.BodyActuator_upd_point_is_global(self, *args)

    def set_point_is_global(self, *args):
        r"""
        set_point_is_global(BodyActuator self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_point_is_global(BodyActuator self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.BodyActuator_set_point_is_global(self, *args)

    def copyProperty_spatial_force_is_global(self, source):
        r""" The default is spatial_force_is_global=true. *"""
        return _actuators.BodyActuator_copyProperty_spatial_force_is_global(self, source)

    def append_spatial_force_is_global(self, value):
        r"""
        append_spatial_force_is_global(BodyActuator self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.BodyActuator_append_spatial_force_is_global(self, value)

    def constructProperty_spatial_force_is_global(self, initValue):
        r"""
        constructProperty_spatial_force_is_global(BodyActuator self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _actuators.BodyActuator_constructProperty_spatial_force_is_global(self, initValue)

    def get_spatial_force_is_global(self, *args):
        r"""
        get_spatial_force_is_global(BodyActuator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_spatial_force_is_global(BodyActuator self) -> bool const &
        """
        return _actuators.BodyActuator_get_spatial_force_is_global(self, *args)

    def upd_spatial_force_is_global(self, *args):
        r"""
        upd_spatial_force_is_global(BodyActuator self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_spatial_force_is_global(BodyActuator self) -> bool &
        """
        return _actuators.BodyActuator_upd_spatial_force_is_global(self, *args)

    def set_spatial_force_is_global(self, *args):
        r"""
        set_spatial_force_is_global(BodyActuator self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_spatial_force_is_global(BodyActuator self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.BodyActuator_set_spatial_force_is_global(self, *args)
    PropertyIndex_socket_body = property(_actuators.BodyActuator_PropertyIndex_socket_body_get, _actuators.BodyActuator_PropertyIndex_socket_body_set, doc=r"""PropertyIndex_socket_body : OpenSim::PropertyIndex""")

    def connectSocket_body(self, object):
        r"""
        connectSocket_body(BodyActuator self, OpenSimObject object)

        Parameters
        ----------
        object: OpenSim::Object const &

        """
        return _actuators.BodyActuator_connectSocket_body(self, object)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor leaves body names unspecified. *

        |

        *Overload 2:*
        Convenience Constructor.
           Create a body actuator that applies a vector of spatial forces in the form
           of [torque, force] on a body. The torque is applied about the axis specified
           in ground frame.

           :type body: :py:class:`Body`, in
           :param body:                 the body that the actuator applies torque to
           :type point: :py:class:`Vec3`, in, optional
           :param point:                the point that the force is applied to
           :type pointIsGlobal: boolean, in, optional
           :param pointIsGlobal:        a flag to set if the point is in global frame
           :type spatialForceIsGlobal: boolean, in, optional
           :param spatialForceIsGlobal: a flag to set if the force is in global frame

        |

        *Overload 3:*
        Convenience Constructor.
           Create a body actuator that applies a vector of spatial forces in the form
           of [torque, force] on a body. The torque is applied about the axis specified
           in ground frame.

           :type body: :py:class:`Body`, in
           :param body:                 the body that the actuator applies torque to
           :type point: :py:class:`Vec3`, in, optional
           :param point:                the point that the force is applied to
           :type pointIsGlobal: boolean, in, optional
           :param pointIsGlobal:        a flag to set if the point is in global frame
           :param spatialForceIsGlobal: a flag to set if the force is in global frame

        |

        *Overload 4:*
        Convenience Constructor.
           Create a body actuator that applies a vector of spatial forces in the form
           of [torque, force] on a body. The torque is applied about the axis specified
           in ground frame.

           :type body: :py:class:`Body`, in
           :param body:                 the body that the actuator applies torque to
           :type point: :py:class:`Vec3`, in, optional
           :param point:                the point that the force is applied to
           :param pointIsGlobal:        a flag to set if the point is in global frame
           :param spatialForceIsGlobal: a flag to set if the force is in global frame

        |

        *Overload 5:*
        Convenience Constructor.
           Create a body actuator that applies a vector of spatial forces in the form
           of [torque, force] on a body. The torque is applied about the axis specified
           in ground frame.

           :type body: :py:class:`Body`, in
           :param body:                 the body that the actuator applies torque to
           :param point:                the point that the force is applied to
           :param pointIsGlobal:        a flag to set if the point is in global frame
           :param spatialForceIsGlobal: a flag to set if the force is in global frame
        """
        _actuators.BodyActuator_swiginit(self, _actuators.new_BodyActuator(*args))

    def setPoint(self, point):
        r"""
        %Set the 'point' property that determines where the force vector should
           be applied. The default is the origin of the body Vec3(0). *
        """
        return _actuators.BodyActuator_setPoint(self, point)

    def getPoint(self):
        r""" Return the current value of the 'point' property. *"""
        return _actuators.BodyActuator_getPoint(self)

    def setPointForceIsGlobal(self, isGlobal):
        r"""
        %Set the 'point_is_global' property that determines whether the point is
           specified in inertial coordinates or in the body's local coordinates. *
        """
        return _actuators.BodyActuator_setPointForceIsGlobal(self, isGlobal)

    def getPointIsGlobal(self):
        r""" Return the current value of the 'point_is_global' property. *"""
        return _actuators.BodyActuator_getPointIsGlobal(self)

    def setSpatialForceIsGlobal(self, isGlobal):
        r"""
        %Set the 'spatial_force_is_global' property that determines how to
           interpret the 'axis' vector; if not global (Ground frame) it is in body's
           frame. *
        """
        return _actuators.BodyActuator_setSpatialForceIsGlobal(self, isGlobal)

    def getSpatialForceIsGlobal(self):
        r""" Return the current value of the 'spatial_force_is_global' property. *"""
        return _actuators.BodyActuator_getSpatialForceIsGlobal(self)

    def setBody(self, body):
        r"""
        setBody(BodyActuator self, Body body)

        Parameters
        ----------
        body: OpenSim::Body const &

        """
        return _actuators.BodyActuator_setBody(self, body)

    def getBody(self):
        r"""getBody(BodyActuator self) -> Body"""
        return _actuators.BodyActuator_getBody(self)

    def setBodyName(self, name):
        r"""
        setBodyName(BodyActuator self, std::string const & name)

        Parameters
        ----------
        name: std::string const &

        """
        return _actuators.BodyActuator_setBodyName(self, name)

    def getBodyName(self):
        r"""getBodyName(BodyActuator self) -> std::string const &"""
        return _actuators.BodyActuator_getBodyName(self)
    __swig_destroy__ = _actuators.delete_BodyActuator

# Register BodyActuator in _actuators:
_actuators.BodyActuator_swigregister(BodyActuator)
class PointToPointActuator(opensim.simulation.ScalarActuator):
    r"""
    A class that implements a force actuator acting between two points on two bodies.
    The direction of the force is along the line between the points, with a positive
    value acting to expand the distance between them.  This actuator has no states;
    the control is simply the force to be applied to the model.

    Author: Matt DeMers
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PointToPointActuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.PointToPointActuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PointToPointActuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.PointToPointActuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.PointToPointActuator_getClassName()

    def clone(self):
        r"""clone(PointToPointActuator self) -> PointToPointActuator"""
        return _actuators.PointToPointActuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PointToPointActuator self) -> std::string const &"""
        return _actuators.PointToPointActuator_getConcreteClassName(self)

    def copyProperty_bodyA(self, source):
        r"""
        copyProperty_bodyA(PointToPointActuator self, PointToPointActuator source)

        Parameters
        ----------
        source: OpenSim::PointToPointActuator::Self const &

        """
        return _actuators.PointToPointActuator_copyProperty_bodyA(self, source)

    def append_bodyA(self, value):
        r"""
        append_bodyA(PointToPointActuator self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.PointToPointActuator_append_bodyA(self, value)

    def constructProperty_bodyA(self, *args):
        r"""
        constructProperty_bodyA(PointToPointActuator self)
        constructProperty_bodyA(PointToPointActuator self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.PointToPointActuator_constructProperty_bodyA(self, *args)

    def get_bodyA(self, *args):
        r"""
        get_bodyA(PointToPointActuator self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_bodyA(PointToPointActuator self) -> std::string const &
        """
        return _actuators.PointToPointActuator_get_bodyA(self, *args)

    def upd_bodyA(self, *args):
        r"""
        upd_bodyA(PointToPointActuator self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_bodyA(PointToPointActuator self) -> std::string &
        """
        return _actuators.PointToPointActuator_upd_bodyA(self, *args)

    def set_bodyA(self, *args):
        r"""
        set_bodyA(PointToPointActuator self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_bodyA(PointToPointActuator self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.PointToPointActuator_set_bodyA(self, *args)

    def copyProperty_bodyB(self, source):
        r"""
        copyProperty_bodyB(PointToPointActuator self, PointToPointActuator source)

        Parameters
        ----------
        source: OpenSim::PointToPointActuator::Self const &

        """
        return _actuators.PointToPointActuator_copyProperty_bodyB(self, source)

    def append_bodyB(self, value):
        r"""
        append_bodyB(PointToPointActuator self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.PointToPointActuator_append_bodyB(self, value)

    def constructProperty_bodyB(self, *args):
        r"""
        constructProperty_bodyB(PointToPointActuator self)
        constructProperty_bodyB(PointToPointActuator self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.PointToPointActuator_constructProperty_bodyB(self, *args)

    def get_bodyB(self, *args):
        r"""
        get_bodyB(PointToPointActuator self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_bodyB(PointToPointActuator self) -> std::string const &
        """
        return _actuators.PointToPointActuator_get_bodyB(self, *args)

    def upd_bodyB(self, *args):
        r"""
        upd_bodyB(PointToPointActuator self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_bodyB(PointToPointActuator self) -> std::string &
        """
        return _actuators.PointToPointActuator_upd_bodyB(self, *args)

    def set_bodyB(self, *args):
        r"""
        set_bodyB(PointToPointActuator self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_bodyB(PointToPointActuator self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.PointToPointActuator_set_bodyB(self, *args)

    def copyProperty_points_are_global(self, source):
        r""" The default is points_are_global=false. *"""
        return _actuators.PointToPointActuator_copyProperty_points_are_global(self, source)

    def append_points_are_global(self, value):
        r"""
        append_points_are_global(PointToPointActuator self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.PointToPointActuator_append_points_are_global(self, value)

    def constructProperty_points_are_global(self, initValue):
        r"""
        constructProperty_points_are_global(PointToPointActuator self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _actuators.PointToPointActuator_constructProperty_points_are_global(self, initValue)

    def get_points_are_global(self, *args):
        r"""
        get_points_are_global(PointToPointActuator self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_points_are_global(PointToPointActuator self) -> bool const &
        """
        return _actuators.PointToPointActuator_get_points_are_global(self, *args)

    def upd_points_are_global(self, *args):
        r"""
        upd_points_are_global(PointToPointActuator self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_points_are_global(PointToPointActuator self) -> bool &
        """
        return _actuators.PointToPointActuator_upd_points_are_global(self, *args)

    def set_points_are_global(self, *args):
        r"""
        set_points_are_global(PointToPointActuator self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_points_are_global(PointToPointActuator self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.PointToPointActuator_set_points_are_global(self, *args)

    def copyProperty_pointA(self, source):
        r""" The default location for pointA is bodyA's origin. *"""
        return _actuators.PointToPointActuator_copyProperty_pointA(self, source)

    def append_pointA(self, value):
        r"""
        append_pointA(PointToPointActuator self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.PointToPointActuator_append_pointA(self, value)

    def constructProperty_pointA(self, initValue):
        r"""
        constructProperty_pointA(PointToPointActuator self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _actuators.PointToPointActuator_constructProperty_pointA(self, initValue)

    def get_pointA(self, *args):
        r"""
        get_pointA(PointToPointActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_pointA(PointToPointActuator self) -> Vec3
        """
        return _actuators.PointToPointActuator_get_pointA(self, *args)

    def upd_pointA(self, *args):
        r"""
        upd_pointA(PointToPointActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_pointA(PointToPointActuator self) -> Vec3
        """
        return _actuators.PointToPointActuator_upd_pointA(self, *args)

    def set_pointA(self, *args):
        r"""
        set_pointA(PointToPointActuator self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_pointA(PointToPointActuator self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.PointToPointActuator_set_pointA(self, *args)

    def copyProperty_pointB(self, source):
        r""" The default location for pointB is bodyB's origin. *"""
        return _actuators.PointToPointActuator_copyProperty_pointB(self, source)

    def append_pointB(self, value):
        r"""
        append_pointB(PointToPointActuator self, Vec3 value) -> int

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.PointToPointActuator_append_pointB(self, value)

    def constructProperty_pointB(self, initValue):
        r"""
        constructProperty_pointB(PointToPointActuator self, Vec3 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec3 const &

        """
        return _actuators.PointToPointActuator_constructProperty_pointB(self, initValue)

    def get_pointB(self, *args):
        r"""
        get_pointB(PointToPointActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        get_pointB(PointToPointActuator self) -> Vec3
        """
        return _actuators.PointToPointActuator_get_pointB(self, *args)

    def upd_pointB(self, *args):
        r"""
        upd_pointB(PointToPointActuator self, int i) -> Vec3

        Parameters
        ----------
        i: int

        upd_pointB(PointToPointActuator self) -> Vec3
        """
        return _actuators.PointToPointActuator_upd_pointB(self, *args)

    def set_pointB(self, *args):
        r"""
        set_pointB(PointToPointActuator self, int i, Vec3 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec3 const &

        set_pointB(PointToPointActuator self, Vec3 value)

        Parameters
        ----------
        value: SimTK::Vec3 const &

        """
        return _actuators.PointToPointActuator_set_pointB(self, *args)

    def copyProperty_optimal_force(self, source):
        r""" The default for optimal force is 1. *"""
        return _actuators.PointToPointActuator_copyProperty_optimal_force(self, source)

    def append_optimal_force(self, value):
        r"""
        append_optimal_force(PointToPointActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.PointToPointActuator_append_optimal_force(self, value)

    def constructProperty_optimal_force(self, initValue):
        r"""
        constructProperty_optimal_force(PointToPointActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.PointToPointActuator_constructProperty_optimal_force(self, initValue)

    def get_optimal_force(self, *args):
        r"""
        get_optimal_force(PointToPointActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_optimal_force(PointToPointActuator self) -> double const &
        """
        return _actuators.PointToPointActuator_get_optimal_force(self, *args)

    def upd_optimal_force(self, *args):
        r"""
        upd_optimal_force(PointToPointActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_optimal_force(PointToPointActuator self) -> double &
        """
        return _actuators.PointToPointActuator_upd_optimal_force(self, *args)

    def set_optimal_force(self, *args):
        r"""
        set_optimal_force(PointToPointActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_optimal_force(PointToPointActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.PointToPointActuator_set_optimal_force(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor leaves body names unspecified. *

        |

        *Overload 2:*
        Construct with specified body names. *
        """
        _actuators.PointToPointActuator_swiginit(self, _actuators.new_PointToPointActuator(*args))

    def setPointA(self, pointAPos):
        r"""
        %Set the 'pointA' property to the supplied value; frame is interpreted
           according to the 'points_are_global' property. *
        """
        return _actuators.PointToPointActuator_setPointA(self, pointAPos)

    def getPointA(self):
        r""" Return the current value of the 'pointA' property. *"""
        return _actuators.PointToPointActuator_getPointA(self)

    def setPointB(self, pointBPos):
        r"""
        %Set the 'pointB' property to the supplied value; frame is interpreted
           according to the 'points_are_global' property. *
        """
        return _actuators.PointToPointActuator_setPointB(self, pointBPos)

    def getPointB(self):
        r""" Return the current value of the 'pointB' property. *"""
        return _actuators.PointToPointActuator_getPointB(self)

    def setPointsAreGlobal(self, isGlobal):
        r"""
        %Set the 'points_are_global' property that determines how to interpret
           the 'pointA' and 'pointB' location vectors: if not global (Ground frame)
           then they are in the local frame of 'bodyA' and 'bodyB' respectively. *
        """
        return _actuators.PointToPointActuator_setPointsAreGlobal(self, isGlobal)

    def getPointsAreGlobal(self):
        r""" Return the current value of the 'points_are_global' property. *"""
        return _actuators.PointToPointActuator_getPointsAreGlobal(self)

    def setOptimalForce(self, optimalForce):
        r""" %Set the 'optimal_force' property. *"""
        return _actuators.PointToPointActuator_setOptimalForce(self, optimalForce)

    def getOptimalForce(self):
        r""" Get the current value of the 'optimal_force' property. *"""
        return _actuators.PointToPointActuator_getOptimalForce(self)
    __swig_destroy__ = _actuators.delete_PointToPointActuator

# Register PointToPointActuator in _actuators:
_actuators.PointToPointActuator_swigregister(PointToPointActuator)
class ClutchedPathSpring(opensim.simulation.PathActuator):
    r"""
    The ClutchedPathSpring is an actuator that has passive path spring behavior
    only when the clutch is engaged. The clutch is engaged by a control signal
    of 1 and is off for a control signal of 0. Off means the spring is not
    engaged and the path is free to change length with the motion of the bodies
    it is connected to. The tension produced by the spring is proportional
    to the stretch (z) from the instant that the clutch is engaged.

    The spring tension = x*(K*z)*(1+D*Ldot), where
         - x is the control signal to the actuator
         - z is the stretch in the spring
         - Ldot is the lengthening speed of the actuator
         - K is the spring's linear stiffness (N/m)
         - D is the spring's dissipation factor

    The ClutchedPathSpring maintains the "stretch", z, as an internal state with
    the following dynamics:


         |dz/dt = |Ldot, when x>0 (clutch is engaged)|
         || -(1/Tau)*z, (decay to zero), otherwise|


    Note that the control signal, x, is clamped to (0,1).

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ClutchedPathSpring

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ClutchedPathSpring_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ClutchedPathSpring self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ClutchedPathSpring_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ClutchedPathSpring_getClassName()

    def clone(self):
        r"""clone(ClutchedPathSpring self) -> ClutchedPathSpring"""
        return _actuators.ClutchedPathSpring_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ClutchedPathSpring self) -> std::string const &"""
        return _actuators.ClutchedPathSpring_getConcreteClassName(self)

    def copyProperty_stiffness(self, source):
        r"""
        copyProperty_stiffness(ClutchedPathSpring self, ClutchedPathSpring source)

        Parameters
        ----------
        source: OpenSim::ClutchedPathSpring::Self const &

        """
        return _actuators.ClutchedPathSpring_copyProperty_stiffness(self, source)

    def append_stiffness(self, value):
        r"""
        append_stiffness(ClutchedPathSpring self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ClutchedPathSpring_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue):
        r"""
        constructProperty_stiffness(ClutchedPathSpring self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.ClutchedPathSpring_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args):
        r"""
        get_stiffness(ClutchedPathSpring self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness(ClutchedPathSpring self) -> double const &
        """
        return _actuators.ClutchedPathSpring_get_stiffness(self, *args)

    def upd_stiffness(self, *args):
        r"""
        upd_stiffness(ClutchedPathSpring self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness(ClutchedPathSpring self) -> double &
        """
        return _actuators.ClutchedPathSpring_upd_stiffness(self, *args)

    def set_stiffness(self, *args):
        r"""
        set_stiffness(ClutchedPathSpring self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness(ClutchedPathSpring self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ClutchedPathSpring_set_stiffness(self, *args)

    def copyProperty_dissipation(self, source):
        r"""
        copyProperty_dissipation(ClutchedPathSpring self, ClutchedPathSpring source)

        Parameters
        ----------
        source: OpenSim::ClutchedPathSpring::Self const &

        """
        return _actuators.ClutchedPathSpring_copyProperty_dissipation(self, source)

    def append_dissipation(self, value):
        r"""
        append_dissipation(ClutchedPathSpring self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ClutchedPathSpring_append_dissipation(self, value)

    def constructProperty_dissipation(self, initValue):
        r"""
        constructProperty_dissipation(ClutchedPathSpring self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.ClutchedPathSpring_constructProperty_dissipation(self, initValue)

    def get_dissipation(self, *args):
        r"""
        get_dissipation(ClutchedPathSpring self, int i) -> double const

        Parameters
        ----------
        i: int

        get_dissipation(ClutchedPathSpring self) -> double const &
        """
        return _actuators.ClutchedPathSpring_get_dissipation(self, *args)

    def upd_dissipation(self, *args):
        r"""
        upd_dissipation(ClutchedPathSpring self, int i) -> double

        Parameters
        ----------
        i: int

        upd_dissipation(ClutchedPathSpring self) -> double &
        """
        return _actuators.ClutchedPathSpring_upd_dissipation(self, *args)

    def set_dissipation(self, *args):
        r"""
        set_dissipation(ClutchedPathSpring self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_dissipation(ClutchedPathSpring self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ClutchedPathSpring_set_dissipation(self, *args)

    def copyProperty_relaxation_time_constant(self, source):
        r"""
        copyProperty_relaxation_time_constant(ClutchedPathSpring self, ClutchedPathSpring source)

        Parameters
        ----------
        source: OpenSim::ClutchedPathSpring::Self const &

        """
        return _actuators.ClutchedPathSpring_copyProperty_relaxation_time_constant(self, source)

    def append_relaxation_time_constant(self, value):
        r"""
        append_relaxation_time_constant(ClutchedPathSpring self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ClutchedPathSpring_append_relaxation_time_constant(self, value)

    def constructProperty_relaxation_time_constant(self, initValue):
        r"""
        constructProperty_relaxation_time_constant(ClutchedPathSpring self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.ClutchedPathSpring_constructProperty_relaxation_time_constant(self, initValue)

    def get_relaxation_time_constant(self, *args):
        r"""
        get_relaxation_time_constant(ClutchedPathSpring self, int i) -> double const

        Parameters
        ----------
        i: int

        get_relaxation_time_constant(ClutchedPathSpring self) -> double const &
        """
        return _actuators.ClutchedPathSpring_get_relaxation_time_constant(self, *args)

    def upd_relaxation_time_constant(self, *args):
        r"""
        upd_relaxation_time_constant(ClutchedPathSpring self, int i) -> double

        Parameters
        ----------
        i: int

        upd_relaxation_time_constant(ClutchedPathSpring self) -> double &
        """
        return _actuators.ClutchedPathSpring_upd_relaxation_time_constant(self, *args)

    def set_relaxation_time_constant(self, *args):
        r"""
        set_relaxation_time_constant(ClutchedPathSpring self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_relaxation_time_constant(ClutchedPathSpring self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ClutchedPathSpring_set_relaxation_time_constant(self, *args)

    def copyProperty_initial_stretch(self, source):
        r"""
        copyProperty_initial_stretch(ClutchedPathSpring self, ClutchedPathSpring source)

        Parameters
        ----------
        source: OpenSim::ClutchedPathSpring::Self const &

        """
        return _actuators.ClutchedPathSpring_copyProperty_initial_stretch(self, source)

    def append_initial_stretch(self, value):
        r"""
        append_initial_stretch(ClutchedPathSpring self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ClutchedPathSpring_append_initial_stretch(self, value)

    def constructProperty_initial_stretch(self, initValue):
        r"""
        constructProperty_initial_stretch(ClutchedPathSpring self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.ClutchedPathSpring_constructProperty_initial_stretch(self, initValue)

    def get_initial_stretch(self, *args):
        r"""
        get_initial_stretch(ClutchedPathSpring self, int i) -> double const

        Parameters
        ----------
        i: int

        get_initial_stretch(ClutchedPathSpring self) -> double const &
        """
        return _actuators.ClutchedPathSpring_get_initial_stretch(self, *args)

    def upd_initial_stretch(self, *args):
        r"""
        upd_initial_stretch(ClutchedPathSpring self, int i) -> double

        Parameters
        ----------
        i: int

        upd_initial_stretch(ClutchedPathSpring self) -> double &
        """
        return _actuators.ClutchedPathSpring_upd_initial_stretch(self, *args)

    def set_initial_stretch(self, *args):
        r"""
        set_initial_stretch(ClutchedPathSpring self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_initial_stretch(ClutchedPathSpring self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.ClutchedPathSpring_set_initial_stretch(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Construct a ClutchedPathSpring with default parameters. Users should
                note that the default values for stiffness and dissipation are `NaN`
                so they must be set before simulating.

        |

        *Overload 2:*
         Convenience constructor with ClutchedPathSpring parameters
        :type name: string
        :param name:          the name of a %ClutchedPathSpring instance
        :type stiffness: float
        :param stiffness:     the spring stiffness (K) in N/m
        :type dissipation: float
        :param dissipation:   the dissipation factor (D) in s/m
        :type relaxationTau: float
        :param relaxationTau: the spring relaxation time constant (Tau) in s
        :type stretch0: float, optional
        :param stretch0:      the initial stretch of the spring in m

        |

        *Overload 3:*
         Convenience constructor with ClutchedPathSpring parameters
        :type name: string
        :param name:          the name of a %ClutchedPathSpring instance
        :type stiffness: float
        :param stiffness:     the spring stiffness (K) in N/m
        :type dissipation: float
        :param dissipation:   the dissipation factor (D) in s/m
        :type relaxationTau: float
        :param relaxationTau: the spring relaxation time constant (Tau) in s
        :param stretch0:      the initial stretch of the spring in m
        """
        _actuators.ClutchedPathSpring_swiginit(self, _actuators.new_ClutchedPathSpring(*args))

    def getStiffness(self):
        r""" Spring stiffness in N/m when clutch is engaged."""
        return _actuators.ClutchedPathSpring_getStiffness(self)

    def setStiffness(self, stiffness):
        r"""
        setStiffness(ClutchedPathSpring self, double stiffness)

        Parameters
        ----------
        stiffness: double

        """
        return _actuators.ClutchedPathSpring_setStiffness(self, stiffness)

    def getDissipation(self):
        r""" Spring dissipation factor in s/m when clutch is engaged."""
        return _actuators.ClutchedPathSpring_getDissipation(self)

    def setDissipation(self, dissipation):
        r"""
        setDissipation(ClutchedPathSpring self, double dissipation)

        Parameters
        ----------
        dissipation: double

        """
        return _actuators.ClutchedPathSpring_setDissipation(self, dissipation)

    def getInitialStretch(self):
        r""" Initial spring stretch in m."""
        return _actuators.ClutchedPathSpring_getInitialStretch(self)

    def setInitialStretch(self, stretch0):
        r"""
        setInitialStretch(ClutchedPathSpring self, double stretch0)

        Parameters
        ----------
        stretch0: double

        """
        return _actuators.ClutchedPathSpring_setInitialStretch(self, stretch0)

    def getStretch(self, s):
        r"""
        The stretch in the PathSpring. The value of the stretch
               can only be obtained after the system has been realized to
               Stage::Position
        """
        return _actuators.ClutchedPathSpring_getStretch(self, s)

    def getTension(self, s):
        r"""
        The tension generated by the PathSpring. The value of the tension
               can only be obtained after the system has been realized to
               Stage::Dynamics
        """
        return _actuators.ClutchedPathSpring_getTension(self, s)
    __swig_destroy__ = _actuators.delete_ClutchedPathSpring

# Register ClutchedPathSpring in _actuators:
_actuators.ClutchedPathSpring_swigregister(ClutchedPathSpring)
class SpringGeneralizedForce(opensim.simulation.ForceProducer):
    r"""
    A Force that exerts a generalized force based on spring-like
    characteristics (stiffness and viscosity).

    Author: Frank C. Anderson, Ajay Seth
    Version: 2.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SpringGeneralizedForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.SpringGeneralizedForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SpringGeneralizedForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.SpringGeneralizedForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.SpringGeneralizedForce_getClassName()

    def clone(self):
        r"""clone(SpringGeneralizedForce self) -> SpringGeneralizedForce"""
        return _actuators.SpringGeneralizedForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SpringGeneralizedForce self) -> std::string const &"""
        return _actuators.SpringGeneralizedForce_getConcreteClassName(self)

    def copyProperty_coordinate(self, source):
        r"""
        copyProperty_coordinate(SpringGeneralizedForce self, SpringGeneralizedForce source)

        Parameters
        ----------
        source: OpenSim::SpringGeneralizedForce::Self const &

        """
        return _actuators.SpringGeneralizedForce_copyProperty_coordinate(self, source)

    def append_coordinate(self, value):
        r"""
        append_coordinate(SpringGeneralizedForce self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.SpringGeneralizedForce_append_coordinate(self, value)

    def constructProperty_coordinate(self, *args):
        r"""
        constructProperty_coordinate(SpringGeneralizedForce self)
        constructProperty_coordinate(SpringGeneralizedForce self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.SpringGeneralizedForce_constructProperty_coordinate(self, *args)

    def get_coordinate(self, *args):
        r"""
        get_coordinate(SpringGeneralizedForce self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_coordinate(SpringGeneralizedForce self) -> std::string const &
        """
        return _actuators.SpringGeneralizedForce_get_coordinate(self, *args)

    def upd_coordinate(self, *args):
        r"""
        upd_coordinate(SpringGeneralizedForce self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_coordinate(SpringGeneralizedForce self) -> std::string &
        """
        return _actuators.SpringGeneralizedForce_upd_coordinate(self, *args)

    def set_coordinate(self, *args):
        r"""
        set_coordinate(SpringGeneralizedForce self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_coordinate(SpringGeneralizedForce self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.SpringGeneralizedForce_set_coordinate(self, *args)

    def copyProperty_stiffness(self, source):
        r"""
        copyProperty_stiffness(SpringGeneralizedForce self, SpringGeneralizedForce source)

        Parameters
        ----------
        source: OpenSim::SpringGeneralizedForce::Self const &

        """
        return _actuators.SpringGeneralizedForce_copyProperty_stiffness(self, source)

    def append_stiffness(self, value):
        r"""
        append_stiffness(SpringGeneralizedForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.SpringGeneralizedForce_append_stiffness(self, value)

    def constructProperty_stiffness(self, initValue):
        r"""
        constructProperty_stiffness(SpringGeneralizedForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.SpringGeneralizedForce_constructProperty_stiffness(self, initValue)

    def get_stiffness(self, *args):
        r"""
        get_stiffness(SpringGeneralizedForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_stiffness(SpringGeneralizedForce self) -> double const &
        """
        return _actuators.SpringGeneralizedForce_get_stiffness(self, *args)

    def upd_stiffness(self, *args):
        r"""
        upd_stiffness(SpringGeneralizedForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_stiffness(SpringGeneralizedForce self) -> double &
        """
        return _actuators.SpringGeneralizedForce_upd_stiffness(self, *args)

    def set_stiffness(self, *args):
        r"""
        set_stiffness(SpringGeneralizedForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_stiffness(SpringGeneralizedForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.SpringGeneralizedForce_set_stiffness(self, *args)

    def copyProperty_rest_length(self, source):
        r"""
        copyProperty_rest_length(SpringGeneralizedForce self, SpringGeneralizedForce source)

        Parameters
        ----------
        source: OpenSim::SpringGeneralizedForce::Self const &

        """
        return _actuators.SpringGeneralizedForce_copyProperty_rest_length(self, source)

    def append_rest_length(self, value):
        r"""
        append_rest_length(SpringGeneralizedForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.SpringGeneralizedForce_append_rest_length(self, value)

    def constructProperty_rest_length(self, initValue):
        r"""
        constructProperty_rest_length(SpringGeneralizedForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.SpringGeneralizedForce_constructProperty_rest_length(self, initValue)

    def get_rest_length(self, *args):
        r"""
        get_rest_length(SpringGeneralizedForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_rest_length(SpringGeneralizedForce self) -> double const &
        """
        return _actuators.SpringGeneralizedForce_get_rest_length(self, *args)

    def upd_rest_length(self, *args):
        r"""
        upd_rest_length(SpringGeneralizedForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_rest_length(SpringGeneralizedForce self) -> double &
        """
        return _actuators.SpringGeneralizedForce_upd_rest_length(self, *args)

    def set_rest_length(self, *args):
        r"""
        set_rest_length(SpringGeneralizedForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_rest_length(SpringGeneralizedForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.SpringGeneralizedForce_set_rest_length(self, *args)

    def copyProperty_viscosity(self, source):
        r"""
        copyProperty_viscosity(SpringGeneralizedForce self, SpringGeneralizedForce source)

        Parameters
        ----------
        source: OpenSim::SpringGeneralizedForce::Self const &

        """
        return _actuators.SpringGeneralizedForce_copyProperty_viscosity(self, source)

    def append_viscosity(self, value):
        r"""
        append_viscosity(SpringGeneralizedForce self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.SpringGeneralizedForce_append_viscosity(self, value)

    def constructProperty_viscosity(self, initValue):
        r"""
        constructProperty_viscosity(SpringGeneralizedForce self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.SpringGeneralizedForce_constructProperty_viscosity(self, initValue)

    def get_viscosity(self, *args):
        r"""
        get_viscosity(SpringGeneralizedForce self, int i) -> double const

        Parameters
        ----------
        i: int

        get_viscosity(SpringGeneralizedForce self) -> double const &
        """
        return _actuators.SpringGeneralizedForce_get_viscosity(self, *args)

    def upd_viscosity(self, *args):
        r"""
        upd_viscosity(SpringGeneralizedForce self, int i) -> double

        Parameters
        ----------
        i: int

        upd_viscosity(SpringGeneralizedForce self) -> double &
        """
        return _actuators.SpringGeneralizedForce_upd_viscosity(self, *args)

    def set_viscosity(self, *args):
        r"""
        set_viscosity(SpringGeneralizedForce self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_viscosity(SpringGeneralizedForce self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.SpringGeneralizedForce_set_viscosity(self, *args)

    def __init__(self, *args):
        r"""
        This serves as default constructor or you can specify the coordinate
           name. A name of "" is treated as though unspecified. *
        """
        _actuators.SpringGeneralizedForce_swiginit(self, _actuators.new_SpringGeneralizedForce(*args))

    def setStiffness(self, aStiffness):
        r"""
        setStiffness(SpringGeneralizedForce self, double aStiffness)

        Parameters
        ----------
        aStiffness: double

        """
        return _actuators.SpringGeneralizedForce_setStiffness(self, aStiffness)

    def getStiffness(self):
        r"""getStiffness(SpringGeneralizedForce self) -> double"""
        return _actuators.SpringGeneralizedForce_getStiffness(self)

    def setRestLength(self, aRestLength):
        r"""
        setRestLength(SpringGeneralizedForce self, double aRestLength)

        Parameters
        ----------
        aRestLength: double

        """
        return _actuators.SpringGeneralizedForce_setRestLength(self, aRestLength)

    def getRestLength(self):
        r"""getRestLength(SpringGeneralizedForce self) -> double"""
        return _actuators.SpringGeneralizedForce_getRestLength(self)

    def setViscosity(self, aViscosity):
        r"""
        setViscosity(SpringGeneralizedForce self, double aViscosity)

        Parameters
        ----------
        aViscosity: double

        """
        return _actuators.SpringGeneralizedForce_setViscosity(self, aViscosity)

    def getViscosity(self):
        r"""getViscosity(SpringGeneralizedForce self) -> double"""
        return _actuators.SpringGeneralizedForce_getViscosity(self)

    def getRecordLabels(self):
        r"""
        Methods to query a Force for the value actually applied during simulation
        The names of the quantities (column labels) is returned by this first function
        getRecordLabels()
        """
        return _actuators.SpringGeneralizedForce_getRecordLabels(self)

    def getRecordValues(self, state):
        r"""
        Given SimTK::State object extract all the values necessary to report forces, application location
        frame, etc. used in conjunction with getRecordLabels and should return same size Array
        """
        return _actuators.SpringGeneralizedForce_getRecordValues(self, state)
    __swig_destroy__ = _actuators.delete_SpringGeneralizedForce

# Register SpringGeneralizedForce in _actuators:
_actuators.SpringGeneralizedForce_swigregister(SpringGeneralizedForce)
class RigidTendonMuscle(opensim.simulation.Muscle):
    r"""
    A class implementing a RigidTendonMuscle actuator with no states.
    The path information for a RigidTendonMuscle is contained
    in the base class, and the force-generating behavior should is defined in
    this class. The force (muscle tension) assumes rigid tendon so that
    fiber-length and velocity are kinematics dependent and the force-length
    force-velocity relationships are evaluated directly.
    The control of this model is its activation. Force production is instantaneous
    with no excitation-to-activation dynamics and excitation=activation.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> RigidTendonMuscle

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.RigidTendonMuscle_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(RigidTendonMuscle self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.RigidTendonMuscle_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.RigidTendonMuscle_getClassName()

    def clone(self):
        r"""clone(RigidTendonMuscle self) -> RigidTendonMuscle"""
        return _actuators.RigidTendonMuscle_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(RigidTendonMuscle self) -> std::string const &"""
        return _actuators.RigidTendonMuscle_getConcreteClassName(self)

    def copyProperty_active_force_length_curve(self, source):
        r"""
        copyProperty_active_force_length_curve(RigidTendonMuscle self, RigidTendonMuscle source)

        Parameters
        ----------
        source: OpenSim::RigidTendonMuscle::Self const &

        """
        return _actuators.RigidTendonMuscle_copyProperty_active_force_length_curve(self, source)

    def append_active_force_length_curve(self, value):
        r"""
        append_active_force_length_curve(RigidTendonMuscle self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _actuators.RigidTendonMuscle_append_active_force_length_curve(self, value)

    def constructProperty_active_force_length_curve(self, initValue):
        r"""
        constructProperty_active_force_length_curve(RigidTendonMuscle self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _actuators.RigidTendonMuscle_constructProperty_active_force_length_curve(self, initValue)

    def get_active_force_length_curve(self, *args):
        r"""
        get_active_force_length_curve(RigidTendonMuscle self, int i) -> Function

        Parameters
        ----------
        i: int

        get_active_force_length_curve(RigidTendonMuscle self) -> Function
        """
        return _actuators.RigidTendonMuscle_get_active_force_length_curve(self, *args)

    def upd_active_force_length_curve(self, *args):
        r"""
        upd_active_force_length_curve(RigidTendonMuscle self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_active_force_length_curve(RigidTendonMuscle self) -> Function
        """
        return _actuators.RigidTendonMuscle_upd_active_force_length_curve(self, *args)

    def set_active_force_length_curve(self, *args):
        r"""
        set_active_force_length_curve(RigidTendonMuscle self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_active_force_length_curve(RigidTendonMuscle self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _actuators.RigidTendonMuscle_set_active_force_length_curve(self, *args)

    def copyProperty_passive_force_length_curve(self, source):
        r"""
        copyProperty_passive_force_length_curve(RigidTendonMuscle self, RigidTendonMuscle source)

        Parameters
        ----------
        source: OpenSim::RigidTendonMuscle::Self const &

        """
        return _actuators.RigidTendonMuscle_copyProperty_passive_force_length_curve(self, source)

    def append_passive_force_length_curve(self, value):
        r"""
        append_passive_force_length_curve(RigidTendonMuscle self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _actuators.RigidTendonMuscle_append_passive_force_length_curve(self, value)

    def constructProperty_passive_force_length_curve(self, initValue):
        r"""
        constructProperty_passive_force_length_curve(RigidTendonMuscle self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _actuators.RigidTendonMuscle_constructProperty_passive_force_length_curve(self, initValue)

    def get_passive_force_length_curve(self, *args):
        r"""
        get_passive_force_length_curve(RigidTendonMuscle self, int i) -> Function

        Parameters
        ----------
        i: int

        get_passive_force_length_curve(RigidTendonMuscle self) -> Function
        """
        return _actuators.RigidTendonMuscle_get_passive_force_length_curve(self, *args)

    def upd_passive_force_length_curve(self, *args):
        r"""
        upd_passive_force_length_curve(RigidTendonMuscle self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_passive_force_length_curve(RigidTendonMuscle self) -> Function
        """
        return _actuators.RigidTendonMuscle_upd_passive_force_length_curve(self, *args)

    def set_passive_force_length_curve(self, *args):
        r"""
        set_passive_force_length_curve(RigidTendonMuscle self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_passive_force_length_curve(RigidTendonMuscle self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _actuators.RigidTendonMuscle_set_passive_force_length_curve(self, *args)

    def copyProperty_force_velocity_curve(self, source):
        r"""
        copyProperty_force_velocity_curve(RigidTendonMuscle self, RigidTendonMuscle source)

        Parameters
        ----------
        source: OpenSim::RigidTendonMuscle::Self const &

        """
        return _actuators.RigidTendonMuscle_copyProperty_force_velocity_curve(self, source)

    def append_force_velocity_curve(self, value):
        r"""
        append_force_velocity_curve(RigidTendonMuscle self, Function value) -> int

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _actuators.RigidTendonMuscle_append_force_velocity_curve(self, value)

    def constructProperty_force_velocity_curve(self, initValue):
        r"""
        constructProperty_force_velocity_curve(RigidTendonMuscle self, Function initValue)

        Parameters
        ----------
        initValue: OpenSim::Function const &

        """
        return _actuators.RigidTendonMuscle_constructProperty_force_velocity_curve(self, initValue)

    def get_force_velocity_curve(self, *args):
        r"""
        get_force_velocity_curve(RigidTendonMuscle self, int i) -> Function

        Parameters
        ----------
        i: int

        get_force_velocity_curve(RigidTendonMuscle self) -> Function
        """
        return _actuators.RigidTendonMuscle_get_force_velocity_curve(self, *args)

    def upd_force_velocity_curve(self, *args):
        r"""
        upd_force_velocity_curve(RigidTendonMuscle self, int i) -> Function

        Parameters
        ----------
        i: int

        upd_force_velocity_curve(RigidTendonMuscle self) -> Function
        """
        return _actuators.RigidTendonMuscle_upd_force_velocity_curve(self, *args)

    def set_force_velocity_curve(self, *args):
        r"""
        set_force_velocity_curve(RigidTendonMuscle self, int i, Function value)

        Parameters
        ----------
        i: int
        value: OpenSim::Function const &

        set_force_velocity_curve(RigidTendonMuscle self, Function value)

        Parameters
        ----------
        value: OpenSim::Function const &

        """
        return _actuators.RigidTendonMuscle_set_force_velocity_curve(self, *args)

    def __init__(self, *args):
        r"""
        __init__(RigidTendonMuscle self) -> RigidTendonMuscle
        __init__(RigidTendonMuscle self, std::string const & name, double maxIsometricForce, double optimalFiberLength, double tendonSlackLength, double pennationAngle) -> RigidTendonMuscle

        Parameters
        ----------
        name: std::string const &
        maxIsometricForce: double
        optimalFiberLength: double
        tendonSlackLength: double
        pennationAngle: double

        """
        _actuators.RigidTendonMuscle_swiginit(self, _actuators.new_RigidTendonMuscle(*args))

    def setActivation(self, s, activation):
        r""" activation level for this muscle"""
        return _actuators.RigidTendonMuscle_setActivation(self, s, activation)
    __swig_destroy__ = _actuators.delete_RigidTendonMuscle

# Register RigidTendonMuscle in _actuators:
_actuators.RigidTendonMuscle_swigregister(RigidTendonMuscle)
class Millard2012AccelerationMuscle(opensim.simulation.Muscle):
    r"""
    This class implements a 3 state (activation,fiber length and fiber velocity)
    acceleration musculo-tendon model that has several advantages over
    equilibrium musculo-tendon models: it is possible to simulate 0 activation, it
    requires fewer integrator steps to simulate, and physiological active
    force-length (with a minimum value of 0) and force velocity (with true
    asymptotes at the maximum shortening and lengthening velocities)
    curves can be employed.

    Image: fig_Millard2012AccelerationMuscle.png

    The dynamic equation of the mass, constrained to move in direction
    :math:`\hat{i}` is given by the scalar equation:

    .. math::

        m \ddot{x} = F_{SE} - F_{CE} \cdot \hat{i}


    The kinematic expression for the acceleration of the mass, :math:`\ddot{s}`,
    expressed in terms of the fiber length,_{CE}:math:`, and pennation angle`:math:`is\f[\ddot{x} = \Big(\ddot{l}_{CE} \cos \phi - 2 \dot{l}_{CE}\dot{\phi}\sin\phi - \dot{\phi}^2 l_{CE} \cos \phi - \ddot{\phi} l_{CE} \sin \phi\Big)The kinematic expression for the angular acceleration of the pennation angle can be found by taking the second derivative of the pennation constraint equationl_{CE} \sin \phi = hwhich yields\ddot{\phi} = -\Big( \ddot{l}_{CE}\sin\phi +                     2 \dot{l}_{CE} \dot{\phi} \cos\phi                    - \dot{\phi}^2 l_{CE} \sin \phi \Big) \Big( l_{CE} \cos \phi \Big)An expression for` \ddot{l}_{CE}:math:`can be obtained by substituting inthe equations` \ddot{\phi} :math:`into the equation for`\ddot{x}:math:`and simplifying:\ddot{l}_{CE} = \frac{1}{m} \Big(  F_{SE} - F_{CE} \cdot \hat{i} \Big) \cos \phi                + l_{CE} \dot{\phi}^2Notice that the above equation for`\ddot{l}_{CE}:math:`has no singularities,provided that there are no singularities in` F_{SE}:math:`and` F_{M}\cdot\hat{i}:math:`. The force the fiber applies to the tendon (in N), _{CE}`, is given by (+'ve is tension)

    \f[
    F_{CE} \cdot \hat{i} =
    f_{ISO}\Big(\mathbf{a} \mathbf{f}_L(\hat{l}_{CE})
    \mathbf{f}_V(\frac{\hat{v}_{CE}}{v_{MAX}})
    + \beta_{CE}\hat{v}_{CE}
    + \mathbf{f}_{PE}(\hat{l}_{CE})(1+\beta_{PE}\hat{v}_{CE})
    - \mathbf{f}_K(\hat{l}_{CE})(1-\beta_{K}\hat{v}_{CE})  \Big) \cos \phi
    -  f_{ISO} \Big( \mathbf{f}_{c\phi}(\cos \phi)
    (1- \beta_{c \phi}
    \frac{d}{dt}(\frac{l_{CE}\cos\phi}{l_{CE,OPT}\cos\phi_{OPT}})) \Big)


    The force the tendon generates (in N) is given by (+'ve is tension)

    .. math::

        F_{SE} =  
        f_{ISO} \mathbf{f}_{SE}(\hat{l}_{SE})(1+\beta_{SE}\hat{v}_{SE})

    Every elastic element (:math:`\mathbf{f}_{PE}`,:math:`\mathbf{f}_{K}`,
    :math:`\mathbf{f}_{c\phi}`, and :math:`\mathbf{f}_{SE}`) is accompanied by a
    non-linear damping element of a form that is identical to the damping found
    in a Hunt-Crossley contact model. Additionally a linear damping element,
    :math:`\beta_{CE}\hat{v}_{CE}`, is
    located in the fiber as in J.He et al. Damping is necessary to include in this
    model to prevent the mass from oscillating in a non-physiologic manner.
    Nonlinear damping Hunt-Crossley damping (where the damping force is scaled
    by the elastic force) has been chosen because this form of damping doesn't
    increase the stiffness of the system equations
    (because it is gradually turned on).

    As with the Hunt-Crossley contact model, the force generated by the nonlinear
    spring and damper saturated so that it is greater than or equal to zero. This
    saturation is necessary to ensure that tension elements can only generate
    tensile forces, and that compressive elements only generate compressive forces.
    Note that the sign conventions have been chosen so that damping forces are
    generated in the correct direction for each element.

    *}{
    (1+_{PE}_{CE}) > 0 \
    (1-_{K}_{CE}) > 0 \
    (1- _{c
    (_{CE}_{CE,OPT}_{OPT}})) > 0 \
    (1+_{SE}_{SE}) > 0



    For more information on these new terms please see the
    doxygen for FiberCompressiveForceLengthCurve,
    FiberCompressiveForceCosPennationCurve, and
    MuscleFirstOrderActivationDynamicModel.

    **Units**

    * m: meters
    * rad: radians
    * N: Newtons
    * kg: kilograms
    * s: seconds

    **Caution**

    The Millard2012AccelerationMuscle class is experimental and has not been
    extensively tested in all operational conditions.

    **Usage**

     Note that this object should be updated through the set methods provided.
     These set methods will take care of rebuilding the muscle correctly. If you
     modify the properties directly, the curve will not be rebuilt, and upon
     calling a function that requires a state an exception will be thrown because
     the muscle is out of date with its properties.

     Note that this muscle does not currently implement the ignore_tendon_compliance
     flag, nor the ignore_activation_dynamics flag.

    **Nomenclature**

    Note that dot notation is used to denote time derivatives (units of
    /s:math:`and \f$m/s^2` in this case), where as the hat symbol
    (as in :math:`\hat{l}`,:math:`\hat{v}`) is used to denote time derivatives that have
    been scaled by a characteristic dimension (appear in units of
    /s:math:`and \f$1/s^2` in this case)

    * :math:`: is the mass located at the junction between the fiber and the     tendon. This mass should be thought of as a time constant that indicates    how quickly this model will converge to the force an equilibrium     muscle-tendon model would produce (\f$kg`)
    * :math:`\ddot{x}`: is the acceleration of the mass,
         in the :math:`\hat{i}` direction (/s^2:math:`)\li \f$F_{SE}`: is the force developed by the tendon (:math:`)\li \f$F_{CE}\cdot\hat{i}`: is the force developed by the fiber along the
        tendon (:math:`)\li \f$l_{CE}`: Length of the fiber(m)
    * _{CE,OPT}:math:`: Length the fiber generates maximal isometric force (m)\li`_{CE}=l_{CE}/l_{CE,OPT}:math:`:         Normalized length of the fiber (dimensionless)\li`_{CE}=_{CE}/l_{CE,OPT}:math:`:         Fiber velocity divided by (\f$1/s`)
    * :math:`\hat{v}_{MAX}`:
            Maximum normalized fiber velocity (_{CE,OPT}/s:math:`). This                   quantity typically ranges between 10 and 15 lengths                    per second  (1/s)\li`:math:`: Pennation angle(rad)\li`_{OPT}:math:`: Pennation angle when the fiber is at its optimal                       length (rad)\li \f$l_{SE}`: Length of the series element (tendon) (m)
    * _{SE,R}:math:`: Resting length of the series element(m)\li`_{SE} = l_{SE}/l_{SE,R}:math:`:                 Normalized length of the series element (dimensionless)\li` _{SE} = _{SE}/l_{SE,R}:math:`:                     Normalized velocity of the tendon (1/s)\li \f$f_{ISO}`: maximum force the muscle can develop statically
    (:math:`\hat{v}_{CE}=0`) at its optimal length (_{CE,OPT}:math:`) and pennation angle (`_{OPT}:math:`)\li`:math:`: activation (unitless)\li`_L(_{CE}):math:`:         Active force length multiplier (dimensionless)\li`_V(_{CE}}{v_{MAX}}):math:`:         Force velocity multiplier (dimensionless)\li`_{PE}(_{CE}):math:`:         Passive force length multiplier (dimensionless)\li`_{K}(_{CE}):math:`:        Fiber compressive force length multiplier (dimensionless)\li`_{c():math:`:        Fiber compressive cosine pennation multiplier (dimensionless)\li`_{SE}(_{SE}):math:`:        Series element (tendon) force-length multiplier (dimensionless)\li`_{CE}:math:`: Fiber damping (s)\li`_{PE}:math:`: Fiber parallel element damping coefficient (s)\li`_{K}:math:`: Fiber compressive force length damping coefficient (s)\li`_{c :math:`: Fiber compressive cosine pennation damping                           coefficient (s)\li`_{SE}:math:`: Series element (tendon) force length damping coefficient                       (s)<B> References </B>Hunt,K., and Crossley,F. Coefficient of restitution interpreted as damping in vibroimpact. Transactions of the ASME Journal of Applied Mechanics, 42(E):440445, 1975.J.He, W.S. Levine, and G.E. Leob."The Modelling of the Neuro-musculo-skeletal Control System of A Cat Hindlimb", Proceedings of the IEEE International Symposium on Intelligent Control, 1988.@author Matt Millard`
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Millard2012AccelerationMuscle

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.Millard2012AccelerationMuscle_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Millard2012AccelerationMuscle self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.Millard2012AccelerationMuscle_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.Millard2012AccelerationMuscle_getClassName()

    def clone(self):
        r"""clone(Millard2012AccelerationMuscle self) -> Millard2012AccelerationMuscle"""
        return _actuators.Millard2012AccelerationMuscle_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Millard2012AccelerationMuscle self) -> std::string const &"""
        return _actuators.Millard2012AccelerationMuscle_getConcreteClassName(self)

    def copyProperty_default_activation(self, source):
        r"""
        copyProperty_default_activation(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_default_activation(self, source)

    def append_default_activation(self, value):
        r"""
        append_default_activation(Millard2012AccelerationMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue):
        r"""
        constructProperty_default_activation(Millard2012AccelerationMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args):
        r"""
        get_default_activation(Millard2012AccelerationMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_activation(Millard2012AccelerationMuscle self) -> double const &
        """
        return _actuators.Millard2012AccelerationMuscle_get_default_activation(self, *args)

    def upd_default_activation(self, *args):
        r"""
        upd_default_activation(Millard2012AccelerationMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_activation(Millard2012AccelerationMuscle self) -> double &
        """
        return _actuators.Millard2012AccelerationMuscle_upd_default_activation(self, *args)

    def set_default_activation(self, *args):
        r"""
        set_default_activation(Millard2012AccelerationMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_activation(Millard2012AccelerationMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_default_activation(self, *args)

    def copyProperty_default_fiber_length(self, source):
        r"""
        copyProperty_default_fiber_length(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_default_fiber_length(self, source)

    def append_default_fiber_length(self, value):
        r"""
        append_default_fiber_length(Millard2012AccelerationMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_default_fiber_length(self, value)

    def constructProperty_default_fiber_length(self, initValue):
        r"""
        constructProperty_default_fiber_length(Millard2012AccelerationMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_default_fiber_length(self, initValue)

    def get_default_fiber_length(self, *args):
        r"""
        get_default_fiber_length(Millard2012AccelerationMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_fiber_length(Millard2012AccelerationMuscle self) -> double const &
        """
        return _actuators.Millard2012AccelerationMuscle_get_default_fiber_length(self, *args)

    def upd_default_fiber_length(self, *args):
        r"""
        upd_default_fiber_length(Millard2012AccelerationMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_fiber_length(Millard2012AccelerationMuscle self) -> double &
        """
        return _actuators.Millard2012AccelerationMuscle_upd_default_fiber_length(self, *args)

    def set_default_fiber_length(self, *args):
        r"""
        set_default_fiber_length(Millard2012AccelerationMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_fiber_length(Millard2012AccelerationMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_default_fiber_length(self, *args)

    def copyProperty_default_fiber_velocity(self, source):
        r"""
        copyProperty_default_fiber_velocity(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_default_fiber_velocity(self, source)

    def append_default_fiber_velocity(self, value):
        r"""
        append_default_fiber_velocity(Millard2012AccelerationMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_default_fiber_velocity(self, value)

    def constructProperty_default_fiber_velocity(self, initValue):
        r"""
        constructProperty_default_fiber_velocity(Millard2012AccelerationMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_default_fiber_velocity(self, initValue)

    def get_default_fiber_velocity(self, *args):
        r"""
        get_default_fiber_velocity(Millard2012AccelerationMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_fiber_velocity(Millard2012AccelerationMuscle self) -> double const &
        """
        return _actuators.Millard2012AccelerationMuscle_get_default_fiber_velocity(self, *args)

    def upd_default_fiber_velocity(self, *args):
        r"""
        upd_default_fiber_velocity(Millard2012AccelerationMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_fiber_velocity(Millard2012AccelerationMuscle self) -> double &
        """
        return _actuators.Millard2012AccelerationMuscle_upd_default_fiber_velocity(self, *args)

    def set_default_fiber_velocity(self, *args):
        r"""
        set_default_fiber_velocity(Millard2012AccelerationMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_fiber_velocity(Millard2012AccelerationMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_default_fiber_velocity(self, *args)

    def copyProperty_MuscleFirstOrderActivationDynamicModel(self, source):
        r"""
        copyProperty_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_MuscleFirstOrderActivationDynamicModel(self, source)

    def append_MuscleFirstOrderActivationDynamicModel(self, value):
        r"""
        append_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle self, MuscleFirstOrderActivationDynamicModel value) -> int

        Parameters
        ----------
        value: OpenSim::MuscleFirstOrderActivationDynamicModel const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_MuscleFirstOrderActivationDynamicModel(self, value)

    def constructProperty_MuscleFirstOrderActivationDynamicModel(self, initValue):
        r"""
        constructProperty_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle self, MuscleFirstOrderActivationDynamicModel initValue)

        Parameters
        ----------
        initValue: OpenSim::MuscleFirstOrderActivationDynamicModel const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_MuscleFirstOrderActivationDynamicModel(self, initValue)

    def get_MuscleFirstOrderActivationDynamicModel(self, *args):
        r"""
        get_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle self, int i) -> MuscleFirstOrderActivationDynamicModel

        Parameters
        ----------
        i: int

        get_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle self) -> MuscleFirstOrderActivationDynamicModel
        """
        return _actuators.Millard2012AccelerationMuscle_get_MuscleFirstOrderActivationDynamicModel(self, *args)

    def upd_MuscleFirstOrderActivationDynamicModel(self, *args):
        r"""
        upd_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle self, int i) -> MuscleFirstOrderActivationDynamicModel

        Parameters
        ----------
        i: int

        upd_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle self) -> MuscleFirstOrderActivationDynamicModel
        """
        return _actuators.Millard2012AccelerationMuscle_upd_MuscleFirstOrderActivationDynamicModel(self, *args)

    def set_MuscleFirstOrderActivationDynamicModel(self, *args):
        r"""
        set_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle self, int i, MuscleFirstOrderActivationDynamicModel value)

        Parameters
        ----------
        i: int
        value: OpenSim::MuscleFirstOrderActivationDynamicModel const &

        set_MuscleFirstOrderActivationDynamicModel(Millard2012AccelerationMuscle self, MuscleFirstOrderActivationDynamicModel value)

        Parameters
        ----------
        value: OpenSim::MuscleFirstOrderActivationDynamicModel const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_MuscleFirstOrderActivationDynamicModel(self, *args)

    def copyProperty_ActiveForceLengthCurve(self, source):
        r"""
        copyProperty_ActiveForceLengthCurve(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_ActiveForceLengthCurve(self, source)

    def append_ActiveForceLengthCurve(self, value):
        r"""
        append_ActiveForceLengthCurve(Millard2012AccelerationMuscle self, ActiveForceLengthCurve value) -> int

        Parameters
        ----------
        value: OpenSim::ActiveForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_ActiveForceLengthCurve(self, value)

    def constructProperty_ActiveForceLengthCurve(self, initValue):
        r"""
        constructProperty_ActiveForceLengthCurve(Millard2012AccelerationMuscle self, ActiveForceLengthCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::ActiveForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_ActiveForceLengthCurve(self, initValue)

    def get_ActiveForceLengthCurve(self, *args):
        r"""
        get_ActiveForceLengthCurve(Millard2012AccelerationMuscle self, int i) -> ActiveForceLengthCurve

        Parameters
        ----------
        i: int

        get_ActiveForceLengthCurve(Millard2012AccelerationMuscle self) -> ActiveForceLengthCurve
        """
        return _actuators.Millard2012AccelerationMuscle_get_ActiveForceLengthCurve(self, *args)

    def upd_ActiveForceLengthCurve(self, *args):
        r"""
        upd_ActiveForceLengthCurve(Millard2012AccelerationMuscle self, int i) -> ActiveForceLengthCurve

        Parameters
        ----------
        i: int

        upd_ActiveForceLengthCurve(Millard2012AccelerationMuscle self) -> ActiveForceLengthCurve
        """
        return _actuators.Millard2012AccelerationMuscle_upd_ActiveForceLengthCurve(self, *args)

    def set_ActiveForceLengthCurve(self, *args):
        r"""
        set_ActiveForceLengthCurve(Millard2012AccelerationMuscle self, int i, ActiveForceLengthCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::ActiveForceLengthCurve const &

        set_ActiveForceLengthCurve(Millard2012AccelerationMuscle self, ActiveForceLengthCurve value)

        Parameters
        ----------
        value: OpenSim::ActiveForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_ActiveForceLengthCurve(self, *args)

    def copyProperty_ForceVelocityCurve(self, source):
        r"""
        copyProperty_ForceVelocityCurve(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_ForceVelocityCurve(self, source)

    def append_ForceVelocityCurve(self, value):
        r"""
        append_ForceVelocityCurve(Millard2012AccelerationMuscle self, ForceVelocityCurve value) -> int

        Parameters
        ----------
        value: OpenSim::ForceVelocityCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_ForceVelocityCurve(self, value)

    def constructProperty_ForceVelocityCurve(self, initValue):
        r"""
        constructProperty_ForceVelocityCurve(Millard2012AccelerationMuscle self, ForceVelocityCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::ForceVelocityCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_ForceVelocityCurve(self, initValue)

    def get_ForceVelocityCurve(self, *args):
        r"""
        get_ForceVelocityCurve(Millard2012AccelerationMuscle self, int i) -> ForceVelocityCurve

        Parameters
        ----------
        i: int

        get_ForceVelocityCurve(Millard2012AccelerationMuscle self) -> ForceVelocityCurve
        """
        return _actuators.Millard2012AccelerationMuscle_get_ForceVelocityCurve(self, *args)

    def upd_ForceVelocityCurve(self, *args):
        r"""
        upd_ForceVelocityCurve(Millard2012AccelerationMuscle self, int i) -> ForceVelocityCurve

        Parameters
        ----------
        i: int

        upd_ForceVelocityCurve(Millard2012AccelerationMuscle self) -> ForceVelocityCurve
        """
        return _actuators.Millard2012AccelerationMuscle_upd_ForceVelocityCurve(self, *args)

    def set_ForceVelocityCurve(self, *args):
        r"""
        set_ForceVelocityCurve(Millard2012AccelerationMuscle self, int i, ForceVelocityCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::ForceVelocityCurve const &

        set_ForceVelocityCurve(Millard2012AccelerationMuscle self, ForceVelocityCurve value)

        Parameters
        ----------
        value: OpenSim::ForceVelocityCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_ForceVelocityCurve(self, *args)

    def copyProperty_FiberForceLengthCurve(self, source):
        r"""
        copyProperty_FiberForceLengthCurve(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_FiberForceLengthCurve(self, source)

    def append_FiberForceLengthCurve(self, value):
        r"""
        append_FiberForceLengthCurve(Millard2012AccelerationMuscle self, FiberForceLengthCurve value) -> int

        Parameters
        ----------
        value: OpenSim::FiberForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_FiberForceLengthCurve(self, value)

    def constructProperty_FiberForceLengthCurve(self, initValue):
        r"""
        constructProperty_FiberForceLengthCurve(Millard2012AccelerationMuscle self, FiberForceLengthCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::FiberForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_FiberForceLengthCurve(self, initValue)

    def get_FiberForceLengthCurve(self, *args):
        r"""
        get_FiberForceLengthCurve(Millard2012AccelerationMuscle self, int i) -> FiberForceLengthCurve

        Parameters
        ----------
        i: int

        get_FiberForceLengthCurve(Millard2012AccelerationMuscle self) -> FiberForceLengthCurve
        """
        return _actuators.Millard2012AccelerationMuscle_get_FiberForceLengthCurve(self, *args)

    def upd_FiberForceLengthCurve(self, *args):
        r"""
        upd_FiberForceLengthCurve(Millard2012AccelerationMuscle self, int i) -> FiberForceLengthCurve

        Parameters
        ----------
        i: int

        upd_FiberForceLengthCurve(Millard2012AccelerationMuscle self) -> FiberForceLengthCurve
        """
        return _actuators.Millard2012AccelerationMuscle_upd_FiberForceLengthCurve(self, *args)

    def set_FiberForceLengthCurve(self, *args):
        r"""
        set_FiberForceLengthCurve(Millard2012AccelerationMuscle self, int i, FiberForceLengthCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::FiberForceLengthCurve const &

        set_FiberForceLengthCurve(Millard2012AccelerationMuscle self, FiberForceLengthCurve value)

        Parameters
        ----------
        value: OpenSim::FiberForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_FiberForceLengthCurve(self, *args)

    def copyProperty_TendonForceLengthCurve(self, source):
        r"""
        copyProperty_TendonForceLengthCurve(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_TendonForceLengthCurve(self, source)

    def append_TendonForceLengthCurve(self, value):
        r"""
        append_TendonForceLengthCurve(Millard2012AccelerationMuscle self, TendonForceLengthCurve value) -> int

        Parameters
        ----------
        value: OpenSim::TendonForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_TendonForceLengthCurve(self, value)

    def constructProperty_TendonForceLengthCurve(self, initValue):
        r"""
        constructProperty_TendonForceLengthCurve(Millard2012AccelerationMuscle self, TendonForceLengthCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::TendonForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_TendonForceLengthCurve(self, initValue)

    def get_TendonForceLengthCurve(self, *args):
        r"""
        get_TendonForceLengthCurve(Millard2012AccelerationMuscle self, int i) -> TendonForceLengthCurve

        Parameters
        ----------
        i: int

        get_TendonForceLengthCurve(Millard2012AccelerationMuscle self) -> TendonForceLengthCurve
        """
        return _actuators.Millard2012AccelerationMuscle_get_TendonForceLengthCurve(self, *args)

    def upd_TendonForceLengthCurve(self, *args):
        r"""
        upd_TendonForceLengthCurve(Millard2012AccelerationMuscle self, int i) -> TendonForceLengthCurve

        Parameters
        ----------
        i: int

        upd_TendonForceLengthCurve(Millard2012AccelerationMuscle self) -> TendonForceLengthCurve
        """
        return _actuators.Millard2012AccelerationMuscle_upd_TendonForceLengthCurve(self, *args)

    def set_TendonForceLengthCurve(self, *args):
        r"""
        set_TendonForceLengthCurve(Millard2012AccelerationMuscle self, int i, TendonForceLengthCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::TendonForceLengthCurve const &

        set_TendonForceLengthCurve(Millard2012AccelerationMuscle self, TendonForceLengthCurve value)

        Parameters
        ----------
        value: OpenSim::TendonForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_TendonForceLengthCurve(self, *args)

    def copyProperty_FiberCompressiveForceLengthCurve(self, source):
        r"""
        copyProperty_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_FiberCompressiveForceLengthCurve(self, source)

    def append_FiberCompressiveForceLengthCurve(self, value):
        r"""
        append_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle self, FiberCompressiveForceLengthCurve value) -> int

        Parameters
        ----------
        value: OpenSim::FiberCompressiveForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_FiberCompressiveForceLengthCurve(self, value)

    def constructProperty_FiberCompressiveForceLengthCurve(self, initValue):
        r"""
        constructProperty_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle self, FiberCompressiveForceLengthCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::FiberCompressiveForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_FiberCompressiveForceLengthCurve(self, initValue)

    def get_FiberCompressiveForceLengthCurve(self, *args):
        r"""
        get_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle self, int i) -> FiberCompressiveForceLengthCurve

        Parameters
        ----------
        i: int

        get_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle self) -> FiberCompressiveForceLengthCurve
        """
        return _actuators.Millard2012AccelerationMuscle_get_FiberCompressiveForceLengthCurve(self, *args)

    def upd_FiberCompressiveForceLengthCurve(self, *args):
        r"""
        upd_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle self, int i) -> FiberCompressiveForceLengthCurve

        Parameters
        ----------
        i: int

        upd_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle self) -> FiberCompressiveForceLengthCurve
        """
        return _actuators.Millard2012AccelerationMuscle_upd_FiberCompressiveForceLengthCurve(self, *args)

    def set_FiberCompressiveForceLengthCurve(self, *args):
        r"""
        set_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle self, int i, FiberCompressiveForceLengthCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::FiberCompressiveForceLengthCurve const &

        set_FiberCompressiveForceLengthCurve(Millard2012AccelerationMuscle self, FiberCompressiveForceLengthCurve value)

        Parameters
        ----------
        value: OpenSim::FiberCompressiveForceLengthCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_FiberCompressiveForceLengthCurve(self, *args)

    def copyProperty_FiberCompressiveForceCosPennationCurve(self, source):
        r"""
        copyProperty_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_FiberCompressiveForceCosPennationCurve(self, source)

    def append_FiberCompressiveForceCosPennationCurve(self, value):
        r"""
        append_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle self, FiberCompressiveForceCosPennationCurve value) -> int

        Parameters
        ----------
        value: OpenSim::FiberCompressiveForceCosPennationCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_FiberCompressiveForceCosPennationCurve(self, value)

    def constructProperty_FiberCompressiveForceCosPennationCurve(self, initValue):
        r"""
        constructProperty_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle self, FiberCompressiveForceCosPennationCurve initValue)

        Parameters
        ----------
        initValue: OpenSim::FiberCompressiveForceCosPennationCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_FiberCompressiveForceCosPennationCurve(self, initValue)

    def get_FiberCompressiveForceCosPennationCurve(self, *args):
        r"""
        get_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle self, int i) -> FiberCompressiveForceCosPennationCurve

        Parameters
        ----------
        i: int

        get_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle self) -> FiberCompressiveForceCosPennationCurve
        """
        return _actuators.Millard2012AccelerationMuscle_get_FiberCompressiveForceCosPennationCurve(self, *args)

    def upd_FiberCompressiveForceCosPennationCurve(self, *args):
        r"""
        upd_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle self, int i) -> FiberCompressiveForceCosPennationCurve

        Parameters
        ----------
        i: int

        upd_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle self) -> FiberCompressiveForceCosPennationCurve
        """
        return _actuators.Millard2012AccelerationMuscle_upd_FiberCompressiveForceCosPennationCurve(self, *args)

    def set_FiberCompressiveForceCosPennationCurve(self, *args):
        r"""
        set_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle self, int i, FiberCompressiveForceCosPennationCurve value)

        Parameters
        ----------
        i: int
        value: OpenSim::FiberCompressiveForceCosPennationCurve const &

        set_FiberCompressiveForceCosPennationCurve(Millard2012AccelerationMuscle self, FiberCompressiveForceCosPennationCurve value)

        Parameters
        ----------
        value: OpenSim::FiberCompressiveForceCosPennationCurve const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_FiberCompressiveForceCosPennationCurve(self, *args)

    def copyProperty_fiber_damping(self, source):
        r"""
        copyProperty_fiber_damping(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_fiber_damping(self, source)

    def append_fiber_damping(self, value):
        r"""
        append_fiber_damping(Millard2012AccelerationMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_fiber_damping(self, value)

    def constructProperty_fiber_damping(self, initValue):
        r"""
        constructProperty_fiber_damping(Millard2012AccelerationMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_fiber_damping(self, initValue)

    def get_fiber_damping(self, *args):
        r"""
        get_fiber_damping(Millard2012AccelerationMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_fiber_damping(Millard2012AccelerationMuscle self) -> double const &
        """
        return _actuators.Millard2012AccelerationMuscle_get_fiber_damping(self, *args)

    def upd_fiber_damping(self, *args):
        r"""
        upd_fiber_damping(Millard2012AccelerationMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_fiber_damping(Millard2012AccelerationMuscle self) -> double &
        """
        return _actuators.Millard2012AccelerationMuscle_upd_fiber_damping(self, *args)

    def set_fiber_damping(self, *args):
        r"""
        set_fiber_damping(Millard2012AccelerationMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_fiber_damping(Millard2012AccelerationMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_fiber_damping(self, *args)

    def copyProperty_fiber_force_length_damping(self, source):
        r"""
        copyProperty_fiber_force_length_damping(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_fiber_force_length_damping(self, source)

    def append_fiber_force_length_damping(self, value):
        r"""
        append_fiber_force_length_damping(Millard2012AccelerationMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_fiber_force_length_damping(self, value)

    def constructProperty_fiber_force_length_damping(self, initValue):
        r"""
        constructProperty_fiber_force_length_damping(Millard2012AccelerationMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_fiber_force_length_damping(self, initValue)

    def get_fiber_force_length_damping(self, *args):
        r"""
        get_fiber_force_length_damping(Millard2012AccelerationMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_fiber_force_length_damping(Millard2012AccelerationMuscle self) -> double const &
        """
        return _actuators.Millard2012AccelerationMuscle_get_fiber_force_length_damping(self, *args)

    def upd_fiber_force_length_damping(self, *args):
        r"""
        upd_fiber_force_length_damping(Millard2012AccelerationMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_fiber_force_length_damping(Millard2012AccelerationMuscle self) -> double &
        """
        return _actuators.Millard2012AccelerationMuscle_upd_fiber_force_length_damping(self, *args)

    def set_fiber_force_length_damping(self, *args):
        r"""
        set_fiber_force_length_damping(Millard2012AccelerationMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_fiber_force_length_damping(Millard2012AccelerationMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_fiber_force_length_damping(self, *args)

    def copyProperty_fiber_compressive_force_length_damping(self, source):
        r"""
        copyProperty_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_fiber_compressive_force_length_damping(self, source)

    def append_fiber_compressive_force_length_damping(self, value):
        r"""
        append_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_fiber_compressive_force_length_damping(self, value)

    def constructProperty_fiber_compressive_force_length_damping(self, initValue):
        r"""
        constructProperty_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_fiber_compressive_force_length_damping(self, initValue)

    def get_fiber_compressive_force_length_damping(self, *args):
        r"""
        get_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle self) -> double const &
        """
        return _actuators.Millard2012AccelerationMuscle_get_fiber_compressive_force_length_damping(self, *args)

    def upd_fiber_compressive_force_length_damping(self, *args):
        r"""
        upd_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle self) -> double &
        """
        return _actuators.Millard2012AccelerationMuscle_upd_fiber_compressive_force_length_damping(self, *args)

    def set_fiber_compressive_force_length_damping(self, *args):
        r"""
        set_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_fiber_compressive_force_length_damping(Millard2012AccelerationMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_fiber_compressive_force_length_damping(self, *args)

    def copyProperty_fiber_compressive_force_cos_pennation_damping(self, source):
        r"""
        copyProperty_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_fiber_compressive_force_cos_pennation_damping(self, source)

    def append_fiber_compressive_force_cos_pennation_damping(self, value):
        r"""
        append_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_fiber_compressive_force_cos_pennation_damping(self, value)

    def constructProperty_fiber_compressive_force_cos_pennation_damping(self, initValue):
        r"""
        constructProperty_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_fiber_compressive_force_cos_pennation_damping(self, initValue)

    def get_fiber_compressive_force_cos_pennation_damping(self, *args):
        r"""
        get_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle self) -> double const &
        """
        return _actuators.Millard2012AccelerationMuscle_get_fiber_compressive_force_cos_pennation_damping(self, *args)

    def upd_fiber_compressive_force_cos_pennation_damping(self, *args):
        r"""
        upd_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle self) -> double &
        """
        return _actuators.Millard2012AccelerationMuscle_upd_fiber_compressive_force_cos_pennation_damping(self, *args)

    def set_fiber_compressive_force_cos_pennation_damping(self, *args):
        r"""
        set_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_fiber_compressive_force_cos_pennation_damping(Millard2012AccelerationMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_fiber_compressive_force_cos_pennation_damping(self, *args)

    def copyProperty_tendon_force_length_damping(self, source):
        r"""
        copyProperty_tendon_force_length_damping(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_tendon_force_length_damping(self, source)

    def append_tendon_force_length_damping(self, value):
        r"""
        append_tendon_force_length_damping(Millard2012AccelerationMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_tendon_force_length_damping(self, value)

    def constructProperty_tendon_force_length_damping(self, initValue):
        r"""
        constructProperty_tendon_force_length_damping(Millard2012AccelerationMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_tendon_force_length_damping(self, initValue)

    def get_tendon_force_length_damping(self, *args):
        r"""
        get_tendon_force_length_damping(Millard2012AccelerationMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_tendon_force_length_damping(Millard2012AccelerationMuscle self) -> double const &
        """
        return _actuators.Millard2012AccelerationMuscle_get_tendon_force_length_damping(self, *args)

    def upd_tendon_force_length_damping(self, *args):
        r"""
        upd_tendon_force_length_damping(Millard2012AccelerationMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_tendon_force_length_damping(Millard2012AccelerationMuscle self) -> double &
        """
        return _actuators.Millard2012AccelerationMuscle_upd_tendon_force_length_damping(self, *args)

    def set_tendon_force_length_damping(self, *args):
        r"""
        set_tendon_force_length_damping(Millard2012AccelerationMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_tendon_force_length_damping(Millard2012AccelerationMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_tendon_force_length_damping(self, *args)

    def copyProperty_mass(self, source):
        r"""
        copyProperty_mass(Millard2012AccelerationMuscle self, Millard2012AccelerationMuscle source)

        Parameters
        ----------
        source: OpenSim::Millard2012AccelerationMuscle::Self const &

        """
        return _actuators.Millard2012AccelerationMuscle_copyProperty_mass(self, source)

    def append_mass(self, value):
        r"""
        append_mass(Millard2012AccelerationMuscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_append_mass(self, value)

    def constructProperty_mass(self, initValue):
        r"""
        constructProperty_mass(Millard2012AccelerationMuscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_constructProperty_mass(self, initValue)

    def get_mass(self, *args):
        r"""
        get_mass(Millard2012AccelerationMuscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_mass(Millard2012AccelerationMuscle self) -> double const &
        """
        return _actuators.Millard2012AccelerationMuscle_get_mass(self, *args)

    def upd_mass(self, *args):
        r"""
        upd_mass(Millard2012AccelerationMuscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_mass(Millard2012AccelerationMuscle self) -> double &
        """
        return _actuators.Millard2012AccelerationMuscle_upd_mass(self, *args)

    def set_mass(self, *args):
        r"""
        set_mass(Millard2012AccelerationMuscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_mass(Millard2012AccelerationMuscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.Millard2012AccelerationMuscle_set_mass(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor: produces a non-functional empty muscle

        |

        *Overload 2:*
        Constructs a functional muscle using all of the default curves and
               activation model.

               :type aName: string
               :param aName: The name of the muscle.

               :type aMaxIsometricForce: float
               :param aMaxIsometricForce:
                    The force generated by the muscle when it at its optimal resting length,
                    has a contraction velocity of zero, and is fully activated
                    (Newtons).

               :type aOptimalFiberLength: float
               :param aOptimalFiberLength:
                    The optimal length of the muscle fiber (meters).

               :type aTendonSlackLength: float
               :param aTendonSlackLength:
                    The resting length of the tendon (meters).

               :type aPennationAngle: float
               :param aPennationAngle:
                    The angle of the fiber relative to the tendon when the fiber is at its
                    optimal resting length (radians).
        """
        _actuators.Millard2012AccelerationMuscle_swiginit(self, _actuators.new_Millard2012AccelerationMuscle(*args))

    def getFiberCompressiveForceLengthMultiplier(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :rtype: float
        :return: the normalized force term associated with the compressive force length
                   element, :math:`\mathbf{f}_K(\hat{l}_{CE})`, in the equilibrium equation
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberCompressiveForceLengthMultiplier(self, s)

    def getFiberCompressiveForceCosPennationMultiplier(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :rtype: float
        :return: the normalized force term associated with the compressive force
                    cosine pennation element, :math:`\mathbf{f}_{c\phi}(\cos \phi)`, in the
                    equilibrium equation
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberCompressiveForceCosPennationMultiplier(self, s)

    def getTendonForceMultiplier(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :rtype: float
        :return: the normalized force term associated with tendon element,
                     :math:`\mathbf{f}_{SE}(\hat{l}_{T})`, in the equilibrium equation
        """
        return _actuators.Millard2012AccelerationMuscle_getTendonForceMultiplier(self, s)

    def getMass(self):
        r"""
        :rtype: float
        :return: the size of the mass between the tendon and fiber
        """
        return _actuators.Millard2012AccelerationMuscle_getMass(self)

    def getActivationModel(self):
        r"""
        :rtype: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :return: the MuscleFirstOrderActivationDynamicModel
                     that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getActivationModel(self)

    def getPennationModel(self):
        r"""
        :rtype: :py:class:`MuscleFixedWidthPennationModel`
        :return: the MuscleFixedWidthPennationModel
                     that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getPennationModel(self)

    def getActiveForceLengthCurve(self):
        r"""
        :rtype: :py:class:`ActiveForceLengthCurve`
        :return: the ActiveForceLengthCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getActiveForceLengthCurve(self)

    def getForceVelocityCurve(self):
        r"""
        :rtype: :py:class:`ForceVelocityCurve`
        :return: the ForceVelocityInverseCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getForceVelocityCurve(self)

    def getFiberForceLengthCurve(self):
        r"""
        :rtype: :py:class:`FiberForceLengthCurve`
        :return: the FiberForceLengthCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberForceLengthCurve(self)

    def getTendonForceLengthCurve(self):
        r"""
        :rtype: :py:class:`TendonForceLengthCurve`
        :return: the TendonForceLengthCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getTendonForceLengthCurve(self)

    def getFiberCompressiveForceLengthCurve(self):
        r"""
        :rtype: :py:class:`FiberCompressiveForceLengthCurve`
        :return: the FiberCompressiveForceLengthCurve that this muscle model uses
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberCompressiveForceLengthCurve(self)

    def getFiberCompressiveForceCosPennationCurve(self):
        r"""
        :rtype: :py:class:`FiberCompressiveForceCosPennationCurve`
        :return: the FiberCompressiveForceCosPennationCurve that this muscle
                     model uses.
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberCompressiveForceCosPennationCurve(self)

    def getFiberStiffnessAlongTendon(self, s):
        r"""
        :rtype: float
        :return: the stiffness of the muscle fibers along the tendon (N/m)
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberStiffnessAlongTendon(self, s)

    def setActivationModel(self, aActivationMdl):
        r"""
        :type aActivationMdl: :py:class:`MuscleFirstOrderActivationDynamicModel`
        :param aActivationMdl: the MuscleFirstOrderActivationDynamicModel that this
                                  muscle model uses to simulate activation dynamics
        """
        return _actuators.Millard2012AccelerationMuscle_setActivationModel(self, aActivationMdl)

    def setActiveForceLengthCurve(self, aActiveForceLengthCurve):
        r"""
        :type aActiveForceLengthCurve: :py:class:`ActiveForceLengthCurve`
        :param aActiveForceLengthCurve: the ActiveForceLengthCurve that this muscle
                                    model uses to scale active fiber force as a function
                                    of length
        """
        return _actuators.Millard2012AccelerationMuscle_setActiveForceLengthCurve(self, aActiveForceLengthCurve)

    def setForceVelocityCurve(self, aForceVelocityCurve):
        r"""
        :type aForceVelocityCurve: :py:class:`ForceVelocityCurve`
        :param aForceVelocityCurve: the ForceVelocityCurve that this
                                    muscle model uses to calculate the derivative of
                                    fiber length.
        """
        return _actuators.Millard2012AccelerationMuscle_setForceVelocityCurve(self, aForceVelocityCurve)

    def setFiberForceLengthCurve(self, aFiberForceLengthCurve):
        r"""
        :type aFiberForceLengthCurve: :py:class:`FiberForceLengthCurve`
        :param aFiberForceLengthCurve: the FiberForceLengthCurve that this muscle
                                    model uses to calculate the passive force the muscle
                                    fiber generates as the length of the fiber changes
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberForceLengthCurve(self, aFiberForceLengthCurve)

    def setTendonForceLengthCurve(self, aTendonForceLengthCurve):
        r"""
        :type aTendonForceLengthCurve: :py:class:`TendonForceLengthCurve`
        :param aTendonForceLengthCurve: the TendonForceLengthCurve that this muscle
                                    model uses to define the tendon force length curve
        """
        return _actuators.Millard2012AccelerationMuscle_setTendonForceLengthCurve(self, aTendonForceLengthCurve)

    def setFiberCompressiveForceLengthCurve(self, aFiberCompressiveForceLengthCurve):
        r"""
        :type aFiberCompressiveForceLengthCurve: :py:class:`FiberCompressiveForceLengthCurve`
        :param aFiberCompressiveForceLengthCurve: the
                    FiberCompressiveForceLengthCurve that this muscle model uses to
                    ensure the length of the fiber is always greater than a physically
                    realistic lower bound.
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberCompressiveForceLengthCurve(self, aFiberCompressiveForceLengthCurve)

    def setFiberCompressiveForceCosPennationCurve(self, aFiberCompressiveForceCosPennationCurve):
        r"""
        :type aFiberCompressiveForceCosPennationCurve: :py:class:`FiberCompressiveForceCosPennationCurve`
        :param aFiberCompressiveForceCosPennationCurve: the
                    FiberCompressiveForceCosPennationCurve that this muscle model uses
                    to prevent pennation angles from approaching 90 degrees, which is
                    associated with a singularity in this model.
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberCompressiveForceCosPennationCurve(self, aFiberCompressiveForceCosPennationCurve)

    def setMass(self, mass):
        r"""
        :type mass: float
        :param mass:
                    The size of the mass parameter between the fiber and the tendon.
                    Making this parameter small will make the muscle model more rapidly
                    converge to the results an equilibrium model would produce.

        **Conditions**
                mass >= 0.001
        """
        return _actuators.Millard2012AccelerationMuscle_setMass(self, mass)

    def getDefaultActivation(self):
        r"""
        :rtype: float
        :return: the default activation level that is used as an initial condition
                     if none is provided by the user.
        """
        return _actuators.Millard2012AccelerationMuscle_getDefaultActivation(self)

    def getDefaultFiberLength(self):
        r"""
        :rtype: float
        :return: the default fiber length that is used as an initial condition
                     if none is provided by the user.
        """
        return _actuators.Millard2012AccelerationMuscle_getDefaultFiberLength(self)

    def getDefaultFiberVelocity(self):
        r"""
        :rtype: float
        :return: the default fiber velocity that is used as an initial condition
                     if none is provided by the user.
        """
        return _actuators.Millard2012AccelerationMuscle_getDefaultFiberVelocity(self)

    def getActivationRate(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system
        :rtype: float
        :return: the time derivative of activation
        """
        return _actuators.Millard2012AccelerationMuscle_getActivationRate(self, s)

    def getFiberVelocity(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system
        :rtype: float
        :return: the velocity of the fiber (m/s)
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberVelocity(self, s)

    def getFiberAcceleration(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: The state of the system
        :rtype: float
        :return: the acceleration of the fiber (m/s)
        """
        return _actuators.Millard2012AccelerationMuscle_getFiberAcceleration(self, s)

    def setDefaultActivation(self, activation):
        r"""
        :type activation: float
        :param activation: the default activation level that is used to initialize
                   the muscle
        """
        return _actuators.Millard2012AccelerationMuscle_setDefaultActivation(self, activation)

    def setDefaultFiberLength(self, fiberLength):
        r"""
        :type fiberLength: float
        :param fiberLength: the default fiber length that is used to initialize
                   the muscle
        """
        return _actuators.Millard2012AccelerationMuscle_setDefaultFiberLength(self, fiberLength)

    def setDefaultFiberVelocity(self, fiberVelocity):
        r"""
        :type fiberVelocity: float
        :param fiberVelocity: the default fiber velocity that is used to initialize
                   the muscle
        """
        return _actuators.Millard2012AccelerationMuscle_setDefaultFiberVelocity(self, fiberVelocity)

    def setActivation(self, s, activation):
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :type activation: float
        :param activation: the desired activation level
        """
        return _actuators.Millard2012AccelerationMuscle_setActivation(self, s, activation)

    def setFiberLength(self, s, fiberLength):
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :type fiberLength: float
        :param fiberLength: the desired fiber length (m)
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberLength(self, s, fiberLength)

    def setFiberVelocity(self, s, fiberVelocity):
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :type fiberVelocity: float
        :param fiberVelocity: the desired fiber velocity (m/s)
        """
        return _actuators.Millard2012AccelerationMuscle_setFiberVelocity(self, s, fiberVelocity)

    def computeActuation(self, s):
        r"""
        :type s: :py:class:`State`
        :param s: the state of the system
        :rtype: float
        :return: the tensile force the muscle is generating in N
        """
        return _actuators.Millard2012AccelerationMuscle_computeActuation(self, s)

    def computeInitialFiberEquilibrium(self, s):
        r"""
        This function computes the fiber length such that muscle fiber and
               tendon are developing the same force, and so that the velocity of
               the entire muscle-tendon is spread between the fiber and the tendon
               according to their relative compliances.

               :type s: :py:class:`State`
               :param s: the state of the system
               :raises: MuscleCannotEquilibrate
        """
        return _actuators.Millard2012AccelerationMuscle_computeInitialFiberEquilibrium(self, s)

    def calcInextensibleTendonActiveFiberForce(self, s, aActivation):
        r"""Conditional comment: DEPRECATED"""
        return _actuators.Millard2012AccelerationMuscle_calcInextensibleTendonActiveFiberForce(self, s, aActivation)

    def calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity):
        r"""
        calcActiveFiberForceAlongTendon(Millard2012AccelerationMuscle self, double activation, double fiberLength, double fiberVelocity) -> double

        Parameters
        ----------
        activation: double
        fiberLength: double
        fiberVelocity: double

        """
        return _actuators.Millard2012AccelerationMuscle_calcActiveFiberForceAlongTendon(self, activation, fiberLength, fiberVelocity)

    def extendPostScale(self, s, scaleSet):
        r"""
        End of conditional comment. Adjust the properties of the muscle after the model has been scaled. The
                optimal fiber length and tendon slack length are each multiplied by the
                ratio of the current path length and the path length before scaling.
        """
        return _actuators.Millard2012AccelerationMuscle_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _actuators.delete_Millard2012AccelerationMuscle

# Register Millard2012AccelerationMuscle in _actuators:
_actuators.Millard2012AccelerationMuscle_swigregister(Millard2012AccelerationMuscle)
class McKibbenActuator(opensim.simulation.PathActuator):
    r"""
    McKibben Pneumatic Actuator Model based on the simple cylindrical
    formulation described in J. Dyn. Sys., Meas., Control 122, 386-388
    (1998) (3 pages); doi:10.1115/1.482478.

    Pressure is used as a control signal. There is an optional 'cord'
    attached to the actuator which allows for the path length of the actuator
    to be shorter than the total distance spanned by the points to which the
    actuator is connected. By default its length is zero. Please
    refer to the above paper for details regarding the rest of the
    properties.

    Author: Nabeel Allana
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> McKibbenActuator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.McKibbenActuator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(McKibbenActuator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.McKibbenActuator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.McKibbenActuator_getClassName()

    def clone(self):
        r"""clone(McKibbenActuator self) -> McKibbenActuator"""
        return _actuators.McKibbenActuator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(McKibbenActuator self) -> std::string const &"""
        return _actuators.McKibbenActuator_getConcreteClassName(self)

    def copyProperty_thread_length(self, source):
        r"""
        copyProperty_thread_length(McKibbenActuator self, McKibbenActuator source)

        Parameters
        ----------
        source: OpenSim::McKibbenActuator::Self const &

        """
        return _actuators.McKibbenActuator_copyProperty_thread_length(self, source)

    def append_thread_length(self, value):
        r"""
        append_thread_length(McKibbenActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.McKibbenActuator_append_thread_length(self, value)

    def constructProperty_thread_length(self, initValue):
        r"""
        constructProperty_thread_length(McKibbenActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.McKibbenActuator_constructProperty_thread_length(self, initValue)

    def get_thread_length(self, *args):
        r"""
        get_thread_length(McKibbenActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_thread_length(McKibbenActuator self) -> double const &
        """
        return _actuators.McKibbenActuator_get_thread_length(self, *args)

    def upd_thread_length(self, *args):
        r"""
        upd_thread_length(McKibbenActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_thread_length(McKibbenActuator self) -> double &
        """
        return _actuators.McKibbenActuator_upd_thread_length(self, *args)

    def set_thread_length(self, *args):
        r"""
        set_thread_length(McKibbenActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_thread_length(McKibbenActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.McKibbenActuator_set_thread_length(self, *args)

    def copyProperty_number_of_turns(self, source):
        r"""
        copyProperty_number_of_turns(McKibbenActuator self, McKibbenActuator source)

        Parameters
        ----------
        source: OpenSim::McKibbenActuator::Self const &

        """
        return _actuators.McKibbenActuator_copyProperty_number_of_turns(self, source)

    def append_number_of_turns(self, value):
        r"""
        append_number_of_turns(McKibbenActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.McKibbenActuator_append_number_of_turns(self, value)

    def constructProperty_number_of_turns(self, initValue):
        r"""
        constructProperty_number_of_turns(McKibbenActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.McKibbenActuator_constructProperty_number_of_turns(self, initValue)

    def get_number_of_turns(self, *args):
        r"""
        get_number_of_turns(McKibbenActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_number_of_turns(McKibbenActuator self) -> double const &
        """
        return _actuators.McKibbenActuator_get_number_of_turns(self, *args)

    def upd_number_of_turns(self, *args):
        r"""
        upd_number_of_turns(McKibbenActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_number_of_turns(McKibbenActuator self) -> double &
        """
        return _actuators.McKibbenActuator_upd_number_of_turns(self, *args)

    def set_number_of_turns(self, *args):
        r"""
        set_number_of_turns(McKibbenActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_number_of_turns(McKibbenActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.McKibbenActuator_set_number_of_turns(self, *args)

    def copyProperty_cord_length(self, source):
        r"""
        copyProperty_cord_length(McKibbenActuator self, McKibbenActuator source)

        Parameters
        ----------
        source: OpenSim::McKibbenActuator::Self const &

        """
        return _actuators.McKibbenActuator_copyProperty_cord_length(self, source)

    def append_cord_length(self, value):
        r"""
        append_cord_length(McKibbenActuator self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.McKibbenActuator_append_cord_length(self, value)

    def constructProperty_cord_length(self, initValue):
        r"""
        constructProperty_cord_length(McKibbenActuator self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.McKibbenActuator_constructProperty_cord_length(self, initValue)

    def get_cord_length(self, *args):
        r"""
        get_cord_length(McKibbenActuator self, int i) -> double const

        Parameters
        ----------
        i: int

        get_cord_length(McKibbenActuator self) -> double const &
        """
        return _actuators.McKibbenActuator_get_cord_length(self, *args)

    def upd_cord_length(self, *args):
        r"""
        upd_cord_length(McKibbenActuator self, int i) -> double

        Parameters
        ----------
        i: int

        upd_cord_length(McKibbenActuator self) -> double &
        """
        return _actuators.McKibbenActuator_upd_cord_length(self, *args)

    def set_cord_length(self, *args):
        r"""
        set_cord_length(McKibbenActuator self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_cord_length(McKibbenActuator self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.McKibbenActuator_set_cord_length(self, *args)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor leaves body names unspecified. *

        |

        *Overload 2:*
        Convenience constructor for API users. *
        """
        _actuators.McKibbenActuator_swiginit(self, _actuators.new_McKibbenActuator(*args))

    def setNumberOfTurns(self, val):
        r""" %Set the 'number of turns' property. *"""
        return _actuators.McKibbenActuator_setNumberOfTurns(self, val)

    def getNumberOfTurns(self):
        r""" Get the current value of the 'number of turns' property. *"""
        return _actuators.McKibbenActuator_getNumberOfTurns(self)

    def setThreadLength(self, val):
        r""" %Set the 'thread length' property. *"""
        return _actuators.McKibbenActuator_setThreadLength(self, val)

    def getThreadLength(self):
        r""" Get the current value of the 'thread length' property. *"""
        return _actuators.McKibbenActuator_getThreadLength(self)

    def setCordLength(self, val):
        r""" %Set the 'cord length' property. *"""
        return _actuators.McKibbenActuator_setCordLength(self, val)

    def getCordLength(self):
        r""" Get the current value of the 'cord length' property. *"""
        return _actuators.McKibbenActuator_getCordLength(self)

    def computeActuation(self, s):
        r""" Compute actuation for current state. *"""
        return _actuators.McKibbenActuator_computeActuation(self, s)
    __swig_destroy__ = _actuators.delete_McKibbenActuator

# Register McKibbenActuator in _actuators:
_actuators.McKibbenActuator_swigregister(McKibbenActuator)
class DeGrooteFregly2016Muscle(opensim.simulation.Muscle):
    r"""
     This muscle model was published in De Groote et al. (2016).

    The parameters of the active force-length and force-velocity curves have
    been slightly modified from what was published to ensure the curves go
    through key points:
    - Active force-length curve goes through (1, 1).
    - Force-velocity curve goes through (-1, 0) and (0, 1).
    The default tendon force curve parameters are modified from that in De
    Groote et al., 2016: the curve is parameterized by the strain at 1 norm
    force (rather than "kT"), and the default value for this parameter is
    0.049 (same as in TendonForceLengthCurve) rather than 0.0474.

    This implementation introduces the property 'active_force_width_scale' as
    an addition to the original model, which allows users to effectively make
    the active force-length curve wider. This property may be useful for
    improving the force-generating capacity of a muscle without increasing
    maximum isometric force. This property works by scaling the normalized
    fiber length when the active force-length curve is computed. For example,
    a scale factor of 2 means that the fiber muscle traverses half as far
    along the force-length curve in either direction.

    This implementation adds fiber damping as an addition to the original model.
    Users can specify this via the 'fiber_damping' property, and damping force
    along the fiber is computed by multiplying the property value by the
    normalized fiber velocity and max isometric force. If using this muscle for
    optimization, fiber damping is recommended as it can improve convergence.

    Notes: If converting from Thelen2003Muscles via replaceMuscles(), fiber
       damping will be set to zero since there is no damping in that muscle
       model.

    This class supports tendon compliance dynamics in both explicit and implicit
    form (formulations 1 and 3 from De Groote et al. 2016). Both forms of the
    dynamics use normalized tendon force as the state variable (rather than the
    typical fiber length state). The explicit form is handled through the usual
    Component dynamics interface. The implicit form introduces an additional
    discrete state variable and cache variable in the SimTK::State for the
    derivative of normalized tendon force and muscle-tendon equilibrium residual
    respectively. In general, it is preferable to use the implicit form in
    optimization since it can be robust to arbitrary initial guesses (see De
    Groote et al. 2016). However, the implicit form is only for use with solvers
    that support implicit dynamics (i.e. Moco) and cannot be used to perform a
    time-stepping forward simulation with Manager; use explicit mode for
    time-stepping.


    The acceptable bounds for each property are enforced at model initialization.
    These bounds are:
     - activation_time_constant: (0, inf]
     - deactivation_time_constant: (0, inf]
     - activation_dynamics_smoothing: (0, inf]
     - active_force_width_scale: [1, inf]
     - fiber_damping: [0, inf]
     - passive_fiber_strain_at_one_norm_force: (0, inf]
     - tendon_strain_at_one_norm_force: (0, inf]
     - pennation_angle_at_optimal: [0, Pi/2)
     - default_activation: (0, inf]
     - default_normalized_tendon_force: [0, 5]

    The methods getMinNormalizedTendonForce() and
          getMaxNormalizedTendonForce() provide these bounds for use in custom
          solvers.

    The default value for activation_dynamics_smoothing is set to 0.1 to
          match the originally published model, but a value of 10 is recommended
          to achieve activation and deactivation speeds closer to the intended
          time constants.

    Muscle properties can be optimized using MocoParameter. The acceptable
    bounds for each property are **not** enforced during parameter optimization, so
    the user must supply these bounds to MocoParameter.

    The properties `default_activation` and `default_normalized_tendon_force`
    cannot be optimized because they are applied during model initialization only.



    The documentation for Muscle::MuscleLengthInfo states that the
    optimalFiberLength of a muscle is also its resting length, but this is not
    true for this muscle: there is a non-zero passive fiber force at the
    optimal fiber length.

    In the Muscle class, setIgnoreTendonCompliance() and
    setIngoreActivationDynamics() control modeling options, meaning these
    settings could theoretically be changed. However, for this class, the
    modeling option is ignored and the values of the ignore_tendon_compliance
    and ignore_activation_dynamics properties are used directly.

    De Groote, F., Kinney, A. L., Rao, A. V., & Fregly, B. J. (2016). Evaluation
    of Direct Collocation Optimal Control Problem Formulations for Solving the
    Muscle Redundancy Problem. Annals of Biomedical Engineering, 44(10), 1–15.
    http://doi.org/10.1007/s10439-016-1591-9
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> DeGrooteFregly2016Muscle

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.DeGrooteFregly2016Muscle_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(DeGrooteFregly2016Muscle self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.DeGrooteFregly2016Muscle_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.DeGrooteFregly2016Muscle_getClassName()

    def clone(self):
        r"""clone(DeGrooteFregly2016Muscle self) -> DeGrooteFregly2016Muscle"""
        return _actuators.DeGrooteFregly2016Muscle_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(DeGrooteFregly2016Muscle self) -> std::string const &"""
        return _actuators.DeGrooteFregly2016Muscle_getConcreteClassName(self)

    def copyProperty_activation_time_constant(self, source):
        r"""
        copyProperty_activation_time_constant(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_activation_time_constant(self, source)

    def append_activation_time_constant(self, value):
        r"""
        append_activation_time_constant(DeGrooteFregly2016Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_activation_time_constant(self, value)

    def constructProperty_activation_time_constant(self, initValue):
        r"""
        constructProperty_activation_time_constant(DeGrooteFregly2016Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_activation_time_constant(self, initValue)

    def get_activation_time_constant(self, *args):
        r"""
        get_activation_time_constant(DeGrooteFregly2016Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_time_constant(DeGrooteFregly2016Muscle self) -> double const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_activation_time_constant(self, *args)

    def upd_activation_time_constant(self, *args):
        r"""
        upd_activation_time_constant(DeGrooteFregly2016Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_time_constant(DeGrooteFregly2016Muscle self) -> double &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_activation_time_constant(self, *args)

    def set_activation_time_constant(self, *args):
        r"""
        set_activation_time_constant(DeGrooteFregly2016Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_time_constant(DeGrooteFregly2016Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_activation_time_constant(self, *args)

    def copyProperty_deactivation_time_constant(self, source):
        r"""
        copyProperty_deactivation_time_constant(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_deactivation_time_constant(self, source)

    def append_deactivation_time_constant(self, value):
        r"""
        append_deactivation_time_constant(DeGrooteFregly2016Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_deactivation_time_constant(self, value)

    def constructProperty_deactivation_time_constant(self, initValue):
        r"""
        constructProperty_deactivation_time_constant(DeGrooteFregly2016Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_deactivation_time_constant(self, initValue)

    def get_deactivation_time_constant(self, *args):
        r"""
        get_deactivation_time_constant(DeGrooteFregly2016Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_deactivation_time_constant(DeGrooteFregly2016Muscle self) -> double const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_deactivation_time_constant(self, *args)

    def upd_deactivation_time_constant(self, *args):
        r"""
        upd_deactivation_time_constant(DeGrooteFregly2016Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_deactivation_time_constant(DeGrooteFregly2016Muscle self) -> double &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_deactivation_time_constant(self, *args)

    def set_deactivation_time_constant(self, *args):
        r"""
        set_deactivation_time_constant(DeGrooteFregly2016Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_deactivation_time_constant(DeGrooteFregly2016Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_deactivation_time_constant(self, *args)

    def copyProperty_default_activation(self, source):
        r"""
        copyProperty_default_activation(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_default_activation(self, source)

    def append_default_activation(self, value):
        r"""
        append_default_activation(DeGrooteFregly2016Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_default_activation(self, value)

    def constructProperty_default_activation(self, initValue):
        r"""
        constructProperty_default_activation(DeGrooteFregly2016Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_default_activation(self, initValue)

    def get_default_activation(self, *args):
        r"""
        get_default_activation(DeGrooteFregly2016Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_activation(DeGrooteFregly2016Muscle self) -> double const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_default_activation(self, *args)

    def upd_default_activation(self, *args):
        r"""
        upd_default_activation(DeGrooteFregly2016Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_activation(DeGrooteFregly2016Muscle self) -> double &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_default_activation(self, *args)

    def set_default_activation(self, *args):
        r"""
        set_default_activation(DeGrooteFregly2016Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_activation(DeGrooteFregly2016Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_default_activation(self, *args)

    def copyProperty_default_normalized_tendon_force(self, source):
        r"""
        copyProperty_default_normalized_tendon_force(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_default_normalized_tendon_force(self, source)

    def append_default_normalized_tendon_force(self, value):
        r"""
        append_default_normalized_tendon_force(DeGrooteFregly2016Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_default_normalized_tendon_force(self, value)

    def constructProperty_default_normalized_tendon_force(self, initValue):
        r"""
        constructProperty_default_normalized_tendon_force(DeGrooteFregly2016Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_default_normalized_tendon_force(self, initValue)

    def get_default_normalized_tendon_force(self, *args):
        r"""
        get_default_normalized_tendon_force(DeGrooteFregly2016Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_default_normalized_tendon_force(DeGrooteFregly2016Muscle self) -> double const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_default_normalized_tendon_force(self, *args)

    def upd_default_normalized_tendon_force(self, *args):
        r"""
        upd_default_normalized_tendon_force(DeGrooteFregly2016Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_default_normalized_tendon_force(DeGrooteFregly2016Muscle self) -> double &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_default_normalized_tendon_force(self, *args)

    def set_default_normalized_tendon_force(self, *args):
        r"""
        set_default_normalized_tendon_force(DeGrooteFregly2016Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_default_normalized_tendon_force(DeGrooteFregly2016Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_default_normalized_tendon_force(self, *args)

    def copyProperty_active_force_width_scale(self, source):
        r"""
        copyProperty_active_force_width_scale(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_active_force_width_scale(self, source)

    def append_active_force_width_scale(self, value):
        r"""
        append_active_force_width_scale(DeGrooteFregly2016Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_active_force_width_scale(self, value)

    def constructProperty_active_force_width_scale(self, initValue):
        r"""
        constructProperty_active_force_width_scale(DeGrooteFregly2016Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_active_force_width_scale(self, initValue)

    def get_active_force_width_scale(self, *args):
        r"""
        get_active_force_width_scale(DeGrooteFregly2016Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_active_force_width_scale(DeGrooteFregly2016Muscle self) -> double const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_active_force_width_scale(self, *args)

    def upd_active_force_width_scale(self, *args):
        r"""
        upd_active_force_width_scale(DeGrooteFregly2016Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_active_force_width_scale(DeGrooteFregly2016Muscle self) -> double &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_active_force_width_scale(self, *args)

    def set_active_force_width_scale(self, *args):
        r"""
        set_active_force_width_scale(DeGrooteFregly2016Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_active_force_width_scale(DeGrooteFregly2016Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_active_force_width_scale(self, *args)

    def copyProperty_fiber_damping(self, source):
        r"""
        copyProperty_fiber_damping(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_fiber_damping(self, source)

    def append_fiber_damping(self, value):
        r"""
        append_fiber_damping(DeGrooteFregly2016Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_fiber_damping(self, value)

    def constructProperty_fiber_damping(self, initValue):
        r"""
        constructProperty_fiber_damping(DeGrooteFregly2016Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_fiber_damping(self, initValue)

    def get_fiber_damping(self, *args):
        r"""
        get_fiber_damping(DeGrooteFregly2016Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_fiber_damping(DeGrooteFregly2016Muscle self) -> double const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_fiber_damping(self, *args)

    def upd_fiber_damping(self, *args):
        r"""
        upd_fiber_damping(DeGrooteFregly2016Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_fiber_damping(DeGrooteFregly2016Muscle self) -> double &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_fiber_damping(self, *args)

    def set_fiber_damping(self, *args):
        r"""
        set_fiber_damping(DeGrooteFregly2016Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_fiber_damping(DeGrooteFregly2016Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_fiber_damping(self, *args)

    def copyProperty_ignore_passive_fiber_force(self, source):
        r"""
        copyProperty_ignore_passive_fiber_force(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_ignore_passive_fiber_force(self, source)

    def append_ignore_passive_fiber_force(self, value):
        r"""
        append_ignore_passive_fiber_force(DeGrooteFregly2016Muscle self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_ignore_passive_fiber_force(self, value)

    def constructProperty_ignore_passive_fiber_force(self, initValue):
        r"""
        constructProperty_ignore_passive_fiber_force(DeGrooteFregly2016Muscle self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_ignore_passive_fiber_force(self, initValue)

    def get_ignore_passive_fiber_force(self, *args):
        r"""
        get_ignore_passive_fiber_force(DeGrooteFregly2016Muscle self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_ignore_passive_fiber_force(DeGrooteFregly2016Muscle self) -> bool const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_ignore_passive_fiber_force(self, *args)

    def upd_ignore_passive_fiber_force(self, *args):
        r"""
        upd_ignore_passive_fiber_force(DeGrooteFregly2016Muscle self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_ignore_passive_fiber_force(DeGrooteFregly2016Muscle self) -> bool &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_ignore_passive_fiber_force(self, *args)

    def set_ignore_passive_fiber_force(self, *args):
        r"""
        set_ignore_passive_fiber_force(DeGrooteFregly2016Muscle self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_ignore_passive_fiber_force(DeGrooteFregly2016Muscle self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_ignore_passive_fiber_force(self, *args)

    def copyProperty_passive_fiber_strain_at_one_norm_force(self, source):
        r"""
        copyProperty_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_passive_fiber_strain_at_one_norm_force(self, source)

    def append_passive_fiber_strain_at_one_norm_force(self, value):
        r"""
        append_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_passive_fiber_strain_at_one_norm_force(self, value)

    def constructProperty_passive_fiber_strain_at_one_norm_force(self, initValue):
        r"""
        constructProperty_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_passive_fiber_strain_at_one_norm_force(self, initValue)

    def get_passive_fiber_strain_at_one_norm_force(self, *args):
        r"""
        get_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle self) -> double const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_passive_fiber_strain_at_one_norm_force(self, *args)

    def upd_passive_fiber_strain_at_one_norm_force(self, *args):
        r"""
        upd_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle self) -> double &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_passive_fiber_strain_at_one_norm_force(self, *args)

    def set_passive_fiber_strain_at_one_norm_force(self, *args):
        r"""
        set_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_passive_fiber_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_passive_fiber_strain_at_one_norm_force(self, *args)

    def copyProperty_tendon_strain_at_one_norm_force(self, source):
        r"""
        copyProperty_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_tendon_strain_at_one_norm_force(self, source)

    def append_tendon_strain_at_one_norm_force(self, value):
        r"""
        append_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_tendon_strain_at_one_norm_force(self, value)

    def constructProperty_tendon_strain_at_one_norm_force(self, initValue):
        r"""
        constructProperty_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_tendon_strain_at_one_norm_force(self, initValue)

    def get_tendon_strain_at_one_norm_force(self, *args):
        r"""
        get_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle self) -> double const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_tendon_strain_at_one_norm_force(self, *args)

    def upd_tendon_strain_at_one_norm_force(self, *args):
        r"""
        upd_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle self) -> double &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_tendon_strain_at_one_norm_force(self, *args)

    def set_tendon_strain_at_one_norm_force(self, *args):
        r"""
        set_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_tendon_strain_at_one_norm_force(DeGrooteFregly2016Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_tendon_strain_at_one_norm_force(self, *args)

    def copyProperty_tendon_compliance_dynamics_mode(self, source):
        r"""
        copyProperty_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_tendon_compliance_dynamics_mode(self, source)

    def append_tendon_compliance_dynamics_mode(self, value):
        r"""
        append_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_tendon_compliance_dynamics_mode(self, value)

    def constructProperty_tendon_compliance_dynamics_mode(self, initValue):
        r"""
        constructProperty_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_tendon_compliance_dynamics_mode(self, initValue)

    def get_tendon_compliance_dynamics_mode(self, *args):
        r"""
        get_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle self) -> std::string const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_tendon_compliance_dynamics_mode(self, *args)

    def upd_tendon_compliance_dynamics_mode(self, *args):
        r"""
        upd_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle self) -> std::string &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_tendon_compliance_dynamics_mode(self, *args)

    def set_tendon_compliance_dynamics_mode(self, *args):
        r"""
        set_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_tendon_compliance_dynamics_mode(DeGrooteFregly2016Muscle self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_tendon_compliance_dynamics_mode(self, *args)

    def copyProperty_activation_dynamics_smoothing(self, source):
        r"""
        copyProperty_activation_dynamics_smoothing(DeGrooteFregly2016Muscle self, DeGrooteFregly2016Muscle source)

        Parameters
        ----------
        source: OpenSim::DeGrooteFregly2016Muscle::Self const &

        """
        return _actuators.DeGrooteFregly2016Muscle_copyProperty_activation_dynamics_smoothing(self, source)

    def append_activation_dynamics_smoothing(self, value):
        r"""
        append_activation_dynamics_smoothing(DeGrooteFregly2016Muscle self, double const & value) -> int

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_append_activation_dynamics_smoothing(self, value)

    def constructProperty_activation_dynamics_smoothing(self, initValue):
        r"""
        constructProperty_activation_dynamics_smoothing(DeGrooteFregly2016Muscle self, double const & initValue)

        Parameters
        ----------
        initValue: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_constructProperty_activation_dynamics_smoothing(self, initValue)

    def get_activation_dynamics_smoothing(self, *args):
        r"""
        get_activation_dynamics_smoothing(DeGrooteFregly2016Muscle self, int i) -> double const

        Parameters
        ----------
        i: int

        get_activation_dynamics_smoothing(DeGrooteFregly2016Muscle self) -> double const &
        """
        return _actuators.DeGrooteFregly2016Muscle_get_activation_dynamics_smoothing(self, *args)

    def upd_activation_dynamics_smoothing(self, *args):
        r"""
        upd_activation_dynamics_smoothing(DeGrooteFregly2016Muscle self, int i) -> double

        Parameters
        ----------
        i: int

        upd_activation_dynamics_smoothing(DeGrooteFregly2016Muscle self) -> double &
        """
        return _actuators.DeGrooteFregly2016Muscle_upd_activation_dynamics_smoothing(self, *args)

    def set_activation_dynamics_smoothing(self, *args):
        r"""
        set_activation_dynamics_smoothing(DeGrooteFregly2016Muscle self, int i, double const & value)

        Parameters
        ----------
        i: int
        value: double const &

        set_activation_dynamics_smoothing(DeGrooteFregly2016Muscle self, double const & value)

        Parameters
        ----------
        value: double const &

        """
        return _actuators.DeGrooteFregly2016Muscle_set_activation_dynamics_smoothing(self, *args)
    _has_output_passive_fiber_elastic_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_set, doc=r"""_has_output_passive_fiber_elastic_force : bool""")
    _has_output_passive_fiber_elastic_force_along_tendon = property(_actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_along_tendon_get, _actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_elastic_force_along_tendon_set, doc=r"""_has_output_passive_fiber_elastic_force_along_tendon : bool""")
    _has_output_passive_fiber_damping_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_set, doc=r"""_has_output_passive_fiber_damping_force : bool""")
    _has_output_passive_fiber_damping_force_along_tendon = property(_actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_along_tendon_get, _actuators.DeGrooteFregly2016Muscle__has_output_passive_fiber_damping_force_along_tendon_set, doc=r"""_has_output_passive_fiber_damping_force_along_tendon : bool""")
    _has_output_implicitresidual_normalized_tendon_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_implicitresidual_normalized_tendon_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_implicitresidual_normalized_tendon_force_set, doc=r"""_has_output_implicitresidual_normalized_tendon_force : bool""")
    _has_output_implicitenabled_normalized_tendon_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_implicitenabled_normalized_tendon_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_implicitenabled_normalized_tendon_force_set, doc=r"""_has_output_implicitenabled_normalized_tendon_force : bool""")
    _has_output_statebounds_normalized_tendon_force = property(_actuators.DeGrooteFregly2016Muscle__has_output_statebounds_normalized_tendon_force_get, _actuators.DeGrooteFregly2016Muscle__has_output_statebounds_normalized_tendon_force_set, doc=r"""_has_output_statebounds_normalized_tendon_force : bool""")

    def __init__(self):
        r"""__init__(DeGrooteFregly2016Muscle self) -> DeGrooteFregly2016Muscle"""
        _actuators.DeGrooteFregly2016Muscle_swiginit(self, _actuators.new_DeGrooteFregly2016Muscle())

    def getActivation(self, s):
        r""" If ignore_activation_dynamics is true, this gets excitation instead."""
        return _actuators.DeGrooteFregly2016Muscle_getActivation(self, s)

    def setActivation(self, s, activation):
        r""" If ignore_activation_dynamics is true, this sets excitation instead."""
        return _actuators.DeGrooteFregly2016Muscle_setActivation(self, s, activation)

    def computeInitialFiberEquilibrium(self, s):
        r"""
        In this method, calcEquilibriumResidual() is used to find a value of the
        normalized tendon force state variable that produces muscle-tendon
        equilibrium. This relies on the implicit form of tendon compliance since
        the explicit form uses the normalized tendon force state variable
        directly to compute fiber force, which always produces a zero
        muscle-tendon equilibrium residual. The derivative of normalized tendon
        force is set to zero since a value is required for the implicit form of
        the model.
        """
        return _actuators.DeGrooteFregly2016Muscle_computeInitialFiberEquilibrium(self, s)

    def getPassiveFiberElasticForce(self, s):
        r"""
        Get the portion of the passive fiber force generated by the elastic
        element only (N).
        """
        return _actuators.DeGrooteFregly2016Muscle_getPassiveFiberElasticForce(self, s)

    def getPassiveFiberElasticForceAlongTendon(self, s):
        r"""
        Get the portion of the passive fiber force generated by the elastic
        element only, projected onto the tendon direction (N).
        """
        return _actuators.DeGrooteFregly2016Muscle_getPassiveFiberElasticForceAlongTendon(self, s)

    def getPassiveFiberDampingForce(self, s):
        r"""
        Get the portion of the passive fiber force generated by the damping
        element only (N).
        """
        return _actuators.DeGrooteFregly2016Muscle_getPassiveFiberDampingForce(self, s)

    def getPassiveFiberDampingForceAlongTendon(self, s):
        r"""
        Get the portion of the passive fiber force generated by the damping
        element only, projected onto the tendon direction (N).
        """
        return _actuators.DeGrooteFregly2016Muscle_getPassiveFiberDampingForceAlongTendon(self, s)

    def getImplicitEnabledNormalizedTendonForce(self, arg2):
        r"""
        Get whether fiber dynamics is in implicit dynamics mode when using
        normalized tendon force as the state. This is useful to indicate to
        solvers to handle the normalized tendon force derivative and
        muscle-tendon equilibrium variables, which are added to the State as
        discrete and cache variables, respectively.
        This function is intended primarily for the model Output
        'implicitenabled_normalized_tendon_force'. We don't need the state, but
        the state parameter is a requirement of Output functions.
        """
        return _actuators.DeGrooteFregly2016Muscle_getImplicitEnabledNormalizedTendonForce(self, arg2)

    def getImplicitResidualNormalizedTendonForce(self, s):
        r"""
        Compute the muscle-tendon force equilibrium residual value when using
        implicit contraction dynamics with normalized tendon force as the
        state.
        This function is intended primarily for the model Output
        'implicitresidual_normalized_tendon_force'.
        """
        return _actuators.DeGrooteFregly2016Muscle_getImplicitResidualNormalizedTendonForce(self, s)

    def getNormalizedTendonForce(self, s):
        r"""
        If ignore_tendon_compliance is true, this gets normalized fiber force
        along the tendon instead.
        """
        return _actuators.DeGrooteFregly2016Muscle_getNormalizedTendonForce(self, s)

    def getNormalizedTendonForceDerivative(self, s):
        r"""
        Obtain the time derivative of the normalized tendon force.
        - If ignore_tendon_compliance is false, this returns zero.
        - If tendon_compliance_dynamics_mode is 'implicit', this gets the
        discrete variable normalized tendon force derivative value.
        - If tendon_compliance_dynamics_mode is 'explicit', this gets the value
        returned by getStateVariableDerivativeValue() for the
        'normalized_tendon_force' state.
        """
        return _actuators.DeGrooteFregly2016Muscle_getNormalizedTendonForceDerivative(self, s)

    def getEquilibriumResidual(self, s):
        r"""
        This calls calcEquilibriumResidual() using values from the provided
        SimTK::State as arguments. While is computed using implicit mode, the
        value of normalized tendon force derivative used *is* consistent with
        the property `tendon_compliance_dynamics_mode` (see
        getNormalizedTendonForceDerivative()).
        """
        return _actuators.DeGrooteFregly2016Muscle_getEquilibriumResidual(self, s)

    def getLinearizedEquilibriumResidualDerivative(self, s):
        
        return _actuators.DeGrooteFregly2016Muscle_getLinearizedEquilibriumResidualDerivative(self, s)

    @staticmethod
    def getActivationStateName():
        r"""getActivationStateName() -> std::string"""
        return _actuators.DeGrooteFregly2016Muscle_getActivationStateName()

    @staticmethod
    def getNormalizedTendonForceStateName():
        r"""getNormalizedTendonForceStateName() -> std::string"""
        return _actuators.DeGrooteFregly2016Muscle_getNormalizedTendonForceStateName()

    @staticmethod
    def getImplicitDynamicsDerivativeName():
        r"""getImplicitDynamicsDerivativeName() -> std::string"""
        return _actuators.DeGrooteFregly2016Muscle_getImplicitDynamicsDerivativeName()

    @staticmethod
    def getImplicitDynamicsResidualName():
        r"""getImplicitDynamicsResidualName() -> std::string"""
        return _actuators.DeGrooteFregly2016Muscle_getImplicitDynamicsResidualName()

    @staticmethod
    def getMinNormalizedTendonForce():
        r"""getMinNormalizedTendonForce() -> double"""
        return _actuators.DeGrooteFregly2016Muscle_getMinNormalizedTendonForce()

    @staticmethod
    def getMaxNormalizedTendonForce():
        r"""getMaxNormalizedTendonForce() -> double"""
        return _actuators.DeGrooteFregly2016Muscle_getMaxNormalizedTendonForce()

    def getBoundsNormalizedTendonForce(self, arg2):
        r"""
        The first element of the Vec2 is the lower bound, and the second is the
        upper bound.
        This function is intended primarily for the model Output
        'statebounds_normalized_tendon_force'. We don't need the state, but the
        state parameter is a requirement of Output functions.
        """
        return _actuators.DeGrooteFregly2016Muscle_getBoundsNormalizedTendonForce(self, arg2)

    @staticmethod
    def getMinNormalizedFiberLength():
        r"""getMinNormalizedFiberLength() -> double"""
        return _actuators.DeGrooteFregly2016Muscle_getMinNormalizedFiberLength()

    @staticmethod
    def getMaxNormalizedFiberLength():
        r"""getMaxNormalizedFiberLength() -> double"""
        return _actuators.DeGrooteFregly2016Muscle_getMaxNormalizedFiberLength()

    def getBoundsNormalizedFiberLength(self):
        r"""
        The first element of the Vec2 is the lower bound, and the second is the
        upper bound.
        Note that since fiber length is not used as a state variable, these
        bounds cannot be enforced directly. It is upon the user to ensure the
        muscle fiber is operating within the specified domain.
        """
        return _actuators.DeGrooteFregly2016Muscle_getBoundsNormalizedFiberLength(self)

    def setNormalizedTendonForce(self, s, normTendonForce):
        r""" If ignore_tendon_compliance is true, this sets nothing."""
        return _actuators.DeGrooteFregly2016Muscle_setNormalizedTendonForce(self, s, normTendonForce)

    def calcActiveForceLengthMultiplier(self, normFiberLength):
        r"""
        These functions compute the values of normalized/dimensionless curves,
        their derivatives and integrals, and other quantities of the muscle.
        These do not depend on a SimTK::State.

        The active force-length curve is the sum of 3 Gaussian-like curves. The
        width of the curve can be adjusted via the 'active_force_width_scale'
        property.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcActiveForceLengthMultiplier(self, normFiberLength)

    def calcActiveForceLengthMultiplierDerivative(self, normFiberLength):
        r"""
        The derivative of the active force-length curve with respect to
        normalized fiber length. This curve is based on the derivative of the
        Gaussian-like curve used in calcActiveForceLengthMultiplier(). The
        'active_force_width_scale' property also affects the value of the
        derivative curve.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcActiveForceLengthMultiplierDerivative(self, normFiberLength)

    @staticmethod
    def calcForceVelocityMultiplier(normFiberVelocity):
        r"""
        The parameters of this curve are not modifiable, so this function is
        static.
        Domain: [-1, 1]
        Range: [0, 1.794]
        Notes: It is upon the user to check that the muscle fiber is acting
              within the specified domain. Force computations outside this range
              may be incorrect.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcForceVelocityMultiplier(normFiberVelocity)

    @staticmethod
    def calcForceVelocityInverseCurve(forceVelocityMult):
        r"""
        This is the inverse of the force-velocity multiplier function, and
        returns the normalized fiber velocity (in [-1, 1]) as a function of
        the force-velocity multiplier.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcForceVelocityInverseCurve(forceVelocityMult)

    def calcPassiveForceMultiplier(self, normFiberLength):
        r"""
        This is the passive force-length curve. The curve becomes negative below
        the minNormFiberLength.

        We modified this equation from that in the supplementary materials of De
        Groote et al., 2016, which is the same function used in
        Thelen2003Muscle. The version in the supplementary materials passes
        through y = 0 at x = 1.0 and allows for negative forces. We do not want
        negative forces within the allowed range of fiber lengths, so we
        modified the equation to pass through y = 0 at x = minNormFiberLength.
        (This is not an issue for Thelen2003Muscle because the curve is not
        smooth and returns 0 for lengths less than optimal fiber length.)
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPassiveForceMultiplier(self, normFiberLength)

    def calcPassiveForceMultiplierDerivative(self, normFiberLength):
        r"""
        This is the derivative of the passive force-length curve with respect to
        the normalized fiber length.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPassiveForceMultiplierDerivative(self, normFiberLength)

    def calcPassiveForceMultiplierIntegral(self, normFiberLength):
        r"""
        This is the integral of the passive force-length curve with respect to
        the normalized fiber length over the domain
        [minNormFiberLength normFiberLength], where minNormFiberLength is the
        value return by getMinNormalizedFiberLength().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPassiveForceMultiplierIntegral(self, normFiberLength)

    def calcTendonForceMultiplier(self, normTendonLength):
        r"""
        The normalized tendon force as a function of normalized tendon length.
        Note that this curve does not go through (1, 0); when
        normTendonLength=1, this function returns a slightly negative number.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceMultiplier(self, normTendonLength)

    def calcTendonForceMultiplierDerivative(self, normTendonLength):
        r"""
        This is the derivative of the tendon-force length curve with respect to
        normalized tendon length.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceMultiplierDerivative(self, normTendonLength)

    def calcTendonForceMultiplierIntegral(self, normTendonLength):
        r"""
        This is the integral of the tendon-force length curve with respect to
        normalized tendon length over the domain
        [minNormTendonLength normTendonLength]. The lower bound on the domain
        is computed by passing the value return by getMinNormalizedTendonForce()
        to calcTendonForceLengthInverseCurve().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceMultiplierIntegral(self, normTendonLength)

    def calcTendonForceLengthInverseCurve(self, normTendonForce):
        r"""
        This is the inverse of the tendon force-length curve, and returns the
        normalized tendon length as a function of the normalized tendon force.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceLengthInverseCurve(self, normTendonForce)

    def calcTendonForceLengthInverseCurveDerivative(self, derivNormTendonForce, normTendonLength):
        r"""
        This returns normalized tendon velocity given the derivative of
        normalized tendon force and normalized tendon length. This is derived
        by taking the derivative of the tendon force multiplier curve with
        respect to time and then solving for normalized fiber velocity (see
        supplementary information for De Groote et al. 2016).
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonForceLengthInverseCurveDerivative(self, derivNormTendonForce, normTendonLength)

    def calcFiberForce(self, activation, activeForceLengthMultiplier, forceVelocityMultiplier, normPassiveFiberForce, normFiberVelocity, activeFiberForce, conPassiveFiberForce, nonConPassiveFiberForce, totalFiberForce):
        r"""
        This computes both the total fiber force and the individual components
        of fiber force (active, conservative passive, and non-conservative
        passive).
        Notes: based on Millard2012EquilibriumMuscle::calcFiberForce().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcFiberForce(self, activation, activeForceLengthMultiplier, forceVelocityMultiplier, normPassiveFiberForce, normFiberVelocity, activeFiberForce, conPassiveFiberForce, nonConPassiveFiberForce, totalFiberForce)

    def calcFiberStiffness(self, activation, normFiberLength, fiberVelocityMultiplier):
        r"""
        The stiffness of the fiber in the direction of the fiber. This includes
        both active and passive force contributions to stiffness from the muscle
        fiber.
        Notes: based on Millard2012EquilibriumMuscle::calcFiberStiffness().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcFiberStiffness(self, activation, normFiberLength, fiberVelocityMultiplier)

    def calcTendonStiffness(self, normTendonLength):
        r"""
        The stiffness of the tendon in the direction of the tendon.
        Notes: based on Millard2012EquilibriumMuscle.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcTendonStiffness(self, normTendonLength)

    def calcMuscleStiffness(self, *args):
        r"""
        calcMuscleStiffness(DeGrooteFregly2016Muscle self, SimTK::Real const & tendonStiffness, SimTK::Real const & fiberStiffnessAlongTendon) -> SimTK::Real

        Parameters
        ----------
        tendonStiffness: SimTK::Real const &
        fiberStiffnessAlongTendon: SimTK::Real const &

        calcMuscleStiffness(DeGrooteFregly2016Muscle self, State s) -> double

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _actuators.DeGrooteFregly2016Muscle_calcMuscleStiffness(self, *args)

    def calcPartialPennationAnglePartialFiberLength(self, fiberLength):
        r"""
        The derivative of pennation angle with respect to fiber length.
        Notes: based on
        MuscleFixedWidthPennationModel::calc_DPennationAngle_DFiberLength().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPartialPennationAnglePartialFiberLength(self, fiberLength)

    def calcPartialFiberForceAlongTendonPartialFiberLength(self, fiberForce, fiberStiffness, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength):
        r"""
        The derivative of the fiber force along the tendon with respect to fiber
        length.
        Notes: based on
        Millard2012EquilibriumMuscle::calc_DFiberForceAT_DFiberLength().
        """
        return _actuators.DeGrooteFregly2016Muscle_calcPartialFiberForceAlongTendonPartialFiberLength(self, fiberForce, fiberStiffness, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength)

    def calcFiberStiffnessAlongTendon(self, fiberLength, partialFiberForceAlongTendonPartialFiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength):
        r"""
        The derivative of the fiber force along the tendon with respect to the
        fiber length along the tendon.
        Notes: based on
        Millard2012EquilibriumMuscle::calc_DFiberForceAT_DFiberLengthAT.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcFiberStiffnessAlongTendon(self, fiberLength, partialFiberForceAlongTendonPartialFiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength)

    def calcPartialTendonLengthPartialFiberLength(self, fiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength):
        r"""
        calcPartialTendonLengthPartialFiberLength(DeGrooteFregly2016Muscle self, SimTK::Real const & fiberLength, SimTK::Real const & sinPennationAngle, SimTK::Real const & cosPennationAngle, SimTK::Real const & partialPennationAnglePartialFiberLength) -> SimTK::Real

        Parameters
        ----------
        fiberLength: SimTK::Real const &
        sinPennationAngle: SimTK::Real const &
        cosPennationAngle: SimTK::Real const &
        partialPennationAnglePartialFiberLength: SimTK::Real const &

        """
        return _actuators.DeGrooteFregly2016Muscle_calcPartialTendonLengthPartialFiberLength(self, fiberLength, sinPennationAngle, cosPennationAngle, partialPennationAnglePartialFiberLength)

    def calcPartialTendonForcePartialFiberLength(self, tendonStiffness, fiberLength, sinPennationAngle, cosPennationAngle):
        r"""
        calcPartialTendonForcePartialFiberLength(DeGrooteFregly2016Muscle self, SimTK::Real const & tendonStiffness, SimTK::Real const & fiberLength, SimTK::Real const & sinPennationAngle, SimTK::Real const & cosPennationAngle) -> SimTK::Real

        Parameters
        ----------
        tendonStiffness: SimTK::Real const &
        fiberLength: SimTK::Real const &
        sinPennationAngle: SimTK::Real const &
        cosPennationAngle: SimTK::Real const &

        """
        return _actuators.DeGrooteFregly2016Muscle_calcPartialTendonForcePartialFiberLength(self, tendonStiffness, fiberLength, sinPennationAngle, cosPennationAngle)

    def calcEquilibriumResidual(self, muscleTendonLength, muscleTendonVelocity, activation, normTendonForce, normTendonForceDerivative):
        r"""
        The residual (i.e. error) in the muscle-tendon equilibrium equation:
            residual = normTendonForce - normFiberForce * cosPennationAngle
        The residual is unitless (units of normalized force).
        This is computed using the muscle in implicit mode, since explicit mode
        uses the normalized tendon force state variable directly
        to compute fiber force, which always produces a zero muscle-tendon
        equilibrium residual.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcEquilibriumResidual(self, muscleTendonLength, muscleTendonVelocity, activation, normTendonForce, normTendonForceDerivative)

    def calcLinearizedEquilibriumResidualDerivative(self, muscleTendonLength, muscleTendonVelocity, activation, normTendonForce, normTendonForceDerivative):
        r"""
        The residual (i.e. error) in the time derivative of the linearized
        muscle-tendon equilibrium equation (Millard et al. 2013, equation A6):
            residual = fiberStiffnessAlongTendon * fiberVelocityAlongTendon -
                       tendonStiffness *
                           (muscleTendonVelocity - fiberVelocityAlongTendon)
        This may be useful for finding equilibrium when there is velocity in the
        muscle-tendon actuator. Velocity is divided between the muscle and
        tendon based on their relative stiffnesses.
        """
        return _actuators.DeGrooteFregly2016Muscle_calcLinearizedEquilibriumResidualDerivative(self, muscleTendonLength, muscleTendonVelocity, activation, normTendonForce, normTendonForceDerivative)

    def exportFiberLengthCurvesToTable(self, *args):
        r"""
        Export the active force-length multiplier and passive force multiplier
        curves to a DataTable. If the normFiberLengths argument is omitted, we
        use createVectorLinspace(200, minNormFiberLength, maxNormFiberLength).
        """
        return _actuators.DeGrooteFregly2016Muscle_exportFiberLengthCurvesToTable(self, *args)

    def exportFiberVelocityMultiplierToTable(self, *args):
        r"""
        Export the fiber force-velocity multiplier curve to a DataTable. If
        the normFiberVelocities argument is omitted, we use
        createVectorLinspace(200, -1.1, 1.1).
        """
        return _actuators.DeGrooteFregly2016Muscle_exportFiberVelocityMultiplierToTable(self, *args)

    def exportTendonForceMultiplierToTable(self, *args):
        r"""
        Export the fiber tendon force multiplier curve to a DataTable. If
        the normFiberVelocities argument is omitted, we use
        createVectorLinspace(200, 0.95, 1 + <strain at 1 norm force>)
        """
        return _actuators.DeGrooteFregly2016Muscle_exportTendonForceMultiplierToTable(self, *args)

    def printCurvesToSTOFiles(self, *args):
        r"""
        Print the muscle curves to STO files. The files will be named as
        `<muscle-name>_<curve_type>.sto`.

        :type directory: string, optional
        :param directory:
                The directory to which the data files should be written. Do NOT
                include the filename. By default, the files are printed to the
                current working directory.
        """
        return _actuators.DeGrooteFregly2016Muscle_printCurvesToSTOFiles(self, *args)

    @staticmethod
    def replaceMuscles(model, allowUnsupportedMuscles=False):
        r"""
        Replace muscles of other types in the model with muscles of this type.
        Currently, only Millard2012EquilibriumMuscles and Thelen2003Muscles
        are replaced. For these two muscle classes, we copy property values into
        equivalent properties of the newly created DeGrooteFregly2016Muscle.
        If the model has muscles of other types, an exception is
        thrown unless allowUnsupportedMuscles is true, in which a
        DeGrooteFregly2016Muscle is created using only the base Muscle class
        property values.
        Since the DeGrooteFregly2016Muscle implements tendon compliance dynamics
        with normalized tendon force as the state variable, this function
        ignores the 'default_fiber_length' property in replaced muscles.
        """
        return _actuators.DeGrooteFregly2016Muscle_replaceMuscles(model, allowUnsupportedMuscles)

    def extendPostScale(self, s, scaleSet):
        r"""
        Adjust the properties of the muscle after the model has been scaled. The
        optimal fiber length and tendon slack length are each multiplied by the
        ratio of the current path length and the path length before scaling.
        """
        return _actuators.DeGrooteFregly2016Muscle_extendPostScale(self, s, scaleSet)
    __swig_destroy__ = _actuators.delete_DeGrooteFregly2016Muscle

# Register DeGrooteFregly2016Muscle in _actuators:
_actuators.DeGrooteFregly2016Muscle_swigregister(DeGrooteFregly2016Muscle)
class SetFunctionBasedPaths(opensim.common.OpenSimObject):
    r"""
    A class for holding a set of pointers to objects.  It is derived from
    base class C and is implemented as a wrapper around template class
    ArrayPtrs<T>.

    See also: ArrayPtrs
    Author: Frank C. Anderson
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> SetFunctionBasedPaths

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.SetFunctionBasedPaths_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(SetFunctionBasedPaths self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.SetFunctionBasedPaths_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.SetFunctionBasedPaths_getClassName()

    def clone(self):
        r"""clone(SetFunctionBasedPaths self) -> SetFunctionBasedPaths"""
        return _actuators.SetFunctionBasedPaths_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(SetFunctionBasedPaths self) -> std::string const &"""
        return _actuators.SetFunctionBasedPaths_getConcreteClassName(self)
    __swig_destroy__ = _actuators.delete_SetFunctionBasedPaths

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Default constructor.

        |

        *Overload 2:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :type aUpdateFromXMLNode: boolean, optional
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 3:*

        Construct from file.

        :type aFileName: string
        :param aFileName:             Name of the file.
        :param aUpdateFromXMLNode:    Whether to update from XML.

        |

        *Overload 4:*

        Copy constructor.

        :type aSet: OpenSim::Set< OpenSim::FunctionBasedPath,OpenSim::Object >
        :param aSet: Set to be copied.
        """
        _actuators.SetFunctionBasedPaths_swiginit(self, _actuators.new_SetFunctionBasedPaths(*args))

    def setupGroups(self):
        r"""Setup groups (match group member names to set members)."""
        return _actuators.SetFunctionBasedPaths_setupGroups(self)

    def setMemoryOwner(self, aTrueFalse):
        r"""
        Assign this set to another set.
        This operator makes a complete copy of the specified set; all member
        variables and objects in the set are copied.  Because all objects are
        copied, this set takes ownership of the newly allocated objects (i.e.,
        _memoryOwner is set to true. So, the result is two independent,
        identical sets, with the possible exception of the _memoryOwner flag.

        :param set: The Set to be copied.
        :rtype: void
        :return: Reference to this set.

        %Set whether or not this Set owns the memory pointed to by the pointers
        it holds.

        :type aTrueFalse: boolean
        :param aTrueFalse: If true, all the memory associated with each of the
            pointers in this array are deleted upon the array's destruction.  If
            false, deletes are not issued for each of the pointers.
        """
        return _actuators.SetFunctionBasedPaths_setMemoryOwner(self, aTrueFalse)

    def setSize(self, aSize):
        r"""
        %Set the size of the array.  This method can be used only to decrease
        the size of the array.  If the size of an array is decreased, all objects
        in the array that become invalid as a result of the decrease are
        deleted.

        Note that the size of an array is different than its capacity.  The size
        indicates how many valid elements are stored in an array.  The capacity
        indicates how much the size of the array can be increased without
        allocated more memory.  At all times size <= capacity.

        :type aSize: int
        :param aSize: Desired size of the array.  The size must be greater than
            or equal to zero and less than or equal to the current size of the
            array.
        :rtype: boolean
        :return: True if the requested size change was carried out, false
            otherwise.
        """
        return _actuators.SetFunctionBasedPaths_setSize(self, aSize)

    def getSize(self):
        r"""
        Get the size of the array.

        :rtype: int
        :return: Size of the array.
        """
        return _actuators.SetFunctionBasedPaths_getSize(self)

    def getIndex(self, *args):
        r"""
        *Overload 1:*

        Get the index of an object.

        :type aObject: :py:class:`FunctionBasedPath`
        :param aObject: Address of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object with the address aObject.  If no such object
            exists in the array, -1 is returned.

        |

        *Overload 2:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :type aStartIndex: int, optional
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.

        |

        *Overload 3:*

        Get the index of an object by specifying its name.

        :type aName: string
        :param aName: Name of the object whose index is sought.
        :param aStartIndex: Index at which to start searching.  If the object is
            not found at or following aStartIndex, the array is searched from
            its beginning.
        :rtype: int
        :return: Index of the object named aName.  If no such object exists in
            the array, -1 is returned.
        """
        return _actuators.SetFunctionBasedPaths_getIndex(self, *args)

    def getGroupNamesContaining(self, aObjectName, rGroupNames):
        r"""Get names of groups containing a given object"""
        return _actuators.SetFunctionBasedPaths_getGroupNamesContaining(self, aObjectName, rGroupNames)

    def adoptAndAppend(self, aObject):
        r"""
        Append to the array, and adopt passed in pointer.  A copy is NOT made of the specified object.  If
        getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aObject: :py:class:`FunctionBasedPath`
        :param aObject: Object to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _actuators.SetFunctionBasedPaths_adoptAndAppend(self, aObject)

    def cloneAndAppend(self, aObject):
        r"""
        cloneAndAppend creates a clone of the passed in object and appends the clone to the array.
        The original object is unaffected and is not associated with the Set. The clone is created
        using the method clone() available to OpenSim::Object

        :type aObject: :py:class:`FunctionBasedPath`
        :param aObject: Object whose clone is to be appended.
        :rtype: boolean
        :return: True if the append was successful, false otherwise.
        """
        return _actuators.SetFunctionBasedPaths_cloneAndAppend(self, aObject)

    def insert(self, aIndex, aObject):
        r"""
        Insert an object into the array at a specified index.  A copy of the
        specified object is NOT made.  If getMemoryOwner() is true, this Set takes
        over ownership of the object and deletes it when the Set itself is deleted.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`FunctionBasedPath`
        :param aObject: Object to be inserted.
        :type aIndex: int
        :param aIndex: Index at which to insert the new object.  All current elements
            from aIndex to the end of the array are shifted one place in the direction
            of the end of the array.  The specified index must be less than or
            equal to the size of the array.  Note that if aIndex is equal to the
            size of the array, the insertion is equivalent to an append.
        :rtype: boolean
        :return: True if the insertion was successful, false otherwise.
        """
        return _actuators.SetFunctionBasedPaths_insert(self, aIndex, aObject)

    def remove(self, *args):
        r"""
        *Overload 1:*

        Remove an object from the array at a specified index.
        If this set is set as the memory owner, the object is deleted when it
        is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aIndex: int
        :param aIndex: Index of the value to remove.  All elements from aIndex to
            the end of the array are shifted one place toward the beginning of
            the array.  If aIndex is less than 0 or greater than or equal to the
            current size of the array, no element is removed.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.

        |

        *Overload 2:*

        Remove an object from the array by specifying its address.
        The object is deleted when it is removed.

        This method is relatively computationally costly since many of the array
        elements may need to be shifted.

        :type aObject: :py:class:`FunctionBasedPath`
        :param aObject: Pointer to the object to be removed.  If an object with the
            specified address is not found, no action is taken.
        :rtype: boolean
        :return: True if the removal was successful, false otherwise.
        """
        return _actuators.SetFunctionBasedPaths_remove(self, *args)

    def clearAndDestroy(self):
        r"""clearAndDestroy(SetFunctionBasedPaths self)"""
        return _actuators.SetFunctionBasedPaths_clearAndDestroy(self)

    def set(self, aIndex, aObject, preserveGroups=False):
        r"""
        %Set the object at a specified index.  A copy of the object is NOT made.
        If getMemoryOwner() is true, this Set takes over ownership of the object and
        deletes it when the Set itself is deleted.

        :type aIndex: int
        :param aIndex: Index of the array element to be set.  aIndex must be
            greater than zero and less than or equal to the size of the array.  Note
            that if aIndex is equal to the size of the array, the set is equivalent
            to an append.
        :type aObject: :py:class:`FunctionBasedPath`
        :param aObject: Object to be set.
        :type preserveGroups: boolean, optional
        :param preserveGroups: If true, the new object will be added to the groups
            that the object it replaces belonged to
        :rtype: boolean
        :return: True if the set was successful, false otherwise.
        """
        return _actuators.SetFunctionBasedPaths_set(self, aIndex, aObject, preserveGroups)

    def get(self, *args):
        r"""
        *Overload 1:*

        Get the value at a specified array index.

        If the index is negative or passed the end of the array, an exception
        is thrown.

        For faster execution, the array elements can be accessed through the
        overloaded operator[], which does no bounds checking.

        :type aIndex: int
        :param aIndex: Index of the desired array element.
        :rtype: :py:class:`FunctionBasedPath`
        :return: Reference to the array element.
        :raises: Exception if (aIndex<0)||(aIndex>=_size) or if the pointer
            at aIndex is NULL.
        See also: operator[].

        |

        *Overload 2:*

        Get the first object that has a specified name.

        If the array doesn't contain an object of the specified name, an
        exception is thrown.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: :py:class:`FunctionBasedPath`
        :return: Pointer to the object.
        :raises: Exception if no such object exists.
        See also: getIndex()
        """
        return _actuators.SetFunctionBasedPaths_get(self, *args)

    def contains(self, aName):
        r"""
        Get whether this Set contains any object with the specified name.

        :type aName: string
        :param aName: Name of the desired object.
        :rtype: boolean
        :return: true if the object exists
        """
        return _actuators.SetFunctionBasedPaths_contains(self, aName)

    def getNames(self, rNames):
        r"""
        Get names of objects in the set.

        :type rNames: OpenSim::Array< std::string >
        :param rNames: Array of names.  The names are appended to rNames, so it
            is permissible to send in an non-empty array; the names in the set
            will simply be appended to the array sent in.
        """
        return _actuators.SetFunctionBasedPaths_getNames(self, rNames)

    def getNumGroups(self):
        r"""Get the number of groups."""
        return _actuators.SetFunctionBasedPaths_getNumGroups(self)

    def addGroup(self, aGroupName):
        r"""Add an empty group to the set."""
        return _actuators.SetFunctionBasedPaths_addGroup(self, aGroupName)

    def removeGroup(self, aGroupName):
        r"""Remove a group from the set. Elements are not removed."""
        return _actuators.SetFunctionBasedPaths_removeGroup(self, aGroupName)

    def renameGroup(self, oldGroupName, newGroupName):
        r"""Rename a group."""
        return _actuators.SetFunctionBasedPaths_renameGroup(self, oldGroupName, newGroupName)

    def addObjectToGroup(self, aGroupName, aObjectName):
        r"""Add an object to a group."""
        return _actuators.SetFunctionBasedPaths_addObjectToGroup(self, aGroupName, aObjectName)

    def getGroupNames(self, rGroupNames):
        r"""Get names of all groups"""
        return _actuators.SetFunctionBasedPaths_getGroupNames(self, rGroupNames)

    def getGroup(self, *args):
        r"""
        *Overload 1:*

        Get a group by name.

        |

        *Overload 2:*

        Get a group by index.
        """
        return _actuators.SetFunctionBasedPaths_getGroup(self, *args)

    class SetIterator(object):
        """
        Use this object to iterate over a Set. You create an instance of
        this nested class by calling Set.__iter__().
        """
        def __init__(self, set_obj, index):
            """Construct an iterator for the Set `set`."""
            self._set_obj = set_obj
            self._index = index
        def __iter__(self):
            """This iterator is also iterable."""
            return self
        def next(self):
            if self._index < self._set_obj.getSize():
                current_index = self._index
                self._index += 1
                return self._set_obj.get(current_index)
            else:
    # This is how Python knows to stop iterating.
                 raise StopIteration()
        __next__ = next # For Python 3.

    def __iter__(self):
        """Get an iterator for this Set, starting at index 0."""
        return self.SetIterator(self, 0)

    def items(self):
        """
        A generator function that allows you to iterate over the key-value
        pairs of this Set. You can use this in a for-loop as such::

            for key, val in my_function_set.items():
    # `val` is an item in the Set, and `key` is its name.
                print key, val
        """
        index = 0
        while index < self.getSize():
            yield self.get(index).getName(), self.get(index)
            index += 1


# Register SetFunctionBasedPaths in _actuators:
_actuators.SetFunctionBasedPaths_swigregister(SetFunctionBasedPaths)
class ModelFactory(object):
    r""" This class provides utilities for creating OpenSim models."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def createNLinkPendulum(numLinks):
        r"""
        Create a pendulum with the provided number of links.
        For each link, there is a body `/bodyset/b#` (where `#` is the link
        index starting at 0), a PinJoint `/jointset/j#` with coordinate
        `/jointset/j#/q#`, a CoordinateActuator `/tau#`, a Marker
        `/markerset/marker#` at the origin of the link's body, and a
        PhysicalOffsetFrame ``/b``#center at the center of the link.
        """
        return _actuators.ModelFactory_createNLinkPendulum(numLinks)

    @staticmethod
    def createPendulum():
        r""" This is a convenience for `createNLinkPendulum(1)`."""
        return _actuators.ModelFactory_createPendulum()

    @staticmethod
    def createDoublePendulum():
        r""" This is a convenience for `createNLinkPendulum(2)`."""
        return _actuators.ModelFactory_createDoublePendulum()

    @staticmethod
    def createSlidingPointMass():
        r"""
        This model contains:
        - 1 body: mass 1.0 kg, `/body`.
        - 1 joint: SliderJoint along x axis, `/jointset/slider`, with
                   coordinate `/slider/position`.
        - 1 actuator: CoordinateActuator, controls [-10, 10],
                     `/forceset/actuator`.
        Gravity is default; that is, (0, -g, 0).
        """
        return _actuators.ModelFactory_createSlidingPointMass()

    @staticmethod
    def createPlanarPointMass():
        r"""
        This model contains:
        - 2 bodies: a massless body "intermed", and "body" with mass 1.
        - 2 slider joints: "tx" and "ty" (coordinates "tx" and "ty").
        - 2 coordinate actuators: "force_x" and "force_y".
        Gravity is default; that is, (0, -g, 0).
        """
        return _actuators.ModelFactory_createPlanarPointMass()

    @staticmethod
    def replaceMusclesWithPathActuators(model):
        r"""
        Replace muscles in a model with a PathActuator of the same path,
        optimal force, and min/max control defaults.
        Notes: This only replaces muscles within the model's ForceSet.
        """
        return _actuators.ModelFactory_replaceMusclesWithPathActuators(model)

    @staticmethod
    def removeMuscles(model):
        r"""
        Remove muscles from the model.
        Notes: This only removes muscles within the model's ForceSet.
        """
        return _actuators.ModelFactory_removeMuscles(model)

    @staticmethod
    def replaceJointWithWeldJoint(model, jointName):
        r"""
        Replace a joint in the model with a WeldJoint.
        Notes: This assumes the joint is in the JointSet and that the joint's
              connectees are PhysicalOffsetFrames.
        """
        return _actuators.ModelFactory_replaceJointWithWeldJoint(model, jointName)

    @staticmethod
    def createReserveActuators(*args):
        r"""
        Add CoordinateActuator%s for each unconstrained coordinate (e.g.,
        `! Coordinate::isConstrained()`) in the model, using the provided optimal
        force. Increasing the optimal force decreases the required control
        signal to generate a given actuation level. The actuators are added to
        the model's ForceSet and are named "reserve_<coordinate-path>" with
        forward slashes converted to underscores. The `bound` argument, if
        supplied, sets the min and max controls to `-bound` and `bound`,
        respectively.
        The fourth (optional) argument specifies whether or not to skip
        coordinates that already have CoordinateActuator%s associated with
        them (default: true).
        The fifth (optional) argument specifies whether or not to skip
        coordinates that are associated with joints whose parent body is Ground
        (default: false).
        """
        return _actuators.ModelFactory_createReserveActuators(*args)

    @staticmethod
    def createResidualActuators(*args):
        r"""
        Add CoordinateActuator%s for each unconstrained coordinate (e.g.,
        `! Coordinate::isConstrained()`) in the model associated with joints
        whose parent body is Ground. The optimal force for rotational and
        translational coordinates can be set separately using the arguments
        `rotationalOptimalForce` and `translationalOptimalForce`. The actuators
        are added to the model's ForceSet and are named
        "residual_<coordinate-path>" with forward slashes converted to
        underscores. The `bound` argument, if supplied, sets the min and max
        controls to `-bound` and `bound`, respectively.
        The fifth (optional) argument specifies whether or not to skip
        coordinates that already have CoordinateActuator%s associated with them
        (default: true).
        """
        return _actuators.ModelFactory_createResidualActuators(*args)

    @staticmethod
    def replacePathsWithFunctionBasedPaths(model, functionBasedPaths):
        r"""
        Replace the paths of the forces in the model with the provided Set of
        FunctionBasedPath%s. The name of each FunctionBasedPath should match the
        component path (i.e., '/forceset/soleus_r') of the corresponding Force
        in the model. The Force objects in the model must have a property named
        'path' that stores an object derived from AbstractGeometryPath.
        """
        return _actuators.ModelFactory_replacePathsWithFunctionBasedPaths(model, functionBasedPaths)

    def __init__(self):
        r"""__init__(ModelFactory self) -> ModelFactory"""
        _actuators.ModelFactory_swiginit(self, _actuators.new_ModelFactory())
    __swig_destroy__ = _actuators.delete_ModelFactory

# Register ModelFactory in _actuators:
_actuators.ModelFactory_swigregister(ModelFactory)
class ModelOperator(opensim.common.OpenSimObject):
    r"""
     This abstract base class describes *any* operation that modifies a Model
    as part of a ModelProcessor.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelOperator

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModelOperator_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelOperator self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModelOperator_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModelOperator_getClassName()

    def clone(self):
        r"""clone(ModelOperator self) -> ModelOperator"""
        return _actuators.ModelOperator_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelOperator self) -> std::string const &"""
        return _actuators.ModelOperator_getConcreteClassName(self)

    def operate(self, model, relativeToDirectory):
        r"""
        Perform an operation on the model, using `relativeToDirectory` to locate
           any files that this operator reads.
        """
        return _actuators.ModelOperator_operate(self, model, relativeToDirectory)
    __swig_destroy__ = _actuators.delete_ModelOperator

# Register ModelOperator in _actuators:
_actuators.ModelOperator_swigregister(ModelOperator)
class ModelProcessor(opensim.common.OpenSimObject):
    r"""
     This class describes a workflow for processing a Model using
    ModelOperator%s. The user must provide a source model via either the model
    property or the filepath property. In C++, one can easily chain together
    the operators in a processor using the C++ pipe operator:

    .. code-block:: c++

        ModelProcessor proc = ModelProcessor("model.osim") | ModOpAddReserves();
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModelProcessor

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModelProcessor_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModelProcessor self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModelProcessor_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModelProcessor_getClassName()

    def clone(self):
        r"""clone(ModelProcessor self) -> ModelProcessor"""
        return _actuators.ModelProcessor_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModelProcessor self) -> std::string const &"""
        return _actuators.ModelProcessor_getConcreteClassName(self)

    def copyProperty_filepath(self, source):
        r"""
        copyProperty_filepath(ModelProcessor self, ModelProcessor source)

        Parameters
        ----------
        source: OpenSim::ModelProcessor::Self const &

        """
        return _actuators.ModelProcessor_copyProperty_filepath(self, source)

    def append_filepath(self, value):
        r"""
        append_filepath(ModelProcessor self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.ModelProcessor_append_filepath(self, value)

    def constructProperty_filepath(self, initValue):
        r"""
        constructProperty_filepath(ModelProcessor self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.ModelProcessor_constructProperty_filepath(self, initValue)

    def get_filepath(self, *args):
        r"""
        get_filepath(ModelProcessor self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_filepath(ModelProcessor self) -> std::string const &
        """
        return _actuators.ModelProcessor_get_filepath(self, *args)

    def upd_filepath(self, *args):
        r"""
        upd_filepath(ModelProcessor self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_filepath(ModelProcessor self) -> std::string &
        """
        return _actuators.ModelProcessor_upd_filepath(self, *args)

    def set_filepath(self, *args):
        r"""
        set_filepath(ModelProcessor self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_filepath(ModelProcessor self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.ModelProcessor_set_filepath(self, *args)

    def copyProperty_operators(self, source):
        r"""
        copyProperty_operators(ModelProcessor self, ModelProcessor source)

        Parameters
        ----------
        source: OpenSim::ModelProcessor::Self const &

        """
        return _actuators.ModelProcessor_copyProperty_operators(self, source)

    def get_operators(self, i):
        r"""
        get_operators(ModelProcessor self, int i) -> ModelOperator

        Parameters
        ----------
        i: int

        """
        return _actuators.ModelProcessor_get_operators(self, i)

    def upd_operators(self, i):
        r"""
        upd_operators(ModelProcessor self, int i) -> ModelOperator

        Parameters
        ----------
        i: int

        """
        return _actuators.ModelProcessor_upd_operators(self, i)

    def set_operators(self, i, value):
        r"""
        set_operators(ModelProcessor self, int i, ModelOperator value)

        Parameters
        ----------
        i: int
        value: OpenSim::ModelOperator const &

        """
        return _actuators.ModelProcessor_set_operators(self, i, value)

    def append_operators(self, value):
        r"""
        append_operators(ModelProcessor self, ModelOperator value) -> int

        Parameters
        ----------
        value: OpenSim::ModelOperator const &

        """
        return _actuators.ModelProcessor_append_operators(self, value)

    def constructProperty_operators(self):
        r"""constructProperty_operators(ModelProcessor self)"""
        return _actuators.ModelProcessor_constructProperty_operators(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        This constructor is only for use when reading (deserializing) from an
           XML file.

        |

        *Overload 2:*
        Use a Model object as the source model.
           Since this constructor is not explicit, you can provide a Model to
           any function that takes a ModelProcessor (in C++).

        |

        *Overload 3:*
        Use the filepath of a .osim file to obtain the source model.
           Since this constructor is not explicit, you can provide a string
           filepath any function that takes a ModelProcessor (in C++).
        """
        _actuators.ModelProcessor_swiginit(self, _actuators.new_ModelProcessor(*args))

    def getModel(self):
        r"""
        Obtain the base model, if one was provided via the model property or
           setModel(). This ignores base models specified via the filepath
           property.
        """
        return _actuators.ModelProcessor_getModel(self)

    def updModel(self):
        r"""
        Obtain a mutable reference to the base model, if one was provided via
           the model property or setModel(). This ignores base models specified
           via the filepath property.
        """
        return _actuators.ModelProcessor_updModel(self)

    def process(self, *args):
        r"""
        Process and obtain the model. If the base model is specified via the
           filepath property, the filepath will be evaluated relative to
           `relativeToDirectory`, if provided.
        """
        return _actuators.ModelProcessor_process(self, *args)

    def append(self, op):
        r""" Append an operation to the end of the operations in this processor."""
        return _actuators.ModelProcessor_append(self, op)

    def __or__(self, right):
        r"""
        This operator allows one to write the following code in C++:

           .. code-block:: c++

               ModelProcessor proc = ModelProcessor("model.osim") | ModOpAddReserves();
        """
        return _actuators.ModelProcessor___or__(self, right)

    def setModel(self, model):
        r"""
        setModel(ModelProcessor self, Model model)

        Parameters
        ----------
        model: OpenSim::Model *

        """
        return _actuators.ModelProcessor_setModel(self, model)
    __swig_destroy__ = _actuators.delete_ModelProcessor

# Register ModelProcessor in _actuators:
_actuators.ModelProcessor_swigregister(ModelProcessor)
class ModOpIgnoreActivationDynamics(ModelOperator):
    r""" Turn off activation dynamics for all muscles in the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpIgnoreActivationDynamics

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpIgnoreActivationDynamics_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpIgnoreActivationDynamics self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpIgnoreActivationDynamics_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpIgnoreActivationDynamics_getClassName()

    def clone(self):
        r"""clone(ModOpIgnoreActivationDynamics self) -> ModOpIgnoreActivationDynamics"""
        return _actuators.ModOpIgnoreActivationDynamics_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpIgnoreActivationDynamics self) -> std::string const &"""
        return _actuators.ModOpIgnoreActivationDynamics_getConcreteClassName(self)

    def operate(self, model, arg3):
        r"""
        operate(ModOpIgnoreActivationDynamics self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpIgnoreActivationDynamics_operate(self, model, arg3)

    def __init__(self):
        r"""__init__(ModOpIgnoreActivationDynamics self) -> ModOpIgnoreActivationDynamics"""
        _actuators.ModOpIgnoreActivationDynamics_swiginit(self, _actuators.new_ModOpIgnoreActivationDynamics())
    __swig_destroy__ = _actuators.delete_ModOpIgnoreActivationDynamics

# Register ModOpIgnoreActivationDynamics in _actuators:
_actuators.ModOpIgnoreActivationDynamics_swigregister(ModOpIgnoreActivationDynamics)
class ModOpIgnoreTendonCompliance(ModelOperator):
    r""" Turn off tendon compliance for all muscles in the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpIgnoreTendonCompliance

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpIgnoreTendonCompliance_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpIgnoreTendonCompliance self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpIgnoreTendonCompliance_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpIgnoreTendonCompliance_getClassName()

    def clone(self):
        r"""clone(ModOpIgnoreTendonCompliance self) -> ModOpIgnoreTendonCompliance"""
        return _actuators.ModOpIgnoreTendonCompliance_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpIgnoreTendonCompliance self) -> std::string const &"""
        return _actuators.ModOpIgnoreTendonCompliance_getConcreteClassName(self)

    def operate(self, model, arg3):
        r"""
        operate(ModOpIgnoreTendonCompliance self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpIgnoreTendonCompliance_operate(self, model, arg3)

    def __init__(self):
        r"""__init__(ModOpIgnoreTendonCompliance self) -> ModOpIgnoreTendonCompliance"""
        _actuators.ModOpIgnoreTendonCompliance_swiginit(self, _actuators.new_ModOpIgnoreTendonCompliance())
    __swig_destroy__ = _actuators.delete_ModOpIgnoreTendonCompliance

# Register ModOpIgnoreTendonCompliance in _actuators:
_actuators.ModOpIgnoreTendonCompliance_swigregister(ModOpIgnoreTendonCompliance)
class ModOpScaleMaxIsometricForce(ModelOperator):
    r""" Scale the max isometric force for all muscles in the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpScaleMaxIsometricForce

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpScaleMaxIsometricForce_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpScaleMaxIsometricForce self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpScaleMaxIsometricForce_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpScaleMaxIsometricForce_getClassName()

    def clone(self):
        r"""clone(ModOpScaleMaxIsometricForce self) -> ModOpScaleMaxIsometricForce"""
        return _actuators.ModOpScaleMaxIsometricForce_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpScaleMaxIsometricForce self) -> std::string const &"""
        return _actuators.ModOpScaleMaxIsometricForce_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ModOpScaleMaxIsometricForce self) -> ModOpScaleMaxIsometricForce
        __init__(ModOpScaleMaxIsometricForce self, double scaleFactor) -> ModOpScaleMaxIsometricForce

        Parameters
        ----------
        scaleFactor: double

        """
        _actuators.ModOpScaleMaxIsometricForce_swiginit(self, _actuators.new_ModOpScaleMaxIsometricForce(*args))

    def operate(self, model, arg3):
        r"""
        operate(ModOpScaleMaxIsometricForce self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpScaleMaxIsometricForce_operate(self, model, arg3)
    __swig_destroy__ = _actuators.delete_ModOpScaleMaxIsometricForce

# Register ModOpScaleMaxIsometricForce in _actuators:
_actuators.ModOpScaleMaxIsometricForce_swigregister(ModOpScaleMaxIsometricForce)
class ModOpRemoveMuscles(ModelOperator):
    r""" Remove all muscles contained in the model's ForceSet."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpRemoveMuscles

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpRemoveMuscles_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpRemoveMuscles self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpRemoveMuscles_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpRemoveMuscles_getClassName()

    def clone(self):
        r"""clone(ModOpRemoveMuscles self) -> ModOpRemoveMuscles"""
        return _actuators.ModOpRemoveMuscles_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpRemoveMuscles self) -> std::string const &"""
        return _actuators.ModOpRemoveMuscles_getConcreteClassName(self)

    def operate(self, model, arg3):
        r"""
        operate(ModOpRemoveMuscles self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpRemoveMuscles_operate(self, model, arg3)

    def __init__(self):
        r"""__init__(ModOpRemoveMuscles self) -> ModOpRemoveMuscles"""
        _actuators.ModOpRemoveMuscles_swiginit(self, _actuators.new_ModOpRemoveMuscles())
    __swig_destroy__ = _actuators.delete_ModOpRemoveMuscles

# Register ModOpRemoveMuscles in _actuators:
_actuators.ModOpRemoveMuscles_swigregister(ModOpRemoveMuscles)
class ModOpAddReserves(ModelOperator):
    r"""
     Add reserve actuators to the model using
    ModelFactory::createReserveActuators.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpAddReserves

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpAddReserves_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpAddReserves self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpAddReserves_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpAddReserves_getClassName()

    def clone(self):
        r"""clone(ModOpAddReserves self) -> ModOpAddReserves"""
        return _actuators.ModOpAddReserves_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpAddReserves self) -> std::string const &"""
        return _actuators.ModOpAddReserves_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ModOpAddReserves self) -> ModOpAddReserves
        __init__(ModOpAddReserves self, double optimalForce) -> ModOpAddReserves

        Parameters
        ----------
        optimalForce: double

        __init__(ModOpAddReserves self, double optimalForce, double bound) -> ModOpAddReserves

        Parameters
        ----------
        optimalForce: double
        bound: double

        __init__(ModOpAddReserves self, double optimalForce, double bounds, bool skipCoordsWithActu) -> ModOpAddReserves

        Parameters
        ----------
        optimalForce: double
        bounds: double
        skipCoordsWithActu: bool

        __init__(ModOpAddReserves self, double optimalForce, double bounds, bool skipCoordsWithActu, bool skipResidualCoords) -> ModOpAddReserves

        Parameters
        ----------
        optimalForce: double
        bounds: double
        skipCoordsWithActu: bool
        skipResidualCoords: bool

        """
        _actuators.ModOpAddReserves_swiginit(self, _actuators.new_ModOpAddReserves(*args))

    def operate(self, model, arg3):
        r"""
        operate(ModOpAddReserves self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpAddReserves_operate(self, model, arg3)
    __swig_destroy__ = _actuators.delete_ModOpAddReserves

# Register ModOpAddReserves in _actuators:
_actuators.ModOpAddReserves_swigregister(ModOpAddReserves)
class ModOpAddResiduals(ModelOperator):
    r"""
     Add residual actuators to the model using
    ModelFactory::createResidualActuators.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpAddResiduals

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpAddResiduals_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpAddResiduals self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpAddResiduals_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpAddResiduals_getClassName()

    def clone(self):
        r"""clone(ModOpAddResiduals self) -> ModOpAddResiduals"""
        return _actuators.ModOpAddResiduals_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpAddResiduals self) -> std::string const &"""
        return _actuators.ModOpAddResiduals_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ModOpAddResiduals self) -> ModOpAddResiduals
        __init__(ModOpAddResiduals self, double rotOptimalForce, double transOptimalForce) -> ModOpAddResiduals

        Parameters
        ----------
        rotOptimalForce: double
        transOptimalForce: double

        __init__(ModOpAddResiduals self, double rotOptimalForce, double transOptimalForce, double bound) -> ModOpAddResiduals

        Parameters
        ----------
        rotOptimalForce: double
        transOptimalForce: double
        bound: double

        __init__(ModOpAddResiduals self, double rotOptimalForce, double transOptimalForce, double bounds, bool skipCoordsWithActu) -> ModOpAddResiduals

        Parameters
        ----------
        rotOptimalForce: double
        transOptimalForce: double
        bounds: double
        skipCoordsWithActu: bool

        """
        _actuators.ModOpAddResiduals_swiginit(self, _actuators.new_ModOpAddResiduals(*args))

    def operate(self, model, arg3):
        r"""
        operate(ModOpAddResiduals self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpAddResiduals_operate(self, model, arg3)
    __swig_destroy__ = _actuators.delete_ModOpAddResiduals

# Register ModOpAddResiduals in _actuators:
_actuators.ModOpAddResiduals_swigregister(ModOpAddResiduals)
class ModOpAddExternalLoads(ModelOperator):
    r"""
     Add external loads (e.g., ground reaction forces) to the model from a
    XML file. The ExternalLoads setting
    external_loads_model_kinematics_file is ignored.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpAddExternalLoads

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpAddExternalLoads_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpAddExternalLoads self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpAddExternalLoads_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpAddExternalLoads_getClassName()

    def clone(self):
        r"""clone(ModOpAddExternalLoads self) -> ModOpAddExternalLoads"""
        return _actuators.ModOpAddExternalLoads_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpAddExternalLoads self) -> std::string const &"""
        return _actuators.ModOpAddExternalLoads_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ModOpAddExternalLoads self) -> ModOpAddExternalLoads
        __init__(ModOpAddExternalLoads self, std::string filepath) -> ModOpAddExternalLoads

        Parameters
        ----------
        filepath: std::string

        """
        _actuators.ModOpAddExternalLoads_swiginit(self, _actuators.new_ModOpAddExternalLoads(*args))

    def operate(self, model, relativeToDirectory):
        r""" The ExternalLoads XML file is located relative to `relativeToDirectory`."""
        return _actuators.ModOpAddExternalLoads_operate(self, model, relativeToDirectory)
    __swig_destroy__ = _actuators.delete_ModOpAddExternalLoads

# Register ModOpAddExternalLoads in _actuators:
_actuators.ModOpAddExternalLoads_swigregister(ModOpAddExternalLoads)
class ModOpReplaceJointsWithWelds(ModelOperator):
    r"""Proxy of C++ OpenSim::ModOpReplaceJointsWithWelds class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpReplaceJointsWithWelds

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpReplaceJointsWithWelds_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpReplaceJointsWithWelds self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpReplaceJointsWithWelds_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpReplaceJointsWithWelds_getClassName()

    def clone(self):
        r"""clone(ModOpReplaceJointsWithWelds self) -> ModOpReplaceJointsWithWelds"""
        return _actuators.ModOpReplaceJointsWithWelds_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpReplaceJointsWithWelds self) -> std::string const &"""
        return _actuators.ModOpReplaceJointsWithWelds_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ModOpReplaceJointsWithWelds self) -> ModOpReplaceJointsWithWelds
        __init__(ModOpReplaceJointsWithWelds self, StdVectorString paths) -> ModOpReplaceJointsWithWelds

        Parameters
        ----------
        paths: std::vector< std::string,std::allocator< std::string > > const &

        """
        _actuators.ModOpReplaceJointsWithWelds_swiginit(self, _actuators.new_ModOpReplaceJointsWithWelds(*args))

    def operate(self, model, arg3):
        r"""
        operate(ModOpReplaceJointsWithWelds self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpReplaceJointsWithWelds_operate(self, model, arg3)
    __swig_destroy__ = _actuators.delete_ModOpReplaceJointsWithWelds

# Register ModOpReplaceJointsWithWelds in _actuators:
_actuators.ModOpReplaceJointsWithWelds_swigregister(ModOpReplaceJointsWithWelds)
class ModOpReplaceMusclesWithPathActuators(ModelOperator):
    r""" Invoke ModelFactory::replaceMusclesWithPathActuators() on the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpReplaceMusclesWithPathActuators

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpReplaceMusclesWithPathActuators_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpReplaceMusclesWithPathActuators self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpReplaceMusclesWithPathActuators_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpReplaceMusclesWithPathActuators_getClassName()

    def clone(self):
        r"""clone(ModOpReplaceMusclesWithPathActuators self) -> ModOpReplaceMusclesWithPathActuators"""
        return _actuators.ModOpReplaceMusclesWithPathActuators_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpReplaceMusclesWithPathActuators self) -> std::string const &"""
        return _actuators.ModOpReplaceMusclesWithPathActuators_getConcreteClassName(self)

    def operate(self, model, arg3):
        r"""
        operate(ModOpReplaceMusclesWithPathActuators self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpReplaceMusclesWithPathActuators_operate(self, model, arg3)

    def __init__(self):
        r"""__init__(ModOpReplaceMusclesWithPathActuators self) -> ModOpReplaceMusclesWithPathActuators"""
        _actuators.ModOpReplaceMusclesWithPathActuators_swiginit(self, _actuators.new_ModOpReplaceMusclesWithPathActuators())
    __swig_destroy__ = _actuators.delete_ModOpReplaceMusclesWithPathActuators

# Register ModOpReplaceMusclesWithPathActuators in _actuators:
_actuators.ModOpReplaceMusclesWithPathActuators_swigregister(ModOpReplaceMusclesWithPathActuators)
class ModOpReplacePathsWithFunctionBasedPaths(ModelOperator):
    r""" Invoke ModelFactory::replacePathsWithFunctionBasedPaths() on the model."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpReplacePathsWithFunctionBasedPaths

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpReplacePathsWithFunctionBasedPaths_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpReplacePathsWithFunctionBasedPaths self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpReplacePathsWithFunctionBasedPaths_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpReplacePathsWithFunctionBasedPaths_getClassName()

    def clone(self):
        r"""clone(ModOpReplacePathsWithFunctionBasedPaths self) -> ModOpReplacePathsWithFunctionBasedPaths"""
        return _actuators.ModOpReplacePathsWithFunctionBasedPaths_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpReplacePathsWithFunctionBasedPaths self) -> std::string const &"""
        return _actuators.ModOpReplacePathsWithFunctionBasedPaths_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ModOpReplacePathsWithFunctionBasedPaths self) -> ModOpReplacePathsWithFunctionBasedPaths
        __init__(ModOpReplacePathsWithFunctionBasedPaths self, std::string pathsFile) -> ModOpReplacePathsWithFunctionBasedPaths

        Parameters
        ----------
        pathsFile: std::string

        """
        _actuators.ModOpReplacePathsWithFunctionBasedPaths_swiginit(self, _actuators.new_ModOpReplacePathsWithFunctionBasedPaths(*args))

    def operate(self, model, arg3):
        r"""
        operate(ModOpReplacePathsWithFunctionBasedPaths self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpReplacePathsWithFunctionBasedPaths_operate(self, model, arg3)
    __swig_destroy__ = _actuators.delete_ModOpReplacePathsWithFunctionBasedPaths

# Register ModOpReplacePathsWithFunctionBasedPaths in _actuators:
_actuators.ModOpReplacePathsWithFunctionBasedPaths_swigregister(ModOpReplacePathsWithFunctionBasedPaths)
class ModOpPrescribeCoordinateValues(ModelOperator):
    r"""
    Prescribe motion to Coordinate%s in a model by providing a table containing
    time series data of Coordinate values. Any columns in the provided table
    (e.g., "/jointset/ankle_r/ankle_angle_r/value") that do not match a valid
    path to a Joint Coordinate value in the model will be ignored. A GCVSpline
    function is created for each column of Coordinate values and this function
    is assigned to the `prescribed_function` property for the matching Coordinate.
    In addition, the `prescribed` property for each matching Coordinate is set
    to "true".
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ModOpPrescribeCoordinateValues

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.ModOpPrescribeCoordinateValues_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ModOpPrescribeCoordinateValues self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.ModOpPrescribeCoordinateValues_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.ModOpPrescribeCoordinateValues_getClassName()

    def clone(self):
        r"""clone(ModOpPrescribeCoordinateValues self) -> ModOpPrescribeCoordinateValues"""
        return _actuators.ModOpPrescribeCoordinateValues_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ModOpPrescribeCoordinateValues self) -> std::string const &"""
        return _actuators.ModOpPrescribeCoordinateValues_getConcreteClassName(self)

    def __init__(self, table):
        r"""
        __init__(ModOpPrescribeCoordinateValues self, TableProcessor table) -> ModOpPrescribeCoordinateValues

        Parameters
        ----------
        table: OpenSim::TableProcessor

        """
        _actuators.ModOpPrescribeCoordinateValues_swiginit(self, _actuators.new_ModOpPrescribeCoordinateValues(table))

    def operate(self, model, arg3):
        r"""
        operate(ModOpPrescribeCoordinateValues self, Model model, std::string const & arg3)

        Parameters
        ----------
        model: OpenSim::Model &
        arg3: std::string const &

        """
        return _actuators.ModOpPrescribeCoordinateValues_operate(self, model, arg3)
    __swig_destroy__ = _actuators.delete_ModOpPrescribeCoordinateValues

# Register ModOpPrescribeCoordinateValues in _actuators:
_actuators.ModOpPrescribeCoordinateValues_swigregister(ModOpPrescribeCoordinateValues)
class PolynomialPathFitterBounds(opensim.common.OpenSimObject):
    r"""
    A helper class for specifying the minimum and maximum bounds for the
    coordinate at `coordinate_path` during path fitting.

    The bounds are specified as a `SimTK::Vec2` in the property `bounds`, where
    the first element is the minimum bound and the second element is the maximum
    bound.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PolynomialPathFitterBounds

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.PolynomialPathFitterBounds_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PolynomialPathFitterBounds self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.PolynomialPathFitterBounds_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.PolynomialPathFitterBounds_getClassName()

    def clone(self):
        r"""clone(PolynomialPathFitterBounds self) -> PolynomialPathFitterBounds"""
        return _actuators.PolynomialPathFitterBounds_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PolynomialPathFitterBounds self) -> std::string const &"""
        return _actuators.PolynomialPathFitterBounds_getConcreteClassName(self)

    def copyProperty_coordinate_path(self, source):
        r"""
        copyProperty_coordinate_path(PolynomialPathFitterBounds self, PolynomialPathFitterBounds source)

        Parameters
        ----------
        source: OpenSim::PolynomialPathFitterBounds::Self const &

        """
        return _actuators.PolynomialPathFitterBounds_copyProperty_coordinate_path(self, source)

    def append_coordinate_path(self, value):
        r"""
        append_coordinate_path(PolynomialPathFitterBounds self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.PolynomialPathFitterBounds_append_coordinate_path(self, value)

    def constructProperty_coordinate_path(self, initValue):
        r"""
        constructProperty_coordinate_path(PolynomialPathFitterBounds self, std::string const & initValue)

        Parameters
        ----------
        initValue: std::string const &

        """
        return _actuators.PolynomialPathFitterBounds_constructProperty_coordinate_path(self, initValue)

    def get_coordinate_path(self, *args):
        r"""
        get_coordinate_path(PolynomialPathFitterBounds self, int i) -> std::string const

        Parameters
        ----------
        i: int

        get_coordinate_path(PolynomialPathFitterBounds self) -> std::string const &
        """
        return _actuators.PolynomialPathFitterBounds_get_coordinate_path(self, *args)

    def upd_coordinate_path(self, *args):
        r"""
        upd_coordinate_path(PolynomialPathFitterBounds self, int i) -> std::string

        Parameters
        ----------
        i: int

        upd_coordinate_path(PolynomialPathFitterBounds self) -> std::string &
        """
        return _actuators.PolynomialPathFitterBounds_upd_coordinate_path(self, *args)

    def set_coordinate_path(self, *args):
        r"""
        set_coordinate_path(PolynomialPathFitterBounds self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        set_coordinate_path(PolynomialPathFitterBounds self, std::string const & value)

        Parameters
        ----------
        value: std::string const &

        """
        return _actuators.PolynomialPathFitterBounds_set_coordinate_path(self, *args)

    def copyProperty_bounds(self, source):
        r"""
        copyProperty_bounds(PolynomialPathFitterBounds self, PolynomialPathFitterBounds source)

        Parameters
        ----------
        source: OpenSim::PolynomialPathFitterBounds::Self const &

        """
        return _actuators.PolynomialPathFitterBounds_copyProperty_bounds(self, source)

    def append_bounds(self, value):
        r"""
        append_bounds(PolynomialPathFitterBounds self, Vec2 value) -> int

        Parameters
        ----------
        value: SimTK::Vec2 const &

        """
        return _actuators.PolynomialPathFitterBounds_append_bounds(self, value)

    def constructProperty_bounds(self, initValue):
        r"""
        constructProperty_bounds(PolynomialPathFitterBounds self, Vec2 initValue)

        Parameters
        ----------
        initValue: SimTK::Vec2 const &

        """
        return _actuators.PolynomialPathFitterBounds_constructProperty_bounds(self, initValue)

    def get_bounds(self, *args):
        r"""
        get_bounds(PolynomialPathFitterBounds self, int i) -> Vec2

        Parameters
        ----------
        i: int

        get_bounds(PolynomialPathFitterBounds self) -> Vec2
        """
        return _actuators.PolynomialPathFitterBounds_get_bounds(self, *args)

    def upd_bounds(self, *args):
        r"""
        upd_bounds(PolynomialPathFitterBounds self, int i) -> Vec2

        Parameters
        ----------
        i: int

        upd_bounds(PolynomialPathFitterBounds self) -> Vec2
        """
        return _actuators.PolynomialPathFitterBounds_upd_bounds(self, *args)

    def set_bounds(self, *args):
        r"""
        set_bounds(PolynomialPathFitterBounds self, int i, Vec2 value)

        Parameters
        ----------
        i: int
        value: SimTK::Vec2 const &

        set_bounds(PolynomialPathFitterBounds self, Vec2 value)

        Parameters
        ----------
        value: SimTK::Vec2 const &

        """
        return _actuators.PolynomialPathFitterBounds_set_bounds(self, *args)

    def __init__(self, *args):
        r"""
        __init__(PolynomialPathFitterBounds self) -> PolynomialPathFitterBounds
        __init__(PolynomialPathFitterBounds self, std::string const & coordinatePath, Vec2 bounds) -> PolynomialPathFitterBounds

        Parameters
        ----------
        coordinatePath: std::string const &
        bounds: SimTK::Vec2 const &

        """
        _actuators.PolynomialPathFitterBounds_swiginit(self, _actuators.new_PolynomialPathFitterBounds(*args))
    __swig_destroy__ = _actuators.delete_PolynomialPathFitterBounds

# Register PolynomialPathFitterBounds in _actuators:
_actuators.PolynomialPathFitterBounds_swigregister(PolynomialPathFitterBounds)
class PolynomialPathFitter(opensim.common.OpenSimObject):
    r"""
    A utility class for fitting a set of `FunctionBasedPath`s to existing
    geometry-path in an OpenSim model using `MultivariatePolynomialFunction`s.

    The primary inputs to this class include a model containing path objects
    derived from `AbstractGeometryPath` (e.g., `GeometryPath`) and a reference
    trajectory containing coordinate values for all `Coordinate`s in the model.
    The path fitting process samples coordinate values around the reference
    trajectory, computes path lengths and moment arms from the geometry-based
    paths in the model, and fits polynomial coefficients for
    `MultivariatePolynomialFunction` objects based on the path length and moment
    arm samples. The fitted paths are written to an XML file, along with the
    modified coordinate values, sampled coordinate values, path lengths, and
    moment arms for both the original and fitted paths.

    Notes: Each file name is prefixed with the name of the model, and the
          directory to which the results are written can be specified using the
         `setOutputDirectory` method.

    # Settings
    Various settings can be adjusted to control the path fitting process. The
    `setMomentArmsThreshold` method determines whether or not a path depends on a
    model coordinate. In other words, the absolute value the moment arm of a with
    respect to a particular coordinate must be greater than this value to be
    included during path fitting. The `setMinimumPolynomialOrder` and
    `setMaximumPolynomialOrder` methods specify the minimum and maximum order of
    the polynomial used to fit each path. The `setGlobalCoordinateSamplingBounds`
    property specifies the global bounds (in degrees) that determine the minimum
    and maximum coordinate values sampled at each time point. The method
    `appendCoordinateSamplingBounds` can be used to override the global bounds
    for a specific coordinate. The `setMomentArmTolerance` and
    `setPathLengthTolerance` methods specify the tolerance on the
    root-mean-square (RMS) error (in meters) between the moment arms and path
    lengths computed from the original model paths and the fitted polynomial
    paths. The `setNumSamplesPerFrame` method specifies the number of samples
    taken per time frame in the coordinate values table used to fit each path.
    The `setNumParallelThreads` method specifies the number of threads used to
    parallelize the path fitting process. The `setLatinHypercubeAlgorithm` method
    specifies the Latin hypercube sampling algorithm used to sample coordinate
    values for path fitting.

    The default settings are as follows:

       - Moment arm threshold: 1e-3 meters
       - Minimum polynomial order: 2
       - Maximum polynomial order: 6
       - Global coordinate sampling bounds: [-10, 10] degrees
       - Moment arm tolerance: 1e-4 meters
       - Path length tolerance: 1e-4 meters
       - Number of samples per frame: 25
       - Number of threads: number of available hardware threads
       - Latin hypercube sampling algorithm: "random"
       - Use stepwise regression: False

    The default settings were chosen based on testing with a human
          lower-extremity model. Different settings may be required for other
          models with larger or smaller anatomical measures (e.g., dinosaur
          models).

    # Usage
    The most basic usage of `PolynomialPathFitter` requires the user to provide
    a model and reference trajectory. The model should contain at least one path
    object derived from `AbstractGeometryPath` and should not contain any
    `FunctionBasedPath` objects. The reference trajectory must contain coordinate
    values for all `Coordinate`s in the model:

    .. code-block:: c++

        PolynomialPathFitter fitter;
        fitter.setModel(ModelProcessor("model.osim"));
        fitter.setCoordinateValues(TableProcessor("values.sto"));

    The additional settings can be adjusted using the various `set` methods
    described above. For example, the global coordinate sampling bounds, bounds
    for the coordinate at "/jointset/slider/position", and the number of samples
    per frame can be set as follows:

    .. code-block:: c++

        fitter.setGlobalCoordinateSamplingBounds(SimTK::Vec2(-20.0, 20.0));
        fitter.appendCoordinateSamplingBounds(
                "/jointset/slider/position", SimTK::Vec2(-5.0, 15.0));
        fitter.setNumSamplesPerFrame(50);

    The path fitting process can be run using the `run()` method:

    .. code-block:: c++

        fitter.run();

    # Recommendations
    Information from each step of the path fitting process is logged to the
    console, provided that you have set the OpenSim::Logger to level "info" or
    greater. Warnings are printed if the number of samples is likely insufficient
    for the fitting process, or if the fit for a particular path did not meet the
    specified tolerances.

    In general, it is up to the user to decide how many sample points are needed
    to adequately cover the range of motion of the model's coordinates. As the
    complexity of a muscle path increases, more sample points over a larger
    dimension of coordinate values are needed to achieve a good fit. Users may
    consider manually creating the coordinates value table to ensure that the
    sampling covers the full range of motion for the model.

    It is highly recommended to use the files printed to the output directory to
    evaluate the quality of the fitted paths (see `setOutputDirectory()` for more
    details). Depending on the quality of the original model, it may not be
    possible to achieve a good fit for all paths (e.g., due to kinks or other
    discontinuities in the path). Finally, the fitted paths should only be used
    in simulations for which the coordinate values represent the expected range
    of motion for the model. If you are unsure if a simulation you have created
    with the fitted paths is valid, you can use the `evaluateFunctionBasedPaths`
    static method to compare the fitted paths to the original model paths given a
    new kinematic trajectory.

    The `evaluateFunctionBasedPaths` method can be used independently from
          the rest of this class, and does not require the `FunctionBasedPath`s
          in the model to use `MultivariatePolynomialFunction`s.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PolynomialPathFitter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _actuators.PolynomialPathFitter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PolynomialPathFitter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _actuators.PolynomialPathFitter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _actuators.PolynomialPathFitter_getClassName()

    def clone(self):
        r"""clone(PolynomialPathFitter self) -> PolynomialPathFitter"""
        return _actuators.PolynomialPathFitter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PolynomialPathFitter self) -> std::string const &"""
        return _actuators.PolynomialPathFitter_getConcreteClassName(self)
    __swig_destroy__ = _actuators.delete_PolynomialPathFitter

    def __init__(self, *args):
        r"""
        __init__(PolynomialPathFitter self) -> PolynomialPathFitter
        __init__(PolynomialPathFitter self, PolynomialPathFitter arg2) -> PolynomialPathFitter

        Parameters
        ----------
        arg2: OpenSim::PolynomialPathFitter const &

        __init__(PolynomialPathFitter self, PolynomialPathFitter arg2) -> PolynomialPathFitter

        Parameters
        ----------
        arg2: OpenSim::PolynomialPathFitter &&

        """
        _actuators.PolynomialPathFitter_swiginit(self, _actuators.new_PolynomialPathFitter(*args))

    def setModel(self, model):
        r"""
        The model containing geometry-based path objects to which
        polynomial-based path objects will be fitted.

        The model should be provided using a `ModelProcessor` object. We expect
        the model to contain at least one path object derived from
        `AbstractGeometryPath` and does not already contain any
        `FunctionBasedPath` objects. The bounds for clamped coordinates are
        obeyed during the fitting process. Locked coordinates are unlocked if
        data is provided for them, or replaced with WeldJoints if no data is
        provided for them.
        """
        return _actuators.PolynomialPathFitter_setModel(self, model)

    def setCoordinateValues(self, coordinateValues):
        r"""
        The reference trajectory used to sample coordinate values for path
        fitting.

        The reference trajectory should be provided using a `TableProcessor`
        object. The reference trajectory must contain coordinate values for all
        `Coordinate`s in the model. We assumed that the coordinate values meet
        all the kinematic constraints in the model, except for
        `CoordinateCouplerConstraint`s, since we automatically update the
        coordinate trajectory to satisfy these constraints. The `TimeSeriesTable`
        must contain the "inDegrees" metadata flag; the coordinate values are
        automatically converted to radians if this flag is set to "yes".
        """
        return _actuators.PolynomialPathFitter_setCoordinateValues(self, coordinateValues)

    def run(self):
        r"""
        Run the path fitting process.

        The path fitting process consists of the following steps:

            1. Load the model and reference coordinate values trajectory. The
               coordinate values table is modified to update the column labels
               based on the model coordinate paths, to update any coordinates
               dependent on `CoordinateCouplerConstraint`s, and to convert the
               coordinate values to radians if the "inDegrees" metadata flag is
               set to "yes".

            2. Set sampling bounds for coordinates based on the global and
               coordinate-specific bounds properties.

            3. Verify that the remaining user settings are valid.

            4. Sample coordinate values around the reference trajectory using
               Latin hypercube sampling. The sampling is defined based on the
               coordinate bounds and range maps, the number of samples per frame,
               and the Latin hypercube sampling algorithm.

            5. Compute path lengths and moment arms from the geometry-based paths
               in the input model.

            6. Filter out bad coordinate samples and populate a map containing
               the coordinates that path is dependent on.

            7. Fit the polynomial coefficients by finding a least-squares fit
               between the path lengths and moment arms computed from the
               geometry-based paths and the path lengths and moment arms
               computed from the fitted polynomial-based paths.

            8. Print out a summary of the path fitting results, including
               information about the fitted polynomial functions and
               root-mean-square (RMS) errors between the original and fitted
               paths.

            9. Write the fitted paths, modified coordinate values, sampled
               coordinate values, path lengths, and moment arms to files.

        Notes: Steps 4, 5, and 7 are parallelized using the number of threads
              specified via the `setParallel()` method.
        """
        return _actuators.PolynomialPathFitter_run(self)

    def setOutputDirectory(self, directory):
        r"""
        The directory to which the path fitting results are written.

        If the path fitting is successful, the fitted paths are written as a
        `Set` of `FunctionBasedPath` objects (with path length functions defined
        using `MultivariatePolynomialFunction` objects) to an XML file. Files
        containing the modified coordinate values, sampled coordinate values,
        path lengths, and moment arms for both the original and fitted paths are
        also written to the output directory.

        Notes: By default, results are written to the current working directory.
        """
        return _actuators.PolynomialPathFitter_setOutputDirectory(self, directory)

    def getOutputDirectory(self):
        r"""getOutputDirectory(PolynomialPathFitter self) -> std::string"""
        return _actuators.PolynomialPathFitter_getOutputDirectory(self)

    def setUseStepwiseRegression(self, tf):
        r"""
        Whether or not to use stepwise regression to fit a minimal set of
        polynomial coefficients.

        Stepwise regression builds a vector of coefficients by individually
        adding polynomial terms that result in the smallest path length and
        moment arm error. When a new term is added, the fitting process is
        repeated to recompute the coefficients. Polynomial terms are added until
        the path length and moment arm tolerances are met, or the maximum number
        of terms is reached.

        Notes: By default, this setting is false.
        If enabled, stepwise regression will fit coefficients using the
              maximum polynomial order based on `setMaximumPolynomialOrder()`.
        """
        return _actuators.PolynomialPathFitter_setUseStepwiseRegression(self, tf)

    def getUseStepwiseRegression(self):
        r"""getUseStepwiseRegression(PolynomialPathFitter self) -> bool"""
        return _actuators.PolynomialPathFitter_getUseStepwiseRegression(self)

    def setMomentArmThreshold(self, threshold):
        r"""
        The moment arm threshold value that determines whether or not a path
        depends on a model coordinate. In other words, the moment arm of a path
        with respect to a particular coordinate must be greater than this value
        to be included during path fitting.

        Notes: The default moment arm threshold is set to 1e-3 meters.
        """
        return _actuators.PolynomialPathFitter_setMomentArmThreshold(self, threshold)

    def getMomentArmThreshold(self):
        
        return _actuators.PolynomialPathFitter_getMomentArmThreshold(self)

    def setMinimumPolynomialOrder(self, order):
        r"""
        The minimum order of the polynomial used to fit each path. The order of
        a polynomial is the highest power of the independent variable(s) in the
        polynomial.

        Notes: The default minimum polynomial order is set to 2.
        """
        return _actuators.PolynomialPathFitter_setMinimumPolynomialOrder(self, order)

    def getMinimumPolynomialOrder(self):
        
        return _actuators.PolynomialPathFitter_getMinimumPolynomialOrder(self)

    def setMaximumPolynomialOrder(self, order):
        r"""
        The maximum order of the polynomial used to fit each path. The order of
        a polynomial is the highest power of the independent variable(s) in the
        polynomial.

        Notes: The default maximum polynomial order is set to 6.
        """
        return _actuators.PolynomialPathFitter_setMaximumPolynomialOrder(self, order)

    def getMaximumPolynomialOrder(self):
        
        return _actuators.PolynomialPathFitter_getMaximumPolynomialOrder(self)

    def setGlobalCoordinateSamplingBounds(self, bounds):
        r"""
        The global bounds that determine the minimum and maximum coordinate value
        samples at each time point.

        The bounds are specified as a `SimTK::Vec2`, where the first element is
        the minimum bound and the second element is the maximum bound. Rotational
        coordinates are in degrees; translational coordinates in meters. The
        maximum sample value at a particular time point is the nominal coordinate
        value plus the maximum bound, and the minimum sample value is the
        nominal coordinate value minus the minimum bound.

        Notes: The default global bounds are set to [-10, 10] degrees/meters.
        If you have a model with paths that cross translational joints, you may
        to specify smaller bounds for the translational coordinates (see
        `appendCoordinateSamplingBounds()`).

        To override the default global bounds for a specific coordinate,
              use the `appendCoordinateSamplingBounds()` method.
        """
        return _actuators.PolynomialPathFitter_setGlobalCoordinateSamplingBounds(self, bounds)

    def getGlobalCoordinateSamplingBounds(self):
        
        return _actuators.PolynomialPathFitter_getGlobalCoordinateSamplingBounds(self)

    def appendCoordinateSamplingBounds(self, coordinatePath, bounds):
        r"""
        The bounds (in degrees) that determine the minimum and maximum coordinate
        value samples at each time point for the coordinate at `coordinatePath`.

        The bounds are specified as a `SimTK::Vec2`, where the first element is
        the minimum bound and the second element is the maximum bound. The
        maximum sample value at a particular time point is the nominal coordinate
        value plus the maximum bound, and the minimum sample value is the
        nominal coordinate value minus the minimum bound. This overrides the
        global bounds set by `setGlobalCoordinateSamplingBounds()` for this
        coordinate.
        """
        return _actuators.PolynomialPathFitter_appendCoordinateSamplingBounds(self, coordinatePath, bounds)

    def setMomentArmTolerance(self, tolerance):
        r"""
        The tolerance on the root-mean-square (RMS) error (in meters) between the
        moment arms computed from an original model path and a fitted
        polynomial-based path, which is used to determine the order of the
        polynomial used in the fitted path.

        The moment arm RMS error must be less than the tolerance for the
        polynomial order to be accepted. If the RMS error is greater than the
        tolerance, the polynomial order is increased by one and the path is
        refitted. This process is repeated until the RMS error is less than the
        tolerance or the maximum polynomial order is reached.

        Notes: The default moment arm tolerance is set to 1e-4 meters.
        The path length RMS error must also be less than the path length
              tolerance for the polynomial order to be accepted (see
              `setPathLengthTolerance`).
        """
        return _actuators.PolynomialPathFitter_setMomentArmTolerance(self, tolerance)

    def getMomentArmTolerance(self):
        
        return _actuators.PolynomialPathFitter_getMomentArmTolerance(self)

    def setPathLengthTolerance(self, tolerance):
        r"""
        The tolerance on the root-mean-square (RMS) error (in meters) between the
        path lengths computed from an original model path and a fitted
        polynomial-based path, which is used to determine the order of the
        polynomial used in the fitted path.

        The path length RMS error must be less than the tolerance for the
        polynomial order to be accepted. If the RMS error is greater than the
        tolerance, the polynomial order is increased by one and the path is
        refitted. This process is repeated until the RMS error is less than the
        tolerance or the maximum polynomial order is reached.

        Notes: The default path length tolerance is set to 1e-4 meters.
        The moment arm RMS error must also be less than the moment arm
              tolerance for the polynomial order to be accepted (see
             `setMomentArmTolerance`).
        """
        return _actuators.PolynomialPathFitter_setPathLengthTolerance(self, tolerance)

    def getPathLengthTolerance(self):
        
        return _actuators.PolynomialPathFitter_getPathLengthTolerance(self)

    def setNumSamplesPerFrame(self, numSamples):
        r"""
        The number of samples taken per time frame in the coordinate values table
        used to fit each path.

        Notes: The default number of samples per frame is set to 25.
        """
        return _actuators.PolynomialPathFitter_setNumSamplesPerFrame(self, numSamples)

    def getNumSamplesPerFrame(self):
        
        return _actuators.PolynomialPathFitter_getNumSamplesPerFrame(self)

    def setNumParallelThreads(self, numThreads):
        r"""
        The number of threads used to parallelize the path fitting process.

        This setting is used to divide the coordinate sampling, path length and
        moment arm computations, and path fitting across multiple threads. The
        number of threads must be greater than zero.

        Notes: The default is the number of available hardware threads.
        """
        return _actuators.PolynomialPathFitter_setNumParallelThreads(self, numThreads)

    def getNumParallelThreads(self):
        r"""  numThreads)"""
        return _actuators.PolynomialPathFitter_getNumParallelThreads(self)

    def setLatinHypercubeAlgorithm(self, algorithm):
        r"""
        The Latin hypercube sampling algorithm used to sample coordinate values
        for path fitting.

        The Latin hypercube sampling algorithm is used to sample coordinate
        values for path fitting. The algorithm can be set to either "random" or
        "ESEA", which stands for the enhanced stochastic evolutionary algorithm
        developed by Jin et al. 2005 (see class `LatinHypercubeDesign` for more
        details). The "random" algorithm is used by default, and "ESEA" can be
        used to improve the quality of the sampling at the expense of higher
        computational cost. For most applications, the "random" algorithm is
        likely sufficient.
        """
        return _actuators.PolynomialPathFitter_setLatinHypercubeAlgorithm(self, algorithm)

    def getLatinHypercubeAlgorithm(self):
        
        return _actuators.PolynomialPathFitter_getLatinHypercubeAlgorithm(self)

    def setIncludeMomentArmFunctions(self, tf):
        r"""
        Whether or not to include moment arm functions in the fitted path
        (default: false).

        The moment arm functions are constructed by taking the derivative of the
        path length function with respect to the coordinate values using
        symbolic differentiation. The function coefficients are negated to match
        the moment arm convention in OpenSim.
        """
        return _actuators.PolynomialPathFitter_setIncludeMomentArmFunctions(self, tf)

    def getIncludeMomentArmFunctions(self):
        r"""  tf)"""
        return _actuators.PolynomialPathFitter_getIncludeMomentArmFunctions(self)

    def setIncludeLengtheningSpeedFunction(self, tf):
        r"""
        Whether or not to include the lengthening speed function in the fitted
        path (default: false).

        The lengthening speed function is computed by taking dot product of the
        moment arm functions by the vector of time derivatives of the coordinate
        values using symbolic math. The result is negated to offset the negation
        applied to the moment arm function expressions.

        Notes: Since FunctionBasedPath uses cached moment arm values to compute
              lengthening speed, including this function in the path definition
              may make lengthening speed evaluation slower compared to
              only including the moment arm functions (the moment arm expressions
              are effectively evaluated twice). Therefore, this setting is
              disabled by default.
        """
        return _actuators.PolynomialPathFitter_setIncludeLengtheningSpeedFunction(self, tf)

    def getIncludeLengtheningSpeedFunction(self):
        r"""  tf)"""
        return _actuators.PolynomialPathFitter_getIncludeLengtheningSpeedFunction(self)

    @staticmethod
    def evaluateFunctionBasedPaths(model, trajectory, functionBasedPathsFile, pathLengthTolerance=1e-4, momentArmTolerance=1e-4):
        r"""
        Print out a summary of the path fitting results, including information
        about the fitted polynomial functions and root-mean-square (RMS) errors
        between the original and fitted paths.

        The `trajectory` argument is a `TableProcessor` object containing the
        simulation trajectory, specifically the set of coordinate values, used to
        compute path lengths and moment arms. The `polynomialPathsFile` argument
        is the path to an XML file containing the set of `FunctionBasedPath`s
        fitted to the geometry-based paths in `model`. These paths can be defined
        by `MultivariatePolynomialFunction`s generated by this class or any other
        `Function` objects that approximate the original model paths.
        """
        return _actuators.PolynomialPathFitter_evaluateFunctionBasedPaths(model, trajectory, functionBasedPathsFile, pathLengthTolerance, momentArmTolerance)

# Register PolynomialPathFitter in _actuators:
_actuators.PolynomialPathFitter_swigregister(PolynomialPathFitter)

