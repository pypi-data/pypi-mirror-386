# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _analyses
else:
    import _analyses

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _analyses.delete_SwigPyIterator

    def value(self):
        r"""value(SwigPyIterator self) -> PyObject *"""
        return _analyses.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""
        incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _analyses.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""
        decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _analyses.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""
        distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _analyses.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""
        equal(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _analyses.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(SwigPyIterator self) -> SwigPyIterator"""
        return _analyses.SwigPyIterator_copy(self)

    def next(self):
        r"""next(SwigPyIterator self) -> PyObject *"""
        return _analyses.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(SwigPyIterator self) -> PyObject *"""
        return _analyses.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(SwigPyIterator self) -> PyObject *"""
        return _analyses.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""
        advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _analyses.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""
        __eq__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _analyses.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""
        __ne__(SwigPyIterator self, SwigPyIterator x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _analyses.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""
        __iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _analyses.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""
        __isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _analyses.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""
        __add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _analyses.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _analyses.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _analyses:
_analyses.SwigPyIterator_swigregister(SwigPyIterator)
import opensim.actuators
import opensim.simulation
import opensim.common
import opensim.simbody
class Kinematics(opensim.simulation.Analysis):
    r"""
    A class for recording the kinematics of the generalized coordinates
    of a model during a simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Kinematics

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.Kinematics_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Kinematics self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.Kinematics_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.Kinematics_getClassName()

    def clone(self):
        r"""clone(Kinematics self) -> Kinematics"""
        return _analyses.Kinematics_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Kinematics self) -> std::string const &"""
        return _analyses.Kinematics_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(Kinematics self, Model aModel=None) -> Kinematics

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(Kinematics self, std::string const & aFileName) -> Kinematics

        Parameters
        ----------
        aFileName: std::string const &

        """
        _analyses.Kinematics_swiginit(self, _analyses.new_Kinematics(*args))
    __swig_destroy__ = _analyses.delete_Kinematics

    def setStorageCapacityIncrements(self, arg2):
        r"""
        setStorageCapacityIncrements(Kinematics self, int arg2)

        Parameters
        ----------
        arg2: int

        """
        return _analyses.Kinematics_setStorageCapacityIncrements(self, arg2)

    def getAccelerationStorage(self):
        r"""getAccelerationStorage(Kinematics self) -> Storage"""
        return _analyses.Kinematics_getAccelerationStorage(self)

    def getVelocityStorage(self):
        r"""getVelocityStorage(Kinematics self) -> Storage"""
        return _analyses.Kinematics_getVelocityStorage(self)

    def getPositionStorage(self):
        r"""getPositionStorage(Kinematics self) -> Storage"""
        return _analyses.Kinematics_getPositionStorage(self)

    def setModel(self, aModel):
        r"""
        setModel(Kinematics self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.Kinematics_setModel(self, aModel)

    def setRecordAccelerations(self, aRecordAccelerations):
        r"""
        setRecordAccelerations(Kinematics self, bool aRecordAccelerations)

        Parameters
        ----------
        aRecordAccelerations: bool

        """
        return _analyses.Kinematics_setRecordAccelerations(self, aRecordAccelerations)

    def begin(self, s):
        r"""
        begin(Kinematics self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.Kinematics_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(Kinematics self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.Kinematics_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(Kinematics self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.Kinematics_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(Kinematics self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.Kinematics_printResults(self, *args)

# Register Kinematics in _analyses:
_analyses.Kinematics_swigregister(Kinematics)
class Actuation(opensim.simulation.Analysis):
    r"""
    A class for recording the basic actuator information for a model
    during a simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> Actuation

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.Actuation_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(Actuation self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.Actuation_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.Actuation_getClassName()

    def clone(self):
        r"""clone(Actuation self) -> Actuation"""
        return _analyses.Actuation_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(Actuation self) -> std::string const &"""
        return _analyses.Actuation_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(Actuation self, Model aModel=None) -> Actuation

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(Actuation self, std::string const & aFileName) -> Actuation

        Parameters
        ----------
        aFileName: std::string const &

        __init__(Actuation self, Actuation aObject) -> Actuation

        Parameters
        ----------
        aObject: OpenSim::Actuation const &

        """
        _analyses.Actuation_swiginit(self, _analyses.new_Actuation(*args))
    __swig_destroy__ = _analyses.delete_Actuation

    def setStorageCapacityIncrements(self, arg2):
        r"""
        setStorageCapacityIncrements(Actuation self, int arg2)

        Parameters
        ----------
        arg2: int

        """
        return _analyses.Actuation_setStorageCapacityIncrements(self, arg2)

    def getForceStorage(self):
        r"""getForceStorage(Actuation self) -> Storage"""
        return _analyses.Actuation_getForceStorage(self)

    def getSpeedStorage(self):
        r"""getSpeedStorage(Actuation self) -> Storage"""
        return _analyses.Actuation_getSpeedStorage(self)

    def getPowerStorage(self):
        r"""getPowerStorage(Actuation self) -> Storage"""
        return _analyses.Actuation_getPowerStorage(self)

    def setModel(self, aModel):
        r"""
        setModel(Actuation self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.Actuation_setModel(self, aModel)

    def begin(self, s):
        r"""
        begin(Actuation self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.Actuation_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(Actuation self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.Actuation_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(Actuation self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.Actuation_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(Actuation self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.Actuation_printResults(self, *args)

# Register Actuation in _analyses:
_analyses.Actuation_swigregister(Actuation)
class MuscleAnalysis(opensim.simulation.Analysis):
    r"""
    A class for recording and computing basic quantities (length, shortening
    velocity, tendon length, ...) for muscles during a simulation.

    Author: Ajay Seth, Matthew Millard, Katherine Holzbaur, Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> MuscleAnalysis

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.MuscleAnalysis_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(MuscleAnalysis self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.MuscleAnalysis_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.MuscleAnalysis_getClassName()

    def clone(self):
        r"""clone(MuscleAnalysis self) -> MuscleAnalysis"""
        return _analyses.MuscleAnalysis_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(MuscleAnalysis self) -> std::string const &"""
        return _analyses.MuscleAnalysis_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(MuscleAnalysis self, Model aModel=None) -> MuscleAnalysis

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(MuscleAnalysis self, std::string const & aFileName) -> MuscleAnalysis

        Parameters
        ----------
        aFileName: std::string const &

        __init__(MuscleAnalysis self, MuscleAnalysis aObject) -> MuscleAnalysis

        Parameters
        ----------
        aObject: OpenSim::MuscleAnalysis const &

        """
        _analyses.MuscleAnalysis_swiginit(self, _analyses.new_MuscleAnalysis(*args))
    __swig_destroy__ = _analyses.delete_MuscleAnalysis

    def setModel(self, aModel):
        r"""
        setModel(MuscleAnalysis self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.MuscleAnalysis_setModel(self, aModel)

    def setStorageCapacityIncrements(self, arg2):
        r"""
        setStorageCapacityIncrements(MuscleAnalysis self, int arg2)

        Parameters
        ----------
        arg2: int

        """
        return _analyses.MuscleAnalysis_setStorageCapacityIncrements(self, arg2)

    def getPennationAngleStorage(self):
        r"""getPennationAngleStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getPennationAngleStorage(self)

    def getMuscleTendonLengthStorage(self):
        r"""getMuscleTendonLengthStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getMuscleTendonLengthStorage(self)

    def getFiberLengthStorage(self):
        r"""getFiberLengthStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getFiberLengthStorage(self)

    def getNormalizedFiberLengthStorage(self):
        r"""getNormalizedFiberLengthStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getNormalizedFiberLengthStorage(self)

    def getTendonLengthStorage(self):
        r"""getTendonLengthStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getTendonLengthStorage(self)

    def getFiberVelocityStorage(self):
        r"""getFiberVelocityStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getFiberVelocityStorage(self)

    def getNormalizedFiberVelocityStorage(self):
        r"""getNormalizedFiberVelocityStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getNormalizedFiberVelocityStorage(self)

    def getPennationAngularVelocityStorage(self):
        r"""getPennationAngularVelocityStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getPennationAngularVelocityStorage(self)

    def getForceStorage(self):
        r"""getForceStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getForceStorage(self)

    def getFiberForceStorage(self):
        r"""getFiberForceStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getFiberForceStorage(self)

    def getActiveFiberForceStorage(self):
        r"""getActiveFiberForceStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getActiveFiberForceStorage(self)

    def getPassiveFiberForceStorage(self):
        r"""getPassiveFiberForceStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getPassiveFiberForceStorage(self)

    def getActiveFiberForceAlongTendonStorage(self):
        r"""getActiveFiberForceAlongTendonStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getActiveFiberForceAlongTendonStorage(self)

    def getPassiveFiberForceAlongTendonStorage(self):
        r"""getPassiveFiberForceAlongTendonStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getPassiveFiberForceAlongTendonStorage(self)

    def getFiberActivePowerStorage(self):
        r"""getFiberActivePowerStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getFiberActivePowerStorage(self)

    def getFiberPassivePowerStorage(self):
        r"""getFiberPassivePowerStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getFiberPassivePowerStorage(self)

    def getTendonPowerStorage(self):
        r"""getTendonPowerStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getTendonPowerStorage(self)

    def getMusclePowerStorage(self):
        r"""getMusclePowerStorage(MuscleAnalysis self) -> Storage"""
        return _analyses.MuscleAnalysis_getMusclePowerStorage(self)

    def setMuscles(self, aMuscles):
        r"""
        setMuscles(MuscleAnalysis self, ArrayStr aMuscles)

        Parameters
        ----------
        aMuscles: OpenSim::Array< std::string > &

        """
        return _analyses.MuscleAnalysis_setMuscles(self, aMuscles)

    def setCoordinates(self, aCoordinates):
        r"""
        setCoordinates(MuscleAnalysis self, ArrayStr aCoordinates)

        Parameters
        ----------
        aCoordinates: OpenSim::Array< std::string > &

        """
        return _analyses.MuscleAnalysis_setCoordinates(self, aCoordinates)

    def setComputeMoments(self, aTrueFalse):
        r"""
        setComputeMoments(MuscleAnalysis self, bool aTrueFalse)

        Parameters
        ----------
        aTrueFalse: bool

        """
        return _analyses.MuscleAnalysis_setComputeMoments(self, aTrueFalse)

    def getComputeMoments(self):
        r"""getComputeMoments(MuscleAnalysis self) -> bool"""
        return _analyses.MuscleAnalysis_getComputeMoments(self)

    def begin(self, s):
        r"""
        begin(MuscleAnalysis self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.MuscleAnalysis_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(MuscleAnalysis self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.MuscleAnalysis_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(MuscleAnalysis self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.MuscleAnalysis_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(MuscleAnalysis self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.MuscleAnalysis_printResults(self, *args)

    def allocateStorageObjects(self):
        r"""
        Intended for use only by GUI that holds one MuscleAnalysis and keeps changing attributes to generate various plots
        For all other use cases, the code handles the allocation/deallocation of resources internally.
        """
        return _analyses.MuscleAnalysis_allocateStorageObjects(self)

# Register MuscleAnalysis in _analyses:
_analyses.MuscleAnalysis_swigregister(MuscleAnalysis)
class InverseDynamics(opensim.simulation.Analysis):
    r"""
     Conditional comment: *
    A class for performing and recording Inverse Dynamics forces/moments
    on a motion trajectory.

    Author: Eran
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> InverseDynamics

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.InverseDynamics_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(InverseDynamics self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.InverseDynamics_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.InverseDynamics_getClassName()

    def clone(self):
        r"""clone(InverseDynamics self) -> InverseDynamics"""
        return _analyses.InverseDynamics_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(InverseDynamics self) -> std::string const &"""
        return _analyses.InverseDynamics_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(InverseDynamics self, Model aModel=None) -> InverseDynamics

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(InverseDynamics self, InverseDynamics aObject) -> InverseDynamics

        Parameters
        ----------
        aObject: OpenSim::InverseDynamics const &

        """
        _analyses.InverseDynamics_swiginit(self, _analyses.new_InverseDynamics(*args))
    __swig_destroy__ = _analyses.delete_InverseDynamics

    def setStorageCapacityIncrements(self, arg2):
        r"""
        setStorageCapacityIncrements(InverseDynamics self, int arg2)

        Parameters
        ----------
        arg2: int

        """
        return _analyses.InverseDynamics_setStorageCapacityIncrements(self, arg2)

    def getStorage(self):
        r"""getStorage(InverseDynamics self) -> Storage"""
        return _analyses.InverseDynamics_getStorage(self)

    def getUseModelForceSet(self):
        r"""getUseModelForceSet(InverseDynamics self) -> bool"""
        return _analyses.InverseDynamics_getUseModelForceSet(self)

    def setUseModelForceSet(self, aUseModelForceSet):
        r"""
        setUseModelForceSet(InverseDynamics self, bool aUseModelForceSet)

        Parameters
        ----------
        aUseModelForceSet: bool

        """
        return _analyses.InverseDynamics_setUseModelForceSet(self, aUseModelForceSet)

    def setModel(self, aModel):
        r"""
        setModel(InverseDynamics self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.InverseDynamics_setModel(self, aModel)

    def printResults(self, *args):
        r"""
        printResults(InverseDynamics self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.InverseDynamics_printResults(self, *args)

# Register InverseDynamics in _analyses:
_analyses.InverseDynamics_swigregister(InverseDynamics)
class StaticOptimization(opensim.simulation.Analysis):
    r"""
    This class implements static optimization to compute Muscle Forces and
    activations.

    Author: Jeff Reinbolt
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> StaticOptimization

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.StaticOptimization_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(StaticOptimization self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.StaticOptimization_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.StaticOptimization_getClassName()

    def clone(self):
        r"""clone(StaticOptimization self) -> StaticOptimization"""
        return _analyses.StaticOptimization_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(StaticOptimization self) -> std::string const &"""
        return _analyses.StaticOptimization_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(StaticOptimization self, Model aModel=None) -> StaticOptimization

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(StaticOptimization self, StaticOptimization aObject) -> StaticOptimization

        Parameters
        ----------
        aObject: OpenSim::StaticOptimization const &

        """
        _analyses.StaticOptimization_swiginit(self, _analyses.new_StaticOptimization(*args))
    __swig_destroy__ = _analyses.delete_StaticOptimization

    def setStorageCapacityIncrements(self, arg2):
        r"""
        setStorageCapacityIncrements(StaticOptimization self, int arg2)

        Parameters
        ----------
        arg2: int

        """
        return _analyses.StaticOptimization_setStorageCapacityIncrements(self, arg2)

    def getActivationStorage(self):
        r"""getActivationStorage(StaticOptimization self) -> Storage"""
        return _analyses.StaticOptimization_getActivationStorage(self)

    def getForceStorage(self):
        r"""getForceStorage(StaticOptimization self) -> Storage"""
        return _analyses.StaticOptimization_getForceStorage(self)

    def getStatesDerivativeStore(self):
        r"""getStatesDerivativeStore(StaticOptimization self) -> Storage"""
        return _analyses.StaticOptimization_getStatesDerivativeStore(self)

    def getUseModelForceSet(self):
        r"""getUseModelForceSet(StaticOptimization self) -> bool"""
        return _analyses.StaticOptimization_getUseModelForceSet(self)

    def setUseModelForceSet(self, aUseModelActuatorSet):
        r"""
        setUseModelForceSet(StaticOptimization self, bool aUseModelActuatorSet)

        Parameters
        ----------
        aUseModelActuatorSet: bool

        """
        return _analyses.StaticOptimization_setUseModelForceSet(self, aUseModelActuatorSet)

    def setModel(self, aModel):
        r"""
        setModel(StaticOptimization self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.StaticOptimization_setModel(self, aModel)

    def setActivationExponent(self, aExponent):
        r"""
        setActivationExponent(StaticOptimization self, double const aExponent)

        Parameters
        ----------
        aExponent: double const

        """
        return _analyses.StaticOptimization_setActivationExponent(self, aExponent)

    def getActivationExponent(self):
        r"""getActivationExponent(StaticOptimization self) -> double"""
        return _analyses.StaticOptimization_getActivationExponent(self)

    def setUseMusclePhysiology(self, useIt):
        r"""
        setUseMusclePhysiology(StaticOptimization self, bool const useIt)

        Parameters
        ----------
        useIt: bool const

        """
        return _analyses.StaticOptimization_setUseMusclePhysiology(self, useIt)

    def getUseMusclePhysiology(self):
        r"""getUseMusclePhysiology(StaticOptimization self) -> bool"""
        return _analyses.StaticOptimization_getUseMusclePhysiology(self)

    def setConvergenceCriterion(self, tolerance):
        r"""
        setConvergenceCriterion(StaticOptimization self, double const tolerance)

        Parameters
        ----------
        tolerance: double const

        """
        return _analyses.StaticOptimization_setConvergenceCriterion(self, tolerance)

    def getConvergenceCriterion(self):
        r"""getConvergenceCriterion(StaticOptimization self) -> double"""
        return _analyses.StaticOptimization_getConvergenceCriterion(self)

    def setMaxIterations(self, maxIt):
        r"""
        setMaxIterations(StaticOptimization self, int const maxIt)

        Parameters
        ----------
        maxIt: int const

        """
        return _analyses.StaticOptimization_setMaxIterations(self, maxIt)

    def getMaxIterations(self):
        r"""getMaxIterations(StaticOptimization self) -> int"""
        return _analyses.StaticOptimization_getMaxIterations(self)

    def begin(self, s):
        r"""
        begin(StaticOptimization self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.StaticOptimization_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(StaticOptimization self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.StaticOptimization_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(StaticOptimization self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.StaticOptimization_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(StaticOptimization self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.StaticOptimization_printResults(self, *args)

# Register StaticOptimization in _analyses:
_analyses.StaticOptimization_swigregister(StaticOptimization)
class ForceReporter(opensim.simulation.Analysis):
    r"""
    A class for recording the Forces applied to a model
    during a simulation.

    Author: Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ForceReporter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.ForceReporter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ForceReporter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.ForceReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.ForceReporter_getClassName()

    def clone(self):
        r"""clone(ForceReporter self) -> ForceReporter"""
        return _analyses.ForceReporter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ForceReporter self) -> std::string const &"""
        return _analyses.ForceReporter_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ForceReporter self, Model aModel=None) -> ForceReporter

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(ForceReporter self, std::string const & aFileName) -> ForceReporter

        Parameters
        ----------
        aFileName: std::string const &

        __init__(ForceReporter self, ForceReporter aObject) -> ForceReporter

        Parameters
        ----------
        aObject: OpenSim::ForceReporter const &

        """
        _analyses.ForceReporter_swiginit(self, _analyses.new_ForceReporter(*args))
    __swig_destroy__ = _analyses.delete_ForceReporter

    def getForceStorage(self):
        r"""getForceStorage(ForceReporter self) -> Storage"""
        return _analyses.ForceReporter_getForceStorage(self)

    def updForceStorage(self):
        r"""updForceStorage(ForceReporter self) -> Storage"""
        return _analyses.ForceReporter_updForceStorage(self)

    def getForcesTable(self):
        r""" Get forces table."""
        return _analyses.ForceReporter_getForcesTable(self)

    def setModel(self, aModel):
        r"""
        setModel(ForceReporter self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.ForceReporter_setModel(self, aModel)

    def includeConstraintForces(self, flag):
        r"""
        includeConstraintForces(ForceReporter self, bool flag)

        Parameters
        ----------
        flag: bool

        """
        return _analyses.ForceReporter_includeConstraintForces(self, flag)

    def begin(self, s):
        r"""
        begin(ForceReporter self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.ForceReporter_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(ForceReporter self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.ForceReporter_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(ForceReporter self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.ForceReporter_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(ForceReporter self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.ForceReporter_printResults(self, *args)

# Register ForceReporter in _analyses:
_analyses.ForceReporter_swigregister(ForceReporter)
class PointKinematics(opensim.simulation.Analysis):
    r"""
    A class for recording the kinematics of a point on a body
    of a model during a simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> PointKinematics

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.PointKinematics_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(PointKinematics self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.PointKinematics_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.PointKinematics_getClassName()

    def clone(self):
        r"""clone(PointKinematics self) -> PointKinematics"""
        return _analyses.PointKinematics_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(PointKinematics self) -> std::string const &"""
        return _analyses.PointKinematics_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(PointKinematics self, Model aModel=None) -> PointKinematics

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(PointKinematics self, std::string const & aFileName) -> PointKinematics

        Parameters
        ----------
        aFileName: std::string const &

        __init__(PointKinematics self, PointKinematics aObject) -> PointKinematics

        Parameters
        ----------
        aObject: OpenSim::PointKinematics const &

        """
        _analyses.PointKinematics_swiginit(self, _analyses.new_PointKinematics(*args))
    __swig_destroy__ = _analyses.delete_PointKinematics

    def setBodyPoint(self, aBody, aPoint):
        r"""
        setBodyPoint(PointKinematics self, std::string const & aBody, Vec3 aPoint)

        Parameters
        ----------
        aBody: std::string const &
        aPoint: SimTK::Vec3 const &

        """
        return _analyses.PointKinematics_setBodyPoint(self, aBody, aPoint)

    def setBody(self, aBody):
        r"""
        setBody(PointKinematics self, PhysicalFrame aBody)

        Parameters
        ----------
        aBody: OpenSim::PhysicalFrame const *

        """
        return _analyses.PointKinematics_setBody(self, aBody)

    def setRelativeToBody(self, aBody):
        r"""
        setRelativeToBody(PointKinematics self, PhysicalFrame aBody)

        Parameters
        ----------
        aBody: OpenSim::PhysicalFrame const *

        """
        return _analyses.PointKinematics_setRelativeToBody(self, aBody)

    def getBody(self):
        r"""getBody(PointKinematics self) -> PhysicalFrame"""
        return _analyses.PointKinematics_getBody(self)

    def getRelativeToBody(self):
        r"""getRelativeToBody(PointKinematics self) -> PhysicalFrame"""
        return _analyses.PointKinematics_getRelativeToBody(self)

    def setPoint(self, aPoint):
        r"""
        setPoint(PointKinematics self, Vec3 aPoint)

        Parameters
        ----------
        aPoint: SimTK::Vec3 const &

        """
        return _analyses.PointKinematics_setPoint(self, aPoint)

    def getPoint(self, rPoint):
        r"""
        getPoint(PointKinematics self, Vec3 rPoint)

        Parameters
        ----------
        rPoint: SimTK::Vec3 &

        """
        return _analyses.PointKinematics_getPoint(self, rPoint)

    def setPointName(self, aName):
        r"""
        setPointName(PointKinematics self, std::string const & aName)

        Parameters
        ----------
        aName: std::string const &

        """
        return _analyses.PointKinematics_setPointName(self, aName)

    def getPointName(self):
        r"""getPointName(PointKinematics self) -> std::string const &"""
        return _analyses.PointKinematics_getPointName(self)

    def setModel(self, aModel):
        r"""
        setModel(PointKinematics self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.PointKinematics_setModel(self, aModel)

    def setStorageCapacityIncrements(self, arg2):
        r"""
        setStorageCapacityIncrements(PointKinematics self, int arg2)

        Parameters
        ----------
        arg2: int

        """
        return _analyses.PointKinematics_setStorageCapacityIncrements(self, arg2)

    def getAccelerationStorage(self):
        r"""getAccelerationStorage(PointKinematics self) -> Storage"""
        return _analyses.PointKinematics_getAccelerationStorage(self)

    def getVelocityStorage(self):
        r"""getVelocityStorage(PointKinematics self) -> Storage"""
        return _analyses.PointKinematics_getVelocityStorage(self)

    def getPositionStorage(self):
        r"""getPositionStorage(PointKinematics self) -> Storage"""
        return _analyses.PointKinematics_getPositionStorage(self)

    def begin(self, s):
        r"""
        begin(PointKinematics self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.PointKinematics_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(PointKinematics self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.PointKinematics_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(PointKinematics self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.PointKinematics_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(PointKinematics self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.PointKinematics_printResults(self, *args)

# Register PointKinematics in _analyses:
_analyses.PointKinematics_swigregister(PointKinematics)
cvar = _analyses.cvar
PointKinematicsNAME_LENGTH = cvar.PointKinematicsNAME_LENGTH
PointKinematicsBUFFER_LENGTH = cvar.PointKinematicsBUFFER_LENGTH
PointKinematics.NAME_LENGTH = _analyses.cvar.PointKinematics_NAME_LENGTH
PointKinematics.BUFFER_LENGTH = _analyses.cvar.PointKinematics_BUFFER_LENGTH

class BodyKinematics(opensim.simulation.Analysis):
    r"""
    A class for recording the kinematics of the bodies
    of a model during a simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> BodyKinematics

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.BodyKinematics_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(BodyKinematics self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.BodyKinematics_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.BodyKinematics_getClassName()

    def clone(self):
        r"""clone(BodyKinematics self) -> BodyKinematics"""
        return _analyses.BodyKinematics_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(BodyKinematics self) -> std::string const &"""
        return _analyses.BodyKinematics_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(BodyKinematics self, Model aModel=None, bool aInDegrees=True) -> BodyKinematics

        Parameters
        ----------
        aModel: OpenSim::Model *
        aInDegrees: bool

        __init__(BodyKinematics self, std::string const & aFileName) -> BodyKinematics

        Parameters
        ----------
        aFileName: std::string const &

        __init__(BodyKinematics self, BodyKinematics aObject) -> BodyKinematics

        Parameters
        ----------
        aObject: OpenSim::BodyKinematics const &

        """
        _analyses.BodyKinematics_swiginit(self, _analyses.new_BodyKinematics(*args))
    __swig_destroy__ = _analyses.delete_BodyKinematics

    def setStorageCapacityIncrements(self, arg2):
        r"""
        setStorageCapacityIncrements(BodyKinematics self, int arg2)

        Parameters
        ----------
        arg2: int

        """
        return _analyses.BodyKinematics_setStorageCapacityIncrements(self, arg2)

    def getAccelerationStorage(self):
        r"""getAccelerationStorage(BodyKinematics self) -> Storage"""
        return _analyses.BodyKinematics_getAccelerationStorage(self)

    def getVelocityStorage(self):
        r"""getVelocityStorage(BodyKinematics self) -> Storage"""
        return _analyses.BodyKinematics_getVelocityStorage(self)

    def getPositionStorage(self):
        r"""getPositionStorage(BodyKinematics self) -> Storage"""
        return _analyses.BodyKinematics_getPositionStorage(self)

    def setExpressResultsInLocalFrame(self, aTrueFalse):
        r"""
        setExpressResultsInLocalFrame(BodyKinematics self, bool aTrueFalse)

        Parameters
        ----------
        aTrueFalse: bool

        """
        return _analyses.BodyKinematics_setExpressResultsInLocalFrame(self, aTrueFalse)

    def getExpressResultsInLocalFrame(self):
        r"""getExpressResultsInLocalFrame(BodyKinematics self) -> bool"""
        return _analyses.BodyKinematics_getExpressResultsInLocalFrame(self)

    def setRecordCenterOfMass(self, aTrueFalse):
        r"""
        setRecordCenterOfMass(BodyKinematics self, bool aTrueFalse)

        Parameters
        ----------
        aTrueFalse: bool

        """
        return _analyses.BodyKinematics_setRecordCenterOfMass(self, aTrueFalse)

    def setBodiesToRecord(self, listOfBodies):
        r"""
        setBodiesToRecord(BodyKinematics self, ArrayStr listOfBodies)

        Parameters
        ----------
        listOfBodies: OpenSim::Array< std::string > &

        """
        return _analyses.BodyKinematics_setBodiesToRecord(self, listOfBodies)

    def setModel(self, aModel):
        r"""
        setModel(BodyKinematics self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.BodyKinematics_setModel(self, aModel)

    def begin(self, s):
        r"""
        begin(BodyKinematics self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.BodyKinematics_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(BodyKinematics self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.BodyKinematics_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(BodyKinematics self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.BodyKinematics_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(BodyKinematics self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.BodyKinematics_printResults(self, *args)

# Register BodyKinematics in _analyses:
_analyses.BodyKinematics_swigregister(BodyKinematics)
class JointReaction(opensim.simulation.Analysis):
    r"""
    An analysis for reporting the joint reaction loads from a model. For a given
    joint, the reaction load is calculated as the forces and moments required to
    constrain the body motions to satisfy the joint as if the joint did not
    exist.

    The reaction load acts at the joint center (mobilizer frame) of both the
    parent and child bodies and either force can be reported and expressed in
    any specified frame. The default behavior is the force on the child
    expressed in the ground frame.

    Author: Matt DeMers, Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> JointReaction

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.JointReaction_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(JointReaction self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.JointReaction_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.JointReaction_getClassName()

    def clone(self):
        r"""clone(JointReaction self) -> JointReaction"""
        return _analyses.JointReaction_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(JointReaction self) -> std::string const &"""
        return _analyses.JointReaction_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(JointReaction self, Model aModel=None) -> JointReaction

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(JointReaction self, std::string const & aFileName) -> JointReaction

        Parameters
        ----------
        aFileName: std::string const &

        __init__(JointReaction self, JointReaction aObject) -> JointReaction

        Parameters
        ----------
        aObject: OpenSim::JointReaction const &

        """
        _analyses.JointReaction_swiginit(self, _analyses.new_JointReaction(*args))
    __swig_destroy__ = _analyses.delete_JointReaction

    def setModel(self, aModel):
        r"""
        setModel(JointReaction self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.JointReaction_setModel(self, aModel)

    def getForcesFileName(self):
        r""" Public accessors for the forcesFileName property"""
        return _analyses.JointReaction_getForcesFileName(self)

    def setForcesFileName(self, newForcesFile):
        r"""
        setForcesFileName(JointReaction self, std::string const newForcesFile)

        Parameters
        ----------
        newForcesFile: std::string const

        """
        return _analyses.JointReaction_setForcesFileName(self, newForcesFile)

    def getJointNames(self):
        r""" Public accessors for the JointNames property"""
        return _analyses.JointReaction_getJointNames(self)

    def setJointNames(self, jointNames):
        r"""
        setJointNames(JointReaction self, ArrayStr jointNames)

        Parameters
        ----------
        jointNames: OpenSim::Array< std::string > &

        """
        return _analyses.JointReaction_setJointNames(self, jointNames)

    def getOnBody(self):
        r""" Public accessors for the onBody property"""
        return _analyses.JointReaction_getOnBody(self)

    def setOnBody(self, onBody):
        r"""
        setOnBody(JointReaction self, ArrayStr onBody)

        Parameters
        ----------
        onBody: OpenSim::Array< std::string > &

        """
        return _analyses.JointReaction_setOnBody(self, onBody)

    def getInFrame(self):
        r""" Public accessors for the inFrame property"""
        return _analyses.JointReaction_getInFrame(self)

    def setInFrame(self, inFrame):
        r"""
        setInFrame(JointReaction self, ArrayStr inFrame)

        Parameters
        ----------
        inFrame: OpenSim::Array< std::string > &

        """
        return _analyses.JointReaction_setInFrame(self, inFrame)

    def begin(self, s):
        r"""
        begin(JointReaction self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.JointReaction_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(JointReaction self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.JointReaction_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(JointReaction self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.JointReaction_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(JointReaction self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.JointReaction_printResults(self, *args)

# Register JointReaction in _analyses:
_analyses.JointReaction_swigregister(JointReaction)
class StatesReporter(opensim.simulation.Analysis):
    r"""
    A class for recording the states of a model
    during a simulation.

    Author: Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> StatesReporter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.StatesReporter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(StatesReporter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.StatesReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.StatesReporter_getClassName()

    def clone(self):
        r"""clone(StatesReporter self) -> StatesReporter"""
        return _analyses.StatesReporter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(StatesReporter self) -> std::string const &"""
        return _analyses.StatesReporter_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(StatesReporter self, Model aModel=None) -> StatesReporter

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(StatesReporter self, std::string const & aFileName) -> StatesReporter

        Parameters
        ----------
        aFileName: std::string const &

        __init__(StatesReporter self, StatesReporter aObject) -> StatesReporter

        Parameters
        ----------
        aObject: OpenSim::StatesReporter const &

        """
        _analyses.StatesReporter_swiginit(self, _analyses.new_StatesReporter(*args))
    __swig_destroy__ = _analyses.delete_StatesReporter

    def getStatesStorage(self):
        r"""getStatesStorage(StatesReporter self) -> Storage"""
        return _analyses.StatesReporter_getStatesStorage(self)

    def updStatesStorage(self):
        r"""updStatesStorage(StatesReporter self) -> Storage"""
        return _analyses.StatesReporter_updStatesStorage(self)

    def begin(self, s):
        r"""
        begin(StatesReporter self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.StatesReporter_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(StatesReporter self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.StatesReporter_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(StatesReporter self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.StatesReporter_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(StatesReporter self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.StatesReporter_printResults(self, *args)

# Register StatesReporter in _analyses:
_analyses.StatesReporter_swigregister(StatesReporter)
class InducedAccelerations(opensim.simulation.Analysis):
    r"""
    A class to perform an Induced Accelerations analysis using a constraint-
    method of replacing external (contact) forces in order to determine
    the contributions of actuators to external reaction forces and thus
    model accelerations including that of the center-of-mass.
    The analysis reports the contributions of all forces to user identified
    accelerations of coordinates, bodies and/or center-of-mass.

    Induced Accelerations can apply any OpenSim::Constraint that implements
    setContactPointForInducedAccelerations() to replace external forces, which
    are precisely the same external forces (ExternalLoads file) applied
    during the forward dynamics simulation being analyzed.

    The ConstraintSet supplied must have the same number constraints as
    external forces AND apply to the same bodies with respect to ground.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> InducedAccelerations

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.InducedAccelerations_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(InducedAccelerations self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.InducedAccelerations_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.InducedAccelerations_getClassName()

    def clone(self):
        r"""clone(InducedAccelerations self) -> InducedAccelerations"""
        return _analyses.InducedAccelerations_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(InducedAccelerations self) -> std::string const &"""
        return _analyses.InducedAccelerations_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct an InducedAccelerations instance with a Model.

        :type aModel: :py:class:`Model`, optional
        :param aModel: Model for which the analysis is to be run.

        |

        *Overload 2:*

        Construct InducedAccelerations from file.

        :type aFileName: string
        :param aFileName: File name of the document.

        |

        *Overload 3:*

        Copy constructor.
        """
        _analyses.InducedAccelerations_swiginit(self, _analyses.new_InducedAccelerations(*args))
    __swig_destroy__ = _analyses.delete_InducedAccelerations

    def setModel(self, aModel):
        r"""
        setModel(InducedAccelerations self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.InducedAccelerations_setModel(self, aModel)

    def initialize(self, s):
        r"""
        initialize(InducedAccelerations self, State s)

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.InducedAccelerations_initialize(self, s)

    def begin(self, s):
        r"""
        begin(InducedAccelerations self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.InducedAccelerations_begin(self, s)

    def step(self, s, stepNumber):
        r"""
        step(InducedAccelerations self, State s, int stepNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        stepNumber: int

        """
        return _analyses.InducedAccelerations_step(self, s, stepNumber)

    def end(self, s):
        r"""
        end(InducedAccelerations self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.InducedAccelerations_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(InducedAccelerations self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.InducedAccelerations_printResults(self, *args)

    def addContactConstraintFromExternalForce(self, externalForce):
        r"""
        addContactConstraintFromExternalForce(InducedAccelerations self, ExternalForce externalForce)

        Parameters
        ----------
        externalForce: OpenSim::ExternalForce *

        """
        return _analyses.InducedAccelerations_addContactConstraintFromExternalForce(self, externalForce)

    def applyContactConstraintAccordingToExternalForces(self, s):
        r"""
        applyContactConstraintAccordingToExternalForces(InducedAccelerations self, State s) -> ArrayBool

        Parameters
        ----------
        s: SimTK::State &

        """
        return _analyses.InducedAccelerations_applyContactConstraintAccordingToExternalForces(self, s)

# Register InducedAccelerations in _analyses:
_analyses.InducedAccelerations_swigregister(InducedAccelerations)
class ProbeReporter(opensim.simulation.Analysis):
    r"""
    A class for reporting the outputs of all model-connected Probes to file during
    a simulation. This analysis will, at each 'step_interval', cycle through all
    model Probes and retrieve the SimTK::Vector of probe outputs via getProbeOutputs(s)
    and store them into a Storage object, which will get recorded to a file at the
    termination of the simulation. The column labels for each Probe output will
    come from the overridden method Array<string> getProbeOutputLabels() from the specific
    Probe subclass. A schematic of the ProbeReporter functionality is shown below
    (diagram below assumes a single probe, but ProbeReporter will cycle through every
    Probe in the Model):

                                    DEVELOPER NEEDS TO IMPLEMENT
                                    THIS INSIDE THE CHILD PROBE
                                    ============================
                                    |  SimTK::Vector           |
                              |---> |  computeProbeOutputs(s)  | ----|
                              |     ============================     |
      ===================     |                                      |     ==========================
      |  ProbeReporter  | -----                                      ----> |  Output to file        |
      |  Analysis       | -----                                      ----> |  at end of simulation  |
      ===================     |                                      |     ==========================
                              |     ============================     |
                              |---> |  Array<string>           | ----|
                                    |  getProbeOutputLabels()  |
                                    ============================
                                    DEVELOPER NEEDS TO IMPLEMENT
                                    THIS INSIDE THE CHILD PROBE



    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> ProbeReporter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.ProbeReporter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(ProbeReporter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.ProbeReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.ProbeReporter_getClassName()

    def clone(self):
        r"""clone(ProbeReporter self) -> ProbeReporter"""
        return _analyses.ProbeReporter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(ProbeReporter self) -> std::string const &"""
        return _analyses.ProbeReporter_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        __init__(ProbeReporter self, Model aModel=None) -> ProbeReporter

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(ProbeReporter self, std::string const & aFileName) -> ProbeReporter

        Parameters
        ----------
        aFileName: std::string const &

        __init__(ProbeReporter self, ProbeReporter aObject) -> ProbeReporter

        Parameters
        ----------
        aObject: OpenSim::ProbeReporter const &

        """
        _analyses.ProbeReporter_swiginit(self, _analyses.new_ProbeReporter(*args))
    __swig_destroy__ = _analyses.delete_ProbeReporter

    def getProbeStorage(self):
        r"""getProbeStorage(ProbeReporter self) -> Storage"""
        return _analyses.ProbeReporter_getProbeStorage(self)

    def updProbeStorage(self):
        r"""updProbeStorage(ProbeReporter self) -> Storage"""
        return _analyses.ProbeReporter_updProbeStorage(self)

    def setModel(self, aModel):
        r"""
        setModel(ProbeReporter self, Model aModel)

        Parameters
        ----------
        aModel: OpenSim::Model &

        """
        return _analyses.ProbeReporter_setModel(self, aModel)

    def begin(self, s):
        r"""
        begin(ProbeReporter self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.ProbeReporter_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(ProbeReporter self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.ProbeReporter_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(ProbeReporter self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.ProbeReporter_end(self, s)

    def disableIntegrationOnlyProbes(self):
        r"""disableIntegrationOnlyProbes(ProbeReporter self)"""
        return _analyses.ProbeReporter_disableIntegrationOnlyProbes(self)

    def printResults(self, *args):
        r"""
        printResults(ProbeReporter self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.ProbeReporter_printResults(self, *args)

# Register ProbeReporter in _analyses:
_analyses.ProbeReporter_swigregister(ProbeReporter)
class OutputReporter(opensim.simulation.Analysis):
    r"""
    The OutputReporter Analysis is a wrapper for a TableReporter. It generates
    and writes TimeSeriesTables of Output values according to the names listed
    as properties of the Analysis. OutputReporter enables the AnalyzeTool to
    report on Outputs via the Analysis interface but backed by a TableReporter.
    The OutputReporter currently only supports Outputs of type: double, Vec3
    and SpatialVec. The OutputReporter will automatically write multiple files-
    a file for each supported Output type:
      - `<results-file-name>.sto` (as doubles),
      - `<results-file-name>Vec3.sto`, and
      - `<results-file-name>SpatialVec.sto`.

    Output paths can be absolute (e.g., `/joint/slider/tx|value`) or relative
    to the model (by leaving off the first slash; `joint/slider/tx|value`).
    For outputs on the model itself, you can use `|com_position`, etc. As
    explained for AbstractInput, the vertical bar denotes the output name.

    Note that the internal tables are reset at the beginning of a simulation or
    AnalyzeTool::run() and does not append results to previous tables.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> OutputReporter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.OutputReporter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(OutputReporter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.OutputReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.OutputReporter_getClassName()

    def clone(self):
        r"""clone(OutputReporter self) -> OutputReporter"""
        return _analyses.OutputReporter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(OutputReporter self) -> std::string const &"""
        return _analyses.OutputReporter_getConcreteClassName(self)

    def copyProperty_output_paths(self, source):
        r"""
        copyProperty_output_paths(OutputReporter self, OutputReporter source)

        Parameters
        ----------
        source: OpenSim::OutputReporter::Self const &

        """
        return _analyses.OutputReporter_copyProperty_output_paths(self, source)

    def get_output_paths(self, i):
        r"""
        get_output_paths(OutputReporter self, int i) -> std::string const &

        Parameters
        ----------
        i: int

        """
        return _analyses.OutputReporter_get_output_paths(self, i)

    def upd_output_paths(self, i):
        r"""
        upd_output_paths(OutputReporter self, int i) -> std::string &

        Parameters
        ----------
        i: int

        """
        return _analyses.OutputReporter_upd_output_paths(self, i)

    def set_output_paths(self, i, value):
        r"""
        set_output_paths(OutputReporter self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        """
        return _analyses.OutputReporter_set_output_paths(self, i, value)

    def append_output_paths(self, value):
        r"""
        append_output_paths(OutputReporter self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _analyses.OutputReporter_append_output_paths(self, value)

    def constructProperty_output_paths(self):
        r"""constructProperty_output_paths(OutputReporter self)"""
        return _analyses.OutputReporter_constructProperty_output_paths(self)

    def __init__(self, *args):
        r"""
        __init__(OutputReporter self, Model model=None) -> OutputReporter

        Parameters
        ----------
        model: OpenSim::Model *

        __init__(OutputReporter self, std::string const & fileName) -> OutputReporter

        Parameters
        ----------
        fileName: std::string const &

        """
        _analyses.OutputReporter_swiginit(self, _analyses.new_OutputReporter(*args))
    __swig_destroy__ = _analyses.delete_OutputReporter

# Register OutputReporter in _analyses:
_analyses.OutputReporter_swigregister(OutputReporter)
class IMUDataReporter(opensim.simulation.Analysis):
    r"""
    A class for recording the readings off an IMU object placed on a model
    during a simulation.

    If using this reporter to compute IMU accelerometer signals based on kinematic
    information only (i.e., a solution from the InverseKinematicsTool), then
    set the property `compute_accelerations_without_forces` to true. This property
    will apply forces to the model corresponding to the kinematics that you
    provide as input so that the correct accelerations are computed. The input
    kinematics are splined and then prescribed to the model (via the
    PositionMotion class), and the applied forces are based on derivatives of
    these splines; therefore, you should ensure that the input kinematics produce
    the correct derivatives when splined. It is recommended that you don't not
    compute any quantities near the beginning or end of the time range in your
    data, since spline derivatives can be inaccurate in these regions.

    Author: Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        r"""
        safeDownCast(OpenSimObject obj) -> IMUDataReporter

        Parameters
        ----------
        obj: OpenSim::Object *

        """
        return _analyses.IMUDataReporter_safeDownCast(obj)

    def assign(self, aObject):
        r"""
        assign(IMUDataReporter self, OpenSimObject aObject)

        Parameters
        ----------
        aObject: OpenSim::Object &

        """
        return _analyses.IMUDataReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        r"""getClassName() -> std::string const &"""
        return _analyses.IMUDataReporter_getClassName()

    def clone(self):
        r"""clone(IMUDataReporter self) -> IMUDataReporter"""
        return _analyses.IMUDataReporter_clone(self)

    def getConcreteClassName(self):
        r"""getConcreteClassName(IMUDataReporter self) -> std::string const &"""
        return _analyses.IMUDataReporter_getConcreteClassName(self)

    def copyProperty_report_orientations(self, source):
        r"""
        copyProperty_report_orientations(IMUDataReporter self, IMUDataReporter source)

        Parameters
        ----------
        source: OpenSim::IMUDataReporter::Self const &

        """
        return _analyses.IMUDataReporter_copyProperty_report_orientations(self, source)

    def append_report_orientations(self, value):
        r"""
        append_report_orientations(IMUDataReporter self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _analyses.IMUDataReporter_append_report_orientations(self, value)

    def constructProperty_report_orientations(self, initValue):
        r"""
        constructProperty_report_orientations(IMUDataReporter self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _analyses.IMUDataReporter_constructProperty_report_orientations(self, initValue)

    def get_report_orientations(self, *args):
        r"""
        get_report_orientations(IMUDataReporter self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_report_orientations(IMUDataReporter self) -> bool const &
        """
        return _analyses.IMUDataReporter_get_report_orientations(self, *args)

    def upd_report_orientations(self, *args):
        r"""
        upd_report_orientations(IMUDataReporter self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_report_orientations(IMUDataReporter self) -> bool &
        """
        return _analyses.IMUDataReporter_upd_report_orientations(self, *args)

    def set_report_orientations(self, *args):
        r"""
        set_report_orientations(IMUDataReporter self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_report_orientations(IMUDataReporter self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _analyses.IMUDataReporter_set_report_orientations(self, *args)

    def copyProperty_report_gyroscope_signals(self, source):
        r"""
        copyProperty_report_gyroscope_signals(IMUDataReporter self, IMUDataReporter source)

        Parameters
        ----------
        source: OpenSim::IMUDataReporter::Self const &

        """
        return _analyses.IMUDataReporter_copyProperty_report_gyroscope_signals(self, source)

    def append_report_gyroscope_signals(self, value):
        r"""
        append_report_gyroscope_signals(IMUDataReporter self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _analyses.IMUDataReporter_append_report_gyroscope_signals(self, value)

    def constructProperty_report_gyroscope_signals(self, initValue):
        r"""
        constructProperty_report_gyroscope_signals(IMUDataReporter self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _analyses.IMUDataReporter_constructProperty_report_gyroscope_signals(self, initValue)

    def get_report_gyroscope_signals(self, *args):
        r"""
        get_report_gyroscope_signals(IMUDataReporter self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_report_gyroscope_signals(IMUDataReporter self) -> bool const &
        """
        return _analyses.IMUDataReporter_get_report_gyroscope_signals(self, *args)

    def upd_report_gyroscope_signals(self, *args):
        r"""
        upd_report_gyroscope_signals(IMUDataReporter self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_report_gyroscope_signals(IMUDataReporter self) -> bool &
        """
        return _analyses.IMUDataReporter_upd_report_gyroscope_signals(self, *args)

    def set_report_gyroscope_signals(self, *args):
        r"""
        set_report_gyroscope_signals(IMUDataReporter self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_report_gyroscope_signals(IMUDataReporter self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _analyses.IMUDataReporter_set_report_gyroscope_signals(self, *args)

    def copyProperty_report_accelerometer_signals(self, source):
        r"""
        copyProperty_report_accelerometer_signals(IMUDataReporter self, IMUDataReporter source)

        Parameters
        ----------
        source: OpenSim::IMUDataReporter::Self const &

        """
        return _analyses.IMUDataReporter_copyProperty_report_accelerometer_signals(self, source)

    def append_report_accelerometer_signals(self, value):
        r"""
        append_report_accelerometer_signals(IMUDataReporter self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _analyses.IMUDataReporter_append_report_accelerometer_signals(self, value)

    def constructProperty_report_accelerometer_signals(self, initValue):
        r"""
        constructProperty_report_accelerometer_signals(IMUDataReporter self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _analyses.IMUDataReporter_constructProperty_report_accelerometer_signals(self, initValue)

    def get_report_accelerometer_signals(self, *args):
        r"""
        get_report_accelerometer_signals(IMUDataReporter self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_report_accelerometer_signals(IMUDataReporter self) -> bool const &
        """
        return _analyses.IMUDataReporter_get_report_accelerometer_signals(self, *args)

    def upd_report_accelerometer_signals(self, *args):
        r"""
        upd_report_accelerometer_signals(IMUDataReporter self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_report_accelerometer_signals(IMUDataReporter self) -> bool &
        """
        return _analyses.IMUDataReporter_upd_report_accelerometer_signals(self, *args)

    def set_report_accelerometer_signals(self, *args):
        r"""
        set_report_accelerometer_signals(IMUDataReporter self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_report_accelerometer_signals(IMUDataReporter self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _analyses.IMUDataReporter_set_report_accelerometer_signals(self, *args)

    def copyProperty_compute_accelerations_without_forces(self, source):
        r"""
        copyProperty_compute_accelerations_without_forces(IMUDataReporter self, IMUDataReporter source)

        Parameters
        ----------
        source: OpenSim::IMUDataReporter::Self const &

        """
        return _analyses.IMUDataReporter_copyProperty_compute_accelerations_without_forces(self, source)

    def append_compute_accelerations_without_forces(self, value):
        r"""
        append_compute_accelerations_without_forces(IMUDataReporter self, bool const & value) -> int

        Parameters
        ----------
        value: bool const &

        """
        return _analyses.IMUDataReporter_append_compute_accelerations_without_forces(self, value)

    def constructProperty_compute_accelerations_without_forces(self, initValue):
        r"""
        constructProperty_compute_accelerations_without_forces(IMUDataReporter self, bool const & initValue)

        Parameters
        ----------
        initValue: bool const &

        """
        return _analyses.IMUDataReporter_constructProperty_compute_accelerations_without_forces(self, initValue)

    def get_compute_accelerations_without_forces(self, *args):
        r"""
        get_compute_accelerations_without_forces(IMUDataReporter self, int i) -> bool const

        Parameters
        ----------
        i: int

        get_compute_accelerations_without_forces(IMUDataReporter self) -> bool const &
        """
        return _analyses.IMUDataReporter_get_compute_accelerations_without_forces(self, *args)

    def upd_compute_accelerations_without_forces(self, *args):
        r"""
        upd_compute_accelerations_without_forces(IMUDataReporter self, int i) -> bool

        Parameters
        ----------
        i: int

        upd_compute_accelerations_without_forces(IMUDataReporter self) -> bool &
        """
        return _analyses.IMUDataReporter_upd_compute_accelerations_without_forces(self, *args)

    def set_compute_accelerations_without_forces(self, *args):
        r"""
        set_compute_accelerations_without_forces(IMUDataReporter self, int i, bool const & value)

        Parameters
        ----------
        i: int
        value: bool const &

        set_compute_accelerations_without_forces(IMUDataReporter self, bool const & value)

        Parameters
        ----------
        value: bool const &

        """
        return _analyses.IMUDataReporter_set_compute_accelerations_without_forces(self, *args)

    def copyProperty_frame_paths(self, source):
        r"""
        copyProperty_frame_paths(IMUDataReporter self, IMUDataReporter source)

        Parameters
        ----------
        source: OpenSim::IMUDataReporter::Self const &

        """
        return _analyses.IMUDataReporter_copyProperty_frame_paths(self, source)

    def get_frame_paths(self, i):
        r"""
        get_frame_paths(IMUDataReporter self, int i) -> std::string const &

        Parameters
        ----------
        i: int

        """
        return _analyses.IMUDataReporter_get_frame_paths(self, i)

    def upd_frame_paths(self, i):
        r"""
        upd_frame_paths(IMUDataReporter self, int i) -> std::string &

        Parameters
        ----------
        i: int

        """
        return _analyses.IMUDataReporter_upd_frame_paths(self, i)

    def set_frame_paths(self, i, value):
        r"""
        set_frame_paths(IMUDataReporter self, int i, std::string const & value)

        Parameters
        ----------
        i: int
        value: std::string const &

        """
        return _analyses.IMUDataReporter_set_frame_paths(self, i, value)

    def append_frame_paths(self, value):
        r"""
        append_frame_paths(IMUDataReporter self, std::string const & value) -> int

        Parameters
        ----------
        value: std::string const &

        """
        return _analyses.IMUDataReporter_append_frame_paths(self, value)

    def constructProperty_frame_paths(self):
        r"""constructProperty_frame_paths(IMUDataReporter self)"""
        return _analyses.IMUDataReporter_constructProperty_frame_paths(self)

    def __init__(self, *args):
        r"""
        __init__(IMUDataReporter self, Model aModel=None) -> IMUDataReporter

        Parameters
        ----------
        aModel: OpenSim::Model *

        __init__(IMUDataReporter self, IMUDataReporter aObject) -> IMUDataReporter

        Parameters
        ----------
        aObject: OpenSim::IMUDataReporter const &

        """
        _analyses.IMUDataReporter_swiginit(self, _analyses.new_IMUDataReporter(*args))
    __swig_destroy__ = _analyses.delete_IMUDataReporter

    def setNull(self):
        r"""setNull(IMUDataReporter self)"""
        return _analyses.IMUDataReporter_setNull(self)

    def getOrientationsTable(self):
        r"""getOrientationsTable(IMUDataReporter self) -> TimeSeriesTableQuaternion"""
        return _analyses.IMUDataReporter_getOrientationsTable(self)

    def getGyroscopeSignalsTable(self):
        r"""getGyroscopeSignalsTable(IMUDataReporter self) -> TimeSeriesTableVec3"""
        return _analyses.IMUDataReporter_getGyroscopeSignalsTable(self)

    def getAccelerometerSignalsTable(self):
        r"""getAccelerometerSignalsTable(IMUDataReporter self) -> TimeSeriesTableVec3"""
        return _analyses.IMUDataReporter_getAccelerometerSignalsTable(self)

    def begin(self, s):
        r"""
        begin(IMUDataReporter self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.IMUDataReporter_begin(self, s)

    def step(self, s, setNumber):
        r"""
        step(IMUDataReporter self, State s, int setNumber) -> int

        Parameters
        ----------
        s: SimTK::State const &
        setNumber: int

        """
        return _analyses.IMUDataReporter_step(self, s, setNumber)

    def end(self, s):
        r"""
        end(IMUDataReporter self, State s) -> int

        Parameters
        ----------
        s: SimTK::State const &

        """
        return _analyses.IMUDataReporter_end(self, s)

    def printResults(self, *args):
        r"""
        printResults(IMUDataReporter self, std::string const & aBaseName, std::string const & aDir="", double aDT=-1.0, std::string const & aExtension=".sto") -> int

        Parameters
        ----------
        aBaseName: std::string const &
        aDir: std::string const &
        aDT: double
        aExtension: std::string const &

        """
        return _analyses.IMUDataReporter_printResults(self, *args)

# Register IMUDataReporter in _analyses:
_analyses.IMUDataReporter_swigregister(IMUDataReporter)

